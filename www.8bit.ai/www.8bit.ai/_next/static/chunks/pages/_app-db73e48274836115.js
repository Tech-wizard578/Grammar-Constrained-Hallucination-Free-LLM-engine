(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [888], {
        7035: function(e, t, n) {
            var r = {
                "./1.json": 1129
            };

            function i(e) {
                return n(s(e))
            }

            function s(e) {
                if (!n.o(r, e)) {
                    var t = Error("Cannot find module '" + e + "'");
                    throw t.code = "MODULE_NOT_FOUND", t
                }
                return r[e]
            }
            i.keys = function() {
                return Object.keys(r)
            }, i.resolve = s, e.exports = i, i.id = 7035
        },
        169: function(e, t, n) {
            "use strict";
            n.d(t, {
                V: function() {
                    return c
                }
            });
            var r = n(959),
                i = n(4970);
            let s = "undefined" != typeof window ? r.useLayoutEffect : r.useEffect,
                a = e => e && !Array.isArray(e) && "object" == typeof e,
                o = [],
                l = {},
                u = i.ZP,
                c = (e, t = o) => {
                    let n = l;
                    a(e) ? (n = e, e = null, t = "dependencies" in n ? n.dependencies : o) : a(t) && (t = "dependencies" in (n = t) ? n.dependencies : o), e && "function" != typeof e && console.warn("First parameter must be a function or config object");
                    let {
                        scope: i,
                        revertOnUpdate: c
                    } = n, h = (0, r.useRef)(!1), d = (0, r.useRef)(u.context(() => {}, i)), f = (0, r.useRef)(e => d.current.add(null, e)), p = t && t.length && !c;
                    return s(() => {
                        if (e && d.current.add(e, i), !p || !h.current) return () => d.current.revert()
                    }, t), p && s(() => (h.current = !0, () => d.current.revert()), o), {
                        context: d.current,
                        contextSafe: f.current
                    }
                };
            c.register = e => {
                u = e
            }, c.headless = !0
        },
        3771: function(e, t, n) {
            "use strict";
            n.d(t, {
                useDrag: function() {
                    return ep
                },
                useGesture: function() {
                    return eg
                }
            });
            let r = {
                toVector: (e, t) => (void 0 === e && (e = t), Array.isArray(e) ? e : [e, e]),
                add: (e, t) => [e[0] + t[0], e[1] + t[1]],
                sub: (e, t) => [e[0] - t[0], e[1] - t[1]],
                addTo(e, t) {
                    e[0] += t[0], e[1] += t[1]
                },
                subTo(e, t) {
                    e[0] -= t[0], e[1] -= t[1]
                }
            };

            function i(e, t, n) {
                return 0 === t || Math.abs(t) === 1 / 0 ? Math.pow(e, 5 * n) : e * t * n / (t + n * e)
            }

            function s(e, t, n, r = .15) {
                return 0 === r ? Math.max(t, Math.min(e, n)) : e < t ? -i(t - e, n - t, r) + t : e > n ? +i(e - n, n - t, r) + n : e
            }

            function a(e, t, n) {
                var r;
                return (t = "symbol" == typeof(r = function(e, t) {
                    if ("object" != typeof e || null === e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != typeof r) return r;
                        throw TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(t, "string")) ? r : String(r)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function o(e, t) {
                var n = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), n.push.apply(n, r)
                }
                return n
            }

            function l(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? o(Object(n), !0).forEach(function(t) {
                        a(e, t, n[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o(Object(n)).forEach(function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                    })
                }
                return e
            }
            let u = {
                pointer: {
                    start: "down",
                    change: "move",
                    end: "up"
                },
                mouse: {
                    start: "down",
                    change: "move",
                    end: "up"
                },
                touch: {
                    start: "start",
                    change: "move",
                    end: "end"
                },
                gesture: {
                    start: "start",
                    change: "change",
                    end: "end"
                }
            };

            function c(e) {
                return e ? e[0].toUpperCase() + e.slice(1) : ""
            }
            let h = ["enter", "leave"],
                d = ["gotpointercapture", "lostpointercapture"];

            function f(e) {
                return "touches" in e
            }

            function p(e) {
                return f(e) ? "touch" : "pointerType" in e ? e.pointerType : "mouse"
            }

            function g(e) {
                return f(e) ? ("touchend" === e.type || "touchcancel" === e.type ? e.changedTouches : e.targetTouches)[0] : e
            }

            function A(e, t) {
                try {
                    let n = t.clientX - e.clientX,
                        r = t.clientY - e.clientY,
                        i = (t.clientX + e.clientX) / 2,
                        s = (t.clientY + e.clientY) / 2,
                        a = Math.hypot(n, r);
                    return {
                        angle: -(180 * Math.atan2(n, r)) / Math.PI,
                        distance: a,
                        origin: [i, s]
                    }
                } catch (e) {}
                return null
            }

            function m(e, t) {
                let [n, r] = Array.from(e.touches).filter(e => t.includes(e.identifier));
                return A(n, r)
            }

            function v(e) {
                let t = g(e);
                return f(e) ? t.identifier : t.pointerId
            }

            function y(e) {
                let t = g(e);
                return [t.clientX, t.clientY]
            }

            function x(e) {
                let {
                    deltaX: t,
                    deltaY: n,
                    deltaMode: r
                } = e;
                return 1 === r ? (t *= 40, n *= 40) : 2 === r && (t *= 800, n *= 800), [t, n]
            }

            function E(e, ...t) {
                return "function" == typeof e ? e(...t) : e
            }

            function _() {}

            function b(e, t) {
                return Object.assign({}, t, e || {})
            }
            class w {
                constructor(e, t, n) {
                    this.ctrl = e, this.args = t, this.key = n, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset())
                }
                get state() {
                    return this.ctrl.state[this.key]
                }
                set state(e) {
                    this.ctrl.state[this.key] = e
                }
                get shared() {
                    return this.ctrl.state.shared
                }
                get eventStore() {
                    return this.ctrl.gestureEventStores[this.key]
                }
                get timeoutStore() {
                    return this.ctrl.gestureTimeoutStores[this.key]
                }
                get config() {
                    return this.ctrl.config[this.key]
                }
                get sharedConfig() {
                    return this.ctrl.config.shared
                }
                get handler() {
                    return this.ctrl.handlers[this.key]
                }
                reset() {
                    let {
                        state: e,
                        shared: t,
                        ingKey: n,
                        args: r
                    } = this;
                    t[n] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [
                        [-1 / 0, 1 / 0],
                        [-1 / 0, 1 / 0]
                    ], e.args = r, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0
                }
                start(e) {
                    let t = this.state,
                        n = this.config;
                    t._active || (this.reset(), this.computeInitial(), t._active = !0, t.target = e.target, t.currentTarget = e.currentTarget, t.lastOffset = n.from ? E(n.from, t) : t.offset, t.offset = t.lastOffset, t.startTime = t.timeStamp = e.timeStamp)
                }
                computeValues(e) {
                    let t = this.state;
                    t._values = e, t.values = this.config.transform(e)
                }
                computeInitial() {
                    let e = this.state;
                    e._initial = e._values, e.initial = e.values
                }
                compute(e) {
                    let {
                        state: t,
                        config: n,
                        shared: i
                    } = this;
                    t.args = this.args;
                    let a = 0;
                    if (e && (t.event = e, n.preventDefault && e.cancelable && t.event.preventDefault(), t.type = e.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, function(e) {
                            let t = {};
                            if ("buttons" in e && (t.buttons = e.buttons), "shiftKey" in e) {
                                let {
                                    shiftKey: n,
                                    altKey: r,
                                    metaKey: i,
                                    ctrlKey: s
                                } = e;
                                Object.assign(t, {
                                    shiftKey: n,
                                    altKey: r,
                                    metaKey: i,
                                    ctrlKey: s
                                })
                            }
                            return t
                        }(e)), i.down = i.pressed = i.buttons % 2 == 1 || i.touches > 0, a = e.timeStamp - t.timeStamp, t.timeStamp = e.timeStamp, t.elapsedTime = t.timeStamp - t.startTime), t._active) {
                        let e = t._delta.map(Math.abs);
                        r.addTo(t._distance, e)
                    }
                    this.axisIntent && this.axisIntent(e);
                    let [o, l] = t._movement, [u, c] = n.threshold, {
                        _step: h,
                        values: d
                    } = t;
                    if (n.hasCustomTransform ? (!1 === h[0] && (h[0] = Math.abs(o) >= u && d[0]), !1 === h[1] && (h[1] = Math.abs(l) >= c && d[1])) : (!1 === h[0] && (h[0] = Math.abs(o) >= u && Math.sign(o) * u), !1 === h[1] && (h[1] = Math.abs(l) >= c && Math.sign(l) * c)), t.intentional = !1 !== h[0] || !1 !== h[1], !t.intentional) return;
                    let f = [0, 0];
                    if (n.hasCustomTransform) {
                        let [e, t] = d;
                        f[0] = !1 !== h[0] ? e - h[0] : 0, f[1] = !1 !== h[1] ? t - h[1] : 0
                    } else f[0] = !1 !== h[0] ? o - h[0] : 0, f[1] = !1 !== h[1] ? l - h[1] : 0;
                    this.restrictToAxis && !t._blocked && this.restrictToAxis(f);
                    let p = t.offset,
                        g = t._active && !t._blocked || t.active;
                    g && (t.first = t._active && !t.active, t.last = !t._active && t.active, t.active = i[this.ingKey] = t._active, e && (t.first && ("bounds" in n && (t._bounds = E(n.bounds, t)), this.setup && this.setup()), t.movement = f, this.computeOffset()));
                    let [A, m] = t.offset, [
                        [v, y],
                        [x, _]
                    ] = t._bounds;
                    t.overflow = [A < v ? -1 : A > y ? 1 : 0, m < x ? -1 : m > _ ? 1 : 0], t._movementBound[0] = !!t.overflow[0] && (!1 === t._movementBound[0] ? t._movement[0] : t._movementBound[0]), t._movementBound[1] = !!t.overflow[1] && (!1 === t._movementBound[1] ? t._movement[1] : t._movementBound[1]);
                    let b = t._active && n.rubberband || [0, 0];
                    if (t.offset = function(e, [t, n], [r, i]) {
                            let [
                                [a, o],
                                [l, u]
                            ] = e;
                            return [s(t, a, o, r), s(n, l, u, i)]
                        }(t._bounds, t.offset, b), t.delta = r.sub(t.offset, p), this.computeMovement(), g && (!t.last || a > 32)) {
                        t.delta = r.sub(t.offset, p);
                        let e = t.delta.map(Math.abs);
                        r.addTo(t.distance, e), t.direction = t.delta.map(Math.sign), t._direction = t._delta.map(Math.sign), !t.first && a > 0 && (t.velocity = [e[0] / a, e[1] / a], t.timeDelta = a)
                    }
                }
                emit() {
                    let e = this.state,
                        t = this.shared,
                        n = this.config;
                    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !n.triggerAllEvents) return;
                    let r = this.handler(l(l(l({}, t), e), {}, {
                        [this.aliasKey]: e.values
                    }));
                    void 0 !== r && (e.memo = r)
                }
                clean() {
                    this.eventStore.clean(), this.timeoutStore.clean()
                }
            }
            class C extends w {
                constructor(...e) {
                    super(...e), a(this, "aliasKey", "xy")
                }
                reset() {
                    super.reset(), this.state.axis = void 0
                }
                init() {
                    this.state.offset = [0, 0], this.state.lastOffset = [0, 0]
                }
                computeOffset() {
                    this.state.offset = r.add(this.state.lastOffset, this.state.movement)
                }
                computeMovement() {
                    this.state.movement = r.sub(this.state.offset, this.state.lastOffset)
                }
                axisIntent(e) {
                    let t = this.state,
                        n = this.config;
                    if (!t.axis && e) {
                        let r = "object" == typeof n.axisThreshold ? n.axisThreshold[p(e)] : n.axisThreshold;
                        t.axis = function([e, t], n) {
                            let r = Math.abs(e),
                                i = Math.abs(t);
                            return r > i && r > n ? "x" : i > r && i > n ? "y" : void 0
                        }(t._movement, r)
                    }
                    t._blocked = (n.lockDirection || !!n.axis) && !t.axis || !!n.axis && n.axis !== t.axis
                }
                restrictToAxis(e) {
                    if (this.config.axis || this.config.lockDirection) switch (this.state.axis) {
                        case "x":
                            e[1] = 0;
                            break;
                        case "y":
                            e[0] = 0
                    }
                }
            }
            let S = e => e,
                I = {
                    enabled: (e = !0) => e,
                    eventOptions: (e, t, n) => l(l({}, n.shared.eventOptions), e),
                    preventDefault: (e = !1) => e,
                    triggerAllEvents: (e = !1) => e,
                    rubberband(e = 0) {
                        switch (e) {
                            case !0:
                                return [.15, .15];
                            case !1:
                                return [0, 0];
                            default:
                                return r.toVector(e)
                        }
                    },
                    from: e => "function" == typeof e ? e : null != e ? r.toVector(e) : void 0,
                    transform(e, t, n) {
                        let r = e || n.shared.transform;
                        return this.hasCustomTransform = !!r, r || S
                    },
                    threshold: e => r.toVector(e, 0)
                },
                M = 0,
                T = l(l({}, I), {}, {
                    axis(e, t, {
                        axis: n
                    }) {
                        if (this.lockDirection = "lock" === n, !this.lockDirection) return n
                    },
                    axisThreshold: (e = M) => e,
                    bounds(e = {}) {
                        if ("function" == typeof e) return t => T.bounds(e(t));
                        if ("current" in e) return () => e.current;
                        if ("function" == typeof HTMLElement && e instanceof HTMLElement) return e;
                        let {
                            left: t = -1 / 0,
                            right: n = 1 / 0,
                            top: r = -1 / 0,
                            bottom: i = 1 / 0
                        } = e;
                        return [
                            [t, n],
                            [r, i]
                        ]
                    }
                }),
                B = {
                    ArrowRight: (e, t = 1) => [e * t, 0],
                    ArrowLeft: (e, t = 1) => [-1 * e * t, 0],
                    ArrowUp: (e, t = 1) => [0, -1 * e * t],
                    ArrowDown: (e, t = 1) => [0, e * t]
                };
            class R extends C {
                constructor(...e) {
                    super(...e), a(this, "ingKey", "dragging")
                }
                reset() {
                    super.reset();
                    let e = this.state;
                    e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this)
                }
                setup() {
                    let e = this.state;
                    if (e._bounds instanceof HTMLElement) {
                        let t = e._bounds.getBoundingClientRect(),
                            n = e.currentTarget.getBoundingClientRect(),
                            r = {
                                left: t.left - n.left + e.offset[0],
                                right: t.right - n.right + e.offset[0],
                                top: t.top - n.top + e.offset[1],
                                bottom: t.bottom - n.bottom + e.offset[1]
                            };
                        e._bounds = T.bounds(r)
                    }
                }
                cancel() {
                    let e = this.state;
                    e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
                        this.compute(), this.emit()
                    }, 0))
                }
                setActive() {
                    this.state._active = this.state._pointerActive || this.state._keyboardActive
                }
                clean() {
                    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean()
                }
                pointerDown(e) {
                    let t = this.config,
                        n = this.state;
                    if (null != e.buttons && (Array.isArray(t.pointerButtons) ? !t.pointerButtons.includes(e.buttons) : -1 !== t.pointerButtons && t.pointerButtons !== e.buttons)) return;
                    let r = this.ctrl.setEventIds(e);
                    t.pointerCapture && e.target.setPointerCapture(e.pointerId), r && r.size > 1 && n._pointerActive || (this.start(e), this.setupPointer(e), n._pointerId = v(e), n._pointerActive = !0, this.computeValues(y(e)), this.computeInitial(), t.preventScrollAxis && "mouse" !== p(e) ? (n._active = !1, this.setupScrollPrevention(e)) : t.delay > 0 ? (this.setupDelayTrigger(e), t.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e))
                }
                startPointerDrag(e) {
                    let t = this.state;
                    t._active = !0, t._preventScroll = !0, t._delayed = !1, this.compute(e), this.emit()
                }
                pointerMove(e) {
                    let t = this.state,
                        n = this.config;
                    if (!t._pointerActive) return;
                    let i = v(e);
                    if (void 0 !== t._pointerId && i !== t._pointerId) return;
                    let s = y(e);
                    if (document.pointerLockElement === e.target ? t._delta = [e.movementX, e.movementY] : (t._delta = r.sub(s, t._values), this.computeValues(s)), r.addTo(t._movement, t._delta), this.compute(e), t._delayed && t.intentional) {
                        this.timeoutStore.remove("dragDelay"), t.active = !1, this.startPointerDrag(e);
                        return
                    }
                    if (n.preventScrollAxis && !t._preventScroll) {
                        if (!t.axis) return;
                        if (t.axis === n.preventScrollAxis || "xy" === n.preventScrollAxis) {
                            t._active = !1, this.clean();
                            return
                        }
                        this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
                        return
                    }
                    this.emit()
                }
                pointerUp(e) {
                    this.ctrl.setEventIds(e);
                    try {
                        this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId)
                    } catch (e) {}
                    let t = this.state,
                        n = this.config;
                    if (!t._active || !t._pointerActive) return;
                    let r = v(e);
                    if (void 0 !== t._pointerId && r !== t._pointerId) return;
                    this.state._pointerActive = !1, this.setActive(), this.compute(e);
                    let [i, s] = t._distance;
                    if (t.tap = i <= n.tapsThreshold && s <= n.tapsThreshold, t.tap && n.filterTaps) t._force = !0;
                    else {
                        let [e, r] = t._delta, [i, s] = t._movement, [a, o] = n.swipe.velocity, [l, u] = n.swipe.distance, c = n.swipe.duration;
                        if (t.elapsedTime < c) {
                            let n = Math.abs(e / t.timeDelta),
                                c = Math.abs(r / t.timeDelta);
                            n > a && Math.abs(i) > l && (t.swipe[0] = Math.sign(e)), c > o && Math.abs(s) > u && (t.swipe[1] = Math.sign(r))
                        }
                    }
                    this.emit()
                }
                pointerClick(e) {
                    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation())
                }
                setupPointer(e) {
                    let t = this.config,
                        n = t.device;
                    t.pointerLock && e.currentTarget.requestPointerLock(), t.pointerCapture || (this.eventStore.add(this.sharedConfig.window, n, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "cancel", this.pointerUp.bind(this)))
                }
                pointerClean() {
                    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock()
                }
                preventScroll(e) {
                    this.state._preventScroll && e.cancelable && e.preventDefault()
                }
                setupScrollPrevention(e) {
                    this.state._preventScroll = !1, "persist" in e && "function" == typeof e.persist && e.persist();
                    let t = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
                        passive: !1
                    });
                    this.eventStore.add(this.sharedConfig.window, "touch", "end", t), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", t), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e)
                }
                setupDelayTrigger(e) {
                    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
                        this.state._step = [0, 0], this.startPointerDrag(e)
                    }, this.config.delay)
                }
                keyDown(e) {
                    let t = B[e.key];
                    if (t) {
                        let n = this.state,
                            i = e.shiftKey ? 10 : e.altKey ? .1 : 1;
                        this.start(e), n._delta = t(this.config.keyboardDisplacement, i), n._keyboardActive = !0, r.addTo(n._movement, n._delta), this.compute(e), this.emit()
                    }
                }
                keyUp(e) {
                    e.key in B && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit())
                }
                bind(e) {
                    let t = this.config.device;
                    e(t, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(t, "change", this.pointerMove.bind(this)), e(t, "end", this.pointerUp.bind(this)), e(t, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
                        capture: !0,
                        passive: !1
                    })
                }
            }
            let D = "undefined" != typeof window && window.document && window.document.createElement;

            function L() {
                return D && "ontouchstart" in window
            }
            let P = {
                    isBrowser: D,
                    gesture: function() {
                        try {
                            return "constructor" in GestureEvent
                        } catch (e) {
                            return !1
                        }
                    }(),
                    touch: L(),
                    touchscreen: L() || D && window.navigator.maxTouchPoints > 1,
                    pointer: D && "onpointerdown" in window,
                    pointerLock: D && "exitPointerLock" in window.document
                },
                O = 10,
                N = {
                    mouse: 0,
                    touch: 0,
                    pen: 8
                },
                U = l(l({}, T), {}, {
                    device(e, t, {
                        pointer: {
                            touch: n = !1,
                            lock: r = !1,
                            mouse: i = !1
                        } = {}
                    }) {
                        return (this.pointerLock = r && P.pointerLock, P.touch && n) ? "touch" : this.pointerLock ? "mouse" : P.pointer && !i ? "pointer" : P.touch ? "touch" : "mouse"
                    },
                    preventScrollAxis(e, t, {
                        preventScroll: n
                    }) {
                        if (this.preventScrollDelay = "number" == typeof n ? n : n || void 0 === n && e ? 250 : void 0, P.touchscreen && !1 !== n) return e || (void 0 !== n ? "y" : void 0)
                    },
                    pointerCapture(e, t, {
                        pointer: {
                            capture: n = !0,
                            buttons: r = 1,
                            keys: i = !0
                        } = {}
                    }) {
                        return this.pointerButtons = r, this.keys = i, !this.pointerLock && "pointer" === this.device && n
                    },
                    threshold(e, t, {
                        filterTaps: n = !1,
                        tapsThreshold: i = 3,
                        axis: s
                    }) {
                        let a = r.toVector(e, n ? i : s ? 1 : 0);
                        return this.filterTaps = n, this.tapsThreshold = i, a
                    },
                    swipe({
                        velocity: e = .5,
                        distance: t = 50,
                        duration: n = 250
                    } = {}) {
                        return {
                            velocity: this.transform(r.toVector(e)),
                            distance: this.transform(r.toVector(t)),
                            duration: n
                        }
                    },
                    delay(e = 0) {
                        switch (e) {
                            case !0:
                                return 180;
                            case !1:
                                return 0;
                            default:
                                return e
                        }
                    },
                    axisThreshold: e => e ? l(l({}, N), e) : N,
                    keyboardDisplacement: (e = O) => e
                });

            function F(e) {
                let [t, n] = e.overflow, [r, i] = e._delta, [s, a] = e._direction;
                (t < 0 && r > 0 && s < 0 || t > 0 && r < 0 && s > 0) && (e._movement[0] = e._movementBound[0]), (n < 0 && i > 0 && a < 0 || n > 0 && i < 0 && a > 0) && (e._movement[1] = e._movementBound[1])
            }
            class k extends w {
                constructor(...e) {
                    super(...e), a(this, "ingKey", "pinching"), a(this, "aliasKey", "da")
                }
                init() {
                    this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = new Map
                }
                reset() {
                    super.reset();
                    let e = this.state;
                    e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0
                }
                computeOffset() {
                    let {
                        type: e,
                        movement: t,
                        lastOffset: n
                    } = this.state;
                    "wheel" === e ? this.state.offset = r.add(t, n) : this.state.offset = [(1 + t[0]) * n[0], t[1] + n[1]]
                }
                computeMovement() {
                    let {
                        offset: e,
                        lastOffset: t
                    } = this.state;
                    this.state.movement = [e[0] / t[0], e[1] - t[1]]
                }
                axisIntent() {
                    let e = this.state,
                        [t, n] = e._movement;
                    if (!e.axis) {
                        let r = 30 * Math.abs(t) - Math.abs(n);
                        r < 0 ? e.axis = "angle" : r > 0 && (e.axis = "scale")
                    }
                }
                restrictToAxis(e) {
                    this.config.lockDirection && ("scale" === this.state.axis ? e[1] = 0 : "angle" === this.state.axis && (e[0] = 0))
                }
                cancel() {
                    let e = this.state;
                    e.canceled || setTimeout(() => {
                        e.canceled = !0, e._active = !1, this.compute(), this.emit()
                    }, 0)
                }
                touchStart(e) {
                    this.ctrl.setEventIds(e);
                    let t = this.state,
                        n = this.ctrl.touchIds;
                    if (t._active && t._touchIds.every(e => n.has(e)) || n.size < 2) return;
                    this.start(e), t._touchIds = Array.from(n).slice(0, 2);
                    let r = m(e, t._touchIds);
                    r && this.pinchStart(e, r)
                }
                pointerStart(e) {
                    if (null != e.buttons && e.buttons % 2 != 1) return;
                    this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId);
                    let t = this.state,
                        n = t._pointerEvents,
                        r = this.ctrl.pointerIds;
                    if (t._active && Array.from(n.keys()).every(e => r.has(e)) || (n.size < 2 && n.set(e.pointerId, e), t._pointerEvents.size < 2)) return;
                    this.start(e);
                    let i = A(...Array.from(n.values()));
                    i && this.pinchStart(e, i)
                }
                pinchStart(e, t) {
                    this.state.origin = t.origin, this.computeValues([t.distance, t.angle]), this.computeInitial(), this.compute(e), this.emit()
                }
                touchMove(e) {
                    if (!this.state._active) return;
                    let t = m(e, this.state._touchIds);
                    t && this.pinchMove(e, t)
                }
                pointerMove(e) {
                    let t = this.state._pointerEvents;
                    if (t.has(e.pointerId) && t.set(e.pointerId, e), !this.state._active) return;
                    let n = A(...Array.from(t.values()));
                    n && this.pinchMove(e, n)
                }
                pinchMove(e, t) {
                    let n = this.state,
                        r = n._values[1],
                        i = t.angle - r,
                        s = 0;
                    Math.abs(i) > 270 && (s += Math.sign(i)), this.computeValues([t.distance, t.angle - 360 * s]), n.origin = t.origin, n.turns = s, n._movement = [n._values[0] / n._initial[0] - 1, n._values[1] - n._initial[1]], this.compute(e), this.emit()
                }
                touchEnd(e) {
                    this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some(e => !this.ctrl.touchIds.has(e)) && (this.state._active = !1, this.compute(e), this.emit())
                }
                pointerEnd(e) {
                    let t = this.state;
                    this.ctrl.setEventIds(e);
                    try {
                        e.target.releasePointerCapture(e.pointerId)
                    } catch (e) {}
                    t._pointerEvents.has(e.pointerId) && t._pointerEvents.delete(e.pointerId), t._active && t._pointerEvents.size < 2 && (t._active = !1, this.compute(e), this.emit())
                }
                gestureStart(e) {
                    e.cancelable && e.preventDefault();
                    let t = this.state;
                    t._active || (this.start(e), this.computeValues([e.scale, e.rotation]), t.origin = [e.clientX, e.clientY], this.compute(e), this.emit())
                }
                gestureMove(e) {
                    if (e.cancelable && e.preventDefault(), !this.state._active) return;
                    let t = this.state;
                    this.computeValues([e.scale, e.rotation]), t.origin = [e.clientX, e.clientY];
                    let n = t._movement;
                    t._movement = [e.scale - 1, e.rotation], t._delta = r.sub(t._movement, n), this.compute(e), this.emit()
                }
                gestureEnd(e) {
                    this.state._active && (this.state._active = !1, this.compute(e), this.emit())
                }
                wheel(e) {
                    let t = this.config.modifierKey;
                    (!t || (Array.isArray(t) ? t.find(t => e[t]) : e[t])) && (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)))
                }
                wheelStart(e) {
                    this.start(e), this.wheelChange(e)
                }
                wheelChange(e) {
                    "uv" in e || !e.cancelable || e.preventDefault();
                    let t = this.state;
                    t._delta = [-x(e)[1] / 100 * t.offset[0], 0], r.addTo(t._movement, t._delta), F(t), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit()
                }
                wheelEnd() {
                    this.state._active && (this.state._active = !1, this.compute(), this.emit())
                }
                bind(e) {
                    let t = this.config.device;
                    t && (e(t, "start", this[t + "Start"].bind(this)), e(t, "change", this[t + "Move"].bind(this)), e(t, "end", this[t + "End"].bind(this)), e(t, "cancel", this[t + "End"].bind(this)), e("lostPointerCapture", "", this[t + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
                        passive: !1
                    })
                }
            }
            let Q = l(l({}, I), {}, {
                device(e, t, {
                    shared: n,
                    pointer: {
                        touch: r = !1
                    } = {}
                }) {
                    if (n.target && !P.touch && P.gesture) return "gesture";
                    if (P.touch && r) return "touch";
                    if (P.touchscreen) {
                        if (P.pointer) return "pointer";
                        if (P.touch) return "touch"
                    }
                },
                bounds(e, t, {
                    scaleBounds: n = {},
                    angleBounds: r = {}
                }) {
                    let i = e => {
                            let t = b(E(n, e), {
                                min: -1 / 0,
                                max: 1 / 0
                            });
                            return [t.min, t.max]
                        },
                        s = e => {
                            let t = b(E(r, e), {
                                min: -1 / 0,
                                max: 1 / 0
                            });
                            return [t.min, t.max]
                        };
                    return "function" != typeof n && "function" != typeof r ? [i(), s()] : e => [i(e), s(e)]
                },
                threshold(e, t, n) {
                    return this.lockDirection = "lock" === n.axis, r.toVector(e, this.lockDirection ? [.1, 3] : 0)
                },
                modifierKey: e => void 0 === e ? "ctrlKey" : e,
                pinchOnWheel: (e = !0) => e
            });
            class G extends C {
                constructor(...e) {
                    super(...e), a(this, "ingKey", "moving")
                }
                move(e) {
                    this.config.mouseOnly && "mouse" !== e.pointerType || (this.state._active ? this.moveChange(e) : this.moveStart(e), this.timeoutStore.add("moveEnd", this.moveEnd.bind(this)))
                }
                moveStart(e) {
                    this.start(e), this.computeValues(y(e)), this.compute(e), this.computeInitial(), this.emit()
                }
                moveChange(e) {
                    if (!this.state._active) return;
                    let t = y(e),
                        n = this.state;
                    n._delta = r.sub(t, n._values), r.addTo(n._movement, n._delta), this.computeValues(t), this.compute(e), this.emit()
                }
                moveEnd(e) {
                    this.state._active && (this.state._active = !1, this.compute(e), this.emit())
                }
                bind(e) {
                    e("pointer", "change", this.move.bind(this)), e("pointer", "leave", this.moveEnd.bind(this))
                }
            }
            let z = l(l({}, T), {}, {
                mouseOnly: (e = !0) => e
            });
            class H extends C {
                constructor(...e) {
                    super(...e), a(this, "ingKey", "scrolling")
                }
                scroll(e) {
                    this.state._active || this.start(e), this.scrollChange(e), this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this))
                }
                scrollChange(e) {
                    e.cancelable && e.preventDefault();
                    let t = this.state,
                        n = function(e) {
                            var t, n;
                            let {
                                scrollX: r,
                                scrollY: i,
                                scrollLeft: s,
                                scrollTop: a
                            } = e.currentTarget;
                            return [null !== (t = null != r ? r : s) && void 0 !== t ? t : 0, null !== (n = null != i ? i : a) && void 0 !== n ? n : 0]
                        }(e);
                    t._delta = r.sub(n, t._values), r.addTo(t._movement, t._delta), this.computeValues(n), this.compute(e), this.emit()
                }
                scrollEnd() {
                    this.state._active && (this.state._active = !1, this.compute(), this.emit())
                }
                bind(e) {
                    e("scroll", "", this.scroll.bind(this))
                }
            }
            class V extends C {
                constructor(...e) {
                    super(...e), a(this, "ingKey", "wheeling")
                }
                wheel(e) {
                    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))
                }
                wheelChange(e) {
                    let t = this.state;
                    t._delta = x(e), r.addTo(t._movement, t._delta), F(t), this.compute(e), this.emit()
                }
                wheelEnd() {
                    this.state._active && (this.state._active = !1, this.compute(), this.emit())
                }
                bind(e) {
                    e("wheel", "", this.wheel.bind(this))
                }
            }
            class j extends C {
                constructor(...e) {
                    super(...e), a(this, "ingKey", "hovering")
                }
                enter(e) {
                    this.config.mouseOnly && "mouse" !== e.pointerType || (this.start(e), this.computeValues(y(e)), this.compute(e), this.emit())
                }
                leave(e) {
                    if (this.config.mouseOnly && "mouse" !== e.pointerType) return;
                    let t = this.state;
                    if (!t._active) return;
                    t._active = !1;
                    let n = y(e);
                    t._movement = t._delta = r.sub(n, t._values), this.computeValues(n), this.compute(e), t.delta = t.movement, this.emit()
                }
                bind(e) {
                    e("pointer", "enter", this.enter.bind(this)), e("pointer", "leave", this.leave.bind(this))
                }
            }
            let W = l(l({}, T), {}, {
                    mouseOnly: (e = !0) => e
                }),
                Y = new Map,
                X = new Map;

            function q(e) {
                Y.set(e.key, e.engine), X.set(e.key, e.resolver)
            }
            let K = {
                    key: "drag",
                    engine: R,
                    resolver: U
                },
                J = {
                    key: "hover",
                    engine: j,
                    resolver: W
                },
                Z = {
                    key: "move",
                    engine: G,
                    resolver: z
                },
                $ = {
                    key: "pinch",
                    engine: k,
                    resolver: Q
                },
                ee = {
                    key: "scroll",
                    engine: H,
                    resolver: T
                },
                et = {
                    key: "wheel",
                    engine: V,
                    resolver: T
                };
            var en = n(959);
            let er = {
                    target(e) {
                        if (e) return () => "current" in e ? e.current : e
                    },
                    enabled: (e = !0) => e,
                    window: (e = P.isBrowser ? window : void 0) => e,
                    eventOptions: ({
                        passive: e = !0,
                        capture: t = !1
                    } = {}) => ({
                        passive: e,
                        capture: t
                    }),
                    transform: e => e
                },
                ei = ["target", "eventOptions", "window", "enabled", "transform"];

            function es(e = {}, t) {
                let n = {};
                for (let [r, i] of Object.entries(t)) switch (typeof i) {
                    case "function":
                        n[r] = i.call(n, e[r], r, e);
                        break;
                    case "object":
                        n[r] = es(e[r], i);
                        break;
                    case "boolean":
                        i && (n[r] = e[r])
                }
                return n
            }
            class ea {
                constructor(e, t) {
                    a(this, "_listeners", new Set), this._ctrl = e, this._gestureKey = t
                }
                add(e, t, n, r, i) {
                    let s = this._listeners,
                        a = function(e, t = "") {
                            let n = u[e];
                            return e + (n && n[t] || t)
                        }(t, n),
                        o = l(l({}, this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}), i);
                    e.addEventListener(a, r, o);
                    let c = () => {
                        e.removeEventListener(a, r, o), s.delete(c)
                    };
                    return s.add(c), c
                }
                clean() {
                    this._listeners.forEach(e => e()), this._listeners.clear()
                }
            }
            class eo {
                constructor() {
                    a(this, "_timeouts", new Map)
                }
                add(e, t, n = 140, ...r) {
                    this.remove(e), this._timeouts.set(e, window.setTimeout(t, n, ...r))
                }
                remove(e) {
                    let t = this._timeouts.get(e);
                    t && window.clearTimeout(t)
                }
                clean() {
                    this._timeouts.forEach(e => void window.clearTimeout(e)), this._timeouts.clear()
                }
            }
            class el {
                constructor(e) {
                    a(this, "gestures", new Set), a(this, "_targetEventStore", new ea(this)), a(this, "gestureEventStores", {}), a(this, "gestureTimeoutStores", {}), a(this, "handlers", {}), a(this, "config", {}), a(this, "pointerIds", new Set), a(this, "touchIds", new Set), a(this, "state", {
                        shared: {
                            shiftKey: !1,
                            metaKey: !1,
                            ctrlKey: !1,
                            altKey: !1
                        }
                    }), e.drag && eu(this, "drag"), e.wheel && eu(this, "wheel"), e.scroll && eu(this, "scroll"), e.move && eu(this, "move"), e.pinch && eu(this, "pinch"), e.hover && eu(this, "hover")
                }
                setEventIds(e) {
                    return f(e) ? (this.touchIds = new Set(Array.from(e.touches).filter(t => {
                        var n, r;
                        return t.target === e.currentTarget || (null === (n = e.currentTarget) || void 0 === n || null === (r = n.contains) || void 0 === r ? void 0 : r.call(n, t.target))
                    }).map(e => e.identifier)), this.touchIds) : "pointerId" in e ? ("pointerup" === e.type || "pointercancel" === e.type ? this.pointerIds.delete(e.pointerId) : "pointerdown" === e.type && this.pointerIds.add(e.pointerId), this.pointerIds) : void 0
                }
                applyHandlers(e, t) {
                    this.handlers = e, this.nativeHandlers = t
                }
                applyConfig(e, t) {
                    this.config = function(e, t, n = {}) {
                        let {
                            target: r,
                            eventOptions: i,
                            window: s,
                            enabled: a,
                            transform: o
                        } = e, u = function(e, t) {
                            if (null == e) return {};
                            var n, r, i = function(e, t) {
                                if (null == e) return {};
                                var n, r, i = {},
                                    s = Object.keys(e);
                                for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                                return i
                            }(e, t);
                            if (Object.getOwnPropertySymbols) {
                                var s = Object.getOwnPropertySymbols(e);
                                for (r = 0; r < s.length; r++) n = s[r], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
                            }
                            return i
                        }(e, ei);
                        if (n.shared = es({
                                target: r,
                                eventOptions: i,
                                window: s,
                                enabled: a,
                                transform: o
                            }, er), t) {
                            let e = X.get(t);
                            n[t] = es(l({
                                shared: n.shared
                            }, u), e)
                        } else
                            for (let e in u) {
                                let t = X.get(e);
                                t && (n[e] = es(l({
                                    shared: n.shared
                                }, u[e]), t))
                            }
                        return n
                    }(e, t, this.config)
                }
                clean() {
                    for (let e of (this._targetEventStore.clean(), this.gestures)) this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean()
                }
                effect() {
                    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean()
                }
                bind(...e) {
                    let t;
                    let n = this.config.shared,
                        r = {};
                    if (!n.target || (t = n.target())) {
                        if (n.enabled) {
                            for (let n of this.gestures) {
                                let i = this.config[n],
                                    s = ec(r, i.eventOptions, !!t);
                                i.enabled && new(Y.get(n))(this, e, n).bind(s)
                            }
                            let i = ec(r, n.eventOptions, !!t);
                            for (let t in this.nativeHandlers) i(t, "", n => this.nativeHandlers[t](l(l({}, this.state.shared), {}, {
                                event: n,
                                args: e
                            })), void 0, !0)
                        }
                        for (let e in r) r[e] = function(...e) {
                            return 0 === e.length ? _ : 1 === e.length ? e[0] : function() {
                                let t;
                                for (let n of e) t = n.apply(this, arguments) || t;
                                return t
                            }
                        }(...r[e]);
                        if (!t) return r;
                        for (let e in r) {
                            let {
                                device: n,
                                capture: i,
                                passive: s
                            } = function(e) {
                                let t = e.substring(2).toLowerCase(),
                                    n = !!~t.indexOf("passive");
                                n && (t = t.replace("passive", ""));
                                let r = d.includes(t) ? "capturecapture" : "capture",
                                    i = !!~t.indexOf(r);
                                return i && (t = t.replace("capture", "")), {
                                    device: t,
                                    capture: i,
                                    passive: n
                                }
                            }(e);
                            this._targetEventStore.add(t, n, "", r[e], {
                                capture: i,
                                passive: s
                            })
                        }
                    }
                }
            }

            function eu(e, t) {
                e.gestures.add(t), e.gestureEventStores[t] = new ea(e, t), e.gestureTimeoutStores[t] = new eo
            }
            let ec = (e, t, n) => (r, i, s, a = {}, o = !1) => {
                    var l, d;
                    let f = null !== (l = a.capture) && void 0 !== l ? l : t.capture,
                        p = null !== (d = a.passive) && void 0 !== d ? d : t.passive,
                        g = o ? r : function(e, t = "", n = !1) {
                            let r = u[e],
                                i = r && r[t] || t;
                            return "on" + c(e) + c(i) + (! function(e = !1, t) {
                                return e && !h.includes(t)
                            }(n, i) ? "" : "Capture")
                        }(r, i, f);
                    n && p && (g += "Passive"), e[g] = e[g] || [], e[g].push(s)
                },
                eh = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;

            function ed(e, t, n, r, i, s) {
                if (!e.has(n) || !Y.has(r)) return;
                let a = n + "Start",
                    o = n + "End";
                i[r] = e => {
                    let r;
                    return e.first && a in t && t[a](e), n in t && (r = t[n](e)), e.last && o in t && t[o](e), r
                }, s[r] = s[r] || {}
            }

            function ef(e, t = {}, n, r) {
                let i = en.useMemo(() => new el(e), []);
                if (i.applyHandlers(e, r), i.applyConfig(t, n), en.useEffect(i.effect.bind(i)), en.useEffect(() => i.clean.bind(i), []), void 0 === t.target) return i.bind.bind(i)
            }

            function ep(e, t) {
                return q(K), ef({
                    drag: e
                }, t || {}, "drag")
            }

            function eg(e, t) {
                return ([K, $, ee, et, Z, J].forEach(q), function(e, t) {
                    let {
                        handlers: n,
                        nativeHandlers: r,
                        config: i
                    } = function(e, t) {
                        let [n, r, i] = function(e) {
                            let t = {},
                                n = {},
                                r = new Set;
                            for (let i in e) eh.test(i) ? (r.add(RegExp.lastMatch), n[i] = e[i]) : t[i] = e[i];
                            return [n, t, r]
                        }(e), s = {};
                        return ed(i, n, "onDrag", "drag", s, t), ed(i, n, "onWheel", "wheel", s, t), ed(i, n, "onScroll", "scroll", s, t), ed(i, n, "onPinch", "pinch", s, t), ed(i, n, "onMove", "move", s, t), ed(i, n, "onHover", "hover", s, t), {
                            handlers: s,
                            config: t,
                            nativeHandlers: r
                        }
                    }(e, t || {});
                    return ef(n, i, void 0, r)
                })(e, t || {})
            }
        },
        5415: function(e, t) {
            "use strict";
            t.byteLength = function(e) {
                var t = l(e),
                    n = t[0],
                    r = t[1];
                return (n + r) * 3 / 4 - r
            }, t.toByteArray = function(e) {
                var t, n, s = l(e),
                    a = s[0],
                    o = s[1],
                    u = new i((a + o) * 3 / 4 - o),
                    c = 0,
                    h = o > 0 ? a - 4 : a;
                for (n = 0; n < h; n += 4) t = r[e.charCodeAt(n)] << 18 | r[e.charCodeAt(n + 1)] << 12 | r[e.charCodeAt(n + 2)] << 6 | r[e.charCodeAt(n + 3)], u[c++] = t >> 16 & 255, u[c++] = t >> 8 & 255, u[c++] = 255 & t;
                return 2 === o && (t = r[e.charCodeAt(n)] << 2 | r[e.charCodeAt(n + 1)] >> 4, u[c++] = 255 & t), 1 === o && (t = r[e.charCodeAt(n)] << 10 | r[e.charCodeAt(n + 1)] << 4 | r[e.charCodeAt(n + 2)] >> 2, u[c++] = t >> 8 & 255, u[c++] = 255 & t), u
            }, t.fromByteArray = function(e) {
                for (var t, r = e.length, i = r % 3, s = [], a = 0, o = r - i; a < o; a += 16383) s.push(function(e, t, r) {
                    for (var i, s = [], a = t; a < r; a += 3) s.push(n[(i = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2])) >> 18 & 63] + n[i >> 12 & 63] + n[i >> 6 & 63] + n[63 & i]);
                    return s.join("")
                }(e, a, a + 16383 > o ? o : a + 16383));
                return 1 === i ? s.push(n[(t = e[r - 1]) >> 2] + n[t << 4 & 63] + "==") : 2 === i && s.push(n[(t = (e[r - 2] << 8) + e[r - 1]) >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "="), s.join("")
            };
            for (var n = [], r = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, o = s.length; a < o; ++a) n[a] = s[a], r[s.charCodeAt(a)] = a;

            function l(e) {
                var t = e.length;
                if (t % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
                var n = e.indexOf("="); - 1 === n && (n = t);
                var r = n === t ? 0 : 4 - n % 4;
                return [n, r]
            }
            r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63
        },
        5872: function(e, t, n) {
            "use strict";
            let r = n(5415),
                i = n(551),
                s = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;

            function a(e) {
                if (e > 2147483647) throw RangeError('The value "' + e + '" is invalid for option "size"');
                let t = new Uint8Array(e);
                return Object.setPrototypeOf(t, o.prototype), t
            }

            function o(e, t, n) {
                if ("number" == typeof e) {
                    if ("string" == typeof t) throw TypeError('The "string" argument must be of type string. Received type number');
                    return c(e)
                }
                return l(e, t, n)
            }

            function l(e, t, n) {
                if ("string" == typeof e) return function(e, t) {
                    if (("string" != typeof t || "" === t) && (t = "utf8"), !o.isEncoding(t)) throw TypeError("Unknown encoding: " + t);
                    let n = 0 | p(e, t),
                        r = a(n),
                        i = r.write(e, t);
                    return i !== n && (r = r.slice(0, i)), r
                }(e, t);
                if (ArrayBuffer.isView(e)) return function(e) {
                    if (U(e, Uint8Array)) {
                        let t = new Uint8Array(e);
                        return d(t.buffer, t.byteOffset, t.byteLength)
                    }
                    return h(e)
                }(e);
                if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                if (U(e, ArrayBuffer) || e && U(e.buffer, ArrayBuffer) || "undefined" != typeof SharedArrayBuffer && (U(e, SharedArrayBuffer) || e && U(e.buffer, SharedArrayBuffer))) return d(e, t, n);
                if ("number" == typeof e) throw TypeError('The "value" argument must not be of type number. Received type number');
                let r = e.valueOf && e.valueOf();
                if (null != r && r !== e) return o.from(r, t, n);
                let i = function(e) {
                    var t;
                    if (o.isBuffer(e)) {
                        let t = 0 | f(e.length),
                            n = a(t);
                        return 0 === n.length || e.copy(n, 0, 0, t), n
                    }
                    return void 0 !== e.length ? "number" != typeof e.length || (t = e.length) != t ? a(0) : h(e) : "Buffer" === e.type && Array.isArray(e.data) ? h(e.data) : void 0
                }(e);
                if (i) return i;
                if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return o.from(e[Symbol.toPrimitive]("string"), t, n);
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
            }

            function u(e) {
                if ("number" != typeof e) throw TypeError('"size" argument must be of type number');
                if (e < 0) throw RangeError('The value "' + e + '" is invalid for option "size"')
            }

            function c(e) {
                return u(e), a(e < 0 ? 0 : 0 | f(e))
            }

            function h(e) {
                let t = e.length < 0 ? 0 : 0 | f(e.length),
                    n = a(t);
                for (let r = 0; r < t; r += 1) n[r] = 255 & e[r];
                return n
            }

            function d(e, t, n) {
                let r;
                if (t < 0 || e.byteLength < t) throw RangeError('"offset" is outside of buffer bounds');
                if (e.byteLength < t + (n || 0)) throw RangeError('"length" is outside of buffer bounds');
                return Object.setPrototypeOf(r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), o.prototype), r
            }

            function f(e) {
                if (e >= 2147483647) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes");
                return 0 | e
            }

            function p(e, t) {
                if (o.isBuffer(e)) return e.length;
                if (ArrayBuffer.isView(e) || U(e, ArrayBuffer)) return e.byteLength;
                if ("string" != typeof e) throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                let n = e.length,
                    r = arguments.length > 2 && !0 === arguments[2];
                if (!r && 0 === n) return 0;
                let i = !1;
                for (;;) switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return n;
                    case "utf8":
                    case "utf-8":
                        return P(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * n;
                    case "hex":
                        return n >>> 1;
                    case "base64":
                        return O(e).length;
                    default:
                        if (i) return r ? -1 : P(e).length;
                        t = ("" + t).toLowerCase(), i = !0
                }
            }

            function g(e, t, n) {
                let i = !1;
                if ((void 0 === t || t < 0) && (t = 0), t > this.length || ((void 0 === n || n > this.length) && (n = this.length), n <= 0 || (n >>>= 0) <= (t >>>= 0))) return "";
                for (e || (e = "utf8");;) switch (e) {
                    case "hex":
                        return function(e, t, n) {
                            let r = e.length;
                            (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
                            let i = "";
                            for (let r = t; r < n; ++r) i += F[e[r]];
                            return i
                        }(this, t, n);
                    case "utf8":
                    case "utf-8":
                        return y(this, t, n);
                    case "ascii":
                        return function(e, t, n) {
                            let r = "";
                            n = Math.min(e.length, n);
                            for (let i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
                            return r
                        }(this, t, n);
                    case "latin1":
                    case "binary":
                        return function(e, t, n) {
                            let r = "";
                            n = Math.min(e.length, n);
                            for (let i = t; i < n; ++i) r += String.fromCharCode(e[i]);
                            return r
                        }(this, t, n);
                    case "base64":
                        var s, a;
                        return s = t, a = n, 0 === s && a === this.length ? r.fromByteArray(this) : r.fromByteArray(this.slice(s, a));
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return function(e, t, n) {
                            let r = e.slice(t, n),
                                i = "";
                            for (let e = 0; e < r.length - 1; e += 2) i += String.fromCharCode(r[e] + 256 * r[e + 1]);
                            return i
                        }(this, t, n);
                    default:
                        if (i) throw TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(), i = !0
                }
            }

            function A(e, t, n) {
                let r = e[t];
                e[t] = e[n], e[n] = r
            }

            function m(e, t, n, r, i) {
                var s;
                if (0 === e.length) return -1;
                if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), (s = n = +n) != s && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                    if (i) return -1;
                    n = e.length - 1
                } else if (n < 0) {
                    if (!i) return -1;
                    n = 0
                }
                if ("string" == typeof t && (t = o.from(t, r)), o.isBuffer(t)) return 0 === t.length ? -1 : v(e, t, n, r, i);
                if ("number" == typeof t) return (t &= 255, "function" == typeof Uint8Array.prototype.indexOf) ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : v(e, [t], n, r, i);
                throw TypeError("val must be string, number or Buffer")
            }

            function v(e, t, n, r, i) {
                let s, a = 1,
                    o = e.length,
                    l = t.length;
                if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                    if (e.length < 2 || t.length < 2) return -1;
                    a = 2, o /= 2, l /= 2, n /= 2
                }

                function u(e, t) {
                    return 1 === a ? e[t] : e.readUInt16BE(t * a)
                }
                if (i) {
                    let r = -1;
                    for (s = n; s < o; s++)
                        if (u(e, s) === u(t, -1 === r ? 0 : s - r)) {
                            if (-1 === r && (r = s), s - r + 1 === l) return r * a
                        } else -1 !== r && (s -= s - r), r = -1
                } else
                    for (n + l > o && (n = o - l), s = n; s >= 0; s--) {
                        let n = !0;
                        for (let r = 0; r < l; r++)
                            if (u(e, s + r) !== u(t, r)) {
                                n = !1;
                                break
                            }
                        if (n) return s
                    }
                return -1
            }

            function y(e, t, n) {
                n = Math.min(e.length, n);
                let r = [],
                    i = t;
                for (; i < n;) {
                    let t = e[i],
                        s = null,
                        a = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
                    if (i + a <= n) {
                        let n, r, o, l;
                        switch (a) {
                            case 1:
                                t < 128 && (s = t);
                                break;
                            case 2:
                                (192 & (n = e[i + 1])) == 128 && (l = (31 & t) << 6 | 63 & n) > 127 && (s = l);
                                break;
                            case 3:
                                n = e[i + 1], r = e[i + 2], (192 & n) == 128 && (192 & r) == 128 && (l = (15 & t) << 12 | (63 & n) << 6 | 63 & r) > 2047 && (l < 55296 || l > 57343) && (s = l);
                                break;
                            case 4:
                                n = e[i + 1], r = e[i + 2], o = e[i + 3], (192 & n) == 128 && (192 & r) == 128 && (192 & o) == 128 && (l = (15 & t) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & o) > 65535 && l < 1114112 && (s = l)
                        }
                    }
                    null === s ? (s = 65533, a = 1) : s > 65535 && (s -= 65536, r.push(s >>> 10 & 1023 | 55296), s = 56320 | 1023 & s), r.push(s), i += a
                }
                return function(e) {
                    let t = e.length;
                    if (t <= 4096) return String.fromCharCode.apply(String, e);
                    let n = "",
                        r = 0;
                    for (; r < t;) n += String.fromCharCode.apply(String, e.slice(r, r += 4096));
                    return n
                }(r)
            }

            function x(e, t, n) {
                if (e % 1 != 0 || e < 0) throw RangeError("offset is not uint");
                if (e + t > n) throw RangeError("Trying to access beyond buffer length")
            }

            function E(e, t, n, r, i, s) {
                if (!o.isBuffer(e)) throw TypeError('"buffer" argument must be a Buffer instance');
                if (t > i || t < s) throw RangeError('"value" argument is out of bounds');
                if (n + r > e.length) throw RangeError("Index out of range")
            }

            function _(e, t, n, r, i) {
                B(t, r, i, e, n, 7);
                let s = Number(t & BigInt(4294967295));
                e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s;
                let a = Number(t >> BigInt(32) & BigInt(4294967295));
                return e[n++] = a, a >>= 8, e[n++] = a, a >>= 8, e[n++] = a, a >>= 8, e[n++] = a, n
            }

            function b(e, t, n, r, i) {
                B(t, r, i, e, n, 7);
                let s = Number(t & BigInt(4294967295));
                e[n + 7] = s, s >>= 8, e[n + 6] = s, s >>= 8, e[n + 5] = s, s >>= 8, e[n + 4] = s;
                let a = Number(t >> BigInt(32) & BigInt(4294967295));
                return e[n + 3] = a, a >>= 8, e[n + 2] = a, a >>= 8, e[n + 1] = a, a >>= 8, e[n] = a, n + 8
            }

            function w(e, t, n, r, i, s) {
                if (n + r > e.length || n < 0) throw RangeError("Index out of range")
            }

            function C(e, t, n, r, s) {
                return t = +t, n >>>= 0, s || w(e, t, n, 4, 34028234663852886e22, -34028234663852886e22), i.write(e, t, n, r, 23, 4), n + 4
            }

            function S(e, t, n, r, s) {
                return t = +t, n >>>= 0, s || w(e, t, n, 8, 17976931348623157e292, -17976931348623157e292), i.write(e, t, n, r, 52, 8), n + 8
            }
            t.lW = o, t.h2 = 50, o.TYPED_ARRAY_SUPPORT = function() {
                try {
                    let e = new Uint8Array(1),
                        t = {
                            foo: function() {
                                return 42
                            }
                        };
                    return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo()
                } catch (e) {
                    return !1
                }
            }(), o.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(o.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (o.isBuffer(this)) return this.buffer
                }
            }), Object.defineProperty(o.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (o.isBuffer(this)) return this.byteOffset
                }
            }), o.poolSize = 8192, o.from = function(e, t, n) {
                return l(e, t, n)
            }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array), o.alloc = function(e, t, n) {
                return (u(e), e <= 0) ? a(e) : void 0 !== t ? "string" == typeof n ? a(e).fill(t, n) : a(e).fill(t) : a(e)
            }, o.allocUnsafe = function(e) {
                return c(e)
            }, o.allocUnsafeSlow = function(e) {
                return c(e)
            }, o.isBuffer = function(e) {
                return null != e && !0 === e._isBuffer && e !== o.prototype
            }, o.compare = function(e, t) {
                if (U(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)), U(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)), !o.isBuffer(e) || !o.isBuffer(t)) throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (e === t) return 0;
                let n = e.length,
                    r = t.length;
                for (let i = 0, s = Math.min(n, r); i < s; ++i)
                    if (e[i] !== t[i]) {
                        n = e[i], r = t[i];
                        break
                    }
                return n < r ? -1 : r < n ? 1 : 0
            }, o.isEncoding = function(e) {
                switch (String(e).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, o.concat = function(e, t) {
                let n;
                if (!Array.isArray(e)) throw TypeError('"list" argument must be an Array of Buffers');
                if (0 === e.length) return o.alloc(0);
                if (void 0 === t)
                    for (n = 0, t = 0; n < e.length; ++n) t += e[n].length;
                let r = o.allocUnsafe(t),
                    i = 0;
                for (n = 0; n < e.length; ++n) {
                    let t = e[n];
                    if (U(t, Uint8Array)) i + t.length > r.length ? (o.isBuffer(t) || (t = o.from(t)), t.copy(r, i)) : Uint8Array.prototype.set.call(r, t, i);
                    else if (o.isBuffer(t)) t.copy(r, i);
                    else throw TypeError('"list" argument must be an Array of Buffers');
                    i += t.length
                }
                return r
            }, o.byteLength = p, o.prototype._isBuffer = !0, o.prototype.swap16 = function() {
                let e = this.length;
                if (e % 2 != 0) throw RangeError("Buffer size must be a multiple of 16-bits");
                for (let t = 0; t < e; t += 2) A(this, t, t + 1);
                return this
            }, o.prototype.swap32 = function() {
                let e = this.length;
                if (e % 4 != 0) throw RangeError("Buffer size must be a multiple of 32-bits");
                for (let t = 0; t < e; t += 4) A(this, t, t + 3), A(this, t + 1, t + 2);
                return this
            }, o.prototype.swap64 = function() {
                let e = this.length;
                if (e % 8 != 0) throw RangeError("Buffer size must be a multiple of 64-bits");
                for (let t = 0; t < e; t += 8) A(this, t, t + 7), A(this, t + 1, t + 6), A(this, t + 2, t + 5), A(this, t + 3, t + 4);
                return this
            }, o.prototype.toString = function() {
                let e = this.length;
                return 0 === e ? "" : 0 == arguments.length ? y(this, 0, e) : g.apply(this, arguments)
            }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(e) {
                if (!o.isBuffer(e)) throw TypeError("Argument must be a Buffer");
                return this === e || 0 === o.compare(this, e)
            }, o.prototype.inspect = function() {
                let e = "",
                    n = t.h2;
                return e = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(), this.length > n && (e += " ... "), "<Buffer " + e + ">"
            }, s && (o.prototype[s] = o.prototype.inspect), o.prototype.compare = function(e, t, n, r, i) {
                if (U(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)), !o.isBuffer(e)) throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw RangeError("out of range index");
                if (r >= i && t >= n) return 0;
                if (r >= i) return -1;
                if (t >= n) return 1;
                if (t >>>= 0, n >>>= 0, r >>>= 0, i >>>= 0, this === e) return 0;
                let s = i - r,
                    a = n - t,
                    l = Math.min(s, a),
                    u = this.slice(r, i),
                    c = e.slice(t, n);
                for (let e = 0; e < l; ++e)
                    if (u[e] !== c[e]) {
                        s = u[e], a = c[e];
                        break
                    }
                return s < a ? -1 : a < s ? 1 : 0
            }, o.prototype.includes = function(e, t, n) {
                return -1 !== this.indexOf(e, t, n)
            }, o.prototype.indexOf = function(e, t, n) {
                return m(this, e, t, n, !0)
            }, o.prototype.lastIndexOf = function(e, t, n) {
                return m(this, e, t, n, !1)
            }, o.prototype.write = function(e, t, n, r) {
                var i, s, a, o, l, u, c, h;
                if (void 0 === t) r = "utf8", n = this.length, t = 0;
                else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0;
                else if (isFinite(t)) t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
                else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                let d = this.length - t;
                if ((void 0 === n || n > d) && (n = d), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw RangeError("Attempt to write outside buffer bounds");
                r || (r = "utf8");
                let f = !1;
                for (;;) switch (r) {
                    case "hex":
                        return function(e, t, n, r) {
                            let i;
                            n = Number(n) || 0;
                            let s = e.length - n;
                            r ? (r = Number(r)) > s && (r = s) : r = s;
                            let a = t.length;
                            for (r > a / 2 && (r = a / 2), i = 0; i < r; ++i) {
                                let r = parseInt(t.substr(2 * i, 2), 16);
                                if (r != r) break;
                                e[n + i] = r
                            }
                            return i
                        }(this, e, t, n);
                    case "utf8":
                    case "utf-8":
                        return i = t, s = n, N(P(e, this.length - i), this, i, s);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return a = t, o = n, N(function(e) {
                            let t = [];
                            for (let n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
                            return t
                        }(e), this, a, o);
                    case "base64":
                        return l = t, u = n, N(O(e), this, l, u);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return c = t, h = n, N(function(e, t) {
                            let n, r;
                            let i = [];
                            for (let s = 0; s < e.length && !((t -= 2) < 0); ++s) r = (n = e.charCodeAt(s)) >> 8, i.push(n % 256), i.push(r);
                            return i
                        }(e, this.length - c), this, c, h);
                    default:
                        if (f) throw TypeError("Unknown encoding: " + r);
                        r = ("" + r).toLowerCase(), f = !0
                }
            }, o.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }, o.prototype.slice = function(e, t) {
                let n = this.length;
                e = ~~e, t = void 0 === t ? n : ~~t, e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e);
                let r = this.subarray(e, t);
                return Object.setPrototypeOf(r, o.prototype), r
            }, o.prototype.readUintLE = o.prototype.readUIntLE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || x(e, t, this.length);
                let r = this[e],
                    i = 1,
                    s = 0;
                for (; ++s < t && (i *= 256);) r += this[e + s] * i;
                return r
            }, o.prototype.readUintBE = o.prototype.readUIntBE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || x(e, t, this.length);
                let r = this[e + --t],
                    i = 1;
                for (; t > 0 && (i *= 256);) r += this[e + --t] * i;
                return r
            }, o.prototype.readUint8 = o.prototype.readUInt8 = function(e, t) {
                return e >>>= 0, t || x(e, 1, this.length), this[e]
            }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(e, t) {
                return e >>>= 0, t || x(e, 2, this.length), this[e] | this[e + 1] << 8
            }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(e, t) {
                return e >>>= 0, t || x(e, 2, this.length), this[e] << 8 | this[e + 1]
            }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(e, t) {
                return e >>>= 0, t || x(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
            }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(e, t) {
                return e >>>= 0, t || x(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
            }, o.prototype.readBigUInt64LE = k(function(e) {
                R(e >>>= 0, "offset");
                let t = this[e],
                    n = this[e + 7];
                (void 0 === t || void 0 === n) && D(e, this.length - 8);
                let r = t + 256 * this[++e] + 65536 * this[++e] + 16777216 * this[++e],
                    i = this[++e] + 256 * this[++e] + 65536 * this[++e] + 16777216 * n;
                return BigInt(r) + (BigInt(i) << BigInt(32))
            }), o.prototype.readBigUInt64BE = k(function(e) {
                R(e >>>= 0, "offset");
                let t = this[e],
                    n = this[e + 7];
                (void 0 === t || void 0 === n) && D(e, this.length - 8);
                let r = 16777216 * t + 65536 * this[++e] + 256 * this[++e] + this[++e],
                    i = 16777216 * this[++e] + 65536 * this[++e] + 256 * this[++e] + n;
                return (BigInt(r) << BigInt(32)) + BigInt(i)
            }), o.prototype.readIntLE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || x(e, t, this.length);
                let r = this[e],
                    i = 1,
                    s = 0;
                for (; ++s < t && (i *= 256);) r += this[e + s] * i;
                return r >= (i *= 128) && (r -= Math.pow(2, 8 * t)), r
            }, o.prototype.readIntBE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || x(e, t, this.length);
                let r = t,
                    i = 1,
                    s = this[e + --r];
                for (; r > 0 && (i *= 256);) s += this[e + --r] * i;
                return s >= (i *= 128) && (s -= Math.pow(2, 8 * t)), s
            }, o.prototype.readInt8 = function(e, t) {
                return (e >>>= 0, t || x(e, 1, this.length), 128 & this[e]) ? -((255 - this[e] + 1) * 1) : this[e]
            }, o.prototype.readInt16LE = function(e, t) {
                e >>>= 0, t || x(e, 2, this.length);
                let n = this[e] | this[e + 1] << 8;
                return 32768 & n ? 4294901760 | n : n
            }, o.prototype.readInt16BE = function(e, t) {
                e >>>= 0, t || x(e, 2, this.length);
                let n = this[e + 1] | this[e] << 8;
                return 32768 & n ? 4294901760 | n : n
            }, o.prototype.readInt32LE = function(e, t) {
                return e >>>= 0, t || x(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
            }, o.prototype.readInt32BE = function(e, t) {
                return e >>>= 0, t || x(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
            }, o.prototype.readBigInt64LE = k(function(e) {
                R(e >>>= 0, "offset");
                let t = this[e],
                    n = this[e + 7];
                return (void 0 === t || void 0 === n) && D(e, this.length - 8), (BigInt(this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24)) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + 16777216 * this[++e])
            }), o.prototype.readBigInt64BE = k(function(e) {
                R(e >>>= 0, "offset");
                let t = this[e],
                    n = this[e + 7];
                return (void 0 === t || void 0 === n) && D(e, this.length - 8), (BigInt((t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]) << BigInt(32)) + BigInt(16777216 * this[++e] + 65536 * this[++e] + 256 * this[++e] + n)
            }), o.prototype.readFloatLE = function(e, t) {
                return e >>>= 0, t || x(e, 4, this.length), i.read(this, e, !0, 23, 4)
            }, o.prototype.readFloatBE = function(e, t) {
                return e >>>= 0, t || x(e, 4, this.length), i.read(this, e, !1, 23, 4)
            }, o.prototype.readDoubleLE = function(e, t) {
                return e >>>= 0, t || x(e, 8, this.length), i.read(this, e, !0, 52, 8)
            }, o.prototype.readDoubleBE = function(e, t) {
                return e >>>= 0, t || x(e, 8, this.length), i.read(this, e, !1, 52, 8)
            }, o.prototype.writeUintLE = o.prototype.writeUIntLE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, n >>>= 0, !r) {
                    let r = Math.pow(2, 8 * n) - 1;
                    E(this, e, t, n, r, 0)
                }
                let i = 1,
                    s = 0;
                for (this[t] = 255 & e; ++s < n && (i *= 256);) this[t + s] = e / i & 255;
                return t + n
            }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, n >>>= 0, !r) {
                    let r = Math.pow(2, 8 * n) - 1;
                    E(this, e, t, n, r, 0)
                }
                let i = n - 1,
                    s = 1;
                for (this[t + i] = 255 & e; --i >= 0 && (s *= 256);) this[t + i] = e / s & 255;
                return t + n
            }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
            }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
            }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
            }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
            }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
            }, o.prototype.writeBigUInt64LE = k(function(e, t = 0) {
                return _(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
            }), o.prototype.writeBigUInt64BE = k(function(e, t = 0) {
                return b(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
            }), o.prototype.writeIntLE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, !r) {
                    let r = Math.pow(2, 8 * n - 1);
                    E(this, e, t, n, r - 1, -r)
                }
                let i = 0,
                    s = 1,
                    a = 0;
                for (this[t] = 255 & e; ++i < n && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + i - 1] && (a = 1), this[t + i] = (e / s >> 0) - a & 255;
                return t + n
            }, o.prototype.writeIntBE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, !r) {
                    let r = Math.pow(2, 8 * n - 1);
                    E(this, e, t, n, r - 1, -r)
                }
                let i = n - 1,
                    s = 1,
                    a = 0;
                for (this[t + i] = 255 & e; --i >= 0 && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + i + 1] && (a = 1), this[t + i] = (e / s >> 0) - a & 255;
                return t + n
            }, o.prototype.writeInt8 = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
            }, o.prototype.writeInt16LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
            }, o.prototype.writeInt16BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
            }, o.prototype.writeInt32LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
            }, o.prototype.writeInt32BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || E(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
            }, o.prototype.writeBigInt64LE = k(function(e, t = 0) {
                return _(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), o.prototype.writeBigInt64BE = k(function(e, t = 0) {
                return b(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), o.prototype.writeFloatLE = function(e, t, n) {
                return C(this, e, t, !0, n)
            }, o.prototype.writeFloatBE = function(e, t, n) {
                return C(this, e, t, !1, n)
            }, o.prototype.writeDoubleLE = function(e, t, n) {
                return S(this, e, t, !0, n)
            }, o.prototype.writeDoubleBE = function(e, t, n) {
                return S(this, e, t, !1, n)
            }, o.prototype.copy = function(e, t, n, r) {
                if (!o.isBuffer(e)) throw TypeError("argument should be a Buffer");
                if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n || 0 === e.length || 0 === this.length) return 0;
                if (t < 0) throw RangeError("targetStart out of bounds");
                if (n < 0 || n >= this.length) throw RangeError("Index out of range");
                if (r < 0) throw RangeError("sourceEnd out of bounds");
                r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
                let i = r - n;
                return this === e && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, n, r) : Uint8Array.prototype.set.call(e, this.subarray(n, r), t), i
            }, o.prototype.fill = function(e, t, n, r) {
                let i;
                if ("string" == typeof e) {
                    if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), void 0 !== r && "string" != typeof r) throw TypeError("encoding must be a string");
                    if ("string" == typeof r && !o.isEncoding(r)) throw TypeError("Unknown encoding: " + r);
                    if (1 === e.length) {
                        let t = e.charCodeAt(0);
                        ("utf8" === r && t < 128 || "latin1" === r) && (e = t)
                    }
                } else "number" == typeof e ? e &= 255 : "boolean" == typeof e && (e = Number(e));
                if (t < 0 || this.length < t || this.length < n) throw RangeError("Out of range index");
                if (n <= t) return this;
                if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e)
                    for (i = t; i < n; ++i) this[i] = e;
                else {
                    let s = o.isBuffer(e) ? e : o.from(e, r),
                        a = s.length;
                    if (0 === a) throw TypeError('The value "' + e + '" is invalid for argument "value"');
                    for (i = 0; i < n - t; ++i) this[i + t] = s[i % a]
                }
                return this
            };
            let I = {};

            function M(e, t, n) {
                I[e] = class extends n {
                    constructor() {
                        super(), Object.defineProperty(this, "message", {
                            value: t.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }), this.name = `${this.name} [${e}]`, this.stack, delete this.name
                    }
                    get code() {
                        return e
                    }
                    set code(e) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value: e,
                            writable: !0
                        })
                    }
                    toString() {
                        return `${this.name} [${e}]: ${this.message}`
                    }
                }
            }

            function T(e) {
                let t = "",
                    n = e.length,
                    r = "-" === e[0] ? 1 : 0;
                for (; n >= r + 4; n -= 3) t = `_${e.slice(n-3,n)}${t}`;
                return `${e.slice(0,n)}${t}`
            }

            function B(e, t, n, r, i, s) {
                if (e > n || e < t) {
                    let r;
                    let i = "bigint" == typeof t ? "n" : "";
                    throw r = s > 3 ? 0 === t || t === BigInt(0) ? `>= 0${i} and < 2${i} ** ${(s+1)*8}${i}` : `>= -(2${i} ** ${(s+1)*8-1}${i}) and < 2 ** ${(s+1)*8-1}${i}` : `>= ${t}${i} and <= ${n}${i}`, new I.ERR_OUT_OF_RANGE("value", r, e)
                }
                R(i, "offset"), (void 0 === r[i] || void 0 === r[i + s]) && D(i, r.length - (s + 1))
            }

            function R(e, t) {
                if ("number" != typeof e) throw new I.ERR_INVALID_ARG_TYPE(t, "number", e)
            }

            function D(e, t, n) {
                if (Math.floor(e) !== e) throw R(e, n), new I.ERR_OUT_OF_RANGE(n || "offset", "an integer", e);
                if (t < 0) throw new I.ERR_BUFFER_OUT_OF_BOUNDS;
                throw new I.ERR_OUT_OF_RANGE(n || "offset", `>= ${n?1:0} and <= ${t}`, e)
            }
            M("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
                return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
            }, RangeError), M("ERR_INVALID_ARG_TYPE", function(e, t) {
                return `The "${e}" argument must be of type number. Received type ${typeof t}`
            }, TypeError), M("ERR_OUT_OF_RANGE", function(e, t, n) {
                let r = `The value of "${e}" is out of range.`,
                    i = n;
                return Number.isInteger(n) && Math.abs(n) > 4294967296 ? i = T(String(n)) : "bigint" == typeof n && (i = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = T(i)), i += "n"), r += ` It must be ${t}. Received ${i}`
            }, RangeError);
            let L = /[^+/0-9A-Za-z-_]/g;

            function P(e, t) {
                let n;
                t = t || 1 / 0;
                let r = e.length,
                    i = null,
                    s = [];
                for (let a = 0; a < r; ++a) {
                    if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {
                        if (!i) {
                            if (n > 56319 || a + 1 === r) {
                                (t -= 3) > -1 && s.push(239, 191, 189);
                                continue
                            }
                            i = n;
                            continue
                        }
                        if (n < 56320) {
                            (t -= 3) > -1 && s.push(239, 191, 189), i = n;
                            continue
                        }
                        n = (i - 55296 << 10 | n - 56320) + 65536
                    } else i && (t -= 3) > -1 && s.push(239, 191, 189);
                    if (i = null, n < 128) {
                        if ((t -= 1) < 0) break;
                        s.push(n)
                    } else if (n < 2048) {
                        if ((t -= 2) < 0) break;
                        s.push(n >> 6 | 192, 63 & n | 128)
                    } else if (n < 65536) {
                        if ((t -= 3) < 0) break;
                        s.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                    } else if (n < 1114112) {
                        if ((t -= 4) < 0) break;
                        s.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                    } else throw Error("Invalid code point")
                }
                return s
            }

            function O(e) {
                return r.toByteArray(function(e) {
                    if ((e = (e = e.split("=")[0]).trim().replace(L, "")).length < 2) return "";
                    for (; e.length % 4 != 0;) e += "=";
                    return e
                }(e))
            }

            function N(e, t, n, r) {
                let i;
                for (i = 0; i < r && !(i + n >= t.length) && !(i >= e.length); ++i) t[i + n] = e[i];
                return i
            }

            function U(e, t) {
                return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
            }
            let F = function() {
                let e = "0123456789abcdef",
                    t = Array(256);
                for (let n = 0; n < 16; ++n) {
                    let r = 16 * n;
                    for (let i = 0; i < 16; ++i) t[r + i] = e[n] + e[i]
                }
                return t
            }();

            function k(e) {
                return "undefined" == typeof BigInt ? Q : e
            }

            function Q() {
                throw Error("BigInt not supported")
            }
        },
        3706: function(e, t) {
            "use strict";
            var n, r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0, (r = n = t.ElementType || (t.ElementType = {})).Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype", t.isTag = function(e) {
                return e.type === n.Tag || e.type === n.Script || e.type === n.Style
            }, t.Root = n.Root, t.Text = n.Text, t.Directive = n.Directive, t.Comment = n.Comment, t.Script = n.Script, t.Style = n.Style, t.Tag = n.Tag, t.CDATA = n.CDATA, t.Doctype = n.Doctype
        },
        1612: function(e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n);
                    var i = Object.getOwnPropertyDescriptor(t, n);
                    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
                        enumerable: !0,
                        get: function() {
                            return t[n]
                        }
                    }), Object.defineProperty(e, r, i)
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n]
                }),
                i = this && this.__exportStar || function(e, t) {
                    for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n)
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DomHandler = void 0;
            var s = n(3706),
                a = n(4409);
            i(n(4409), t);
            var o = {
                    withStartIndices: !1,
                    withEndIndices: !1,
                    xmlMode: !1
                },
                l = function() {
                    function e(e, t, n) {
                        this.dom = [], this.root = new a.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, "function" == typeof t && (n = t, t = o), "object" == typeof e && (t = e, e = void 0), this.callback = null != e ? e : null, this.options = null != t ? t : o, this.elementCB = null != n ? n : null
                    }
                    return e.prototype.onparserinit = function(e) {
                        this.parser = e
                    }, e.prototype.onreset = function() {
                        this.dom = [], this.root = new a.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null
                    }, e.prototype.onend = function() {
                        this.done || (this.done = !0, this.parser = null, this.handleCallback(null))
                    }, e.prototype.onerror = function(e) {
                        this.handleCallback(e)
                    }, e.prototype.onclosetag = function() {
                        this.lastNode = null;
                        var e = this.tagStack.pop();
                        this.options.withEndIndices && (e.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(e)
                    }, e.prototype.onopentag = function(e, t) {
                        var n = this.options.xmlMode ? s.ElementType.Tag : void 0,
                            r = new a.Element(e, t, void 0, n);
                        this.addNode(r), this.tagStack.push(r)
                    }, e.prototype.ontext = function(e) {
                        var t = this.lastNode;
                        if (t && t.type === s.ElementType.Text) t.data += e, this.options.withEndIndices && (t.endIndex = this.parser.endIndex);
                        else {
                            var n = new a.Text(e);
                            this.addNode(n), this.lastNode = n
                        }
                    }, e.prototype.oncomment = function(e) {
                        if (this.lastNode && this.lastNode.type === s.ElementType.Comment) {
                            this.lastNode.data += e;
                            return
                        }
                        var t = new a.Comment(e);
                        this.addNode(t), this.lastNode = t
                    }, e.prototype.oncommentend = function() {
                        this.lastNode = null
                    }, e.prototype.oncdatastart = function() {
                        var e = new a.Text(""),
                            t = new a.CDATA([e]);
                        this.addNode(t), e.parent = t, this.lastNode = e
                    }, e.prototype.oncdataend = function() {
                        this.lastNode = null
                    }, e.prototype.onprocessinginstruction = function(e, t) {
                        var n = new a.ProcessingInstruction(e, t);
                        this.addNode(n)
                    }, e.prototype.handleCallback = function(e) {
                        if ("function" == typeof this.callback) this.callback(e, this.dom);
                        else if (e) throw e
                    }, e.prototype.addNode = function(e) {
                        var t = this.tagStack[this.tagStack.length - 1],
                            n = t.children[t.children.length - 1];
                        this.options.withStartIndices && (e.startIndex = this.parser.startIndex), this.options.withEndIndices && (e.endIndex = this.parser.endIndex), t.children.push(e), n && (e.prev = n, n.next = e), e.parent = t, this.lastNode = null
                    }, e
                }();
            t.DomHandler = l, t.default = l
        },
        4409: function(e, t, n) {
            "use strict";
            var r, i = this && this.__extends || (r = function(e, t) {
                    return (r = Object.setPrototypeOf || ({
                        __proto__: []
                    }) instanceof Array && function(e, t) {
                        e.__proto__ = t
                    } || function(e, t) {
                        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
                    })(e, t)
                }, function(e, t) {
                    if ("function" != typeof t && null !== t) throw TypeError("Class extends value " + String(t) + " is not a constructor or null");

                    function n() {
                        this.constructor = e
                    }
                    r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
                }),
                s = this && this.__assign || function() {
                    return (s = Object.assign || function(e) {
                        for (var t, n = 1, r = arguments.length; n < r; n++)
                            for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                        return e
                    }).apply(this, arguments)
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.cloneNode = t.hasChildren = t.isDocument = t.isDirective = t.isComment = t.isText = t.isCDATA = t.isTag = t.Element = t.Document = t.CDATA = t.NodeWithChildren = t.ProcessingInstruction = t.Comment = t.Text = t.DataNode = t.Node = void 0;
            var a = n(3706),
                o = function() {
                    function e() {
                        this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null
                    }
                    return Object.defineProperty(e.prototype, "parentNode", {
                        get: function() {
                            return this.parent
                        },
                        set: function(e) {
                            this.parent = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "previousSibling", {
                        get: function() {
                            return this.prev
                        },
                        set: function(e) {
                            this.prev = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "nextSibling", {
                        get: function() {
                            return this.next
                        },
                        set: function(e) {
                            this.next = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.cloneNode = function(e) {
                        return void 0 === e && (e = !1), _(this, e)
                    }, e
                }();
            t.Node = o;
            var l = function(e) {
                function t(t) {
                    var n = e.call(this) || this;
                    return n.data = t, n
                }
                return i(t, e), Object.defineProperty(t.prototype, "nodeValue", {
                    get: function() {
                        return this.data
                    },
                    set: function(e) {
                        this.data = e
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(o);
            t.DataNode = l;
            var u = function(e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t.type = a.ElementType.Text, t
                }
                return i(t, e), Object.defineProperty(t.prototype, "nodeType", {
                    get: function() {
                        return 3
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(l);
            t.Text = u;
            var c = function(e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t.type = a.ElementType.Comment, t
                }
                return i(t, e), Object.defineProperty(t.prototype, "nodeType", {
                    get: function() {
                        return 8
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(l);
            t.Comment = c;
            var h = function(e) {
                function t(t, n) {
                    var r = e.call(this, n) || this;
                    return r.name = t, r.type = a.ElementType.Directive, r
                }
                return i(t, e), Object.defineProperty(t.prototype, "nodeType", {
                    get: function() {
                        return 1
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(l);
            t.ProcessingInstruction = h;
            var d = function(e) {
                function t(t) {
                    var n = e.call(this) || this;
                    return n.children = t, n
                }
                return i(t, e), Object.defineProperty(t.prototype, "firstChild", {
                    get: function() {
                        var e;
                        return null !== (e = this.children[0]) && void 0 !== e ? e : null
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "lastChild", {
                    get: function() {
                        return this.children.length > 0 ? this.children[this.children.length - 1] : null
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "childNodes", {
                    get: function() {
                        return this.children
                    },
                    set: function(e) {
                        this.children = e
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(o);
            t.NodeWithChildren = d;
            var f = function(e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t.type = a.ElementType.CDATA, t
                }
                return i(t, e), Object.defineProperty(t.prototype, "nodeType", {
                    get: function() {
                        return 4
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(d);
            t.CDATA = f;
            var p = function(e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t.type = a.ElementType.Root, t
                }
                return i(t, e), Object.defineProperty(t.prototype, "nodeType", {
                    get: function() {
                        return 9
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(d);
            t.Document = p;
            var g = function(e) {
                function t(t, n, r, i) {
                    void 0 === r && (r = []), void 0 === i && (i = "script" === t ? a.ElementType.Script : "style" === t ? a.ElementType.Style : a.ElementType.Tag);
                    var s = e.call(this, r) || this;
                    return s.name = t, s.attribs = n, s.type = i, s
                }
                return i(t, e), Object.defineProperty(t.prototype, "nodeType", {
                    get: function() {
                        return 1
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "tagName", {
                    get: function() {
                        return this.name
                    },
                    set: function(e) {
                        this.name = e
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "attributes", {
                    get: function() {
                        var e = this;
                        return Object.keys(this.attribs).map(function(t) {
                            var n, r;
                            return {
                                name: t,
                                value: e.attribs[t],
                                namespace: null === (n = e["x-attribsNamespace"]) || void 0 === n ? void 0 : n[t],
                                prefix: null === (r = e["x-attribsPrefix"]) || void 0 === r ? void 0 : r[t]
                            }
                        })
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(d);

            function A(e) {
                return (0, a.isTag)(e)
            }

            function m(e) {
                return e.type === a.ElementType.CDATA
            }

            function v(e) {
                return e.type === a.ElementType.Text
            }

            function y(e) {
                return e.type === a.ElementType.Comment
            }

            function x(e) {
                return e.type === a.ElementType.Directive
            }

            function E(e) {
                return e.type === a.ElementType.Root
            }

            function _(e, t) {
                if (void 0 === t && (t = !1), v(e)) n = new u(e.data);
                else if (y(e)) n = new c(e.data);
                else if (A(e)) {
                    var n, r = t ? b(e.children) : [],
                        i = new g(e.name, s({}, e.attribs), r);
                    r.forEach(function(e) {
                        return e.parent = i
                    }), null != e.namespace && (i.namespace = e.namespace), e["x-attribsNamespace"] && (i["x-attribsNamespace"] = s({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (i["x-attribsPrefix"] = s({}, e["x-attribsPrefix"])), n = i
                } else if (m(e)) {
                    var r = t ? b(e.children) : [],
                        a = new f(r);
                    r.forEach(function(e) {
                        return e.parent = a
                    }), n = a
                } else if (E(e)) {
                    var r = t ? b(e.children) : [],
                        o = new p(r);
                    r.forEach(function(e) {
                        return e.parent = o
                    }), e["x-mode"] && (o["x-mode"] = e["x-mode"]), n = o
                } else if (x(e)) {
                    var l = new h(e.name, e.data);
                    null != e["x-name"] && (l["x-name"] = e["x-name"], l["x-publicId"] = e["x-publicId"], l["x-systemId"] = e["x-systemId"]), n = l
                } else throw Error("Not implemented yet: ".concat(e.type));
                return n.startIndex = e.startIndex, n.endIndex = e.endIndex, null != e.sourceCodeLocation && (n.sourceCodeLocation = e.sourceCodeLocation), n
            }

            function b(e) {
                for (var t = e.map(function(e) {
                        return _(e, !0)
                    }), n = 1; n < t.length; n++) t[n].prev = t[n - 1], t[n - 1].next = t[n];
                return t
            }
            t.Element = g, t.isTag = A, t.isCDATA = m, t.isText = v, t.isComment = y, t.isDirective = x, t.isDocument = E, t.hasChildren = function(e) {
                return Object.prototype.hasOwnProperty.call(e, "children")
            }, t.cloneNode = _
        },
        7650: function(e, t) {
            var n, r, i, s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x;
            n = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig, r = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig, i = Math.PI / 180, s = Math.sin, a = Math.cos, o = Math.abs, l = Math.sqrt, u = function(e) {
                return Math.round(1e5 * e) / 1e5 || 0
            }, d = function() {
                return c || "undefined" != typeof window && (c = window.gsap) && c.registerPlugin && c
            }, f = function() {
                (c = d()) ? (c.registerEase("_CE", x.create), h = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
            }, p = function(e) {
                return ~~(1e3 * e + (e < 0 ? -.5 : .5)) / 1e3
            }, g = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi, A = /[cLlsSaAhHvVtTqQ]/g, m = function(e) {
                var t, n = e.length,
                    r = 1e20;
                for (t = 1; t < n; t += 6) + e[t] < r && (r = +e[t]);
                return r
            }, v = function(e, t, n) {
                n || 0 === n || (n = Math.max(+e[e.length - 1], +e[1]));
                var r, i = -1 * +e[0],
                    s = -n,
                    a = e.length,
                    o = 1 / (+e[a - 2] + i),
                    l = -t || (Math.abs(+e[a - 1] - +e[1]) < .01 * (+e[a - 2] - +e[0]) ? m(e) + s : +e[a - 1] + s);
                for (r = 0, l = l ? 1 / l : -o; r < a; r += 2) e[r] = (+e[r] + i) * o, e[r + 1] = (+e[r + 1] + s) * l
            }, y = function e(t, n, r, i, s, a, o, l, u, c, h) {
                var d, f = (t + r) / 2,
                    p = (n + i) / 2,
                    g = (r + s) / 2,
                    A = (i + a) / 2,
                    m = (s + o) / 2,
                    v = (a + l) / 2,
                    y = (f + g) / 2,
                    x = (p + A) / 2,
                    E = (g + m) / 2,
                    _ = (A + v) / 2,
                    b = (y + E) / 2,
                    w = (x + _) / 2,
                    C = o - t,
                    S = l - n,
                    I = Math.abs((r - o) * S - (i - l) * C),
                    M = Math.abs((s - o) * S - (a - l) * C);
                return c || (c = [{
                    x: t,
                    y: n
                }, {
                    x: o,
                    y: l
                }], h = 1), c.splice(h || c.length - 1, 0, {
                    x: b,
                    y: w
                }), (I + M) * (I + M) > u * (C * C + S * S) && (d = c.length, e(t, n, f, p, y, x, b, w, u, c, h), e(b, w, E, _, m, v, o, l, u, c, h + 1 + (c.length - d))), c
            }, (x = function() {
                function e(e, t, n) {
                    h || f(), this.id = e, this.setData(t, n)
                }
                var t = e.prototype;
                return t.setData = function(e, t) {
                    t = t || {};
                    var u, h, d, f, p, m, x, E, _, b = (e = e || "0,0,1,1").match(g),
                        w = 1,
                        C = [],
                        S = [],
                        I = t.precision || 1,
                        M = I <= 1;
                    if (this.data = e, (A.test(e) || ~e.indexOf("M") && 0 > e.indexOf("C")) && (b = function(e) {
                            var t, u, c, h, d, f, p, g, A, m, v, y, x, E, _, b = (e + "").replace(r, function(e) {
                                    var t = +e;
                                    return t < 1e-4 && t > -.0001 ? 0 : t
                                }).match(n) || [],
                                w = [],
                                C = 0,
                                S = 0,
                                I = 2 / 3,
                                M = b.length,
                                T = 0,
                                B = "ERROR: malformed path: " + e,
                                R = function(e, t, n, r) {
                                    m = (n - e) / 3, v = (r - t) / 3, p.push(e + m, t + v, n - m, r - v, n, r)
                                };
                            if (!e || !isNaN(b[0]) || isNaN(b[1])) return console.log(B), w;
                            for (t = 0; t < M; t++)
                                if (x = d, isNaN(b[t]) ? f = (d = b[t].toUpperCase()) !== b[t] : t--, c = +b[t + 1], h = +b[t + 2], f && (c += C, h += S), t || (g = c, A = h), "M" === d) p && (p.length < 8 ? w.length -= 1 : T += p.length), C = g = c, S = A = h, p = [c, h], w.push(p), t += 2, d = "L";
                                else if ("C" === d) p || (p = [0, 0]), f || (C = S = 0), p.push(c, h, C + 1 * b[t + 3], S + 1 * b[t + 4], C += 1 * b[t + 5], S += 1 * b[t + 6]), t += 6;
                            else if ("S" === d) m = C, v = S, ("C" === x || "S" === x) && (m += C - p[p.length - 4], v += S - p[p.length - 3]), f || (C = S = 0), p.push(m, v, c, h, C += 1 * b[t + 3], S += 1 * b[t + 4]), t += 4;
                            else if ("Q" === d) m = C + (c - C) * I, v = S + (h - S) * I, f || (C = S = 0), C += 1 * b[t + 3], S += 1 * b[t + 4], p.push(m, v, C + (c - C) * I, S + (h - S) * I, C, S), t += 4;
                            else if ("T" === d) m = C - p[p.length - 4], v = S - p[p.length - 3], p.push(C + m, S + v, c + (C + 1.5 * m - c) * I, h + (S + 1.5 * v - h) * I, C = c, S = h), t += 2;
                            else if ("H" === d) R(C, S, C = c, S), t += 1;
                            else if ("V" === d) R(C, S, C, S = c + (f ? S - C : 0)), t += 1;
                            else if ("L" === d || "Z" === d) "Z" === d && (c = g, h = A, p.closed = !0), ("L" === d || o(C - c) > .5 || o(S - h) > .5) && (R(C, S, c, h), "L" === d && (t += 2)), C = c, S = h;
                            else if ("A" === d) {
                                if (E = b[t + 4], _ = b[t + 5], m = b[t + 6], v = b[t + 7], u = 7, E.length > 1 && (E.length < 3 ? (v = m, m = _, u--) : (v = _, m = E.substr(2), u -= 2), _ = E.charAt(1), E = E.charAt(0)), y = function(e, t, n, r, u, c, h, d, f) {
                                        if (e !== d || t !== f) {
                                            n = o(n), r = o(r);
                                            var p = u % 360 * i,
                                                g = a(p),
                                                A = s(p),
                                                m = Math.PI,
                                                v = 2 * m,
                                                y = (e - d) / 2,
                                                x = (t - f) / 2,
                                                E = g * y + A * x,
                                                _ = -A * y + g * x,
                                                b = E * E,
                                                w = _ * _,
                                                C = b / (n * n) + w / (r * r);
                                            C > 1 && (n = l(C) * n, r = l(C) * r);
                                            var S = n * n,
                                                I = r * r,
                                                M = (S * I - S * w - I * b) / (S * w + I * b);
                                            M < 0 && (M = 0);
                                            var T = (c === h ? -1 : 1) * l(M),
                                                B = n * _ / r * T,
                                                R = -(r * E / n * T),
                                                D = (e + d) / 2 + (g * B - A * R),
                                                L = (t + f) / 2 + (A * B + g * R),
                                                P = (E - B) / n,
                                                O = (_ - R) / r,
                                                N = (-E - B) / n,
                                                U = (-_ - R) / r,
                                                F = P * P + O * O,
                                                k = (O < 0 ? -1 : 1) * Math.acos(P / l(F)),
                                                Q = (P * U - O * N < 0 ? -1 : 1) * Math.acos((P * N + O * U) / l(F * (N * N + U * U)));
                                            isNaN(Q) && (Q = m), !h && Q > 0 ? Q -= v : h && Q < 0 && (Q += v), k %= v;
                                            var G, z = Math.ceil(o(Q %= v) / (v / 4)),
                                                H = [],
                                                V = Q / z,
                                                j = 4 / 3 * s(V / 2) / (1 + a(V / 2)),
                                                W = g * n,
                                                Y = A * n,
                                                X = -(A * r),
                                                q = g * r;
                                            for (G = 0; G < z; G++) E = a(u = k + G * V), _ = s(u), P = a(u += V), O = s(u), H.push(E - j * _, _ + j * E, P + j * O, O - j * P, P, O);
                                            for (G = 0; G < H.length; G += 2) E = H[G], _ = H[G + 1], H[G] = E * W + _ * X + D, H[G + 1] = E * Y + _ * q + L;
                                            return H[G - 2] = d, H[G - 1] = f, H
                                        }
                                    }(C, S, +b[t + 1], +b[t + 2], +b[t + 3], +E, +_, (f ? C : 0) + 1 * m, (f ? S : 0) + 1 * v), t += u, y)
                                    for (u = 0; u < y.length; u++) p.push(y[u]);
                                C = p[p.length - 2], S = p[p.length - 1]
                            } else console.log(B);
                            return (t = p.length) < 6 ? (w.pop(), t = 0) : p[0] === p[t - 2] && p[1] === p[t - 1] && (p.closed = !0), w.totalPoints = T + t, w
                        }(e)[0]), 4 === (u = b.length)) b.unshift(0, 0), b.push(1, 1), u = 8;
                    else if ((u - 2) % 6) throw "Invalid CustomEase";
                    for ((0 != +b[0] || 1 != +b[u - 2]) && v(b, t.height, t.originY), this.segment = b, f = 2; f < u; f += 6) h = {
                        x: +b[f - 2],
                        y: +b[f - 1]
                    }, d = {
                        x: +b[f + 4],
                        y: +b[f + 5]
                    }, C.push(h, d), y(h.x, h.y, +b[f], +b[f + 1], +b[f + 2], +b[f + 3], d.x, d.y, 1 / (2e5 * I), C, C.length - 1);
                    for (f = 0, u = C.length; f < u; f++) x = C[f], E = C[f - 1] || x, (x.x > E.x || E.y !== x.y && E.x === x.x || x === E) && x.x <= 1 ? (E.cx = x.x - E.x, E.cy = x.y - E.y, E.n = x, E.nx = x.x, M && f > 1 && Math.abs(E.cy / E.cx - C[f - 2].cy / C[f - 2].cx) > 2 && (M = 0), E.cx < w && (E.cx ? w = E.cx : (E.cx = .001, f === u - 1 && (E.x -= .001, w = Math.min(w, .001), M = 0)))) : (C.splice(f--, 1), u--);
                    if (p = 1 / (u = 1 / w + 1 | 0), m = 0, x = C[0], M) {
                        for (f = 0; f < u; f++) _ = f * p, x.nx < _ && (x = C[++m]), h = x.y + (_ - x.x) / x.cx * x.cy, S[f] = {
                            x: _,
                            cx: p,
                            y: h,
                            cy: 0,
                            nx: 9
                        }, f && (S[f - 1].cy = h - S[f - 1].y);
                        m = C[C.length - 1], S[u - 1].cy = m.y - h, S[u - 1].cx = m.x - S[S.length - 1].x
                    } else {
                        for (f = 0; f < u; f++) x.nx < f * p && (x = C[++m]), S[f] = x;
                        m < C.length - 1 && (S[f - 1] = C[C.length - 2])
                    }
                    return this.ease = function(e) {
                        var t = S[e * u | 0] || S[u - 1];
                        return t.nx < e && (t = t.n), t.y + (e - t.x) / t.cx * t.cy
                    }, this.ease.custom = this, this.id && c && c.registerEase(this.id, this.ease), this
                }, t.getSVGData = function(t) {
                    return e.getSVGData(this, t)
                }, e.create = function(t, n, r) {
                    return new e(t, n, r).ease
                }, e.register = function(e) {
                    c = e, f()
                }, e.get = function(e) {
                    return c.parseEase(e)
                }, e.getSVGData = function(t, n) {
                    var r, i, s, a, o, l, h, d, f, g, A = (n = n || {}).width || 100,
                        m = n.height || 100,
                        v = n.x || 0,
                        y = (n.y || 0) + m,
                        x = c.utils.toArray(n.path)[0];
                    if (n.invert && (m = -m, y = 0), "string" == typeof t && (t = c.parseEase(t)), t.custom && (t = t.custom), t instanceof e) r = function(e) {
                        "number" == typeof e[0] && (e = [e]);
                        var t, n, r, i, s = "",
                            a = e.length;
                        for (n = 0; n < a; n++) {
                            for (s += "M" + u((i = e[n])[0]) + "," + u(i[1]) + " C", t = i.length, r = 2; r < t; r++) s += u(i[r++]) + "," + u(i[r++]) + " " + u(i[r++]) + "," + u(i[r++]) + " " + u(i[r++]) + "," + u(i[r]) + " ";
                            i.closed && (s += "z")
                        }
                        return s
                    }(function(e, t, n, r, i, s, a) {
                        for (var o, l, u, c, h, d = e.length; --d > -1;)
                            for (u = 0, l = (o = e[d]).length; u < l; u += 2) c = o[u], h = o[u + 1], o[u] = c * t + 0 * h + s, o[u + 1] = 0 * c + h * i + a;
                        return e._dirty = 1, e
                    }([t.segment], A, 0, 0, -m, v, y));
                    else {
                        for (r = [v, y], a = 1 / (h = Math.max(5, 200 * (n.precision || 1))), h += 2, d = 5 / h, f = p(v + a * A), i = ((g = p(y + -(t(a) * m))) - y) / (f - v), s = 2; s < h; s++) o = p(v + s * a * A), (Math.abs(((l = p(y + -(t(s * a) * m))) - g) / (o - f) - i) > d || s === h - 1) && (r.push(f, g), i = (l - g) / (o - f)), f = o, g = l;
                        r = "M" + r.join(",")
                    }
                    return x && x.setAttribute("d", r), r
                }, e
            }()).version = "3.13.0", x.headless = !0, d() && c.registerPlugin(x), t.CustomEase = x, t.default = x, Object.defineProperty(t, "__esModule", {
                value: !0
            })
        },
        6934: function(e, t) {
            ! function(e) {
                "use strict";
                var t = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                    n = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                    r = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
                    i = /(^[#\.][a-z]|[a-y][a-z])/i,
                    s = Math.PI / 180,
                    a = 180 / Math.PI,
                    o = Math.sin,
                    l = Math.cos,
                    u = Math.abs,
                    c = Math.sqrt,
                    h = Math.atan2,
                    d = function(e) {
                        return "string" == typeof e
                    },
                    f = function(e) {
                        return "number" == typeof e
                    },
                    p = {},
                    g = {},
                    A = function(e) {
                        return Math.round((e + 1e8) % 1 * 1e5) / 1e5 || (e < 0 ? 0 : 1)
                    },
                    m = function(e) {
                        return Math.round(1e5 * e) / 1e5 || 0
                    },
                    v = function(e) {
                        return Math.round(1e10 * e) / 1e10 || 0
                    },
                    y = function(e, t, n, r) {
                        var i = e[t],
                            s = 1 === r ? 6 : R(i, n, r);
                        if ((s || !r) && s + n + 2 < i.length) return e.splice(t, 0, i.slice(0, n + s + 2)), i.splice(0, n + s), 1
                    },
                    x = function(e, t, n) {
                        var r = e.length,
                            i = ~~(n * r);
                        if (e[i] > t) {
                            for (; --i && e[i] > t;);
                            i < 0 && (i = 0)
                        } else
                            for (; e[++i] < t && i < r;);
                        return i < r ? i : r - 1
                    },
                    E = function(e, t) {
                        var n = e.length;
                        for (t || e.reverse(); n--;) e[n].reversed || function(e) {
                            var t, n = 0;
                            for (e.reverse(); n < e.length; n += 2) t = e[n], e[n] = e[n + 1], e[n + 1] = t;
                            e.reversed = !e.reversed
                        }(e[n])
                    },
                    _ = function(e, t) {
                        return t.totalLength = e.totalLength, e.samples ? (t.samples = e.samples.slice(0), t.lookup = e.lookup.slice(0), t.minLength = e.minLength, t.resolution = e.resolution) : e.totalPoints && (t.totalPoints = e.totalPoints), t
                    },
                    b = function(e, t) {
                        var n = e.length,
                            r = e[n - 1] || [],
                            i = r.length;
                        n && t[0] === r[i - 2] && t[1] === r[i - 1] && (t = r.concat(t.slice(2)), n--), e[n] = t
                    };

                function w(e) {
                    var t, n = (e = d(e) && i.test(e) && document.querySelector(e) || e).getAttribute ? e : 0;
                    return n && (e = e.getAttribute("d")) ? (n._gsPath || (n._gsPath = {}), (t = n._gsPath[e]) && !t._dirty ? t : n._gsPath[e] = O(e)) : e ? d(e) ? O(e) : f(e[0]) ? [e] : e : console.warn("Expecting a <path> element or an SVG path data string")
                }
                var C = function(e, t) {
                        var n, r = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                            i = [].slice.call(e.attributes),
                            s = i.length;
                        for (t = "," + t + ","; --s > -1;) n = i[s].nodeName.toLowerCase(), 0 > t.indexOf("," + n + ",") && r.setAttributeNS(null, n, i[s].nodeValue);
                        return r
                    },
                    S = {
                        rect: "rx,ry,x,y,width,height",
                        circle: "r,cx,cy",
                        ellipse: "rx,ry,cx,cy",
                        line: "x1,x2,y1,y2"
                    },
                    I = function(e, t) {
                        for (var n = t ? t.split(",") : [], r = {}, i = n.length; --i > -1;) r[n[i]] = +e.getAttribute(n[i]) || 0;
                        return r
                    };

                function M(e, t, n) {
                    var r, i = e[t],
                        s = e[t + 2],
                        o = e[t + 4];
                    return i += (s - i) * n, s += (o - s) * n, i += (s - i) * n, r = s + (o + (e[t + 6] - o) * n - s) * n - i, i = e[t + 1], s = e[t + 3], o = e[t + 5], i += (s - i) * n, s += (o - s) * n, i += (s - i) * n, m(h(s + (o + (e[t + 7] - o) * n - s) * n - i, r) * a)
                }

                function T(e, t, n) {
                    var r = Math.max(0, ~~(u((n = void 0 === n ? 1 : v(n) || 0) - (t = v(t) || 0)) - 1e-8)),
                        i = function(e) {
                            for (var t = [], n = 0; n < e.length; n++) t[n] = _(e[n], e[n].slice(0));
                            return _(e, t)
                        }(e);
                    if (t > n && (t = 1 - t, n = 1 - n, E(i), i.totalLength = 0), t < 0 || n < 0) {
                        var s = Math.abs(~~Math.min(t, n)) + 1;
                        t += s, n += s
                    }
                    i.totalLength || B(i);
                    var a, o, l, c, h, d, f, A, m = n > 1,
                        x = D(i, t, p, !0),
                        w = D(i, n, g),
                        C = w.segment,
                        S = x.segment,
                        I = w.segIndex,
                        T = x.segIndex,
                        L = w.i,
                        P = x.i,
                        O = T === I,
                        N = L === P && O;
                    if (m || r) {
                        for (a = I < T || O && L < P || N && w.t < x.t, y(i, T, P, x.t) && (T++, !a && (I++, N ? (w.t = (w.t - x.t) / (1 - x.t), L = 0) : O && (L -= P))), 1e-5 > Math.abs(1 - (n - t)) ? I = T - 1 : !w.t && I ? I-- : y(i, I, L, w.t) && a && T++, 1 === x.t && (T = (T + 1) % i.length), h = [], f = 1 + (d = i.length) * r, A = T, f += (d - T + I) % d, c = 0; c < f; c++) b(h, i[A++ % d]);
                        i = h
                    } else if (l = 1 === w.t ? 6 : R(C, L, w.t), t !== n)
                        for (o = R(S, P, N ? x.t / w.t : x.t), O && (l += o), C.splice(L + l + 2), (o || P) && S.splice(0, P + o), c = i.length; c--;)(c < T || c > I) && i.splice(c, 1);
                    else C.angle = M(C, L + l, 0), L += l, x = C[L], w = C[L + 1], C.length = C.totalLength = 0, C.totalPoints = i.totalPoints = 8, C.push(x, w, x, w, x, w, x, w);
                    return i.totalLength = 0, i
                }

                function B(e, t) {
                    var n, r, i;
                    for (i = n = r = 0; i < e.length; i++) e[i].resolution = ~~t || 12, r += e[i].length, n += function(e, t, n) {
                        t = t || 0, e.samples || (e.samples = [], e.lookup = []);
                        var r, i, s, a, o, l, h, d, f, p, g, A, m, v, y, x, E, _ = ~~e.resolution || 12,
                            b = 1 / _,
                            w = e.length,
                            C = e[t],
                            S = e[t + 1],
                            I = t ? t / 6 * _ : 0,
                            M = e.samples,
                            T = e.lookup,
                            B = (t ? e.minLength : 1e8) || 1e8,
                            R = M[I + (void 0) * _ - 1],
                            D = t ? M[I - 1] : 0;
                        for (M.length = T.length = 0, i = t + 2; i < w; i += 6) {
                            if (s = e[i + 4] - C, a = e[i + 2] - C, o = e[i] - C, d = e[i + 5] - S, f = e[i + 3] - S, p = e[i + 1] - S, l = h = g = A = 0, .01 > u(s) && .01 > u(d) && u(o) + u(p) < .01) e.length > 8 && (e.splice(i, 6), i -= 6, w -= 6);
                            else
                                for (r = 1; r <= _; r++) m = 1 - (v = b * r), l = h - (h = (v * v * s + 3 * m * (v * a + m * o)) * v), (x = c((g = A - (A = (v * v * d + 3 * m * (v * f + m * p)) * v)) * g + l * l)) < B && (B = x), D += x, M[I++] = D;
                            C += s, S += d
                        }
                        if (R)
                            for (R -= D; I < M.length; I++) M[I] += R;
                        if (M.length && B) {
                            if (e.totalLength = E = M[M.length - 1] || 0, e.minLength = B, E / B < 9999)
                                for (r = 0, x = y = 0; r < E; r += B) T[x++] = M[y] < r ? ++y : y
                        } else e.totalLength = M[0] = 0;
                        return t ? D - M[t / 2 - 1] : D
                    }(e[i]);
                    return e.totalPoints = r, e.totalLength = n, e
                }

                function R(e, t, n) {
                    if (n <= 0 || n >= 1) return 0;
                    var r = e[t],
                        i = e[t + 1],
                        s = e[t + 2],
                        a = e[t + 3],
                        o = e[t + 4],
                        l = e[t + 5],
                        u = e[t + 6],
                        c = e[t + 7],
                        h = r + (s - r) * n,
                        d = s + (o - s) * n,
                        f = i + (a - i) * n,
                        p = a + (l - a) * n,
                        g = h + (d - h) * n,
                        A = f + (p - f) * n,
                        v = o + (u - o) * n,
                        y = l + (c - l) * n;
                    return d += (v - d) * n, p += (y - p) * n, e.splice(t + 2, 4, m(h), m(f), m(g), m(A), m(g + (d - g) * n), m(A + (p - A) * n), m(d), m(p), m(v), m(y)), e.samples && e.samples.splice(t / 6 * e.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6
                }

                function D(e, t, n, r) {
                    n = n || {}, e.totalLength || B(e), (t < 0 || t > 1) && (t = A(t));
                    var i, s, a, o, l, u, c, h = 0,
                        d = e[0];
                    if (t) {
                        if (1 === t) c = 1, h = e.length - 1, u = (d = e[h]).length - 8;
                        else {
                            if (e.length > 1) {
                                for (a = e.totalLength * t, l = u = 0;
                                    (l += e[u++].totalLength) < a;) h = u;
                                t = (a - (o = l - (d = e[h]).totalLength)) / (l - o) || 0
                            }
                            i = d.samples, s = d.resolution, a = d.totalLength * t, o = (u = d.lookup.length ? d.lookup[~~(a / d.minLength)] || 0 : x(i, a, t)) ? i[u - 1] : 0, (l = i[u]) < a && (o = l, l = i[++u]), c = 1 / s * ((a - o) / (l - o) + u % s), u = 6 * ~~(u / s), r && 1 === c && (u + 6 < d.length ? (u += 6, c = 0) : h + 1 < e.length && (u = c = 0, d = e[++h]))
                        }
                    } else c = u = h = 0, d = e[0];
                    return n.t = c, n.i = u, n.path = e, n.segment = d, n.segIndex = h, n
                }

                function L(e, t, n, r) {
                    var i, s, a, o, l, u, c, h, d, f = e[0],
                        p = r || {};
                    if ((t < 0 || t > 1) && (t = A(t)), f.lookup || B(e), e.length > 1) {
                        for (a = e.totalLength * t, l = u = 0;
                            (l += e[u++].totalLength) < a;) f = e[u];
                        t = (a - (o = l - f.totalLength)) / (l - o) || 0
                    }
                    return i = f.samples, s = f.resolution, a = f.totalLength * t, o = (u = f.lookup.length ? f.lookup[t < 1 ? ~~(a / f.minLength) : f.lookup.length - 1] || 0 : x(i, a, t)) ? i[u - 1] : 0, (l = i[u]) < a && (o = l, l = i[++u]), d = 1 - (c = 1 / s * ((a - o) / (l - o) + u % s) || 0), h = f[u = 6 * ~~(u / s)], p.x = m((c * c * (f[u + 6] - h) + 3 * d * (c * (f[u + 4] - h) + d * (f[u + 2] - h))) * c + h), p.y = m((c * c * (f[u + 7] - (h = f[u + 1])) + 3 * d * (c * (f[u + 5] - h) + d * (f[u + 3] - h))) * c + h), n && (p.angle = f.totalLength ? M(f, u, c >= 1 ? 1 - 1e-9 : c || 1e-9) : f.angle || 0), p
                }

                function P(e, t, n, r, i, s, a) {
                    for (var o, l, u, c, h, d = e.length; --d > -1;)
                        for (u = 0, l = (o = e[d]).length; u < l; u += 2) c = o[u], h = o[u + 1], o[u] = c * t + h * r + s, o[u + 1] = c * n + h * i + a;
                    return e._dirty = 1, e
                }

                function O(e) {
                    var n, i, a, h, d, f, p, g, A, m, v, y, x, E, _, b = (e + "").replace(r, function(e) {
                            var t = +e;
                            return t < 1e-4 && t > -.0001 ? 0 : t
                        }).match(t) || [],
                        w = [],
                        C = 0,
                        S = 0,
                        I = 2 / 3,
                        M = b.length,
                        T = 0,
                        B = "ERROR: malformed path: " + e,
                        R = function(e, t, n, r) {
                            m = (n - e) / 3, v = (r - t) / 3, p.push(e + m, t + v, n - m, r - v, n, r)
                        };
                    if (!e || !isNaN(b[0]) || isNaN(b[1])) return console.log(B), w;
                    for (n = 0; n < M; n++)
                        if (x = d, isNaN(b[n]) ? f = (d = b[n].toUpperCase()) !== b[n] : n--, a = +b[n + 1], h = +b[n + 2], f && (a += C, h += S), n || (g = a, A = h), "M" === d) p && (p.length < 8 ? w.length -= 1 : T += p.length), C = g = a, S = A = h, p = [a, h], w.push(p), n += 2, d = "L";
                        else if ("C" === d) p || (p = [0, 0]), f || (C = S = 0), p.push(a, h, C + 1 * b[n + 3], S + 1 * b[n + 4], C += 1 * b[n + 5], S += 1 * b[n + 6]), n += 6;
                    else if ("S" === d) m = C, v = S, ("C" === x || "S" === x) && (m += C - p[p.length - 4], v += S - p[p.length - 3]), f || (C = S = 0), p.push(m, v, a, h, C += 1 * b[n + 3], S += 1 * b[n + 4]), n += 4;
                    else if ("Q" === d) m = C + (a - C) * I, v = S + (h - S) * I, f || (C = S = 0), C += 1 * b[n + 3], S += 1 * b[n + 4], p.push(m, v, C + (a - C) * I, S + (h - S) * I, C, S), n += 4;
                    else if ("T" === d) m = C - p[p.length - 4], v = S - p[p.length - 3], p.push(C + m, S + v, a + (C + 1.5 * m - a) * I, h + (S + 1.5 * v - h) * I, C = a, S = h), n += 2;
                    else if ("H" === d) R(C, S, C = a, S), n += 1;
                    else if ("V" === d) R(C, S, C, S = a + (f ? S - C : 0)), n += 1;
                    else if ("L" === d || "Z" === d) "Z" === d && (a = g, h = A, p.closed = !0), ("L" === d || u(C - a) > .5 || u(S - h) > .5) && (R(C, S, a, h), "L" === d && (n += 2)), C = a, S = h;
                    else if ("A" === d) {
                        if (E = b[n + 4], _ = b[n + 5], m = b[n + 6], v = b[n + 7], i = 7, E.length > 1 && (E.length < 3 ? (v = m, m = _, i--) : (v = _, m = E.substr(2), i -= 2), _ = E.charAt(1), E = E.charAt(0)), y = function(e, t, n, r, i, a, h, d, f) {
                                if (e !== d || t !== f) {
                                    n = u(n), r = u(r);
                                    var p = i % 360 * s,
                                        g = l(p),
                                        A = o(p),
                                        m = Math.PI,
                                        v = 2 * m,
                                        y = (e - d) / 2,
                                        x = (t - f) / 2,
                                        E = g * y + A * x,
                                        _ = -A * y + g * x,
                                        b = E * E,
                                        w = _ * _,
                                        C = b / (n * n) + w / (r * r);
                                    C > 1 && (n = c(C) * n, r = c(C) * r);
                                    var S = n * n,
                                        I = r * r,
                                        M = (S * I - S * w - I * b) / (S * w + I * b);
                                    M < 0 && (M = 0);
                                    var T = (a === h ? -1 : 1) * c(M),
                                        B = n * _ / r * T,
                                        R = -(r * E / n * T),
                                        D = (e + d) / 2 + (g * B - A * R),
                                        L = (t + f) / 2 + (A * B + g * R),
                                        P = (E - B) / n,
                                        O = (_ - R) / r,
                                        N = (-E - B) / n,
                                        U = (-_ - R) / r,
                                        F = P * P + O * O,
                                        k = (O < 0 ? -1 : 1) * Math.acos(P / c(F)),
                                        Q = (P * U - O * N < 0 ? -1 : 1) * Math.acos((P * N + O * U) / c(F * (N * N + U * U)));
                                    isNaN(Q) && (Q = m), !h && Q > 0 ? Q -= v : h && Q < 0 && (Q += v), k %= v;
                                    var G, z = Math.ceil(u(Q %= v) / (v / 4)),
                                        H = [],
                                        V = Q / z,
                                        j = 4 / 3 * o(V / 2) / (1 + l(V / 2)),
                                        W = g * n,
                                        Y = A * n,
                                        X = -(A * r),
                                        q = g * r;
                                    for (G = 0; G < z; G++) E = l(i = k + G * V), _ = o(i), P = l(i += V), O = o(i), H.push(E - j * _, _ + j * E, P + j * O, O - j * P, P, O);
                                    for (G = 0; G < H.length; G += 2) E = H[G], _ = H[G + 1], H[G] = E * W + _ * X + D, H[G + 1] = E * Y + _ * q + L;
                                    return H[G - 2] = d, H[G - 1] = f, H
                                }
                            }(C, S, +b[n + 1], +b[n + 2], +b[n + 3], +E, +_, (f ? C : 0) + 1 * m, (f ? S : 0) + 1 * v), n += i, y)
                            for (i = 0; i < y.length; i++) p.push(y[i]);
                        C = p[p.length - 2], S = p[p.length - 1]
                    } else console.log(B);
                    return (n = p.length) < 6 ? (w.pop(), n = 0) : p[0] === p[n - 2] && p[1] === p[n - 1] && (p.closed = !0), w.totalPoints = T + n, w
                }

                function N(e, t) {
                    1e-4 > u(e[0] - e[2]) && 1e-4 > u(e[1] - e[3]) && (e = e.slice(2));
                    var n, r, i, s, a, o, l, h, d, f, p, g, A, v, y, x = e.length - 2,
                        E = +e[0],
                        _ = +e[1],
                        b = +e[2],
                        w = +e[3],
                        C = [E, _, E, _],
                        S = b - E,
                        I = w - _,
                        M = .001 > Math.abs(e[x] - E) && .001 > Math.abs(e[x + 1] - _);
                    for (M && (e.push(b, w), b = E, w = _, E = e[x - 2], _ = e[x - 1], e.unshift(E, _), x += 4), t = t || 0 === t ? +t : 1, i = 2; i < x; i += 2) n = E, r = _, E = b, _ = w, b = +e[i + 2], w = +e[i + 3], (E !== b || _ !== w) && (s = S, a = I, S = b - E, I = w - _, o = c(s * s + a * a), l = c(S * S + I * I), h = c(Math.pow(S / l + s / o, 2) + Math.pow(I / l + a / o, 2)), d = (o + l) * t * .25 / h, f = E - (E - n) * (o ? d / o : 0), p = E + (b - E) * (l ? d / l : 0), g = E - (f + ((p - f) * (3 * o / (o + l) + .5) / 4 || 0)), A = _ - (_ - r) * (o ? d / o : 0), v = _ + (w - _) * (l ? d / l : 0), y = _ - (A + ((v - A) * (3 * o / (o + l) + .5) / 4 || 0)), (E !== n || _ !== r) && C.push(m(f + g), m(A + y), m(E), m(_), m(p + g), m(v + y)));
                    return E !== b || _ !== w || C.length < 4 ? C.push(m(b), m(w), m(b), m(w)) : C.length -= 2, 2 === C.length ? C.push(E, _, E, _, E, _) : M && (C.splice(0, 6), C.length = C.length - 6), C
                }

                function U(e) {
                    f(e[0]) && (e = [e]);
                    var t, n, r, i, s = "",
                        a = e.length;
                    for (n = 0; n < a; n++) {
                        for (s += "M" + m((i = e[n])[0]) + "," + m(i[1]) + " C", t = i.length, r = 2; r < t; r++) s += m(i[r++]) + "," + m(i[r++]) + " " + m(i[r++]) + "," + m(i[r++]) + " " + m(i[r++]) + "," + m(i[r]) + " ";
                        i.closed && (s += "z")
                    }
                    return s
                }
                var F, k, Q, G, z, H, V, j, W, Y = "transform",
                    X = Y + "Origin",
                    q = function(e) {
                        var t = e.ownerDocument || e;
                        for (!(Y in e.style) && ("msTransform" in e.style) && (X = (Y = "msTransform") + "Origin"); t.parentNode && (t = t.parentNode););
                        if (k = window, V = new es, t) {
                            F = t, Q = t.documentElement, G = t.body, (j = F.createElementNS("http://www.w3.org/2000/svg", "g")).style.transform = "none";
                            var n = t.createElement("div"),
                                r = t.createElement("div"),
                                i = t && (t.body || t.firstElementChild);
                            i && i.appendChild && (i.appendChild(n), n.appendChild(r), n.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), W = r.offsetParent !== n, i.removeChild(n))
                        }
                        return t
                    },
                    K = function(e) {
                        for (var t, n; e && e !== G;)(n = e._gsap) && n.uncache && n.get(e, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), t ? t.push(n) : t = [n]), e = e.parentNode;
                        return t
                    },
                    J = [],
                    Z = [],
                    $ = function(e) {
                        return e.ownerSVGElement || ("svg" === (e.tagName + "").toLowerCase() ? e : null)
                    },
                    ee = function e(t, n) {
                        if (t.parentNode && (F || q(t))) {
                            var r = $(t),
                                i = r ? r.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                                s = r ? n ? "rect" : "g" : "div",
                                a = 2 !== n ? 0 : 100,
                                o = 3 === n ? 100 : 0,
                                l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                                u = F.createElementNS ? F.createElementNS(i.replace(/^https/, "http"), s) : F.createElement(s);
                            return n && (r ? (H || (H = e(t)), u.setAttribute("width", .01), u.setAttribute("height", .01), u.setAttribute("transform", "translate(" + a + "," + o + ")"), H.appendChild(u)) : (z || ((z = e(t)).style.cssText = l), u.style.cssText = l + "width:0.1px;height:0.1px;top:" + o + "px;left:" + a + "px", z.appendChild(u))), u
                        }
                        throw "Need document and parent."
                    },
                    et = function(e) {
                        for (var t = new es, n = 0; n < e.numberOfItems; n++) t.multiply(e.getItem(n).matrix);
                        return t
                    },
                    en = function(e) {
                        var t, n = e.getCTM();
                        return n || (t = e.style[Y], e.style[Y] = "none", e.appendChild(j), n = j.getCTM(), e.removeChild(j), t ? e.style[Y] = t : e.style.removeProperty(Y.replace(/([A-Z])/g, "-$1").toLowerCase())), n || V.clone()
                    },
                    er = function(e, t) {
                        var n, r, i, s, a, o, l = $(e),
                            u = e === l,
                            c = l ? J : Z,
                            h = e.parentNode,
                            d = h && !l && h.shadowRoot && h.shadowRoot.appendChild ? h.shadowRoot : h;
                        if (e === k) return e;
                        if (c.length || c.push(ee(e, 1), ee(e, 2), ee(e, 3)), n = l ? H : z, l) u ? (s = -(i = en(e)).e / i.a, a = -i.f / i.d, r = V) : e.getBBox ? (i = e.getBBox(), s = (r = (r = e.transform ? e.transform.baseVal : {}).numberOfItems ? r.numberOfItems > 1 ? et(r) : r.getItem(0).matrix : V).a * i.x + r.c * i.y, a = r.b * i.x + r.d * i.y) : (r = new es, s = a = 0), t && "g" === e.tagName.toLowerCase() && (s = a = 0), (u ? l : h).appendChild(n), n.setAttribute("transform", "matrix(" + r.a + "," + r.b + "," + r.c + "," + r.d + "," + (r.e + s) + "," + (r.f + a) + ")");
                        else {
                            if (s = a = 0, W)
                                for (r = e.offsetParent, i = e; i && (i = i.parentNode) && i !== r && i.parentNode;)(k.getComputedStyle(i)[Y] + "").length > 4 && (s = i.offsetLeft, a = i.offsetTop, i = 0);
                            if ("absolute" !== (o = k.getComputedStyle(e)).position && "fixed" !== o.position)
                                for (r = e.offsetParent; h && h !== r;) s += h.scrollLeft || 0, a += h.scrollTop || 0, h = h.parentNode;
                            (i = n.style).top = e.offsetTop - a + "px", i.left = e.offsetLeft - s + "px", i[Y] = o[Y], i[X] = o[X], i.position = "fixed" === o.position ? "fixed" : "absolute", d.appendChild(n)
                        }
                        return n
                    },
                    ei = function(e, t, n, r, i, s, a) {
                        return e.a = t, e.b = n, e.c = r, e.d = i, e.e = s, e.f = a, e
                    },
                    es = function() {
                        function e(e, t, n, r, i, s) {
                            void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === s && (s = 0), ei(this, e, t, n, r, i, s)
                        }
                        var t = e.prototype;
                        return t.inverse = function() {
                            var e = this.a,
                                t = this.b,
                                n = this.c,
                                r = this.d,
                                i = this.e,
                                s = this.f,
                                a = e * r - t * n || 1e-10;
                            return ei(this, r / a, -t / a, -n / a, e / a, (n * s - r * i) / a, -(e * s - t * i) / a)
                        }, t.multiply = function(e) {
                            var t = this.a,
                                n = this.b,
                                r = this.c,
                                i = this.d,
                                s = this.e,
                                a = this.f,
                                o = e.a,
                                l = e.c,
                                u = e.b,
                                c = e.d,
                                h = e.e,
                                d = e.f;
                            return ei(this, o * t + u * r, o * n + u * i, l * t + c * r, l * n + c * i, s + h * t + d * r, a + h * n + d * i)
                        }, t.clone = function() {
                            return new e(this.a, this.b, this.c, this.d, this.e, this.f)
                        }, t.equals = function(e) {
                            var t = this.a,
                                n = this.b,
                                r = this.c,
                                i = this.d,
                                s = this.e,
                                a = this.f;
                            return t === e.a && n === e.b && r === e.c && i === e.d && s === e.e && a === e.f
                        }, t.apply = function(e, t) {
                            void 0 === t && (t = {});
                            var n = e.x,
                                r = e.y,
                                i = this.a,
                                s = this.b,
                                a = this.c,
                                o = this.d,
                                l = this.e,
                                u = this.f;
                            return t.x = n * i + r * a + l || 0, t.y = n * s + r * o + u || 0, t
                        }, e
                    }();

                function ea(e, t, n, r) {
                    if (!e || !e.parentNode || (F || q(e)).documentElement === e) return new es;
                    var i = K(e),
                        s = $(e) ? J : Z,
                        a = er(e, n),
                        o = s[0].getBoundingClientRect(),
                        l = s[1].getBoundingClientRect(),
                        u = s[2].getBoundingClientRect(),
                        c = a.parentNode,
                        h = !r && function e(t) {
                            return "fixed" === k.getComputedStyle(t).position || ((t = t.parentNode) && 1 === t.nodeType ? e(t) : void 0)
                        }(e),
                        d = new es((l.left - o.left) / 100, (l.top - o.top) / 100, (u.left - o.left) / 100, (u.top - o.top) / 100, o.left + (h ? 0 : k.pageXOffset || F.scrollLeft || Q.scrollLeft || G.scrollLeft || 0), o.top + (h ? 0 : k.pageYOffset || F.scrollTop || Q.scrollTop || G.scrollTop || 0));
                    if (c.removeChild(a), i)
                        for (o = i.length; o--;)(l = i[o]).scaleX = l.scaleY = 0, l.renderTransform(1, l);
                    return t ? d.inverse() : d
                }
                var eo, el, eu, ec, eh, ed, ef = "x,translateX,left,marginLeft,xPercent".split(","),
                    ep = "y,translateY,top,marginTop,yPercent".split(","),
                    eg = Math.PI / 180,
                    eA = function(e, t, n, r) {
                        for (var i = t.length, s = 2 === r ? 0 : r, a = 0; a < i; a++) e[s] = parseFloat(t[a][n]), 2 === r && (e[s + 1] = 0), s += 2;
                        return e
                    },
                    em = function(e, t, n) {
                        return parseFloat(e._gsap.get(e, t, n || "px")) || 0
                    },
                    ev = function(e) {
                        var t, n = e[0],
                            r = e[1];
                        for (t = 2; t < e.length; t += 2) n = e[t] += n, r = e[t + 1] += r
                    },
                    ey = function(e, t, n, r, i, s, a, o, l) {
                        return "cubic" === a.type ? t = [t] : (!1 !== a.fromCurrent && t.unshift(em(n, r, o), i ? em(n, i, l) : 0), a.relative && ev(t), t = [(i ? N : function(e, t) {
                            void 0 === t && (t = 1);
                            for (var n = e[0], r = 0, i = [n, 0], s = 2; s < e.length; s += 2) i.push(n, r, e[s], r = (e[s] - n) * t / 2, n = e[s], -r);
                            return i
                        })(t, a.curviness)]), t = s(ew(t, n, a)), eC(e, n, r, t, "x", o), i && eC(e, n, i, t, "y", l), B(t, a.resolution || (0 === a.curviness ? 20 : 12))
                    },
                    ex = function(e) {
                        return e
                    },
                    eE = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g,
                    e_ = function(e, t, n) {
                        var r, i = ea(e),
                            s = 0,
                            a = 0;
                        return "svg" === (e.tagName + "").toLowerCase() ? (r = e.viewBox.baseVal).width || (r = {
                            width: +e.getAttribute("width"),
                            height: +e.getAttribute("height")
                        }) : r = t && e.getBBox && e.getBBox(), t && "auto" !== t && (s = t.push ? t[0] * (r ? r.width : e.offsetWidth || 0) : t.x, a = t.push ? t[1] * (r ? r.height : e.offsetHeight || 0) : t.y), n.apply(s || a ? i.apply({
                            x: s,
                            y: a
                        }) : {
                            x: i.e,
                            y: i.f
                        })
                    },
                    eb = function(e, t, n, r) {
                        var i, s = ea(e.parentNode, !0, !0),
                            a = s.clone().multiply(ea(t)),
                            o = e_(e, n, s),
                            l = e_(t, r, s),
                            u = l.x,
                            c = l.y;
                        return a.e = a.f = 0, "auto" === r && t.getTotalLength && "path" === t.tagName.toLowerCase() && (i = t.getAttribute("d").match(eE) || [], u += (i = a.apply({
                            x: +i[0],
                            y: +i[1]
                        })).x, c += i.y), i && (u -= (i = a.apply(t.getBBox())).x, c -= i.y), a.e = u - o.x, a.f = c - o.y, a
                    },
                    ew = function(e, t, n) {
                        var r, i, s, a = n.align,
                            o = n.matrix,
                            l = n.offsetX,
                            u = n.offsetY,
                            c = n.alignOrigin,
                            h = e[0][0],
                            d = e[0][1],
                            f = em(t, "x"),
                            p = em(t, "y");
                        return e && e.length ? (a && ("self" === a || (r = ec(a)[0] || t) === t ? P(e, 1, 0, 0, 1, f - h, p - d) : (c && !1 !== c[2] ? eo.set(t, {
                            transformOrigin: 100 * c[0] + "% " + 100 * c[1] + "%"
                        }) : c = [-(em(t, "xPercent") / 100), -(em(t, "yPercent") / 100)], s = (i = eb(t, r, c, "auto")).apply({
                            x: h,
                            y: d
                        }), P(e, i.a, i.b, i.c, i.d, f + i.e - (s.x - i.e), p + i.f - (s.y - i.f)))), o ? P(e, o.a, o.b, o.c, o.d, o.e, o.f) : (l || u) && P(e, 1, 0, 0, 1, l || 0, u || 0), e) : w("M0,0L0,0")
                    },
                    eC = function(e, t, n, r, i, s) {
                        var a = t._gsap,
                            o = a.harness,
                            l = o && o.aliases && o.aliases[n],
                            u = l && 0 > l.indexOf(",") ? l : n,
                            c = e._pt = new el(e._pt, t, u, 0, 0, ex, 0, a.set(t, u, e));
                        c.u = eu(a.get(t, u, s)) || 0, c.path = r, c.pp = i, e._props.push(u)
                    },
                    eS = {
                        version: "3.13.0",
                        name: "motionPath",
                        register: function(e, t, n) {
                            eu = (eo = e).utils.getUnit, ec = eo.utils.toArray, eh = eo.core.getStyleSaver, ed = eo.core.reverting || function() {}, el = n
                        },
                        init: function(e, t, n) {
                            if (!eo) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1;
                            "object" == typeof t && !t.style && t.path || (t = {
                                path: t
                            });
                            var r, i, s, a, o = [],
                                l = t,
                                u = l.path,
                                c = l.autoRotate,
                                h = l.unitX,
                                d = l.unitY,
                                f = l.x,
                                p = l.y,
                                g = u[0],
                                A = (r = t.start, i = "end" in t ? t.end : 1, function(e) {
                                    return r || 1 !== i ? T(e, r, i) : e
                                });
                            if (this.rawPaths = o, this.target = e, this.tween = n, this.styles = eh && eh(e, "transform"), (this.rotate = c || 0 === c) && (this.rOffset = parseFloat(c) || 0, this.radians = !!t.useRadians, this.rProp = t.rotation || "rotation", this.rSet = e._gsap.set(e, this.rProp, this), this.ru = eu(e._gsap.get(e, this.rProp)) || 0), !Array.isArray(u) || "closed" in u || "number" == typeof g) B(s = A(ew(w(t.path), e, t)), t.resolution), o.push(s), eC(this, e, t.x || "x", s, "x", t.unitX || "px"), eC(this, e, t.y || "y", s, "y", t.unitY || "px");
                            else {
                                for (a in g) !f && ~ef.indexOf(a) ? f = a : !p && ~ep.indexOf(a) && (p = a);
                                for (a in f && p ? o.push(ey(this, eA(eA([], u, f, 0), u, p, 1), e, f, p, A, t, h || eu(u[0][f]), d || eu(u[0][p]))) : f = p = 0, g) a !== f && a !== p && o.push(ey(this, eA([], u, a, 2), e, a, 0, A, t, eu(u[0][a])))
                            }
                            n.vars.immediateRender && this.render(n.progress(), this)
                        },
                        render: function(e, t) {
                            var n = t.rawPaths,
                                r = n.length,
                                i = t._pt;
                            if (t.tween._time || !ed()) {
                                for (e > 1 ? e = 1 : e < 0 && (e = 0); r--;) L(n[r], e, !r && t.rotate, n[r]);
                                for (; i;) i.set(i.t, i.p, i.path[i.pp] + i.u, i.d, e), i = i._next;
                                t.rotate && t.rSet(t.target, t.rProp, n[0].angle * (t.radians ? eg : 1) + t.rOffset + t.ru, t, e)
                            } else t.styles.revert()
                        },
                        getLength: function(e) {
                            return B(w(e)).totalLength
                        },
                        sliceRawPath: T,
                        getRawPath: w,
                        pointsToSegment: N,
                        stringToRawPath: O,
                        rawPathToString: U,
                        transformRawPath: P,
                        getGlobalMatrix: ea,
                        getPositionOnPath: L,
                        cacheRawPathMeasurements: B,
                        convertToPath: function(e, t) {
                            return ec(e).map(function(e) {
                                var r, i, s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x, E, _, b, w, M, T;
                                return r = !1 !== t, "path" !== (T = e.tagName.toLowerCase()) && e.getBBox ? (u = C(e, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), M = I(e, S[T]), "rect" === T ? (o = M.rx, l = M.ry || o, s = M.x, a = M.y, f = M.width - 2 * o, p = M.height - 2 * l, o || l ? (g = s + .44771525016900005 * o, v = (m = (A = s + o) + f) + .552284749831 * o, y = m + o, x = a + .44771525016900005 * l, b = (_ = (E = a + l) + p) + .552284749831 * l, w = _ + l, i = "M" + y + "," + E + " V" + _ + " C" + [y, b, v, w, m, w, m - (m - A) / 3, w, A + (m - A) / 3, w, A, w, g, w, s, b, s, _, s, _ - (_ - E) / 3, s, E + (_ - E) / 3, s, E, s, x, g, a, A, a, A + (m - A) / 3, a, m - (m - A) / 3, a, m, a, v, a, y, x, y, E].join(",") + "z") : i = "M" + (s + f) + "," + a + " v" + p + " h" + -f + " v" + -p + " h" + f + "z") : "circle" === T || "ellipse" === T ? ("circle" === T ? h = .552284749831 * (o = l = M.r) : (o = M.rx, h = .552284749831 * (l = M.ry)), s = M.cx, a = M.cy, c = .552284749831 * o, i = "M" + (s + o) + "," + a + " C" + [s + o, a + h, s + c, a + l, s, a + l, s - c, a + l, s - o, a + h, s - o, a, s - o, a - h, s - c, a - l, s, a - l, s + c, a - l, s + o, a - h, s + o, a].join(",") + "z") : "line" === T ? i = "M" + M.x1 + "," + M.y1 + " L" + M.x2 + "," + M.y2 : ("polyline" === T || "polygon" === T) && (i = "M" + (s = (d = (e.getAttribute("points") + "").match(n) || []).shift()) + "," + (a = d.shift()) + " L" + d.join(","), "polygon" === T && (i += "," + s + "," + a + "z")), u.setAttribute("d", U(u._gsRawPath = O(i))), r && e.parentNode && (e.parentNode.insertBefore(u, e), e.parentNode.removeChild(e)), u) : e
                            })
                        },
                        convertCoordinates: function(e, t, n) {
                            var r = ea(t, !0, !0).multiply(ea(e));
                            return n ? r.apply(n) : r
                        },
                        getAlignMatrix: eb,
                        getRelativePosition: function(e, t, n, r) {
                            var i = eb(e, t, n, r);
                            return {
                                x: i.e,
                                y: i.f
                            }
                        },
                        arrayToRawPath: function(e, t) {
                            var n = eA(eA([], e, (t = t || {}).x || "x", 0), e, t.y || "y", 1);
                            return t.relative && ev(n), ["cubic" === t.type ? n : N(n, t.curviness)]
                        }
                    };
                (eo || "undefined" != typeof window && (eo = window.gsap) && eo.registerPlugin && eo) && eo.registerPlugin(eS), e.MotionPathPlugin = eS, e.default = eS, Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }(t)
        },
        5215: function(e, t) {
            var n, r, i, s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x, E, _, b, w, C, S, I, M, T, B, R, D, L, P, O, N, U, F, k;
            g = function() {
                return n || "undefined" != typeof window && (n = window.gsap) && n.registerPlugin && n
            }, A = 1, m = [], t._scrollers = [], t._proxies = [], v = Date.now, y = function(e, t) {
                return t
            }, x = function() {
                var e = c.core,
                    n = e.bridge || {},
                    r = e._scrollers,
                    i = e._proxies;
                r.push.apply(r, t._scrollers), i.push.apply(i, t._proxies), t._scrollers = r, t._proxies = i, y = function(e, t) {
                    return n[e](t)
                }
            }, E = function(e, n) {
                return ~t._proxies.indexOf(e) && t._proxies[t._proxies.indexOf(e) + 1][n]
            }, _ = function(e) {
                return !!~h.indexOf(e)
            }, b = function(e, t, n, r, i) {
                return e.addEventListener(t, n, {
                    passive: !1 !== r,
                    capture: !!i
                })
            }, w = function(e, t, n, r) {
                return e.removeEventListener(t, n, !!r)
            }, C = "scrollLeft", S = "scrollTop", I = function() {
                return d && d.isPressed || t._scrollers.cache++
            }, B = {
                s: S,
                p: "top",
                p2: "Top",
                os: "bottom",
                os2: "Bottom",
                d: "height",
                d2: "Height",
                a: "y",
                op: T = {
                    s: C,
                    p: "left",
                    p2: "Left",
                    os: "right",
                    os2: "Right",
                    d: "width",
                    d2: "Width",
                    a: "x",
                    sc: (M = function(e, n) {
                        var r = function r(s) {
                            if (s || 0 === s) {
                                A && (i.history.scrollRestoration = "manual");
                                var a = d && d.isPressed;
                                e(s = r.v = Math.round(s) || (d && d.iOS ? 1 : 0)), r.cacheID = t._scrollers.cache, a && y("ss", s)
                            } else(n || t._scrollers.cache !== r.cacheID || y("ref")) && (r.cacheID = t._scrollers.cache, r.v = e());
                            return r.v + r.offset
                        };
                        return r.offset = 0, e && r
                    })(function(e) {
                        return arguments.length ? i.scrollTo(e, B.sc()) : i.pageXOffset || s[C] || a[C] || o[C] || 0
                    })
                },
                sc: M(function(e) {
                    return arguments.length ? i.scrollTo(T.sc(), e) : i.pageYOffset || s[S] || a[S] || o[S] || 0
                })
            }, R = function(e, t) {
                return (t && t._ctx && t._ctx.selector || n.utils.toArray)(e)[0] || ("string" == typeof e && !1 !== n.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
            }, D = function(e, t) {
                for (var n = t.length; n--;)
                    if (t[n] === e || t[n].contains(e)) return !0;
                return !1
            }, L = function(e, r) {
                var i = r.s,
                    o = r.sc;
                _(e) && (e = s.scrollingElement || a);
                var l = t._scrollers.indexOf(e),
                    u = o === B.sc ? 1 : 2;
                ~l || (l = t._scrollers.push(e) - 1), t._scrollers[l + u] || b(e, "scroll", I);
                var c = t._scrollers[l + u],
                    h = c || (t._scrollers[l + u] = M(E(e, i), !0) || (_(e) ? o : M(function(t) {
                        return arguments.length ? e[i] = t : e[i]
                    })));
                return h.target = e, c || (h.smooth = "smooth" === n.getProperty(e, "scrollBehavior")), h
            }, P = function(e, t, n) {
                var r = e,
                    i = e,
                    s = v(),
                    a = s,
                    o = t || 50,
                    l = Math.max(500, 3 * o),
                    u = function(e, t) {
                        var l = v();
                        t || l - s > o ? (i = r, r = e, a = s, s = l) : n ? r += e : r = i + (e - i) / (l - a) * (s - a)
                    };
                return {
                    update: u,
                    reset: function() {
                        i = r = n ? 0 : r, a = s = 0
                    },
                    getVelocity: function(e) {
                        var t = a,
                            o = i,
                            c = v();
                        return (e || 0 === e) && e !== r && u(e), s === a || c - a > l ? 0 : (r + (n ? o : -o)) / ((n ? c : s) - t) * 1e3
                    }
                }
            }, O = function(e, t) {
                return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
            }, N = function(e) {
                var t = Math.max.apply(Math, e),
                    n = Math.min.apply(Math, e);
                return Math.abs(t) >= Math.abs(n) ? t : n
            }, U = function() {
                (c = n.core.globals().ScrollTrigger) && c.core && x()
            }, F = function(e) {
                return n = e || g(), !r && n && "undefined" != typeof document && document.body && (i = window, a = (s = document).documentElement, o = s.body, h = [i, s, a, o], n.utils.clamp, p = n.core.context || function() {}, u = "onpointerenter" in o ? "pointer" : "mouse", l = k.isTouch = i.matchMedia && i.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in i || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, f = k.eventTypes = ("ontouchstart" in a ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in a ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
                    return A = 0
                }, 500), U(), r = 1), r
            }, T.op = B, t._scrollers.cache = 0, (k = function() {
                function e(e) {
                    this.init(e)
                }
                return e.prototype.init = function(e) {
                        r || F(n) || console.warn("Please gsap.registerPlugin(Observer)"), c || U();
                        var t = e.tolerance,
                            h = e.dragMinimum,
                            g = e.type,
                            A = e.target,
                            y = e.lineHeight,
                            x = e.debounce,
                            E = e.preventDefault,
                            C = e.onStop,
                            S = e.onStopDelay,
                            M = e.ignore,
                            k = e.wheelSpeed,
                            Q = e.event,
                            G = e.onDragStart,
                            z = e.onDragEnd,
                            H = e.onDrag,
                            V = e.onPress,
                            j = e.onRelease,
                            W = e.onRight,
                            Y = e.onLeft,
                            X = e.onUp,
                            q = e.onDown,
                            K = e.onChangeX,
                            J = e.onChangeY,
                            Z = e.onChange,
                            $ = e.onToggleX,
                            ee = e.onToggleY,
                            et = e.onHover,
                            en = e.onHoverEnd,
                            er = e.onMove,
                            ei = e.ignoreCheck,
                            es = e.isNormalizer,
                            ea = e.onGestureStart,
                            eo = e.onGestureEnd,
                            el = e.onWheel,
                            eu = e.onEnable,
                            ec = e.onDisable,
                            eh = e.onClick,
                            ed = e.scrollSpeed,
                            ef = e.capture,
                            ep = e.allowClicks,
                            eg = e.lockAxis,
                            eA = e.onLockAxis;
                        this.target = A = R(A) || a, this.vars = e, M && (M = n.utils.toArray(M)), t = t || 1e-9, h = h || 0, k = k || 1, ed = ed || 1, g = g || "wheel,touch,pointer", x = !1 !== x, y || (y = parseFloat(i.getComputedStyle(o).lineHeight) || 22);
                        var em, ev, ey, ex, eE, e_, eb, ew = this,
                            eC = 0,
                            eS = 0,
                            eI = e.passive || !E && !1 !== e.passive,
                            eM = L(A, T),
                            eT = L(A, B),
                            eB = eM(),
                            eR = eT(),
                            eD = ~g.indexOf("touch") && !~g.indexOf("pointer") && "pointerdown" === f[0],
                            eL = _(A),
                            eP = A.ownerDocument || s,
                            eO = [0, 0, 0],
                            eN = [0, 0, 0],
                            eU = 0,
                            eF = function() {
                                return eU = v()
                            },
                            ek = function(e, t) {
                                return (ew.event = e) && M && D(e.target, M) || t && eD && "touch" !== e.pointerType || ei && ei(e, t)
                            },
                            eQ = function() {
                                var e = ew.deltaX = N(eO),
                                    n = ew.deltaY = N(eN),
                                    r = Math.abs(e) >= t,
                                    i = Math.abs(n) >= t;
                                Z && (r || i) && Z(ew, e, n, eO, eN), r && (W && ew.deltaX > 0 && W(ew), Y && ew.deltaX < 0 && Y(ew), K && K(ew), $ && ew.deltaX < 0 != eC < 0 && $(ew), eC = ew.deltaX, eO[0] = eO[1] = eO[2] = 0), i && (q && ew.deltaY > 0 && q(ew), X && ew.deltaY < 0 && X(ew), J && J(ew), ee && ew.deltaY < 0 != eS < 0 && ee(ew), eS = ew.deltaY, eN[0] = eN[1] = eN[2] = 0), (ex || ey) && (er && er(ew), ey && (G && 1 === ey && G(ew), H && H(ew), ey = 0), ex = !1), e_ && (e_ = !1, 1) && eA && eA(ew), eE && (el(ew), eE = !1), em = 0
                            },
                            eG = function(e, t, n) {
                                eO[n] += e, eN[n] += t, ew._vx.update(e), ew._vy.update(t), x ? em || (em = requestAnimationFrame(eQ)) : eQ()
                            },
                            ez = function(e, t) {
                                eg && !eb && (ew.axis = eb = Math.abs(e) > Math.abs(t) ? "x" : "y", e_ = !0), "y" !== eb && (eO[2] += e, ew._vx.update(e, !0)), "x" !== eb && (eN[2] += t, ew._vy.update(t, !0)), x ? em || (em = requestAnimationFrame(eQ)) : eQ()
                            },
                            eH = function(e) {
                                if (!ek(e, 1)) {
                                    var t = (e = O(e, E)).clientX,
                                        n = e.clientY,
                                        r = t - ew.x,
                                        i = n - ew.y,
                                        s = ew.isDragging;
                                    ew.x = t, ew.y = n, (s || (r || i) && (Math.abs(ew.startX - t) >= h || Math.abs(ew.startY - n) >= h)) && (ey = s ? 2 : 1, s || (ew.isDragging = !0), ez(r, i))
                                }
                            },
                            eV = ew.onPress = function(e) {
                                ek(e, 1) || e && e.button || (ew.axis = eb = null, ev.pause(), ew.isPressed = !0, e = O(e), eC = eS = 0, ew.startX = ew.x = e.clientX, ew.startY = ew.y = e.clientY, ew._vx.reset(), ew._vy.reset(), b(es ? A : eP, f[1], eH, eI, !0), ew.deltaX = ew.deltaY = 0, V && V(ew))
                            },
                            ej = ew.onRelease = function(e) {
                                if (!ek(e, 1)) {
                                    w(es ? A : eP, f[1], eH, !0);
                                    var t = !isNaN(ew.y - ew.startY),
                                        r = ew.isDragging,
                                        s = r && (Math.abs(ew.x - ew.startX) > 3 || Math.abs(ew.y - ew.startY) > 3),
                                        a = O(e);
                                    !s && t && (ew._vx.reset(), ew._vy.reset(), E && ep && n.delayedCall(.08, function() {
                                        if (v() - eU > 300 && !e.defaultPrevented) {
                                            if (e.target.click) e.target.click();
                                            else if (eP.createEvent) {
                                                var t = eP.createEvent("MouseEvents");
                                                t.initMouseEvent("click", !0, !0, i, 1, a.screenX, a.screenY, a.clientX, a.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(t)
                                            }
                                        }
                                    })), ew.isDragging = ew.isGesturing = ew.isPressed = !1, C && r && !es && ev.restart(!0), ey && eQ(), z && r && z(ew), j && j(ew, s)
                                }
                            },
                            eW = function(e) {
                                return e.touches && e.touches.length > 1 && (ew.isGesturing = !0) && ea(e, ew.isDragging)
                            },
                            eY = function() {
                                return ew.isGesturing = !1, eo(ew)
                            },
                            eX = function(e) {
                                if (!ek(e)) {
                                    var t = eM(),
                                        n = eT();
                                    eG((t - eB) * ed, (n - eR) * ed, 1), eB = t, eR = n, C && ev.restart(!0)
                                }
                            },
                            eq = function(e) {
                                if (!ek(e)) {
                                    e = O(e, E), el && (eE = !0);
                                    var t = (1 === e.deltaMode ? y : 2 === e.deltaMode ? i.innerHeight : 1) * k;
                                    eG(e.deltaX * t, e.deltaY * t, 0), C && !es && ev.restart(!0)
                                }
                            },
                            eK = function(e) {
                                if (!ek(e)) {
                                    var t = e.clientX,
                                        n = e.clientY,
                                        r = t - ew.x,
                                        i = n - ew.y;
                                    ew.x = t, ew.y = n, ex = !0, C && ev.restart(!0), (r || i) && ez(r, i)
                                }
                            },
                            eJ = function(e) {
                                ew.event = e, et(ew)
                            },
                            eZ = function(e) {
                                ew.event = e, en(ew)
                            },
                            e$ = function(e) {
                                return ek(e) || O(e, E) && eh(ew)
                            };
                        ev = ew._dc = n.delayedCall(S || .25, function() {
                            ew._vx.reset(), ew._vy.reset(), ev.pause(), C && C(ew)
                        }).pause(), ew.deltaX = ew.deltaY = 0, ew._vx = P(0, 50, !0), ew._vy = P(0, 50, !0), ew.scrollX = eM, ew.scrollY = eT, ew.isDragging = ew.isGesturing = ew.isPressed = !1, p(this), ew.enable = function(e) {
                            return !ew.isEnabled && (b(eL ? eP : A, "scroll", I), g.indexOf("scroll") >= 0 && b(eL ? eP : A, "scroll", eX, eI, ef), g.indexOf("wheel") >= 0 && b(A, "wheel", eq, eI, ef), (g.indexOf("touch") >= 0 && l || g.indexOf("pointer") >= 0) && (b(A, f[0], eV, eI, ef), b(eP, f[2], ej), b(eP, f[3], ej), ep && b(A, "click", eF, !0, !0), eh && b(A, "click", e$), ea && b(eP, "gesturestart", eW), eo && b(eP, "gestureend", eY), et && b(A, u + "enter", eJ), en && b(A, u + "leave", eZ), er && b(A, u + "move", eK)), ew.isEnabled = !0, ew.isDragging = ew.isGesturing = ew.isPressed = ex = ey = !1, ew._vx.reset(), ew._vy.reset(), eB = eM(), eR = eT(), e && e.type && eV(e), eu && eu(ew)), ew
                        }, ew.disable = function() {
                            ew.isEnabled && (m.filter(function(e) {
                                return e !== ew && _(e.target)
                            }).length || w(eL ? eP : A, "scroll", I), ew.isPressed && (ew._vx.reset(), ew._vy.reset(), w(es ? A : eP, f[1], eH, !0)), w(eL ? eP : A, "scroll", eX, ef), w(A, "wheel", eq, ef), w(A, f[0], eV, ef), w(eP, f[2], ej), w(eP, f[3], ej), w(A, "click", eF, !0), w(A, "click", e$), w(eP, "gesturestart", eW), w(eP, "gestureend", eY), w(A, u + "enter", eJ), w(A, u + "leave", eZ), w(A, u + "move", eK), ew.isEnabled = ew.isPressed = ew.isDragging = !1, ec && ec(ew))
                        }, ew.kill = ew.revert = function() {
                            ew.disable();
                            var e = m.indexOf(ew);
                            e >= 0 && m.splice(e, 1), d === ew && (d = 0)
                        }, m.push(ew), es && _(A) && (d = ew), ew.enable(Q)
                    },
                    function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }(e.prototype, [{
                        key: "velocityX",
                        get: function() {
                            return this._vx.getVelocity()
                        }
                    }, {
                        key: "velocityY",
                        get: function() {
                            return this._vy.getVelocity()
                        }
                    }]), e
            }()).version = "3.13.0", k.create = function(e) {
                return new k(e)
            }, k.register = F, k.getAll = function() {
                return m.slice()
            }, k.getById = function(e) {
                return m.filter(function(t) {
                    return t.vars.id === e
                })[0]
            }, g() && n.registerPlugin(k), t.Observer = k, t._getProxyProp = E, t._getScrollFunc = L, t._getTarget = R, t._getVelocityProp = P, t._horizontal = T, t._isViewport = _, t._vertical = B, t.default = k, "undefined" == typeof window || window !== t ? Object.defineProperty(t, "__esModule", {
                value: !0
            }) : delete window.default
        },
        547: function(e, t) {
            var n, r, i, s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x, E, _;
            m = function() {
                return "undefined" != typeof window
            }, v = function() {
                return n || m() && (n = window.gsap) && n.registerPlugin && n
            }, y = function(e) {
                return c.maxScroll(e || i)
            }, x = function(e, t) {
                var n, r, s = e.parentNode || a,
                    o = e.getBoundingClientRect(),
                    l = s.getBoundingClientRect(),
                    u = l.top - o.top,
                    c = l.bottom - o.bottom,
                    h = (Math.abs(u) > Math.abs(c) ? u : c) / (1 - t),
                    d = -h * t;
                return h > 0 && (r = .5 == (n = l.height / (i.innerHeight + l.height)) ? 2 * l.height : 2 * Math.min(l.height, Math.abs(-h * n / (2 * n - 1))) * (t || 1), d += t ? -r * t : -r / 2, h += r), {
                    change: h,
                    offset: d
                }
            }, E = function(e) {
                var t = s.querySelector(".ScrollSmoother-wrapper");
                return t || ((t = s.createElement("div")).classList.add("ScrollSmoother-wrapper"), e.parentNode.insertBefore(t, e), t.appendChild(e)), t
            }, (_ = function() {
                var e;

                function t(e) {
                    var m = this;
                    r || t.register(n) || console.warn("Please gsap.registerPlugin(ScrollSmoother)"), e = this.vars = e || {}, h && h.kill(), h = this, g(this);
                    var v, _, b, w, C, S, I, M, T, B, R, D, L, P, O, N, U = e,
                        F = U.smoothTouch,
                        k = U.onUpdate,
                        Q = U.onStop,
                        G = U.smooth,
                        z = U.onFocusIn,
                        H = U.normalizeScroll,
                        V = U.wholePixels,
                        j = this,
                        W = e.effectsPrefix || "",
                        Y = c.getScrollFunc(i),
                        X = 1 === c.isTouch ? !0 === F ? .8 : parseFloat(F) || 0 : 0 === G || !1 === G ? 0 : parseFloat(G) || .8,
                        q = X && +e.speed || 1,
                        K = 0,
                        J = 0,
                        Z = 1,
                        $ = f(0),
                        ee = function() {
                            return $.update(-K)
                        },
                        et = {
                            y: 0
                        },
                        en = function() {
                            return v.style.overflow = "visible"
                        },
                        er = function(e) {
                            e.update();
                            var t = e.getTween();
                            t && (t.pause(), t._time = t._dur, t._tTime = t._tDur), O = !1, e.animation.progress(e.progress, !0)
                        },
                        ei = function(e, n) {
                            (e !== K && !B || n) && (V && (e = Math.round(e)), X && (v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + e + ", 0, 1)", v._gsap.y = e + "px"), J = e - K, K = e, c.isUpdating || t.isRefreshing || c.update())
                        },
                        es = function(e) {
                            return arguments.length ? (e < 0 && (e = 0), et.y = -e, O = !0, B ? K = -e : ei(-e), c.isRefreshing ? w.update() : Y(e / q), this) : -K
                        },
                        ea = "undefined" != typeof ResizeObserver && !1 !== e.autoResize && new ResizeObserver(function() {
                            if (!c.isRefreshing) {
                                var e = y(_) * q;
                                e < -K && es(e), A.restart(!0)
                            }
                        }),
                        eo = function(e) {
                            _.scrollTop = 0, e.target.contains && e.target.contains(_) || z && !1 === z(m, e) || (c.isInViewport(e.target) || e.target === N || m.scrollTo(e.target, !1, "center center"), N = e.target)
                        },
                        el = function(e, t) {
                            if (e < t.start) return e;
                            var n = isNaN(t.ratio) ? 1 : t.ratio,
                                r = t.end - t.start,
                                i = e - t.start,
                                s = t.offset || 0,
                                a = t.pins || [],
                                o = a.offset || 0,
                                l = t._startClamp && t.start <= 0 || t.pins && t.pins.offset ? 0 : t._endClamp && t.end === y() ? 1 : .5;
                            return a.forEach(function(t) {
                                r -= t.distance, t.nativeStart <= e && (i -= t.distance)
                            }), o && (i *= (r - o / n) / r), e + (i - s * l) / n - i
                        },
                        eu = function e(t, r, i) {
                            i || (t.pins.length = t.pins.offset = 0);
                            var s, a, o, l, u, c, h, d, f = t.pins,
                                p = t.markers;
                            for (h = 0; h < r.length; h++)
                                if (d = r[h], t.trigger && d.trigger && t !== d && (d.trigger === t.trigger || d.pinnedContainer === t.trigger || t.trigger.contains(d.trigger)) && (u = d._startNative || d._startClamp || d.start, c = d._endNative || d._endClamp || d.end, o = el(u, t), l = d.pin && c > 0 ? o + (c - u) : el(c, t), d.setPositions(o, l, !0, (d._startClamp ? Math.max(0, o) : o) - u), d.markerStart && p.push(n.quickSetter([d.markerStart, d.markerEnd], "y", "px")), d.pin && d.end > 0 && !i)) {
                                    if (s = d.end - d.start, a = t._startClamp && d.start < 0) {
                                        if (t.start > 0) {
                                            t.setPositions(0, t.end + (t._startNative - t.start), !0), e(t, r);
                                            return
                                        }
                                        s += d.start, f.offset = -d.start
                                    }
                                    f.push({
                                        start: d.start,
                                        nativeStart: u,
                                        end: d.end,
                                        distance: s,
                                        trig: d
                                    }), t.setPositions(t.start, t.end + (a ? -d.start : s), !0)
                                }
                        },
                        ec = function(e, t) {
                            C.forEach(function(n) {
                                return eu(n, e, t)
                            })
                        },
                        eh = function() {
                            a = s.documentElement, o = s.body, en(), requestAnimationFrame(en), C && (c.getAll().forEach(function(e) {
                                e._startNative = e.start, e._endNative = e.end
                            }), C.forEach(function(e) {
                                var t = e._startClamp || e.start,
                                    n = e.autoSpeed ? Math.min(y(), e.end) : t + Math.abs((e.end - t) / e.ratio),
                                    r = n - e.end;
                                if ((t -= r / 2) > (n -= r / 2)) {
                                    var i = t;
                                    t = n, n = i
                                }
                                e._startClamp && t < 0 ? (r = (n = e.ratio < 0 ? y() : e.end / e.ratio) - e.end, t = 0) : (e.ratio < 0 || e._endClamp && n >= y()) && (n = y(), t = e.ratio < 0 ? 0 : e.ratio > 1 ? 0 : n - (n - e.start) / e.ratio, r = (n - t) * e.ratio - (e.end - e.start)), e.offset = r || 1e-4, e.pins.length = e.pins.offset = 0, e.setPositions(t, n, !0)
                            }), ec(c.sort())), $.reset()
                        },
                        ed = function() {
                            return c.addEventListener("refresh", eh)
                        },
                        ef = function() {
                            return C && C.forEach(function(e) {
                                return e.vars.onRefresh(e)
                            })
                        },
                        ep = function() {
                            return C && C.forEach(function(e) {
                                return e.vars.onRefreshInit(e)
                            }), ef
                        },
                        eg = function(e, t, n, r) {
                            return function() {
                                var i = "function" == typeof t ? t(n, r) : t;
                                i || 0 === i || (i = r.getAttribute("data-" + W + e) || ("speed" === e ? 1 : 0)), r.setAttribute("data-" + W + e, i);
                                var s = "clamp(" === (i + "").substr(0, 6);
                                return {
                                    clamp: s,
                                    value: s ? i.substr(6, i.length - 7) : i
                                }
                            }
                        },
                        eA = function(e, t, r, i, s) {
                            s = ("function" == typeof s ? s(i, e) : s) || 0;
                            var a, o, l, h, f, p, g = eg("speed", t, i, e),
                                A = eg("lag", r, i, e),
                                m = n.getProperty(e, "y"),
                                v = e._gsap,
                                E = [],
                                b = function() {
                                    t = g(), r = parseFloat(A().value), a = parseFloat(t.value) || 1, f = (l = "auto" === t.value) || o && o._startClamp && o.start <= 0 || E.offset ? 0 : o && o._endClamp && o.end === y() ? 1 : .5, h && h.kill(), h = r && n.to(e, {
                                        ease: d,
                                        overwrite: !1,
                                        y: "+=0",
                                        duration: r
                                    }), o && (o.ratio = a, o.autoSpeed = l)
                                },
                                w = function() {
                                    v.y = m + "px", v.renderTransform(1), b()
                                },
                                S = [],
                                I = 0,
                                M = function(t) {
                                    if (l) {
                                        w();
                                        var n = x(e, u(0, 1, -t.start / (t.end - t.start)));
                                        I = n.change, p = n.offset
                                    } else p = E.offset || 0, I = (t.end - t.start - p) * (1 - a);
                                    E.forEach(function(e) {
                                        return I -= e.distance * (1 - a)
                                    }), t.offset = I || .001, t.vars.onUpdate(t), h && h.progress(1)
                                };
                            return b(), (1 !== a || l || h) && (o = c.create({
                                trigger: l ? e.parentNode : e,
                                start: function() {
                                    return t.clamp ? "clamp(top bottom+=" + s + ")" : "top bottom+=" + s
                                },
                                end: function() {
                                    return t.value < 0 ? "max" : t.clamp ? "clamp(bottom top-=" + s + ")" : "bottom top-=" + s
                                },
                                scroller: _,
                                scrub: !0,
                                refreshPriority: -999,
                                onRefreshInit: w,
                                onRefresh: M,
                                onKill: function(e) {
                                    var t = C.indexOf(e);
                                    t >= 0 && C.splice(t, 1), w()
                                },
                                onUpdate: function(e) {
                                    var t, r, i, s = m + I * (e.progress - f),
                                        a = E.length,
                                        o = 0;
                                    if (e.offset) {
                                        if (a) {
                                            for (r = -K, i = e.end; a--;) {
                                                if ((t = E[a]).trig.isActive || r >= t.start && r <= t.end) {
                                                    h && (t.trig.progress += t.trig.direction < 0 ? .001 : -.001, t.trig.update(0, 0, 1), h.resetTo("y", parseFloat(v.y), -J, !0), Z && h.progress(1));
                                                    return
                                                }
                                                r > t.end && (o += t.distance), i -= t.distance
                                            }
                                            s = m + o + I * ((n.utils.clamp(e.start, e.end, r) - e.start - o) / (i - e.start) - f)
                                        }
                                        S.length && !l && S.forEach(function(e) {
                                            return e(s - o)
                                        }), s = Math.round(1e5 * (s + p)) / 1e5 || 0, h ? (h.resetTo("y", s, -J, !0), Z && h.progress(1)) : (v.y = s + "px", v.renderTransform(1))
                                    }
                                }
                            }), M(o), n.core.getCache(o.trigger).stRevert = ep, o.startY = m, o.pins = E, o.markers = S, o.ratio = a, o.autoSpeed = l, e.style.willChange = "transform"), o
                        };

                    function em() {
                        return b = v.clientHeight, v.style.overflow = "visible", o.style.height = i.innerHeight + (b - i.innerHeight) / q + "px", b - i.innerHeight
                    }
                    ed(), c.addEventListener("killAll", ed), n.delayedCall(.5, function() {
                        return Z = 0
                    }), this.scrollTop = es, this.scrollTo = function(e, t, r) {
                        var i = n.utils.clamp(0, y(), isNaN(e) ? m.offset(e, r, !!t && !B) : +e);
                        t ? B ? n.to(m, {
                            duration: X,
                            scrollTop: i,
                            overwrite: "auto",
                            ease: d
                        }) : Y(i) : es(i)
                    }, this.offset = function(e, t, r) {
                        var i, s = (e = l(e)[0]).style.cssText,
                            a = c.create({
                                trigger: e,
                                start: t || "top top"
                            });
                        return C && (Z ? c.refresh() : ec([a], !0)), i = a.start / (r ? q : 1), a.kill(!1), e.style.cssText = s, n.core.getCache(e).uncache = 1, i
                    }, this.content = function(e) {
                        if (arguments.length) {
                            var t = l(e || "#smooth-content")[0] || console.warn("ScrollSmoother needs a valid content element.") || o.children[0];
                            return t !== v && (T = (v = t).getAttribute("style") || "", ea && ea.observe(v), n.set(v, {
                                overflow: "visible",
                                width: "100%",
                                boxSizing: "border-box",
                                y: "+=0"
                            }), X || n.set(v, {
                                clearProps: "transform"
                            })), this
                        }
                        return v
                    }, this.wrapper = function(e) {
                        return arguments.length ? (M = (_ = l(e || "#smooth-wrapper")[0] || E(v)).getAttribute("style") || "", em(), n.set(_, X ? {
                            overflow: "hidden",
                            position: "fixed",
                            height: "100%",
                            width: "100%",
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0
                        } : {
                            overflow: "visible",
                            position: "relative",
                            width: "100%",
                            height: "auto",
                            top: "auto",
                            bottom: "auto",
                            left: "auto",
                            right: "auto"
                        }), this) : _
                    }, this.effects = function(e, t) {
                        if (C || (C = []), !e) return C.slice(0);
                        (e = l(e)).forEach(function(e) {
                            for (var t = C.length; t--;) C[t].trigger === e && C[t].kill()
                        });
                        var n, r, i, s = t = t || {},
                            a = s.speed,
                            o = s.lag,
                            u = s.effectsPadding,
                            h = [];
                        for (r = 0; r < e.length; r++)(i = eA(e[r], a, o, r, u)) && h.push(i);
                        return (n = C).push.apply(n, h), !1 !== t.refresh && c.refresh(), h
                    }, this.sections = function(e, t) {
                        if (S || (S = []), !e) return S.slice(0);
                        var n, r = l(e).map(function(e) {
                            return c.create({
                                trigger: e,
                                start: "top 120%",
                                end: "bottom -20%",
                                onToggle: function(t) {
                                    e.style.opacity = t.isActive ? "1" : "0", e.style.pointerEvents = t.isActive ? "all" : "none"
                                }
                            })
                        });
                        return t && t.add ? (n = S).push.apply(n, r) : S = r.slice(0), r
                    }, this.content(e.content), this.wrapper(e.wrapper), this.render = function(e) {
                        return ei(e || 0 === e ? e : K)
                    }, this.getVelocity = function() {
                        return $.getVelocity(-K)
                    }, c.scrollerProxy(_, {
                        scrollTop: es,
                        scrollHeight: function() {
                            return em() && o.scrollHeight
                        },
                        fixedMarkers: !1 !== e.fixedMarkers && !!X,
                        content: v,
                        getBoundingClientRect: function() {
                            return {
                                top: 0,
                                left: 0,
                                width: i.innerWidth,
                                height: i.innerHeight
                            }
                        }
                    }), c.defaults({
                        scroller: _
                    });
                    var ev = c.getAll().filter(function(e) {
                        return e.scroller === i || e.scroller === _
                    });
                    ev.forEach(function(e) {
                        return e.revert(!0, !0)
                    }), w = c.create({
                        animation: n.fromTo(et, {
                            y: function() {
                                return P = 0, 0
                            }
                        }, {
                            y: function() {
                                return P = 1, -em()
                            },
                            immediateRender: !1,
                            ease: "none",
                            data: "ScrollSmoother",
                            duration: 100,
                            onUpdate: function() {
                                if (P) {
                                    var e = O;
                                    e && (er(w), et.y = K), ei(et.y, e), ee(), k && !B && k(j)
                                }
                            }
                        }),
                        onRefreshInit: function(e) {
                            if (!t.isRefreshing) {
                                if (t.isRefreshing = !0, C) {
                                    var n = c.getAll().filter(function(e) {
                                        return !!e.pin
                                    });
                                    C.forEach(function(e) {
                                        e.vars.pinnedContainer || n.forEach(function(t) {
                                            if (t.pin.contains(e.trigger)) {
                                                var n = e.vars;
                                                n.pinnedContainer = t.pin, e.vars = null, e.init(n, e.animation)
                                            }
                                        })
                                    })
                                }
                                var r = e.getTween();
                                L = r && r._end > r._dp._time, D = K, et.y = 0, X && (1 === c.isTouch && (_.style.position = "absolute"), _.scrollTop = 0, 1 === c.isTouch && (_.style.position = "fixed"))
                            }
                        },
                        onRefresh: function(e) {
                            e.animation.invalidate(), e.setPositions(e.start, em() / q), L || er(e), et.y = -Y() * q, ei(et.y), Z || (L && (O = !1), e.animation.progress(n.utils.clamp(0, 1, -(D / q / e.end)))), L && (e.progress -= .001, e.update()), t.isRefreshing = !1
                        },
                        id: "ScrollSmoother",
                        scroller: i,
                        invalidateOnRefresh: !0,
                        start: 0,
                        refreshPriority: -9999,
                        end: function() {
                            return em() / q
                        },
                        onScrubComplete: function() {
                            $.reset(), Q && Q(m)
                        },
                        scrub: X || !0
                    }), this.smooth = function(t) {
                        return arguments.length && (q = (X = t || 0) && +e.speed || 1, w.scrubDuration(t)), w.getTween() ? w.getTween().duration() : 0
                    }, w.getTween() && (w.getTween().vars.ease = e.ease || d), this.scrollTrigger = w, e.effects && this.effects(!0 === e.effects ? "[data-" + W + "speed], [data-" + W + "lag]" : e.effects, {
                        effectsPadding: e.effectsPadding,
                        refresh: !1
                    }), e.sections && this.sections(!0 === e.sections ? "[data-section]" : e.sections), ev.forEach(function(e) {
                        e.vars.scroller = _, e.revert(!1, !0), e.init(e.vars, e.animation)
                    }), this.paused = function(e, t) {
                        return arguments.length ? (!!B !== e && (e ? (w.getTween() && w.getTween().pause(), Y(-K / q), $.reset(), (R = c.normalizeScroll()) && R.disable(), (B = c.observe({
                            preventDefault: !0,
                            type: "wheel,touch,scroll",
                            debounce: !1,
                            allowClicks: !0,
                            onChangeY: function() {
                                return es(-K)
                            }
                        })).nested = p(a, "wheel,touch,scroll", !0, !1 !== t)) : (B.nested.kill(), B.kill(), B = 0, R && R.enable(), w.progress = (-K / q - w.start) / (w.end - w.start), er(w))), this) : !!B
                    }, this.kill = this.revert = function() {
                        m.paused(!1), er(w), w.kill();
                        for (var e = (C || []).concat(S || []), t = e.length; t--;) e[t].kill();
                        c.scrollerProxy(_), c.removeEventListener("killAll", ed), c.removeEventListener("refresh", eh), _.style.cssText = M, v.style.cssText = T;
                        var n = c.defaults({});
                        n && n.scroller === _ && c.defaults({
                            scroller: i
                        }), m.normalizer && c.normalizeScroll(!1), clearInterval(I), h = null, ea && ea.disconnect(), o.style.removeProperty("height"), i.removeEventListener("focusin", eo)
                    }, this.refresh = function(e, t) {
                        return w.refresh(e, t)
                    }, H && (this.normalizer = c.normalizeScroll(!0 === H ? {
                        debounce: !0,
                        content: !X && v
                    } : H)), c.config(e), "scrollBehavior" in i.getComputedStyle(o) && n.set([o, a], {
                        scrollBehavior: "auto"
                    }), i.addEventListener("focusin", eo), I = setInterval(ee, 250), "loading" === s.readyState || requestAnimationFrame(function() {
                        return c.refresh()
                    })
                }
                return t.register = function(e) {
                        return !r && (n = e || v(), m() && window.document && (i = window, a = (s = document).documentElement, o = s.body), n && (l = n.utils.toArray, u = n.utils.clamp, d = n.parseEase("expo"), g = n.core.context || function() {}, c = n.core.globals().ScrollTrigger, n.core.globals("ScrollSmoother", t), o && c && (A = n.delayedCall(.2, function() {
                            return c.isRefreshing || h && h.refresh()
                        }).pause(), f = c.core._getVelocityProp, p = c.core._inputObserver, t.refresh = c.refresh, r = 1))), r
                    }, e = [{
                        key: "progress",
                        get: function() {
                            return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0
                        }
                    }],
                    function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }(t.prototype, e), t
            }()).version = "3.13.0", _.create = function(e) {
                return h && e && h.content() === l(e.content)[0] ? h : new _(e)
            }, _.get = function() {
                return h
            }, v() && n.registerPlugin(_), t.ScrollSmoother = _, t.default = _, "undefined" == typeof window || window !== t ? Object.defineProperty(t, "__esModule", {
                value: !0
            }) : delete window.default
        },
        7835: function(e, t) {
            var n, r, i, s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x, E, _, b, w, C, S, I, M, T, B, R, D, L, P, O, N, U, F, k, Q, G, z, H, V, j, W, Y, X, q, K, J, Z, $, ee, et, en, er, ei, es, ea, eo, el, eu, ec, eh, ed, ef, ep, eg, eA, em, ev, ey, ex, eE, e_, eb, ew, eC, eS, eI, eM, eT, eB, eR, eD, eL, eP, eO, eN, eU, eF, ek, eQ, eG, ez, eH, eV, ej, eW, eY, eX, eq, eK, eJ, eZ, e$, e0, e1, e2, e3, e4, e5, e6, e8, e9, e7, te, tt, tn, tr, ti, ts, ta, to, tl, tu, tc, th, td, tf, tp, tg, tA, tm, tv, ty, tx, tE, t_, tb, tw, tC, tS, tI, tM, tT, tB, tR, tD, tL, tP, tO, tN, tU, tF, tk, tQ, tG, tz, tH, tV, tj, tW, tY, tX, tq, tK, tJ, tZ, t$, t0, t1, t2, t3, t4, t5, t6, t8, t9, t7;
            g = function() {
                return n || "undefined" != typeof window && (n = window.gsap) && n.registerPlugin && n
            }, A = 1, m = [], v = [], y = [], x = Date.now, E = function(e, t) {
                return t
            }, _ = function() {
                var e = c.core,
                    t = e.bridge || {},
                    n = e._scrollers,
                    r = e._proxies;
                n.push.apply(n, v), r.push.apply(r, y), v = n, y = r, E = function(e, n) {
                    return t[e](n)
                }
            }, b = function(e, t) {
                return ~y.indexOf(e) && y[y.indexOf(e) + 1][t]
            }, w = function(e) {
                return !!~h.indexOf(e)
            }, C = function(e, t, n, r, i) {
                return e.addEventListener(t, n, {
                    passive: !1 !== r,
                    capture: !!i
                })
            }, S = function(e, t, n, r) {
                return e.removeEventListener(t, n, !!r)
            }, I = "scrollLeft", M = "scrollTop", T = function() {
                return d && d.isPressed || v.cache++
            }, D = {
                s: M,
                p: "top",
                p2: "Top",
                os: "bottom",
                os2: "Bottom",
                d: "height",
                d2: "Height",
                a: "y",
                op: R = {
                    s: I,
                    p: "left",
                    p2: "Left",
                    os: "right",
                    os2: "Right",
                    d: "width",
                    d2: "Width",
                    a: "x",
                    sc: (B = function(e, t) {
                        var n = function n(r) {
                            if (r || 0 === r) {
                                A && (i.history.scrollRestoration = "manual");
                                var s = d && d.isPressed;
                                e(r = n.v = Math.round(r) || (d && d.iOS ? 1 : 0)), n.cacheID = v.cache, s && E("ss", r)
                            } else(t || v.cache !== n.cacheID || E("ref")) && (n.cacheID = v.cache, n.v = e());
                            return n.v + n.offset
                        };
                        return n.offset = 0, e && n
                    })(function(e) {
                        return arguments.length ? i.scrollTo(e, D.sc()) : i.pageXOffset || s[I] || a[I] || o[I] || 0
                    })
                },
                sc: B(function(e) {
                    return arguments.length ? i.scrollTo(R.sc(), e) : i.pageYOffset || s[M] || a[M] || o[M] || 0
                })
            }, L = function(e, t) {
                return (t && t._ctx && t._ctx.selector || n.utils.toArray)(e)[0] || ("string" == typeof e && !1 !== n.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
            }, P = function(e, t) {
                for (var n = t.length; n--;)
                    if (t[n] === e || t[n].contains(e)) return !0;
                return !1
            }, O = function(e, t) {
                var r = t.s,
                    i = t.sc;
                w(e) && (e = s.scrollingElement || a);
                var o = v.indexOf(e),
                    l = i === D.sc ? 1 : 2;
                ~o || (o = v.push(e) - 1), v[o + l] || C(e, "scroll", T);
                var u = v[o + l],
                    c = u || (v[o + l] = B(b(e, r), !0) || (w(e) ? i : B(function(t) {
                        return arguments.length ? e[r] = t : e[r]
                    })));
                return c.target = e, u || (c.smooth = "smooth" === n.getProperty(e, "scrollBehavior")), c
            }, N = function(e, t, n) {
                var r = e,
                    i = e,
                    s = x(),
                    a = s,
                    o = t || 50,
                    l = Math.max(500, 3 * o),
                    u = function(e, t) {
                        var l = x();
                        t || l - s > o ? (i = r, r = e, a = s, s = l) : n ? r += e : r = i + (e - i) / (l - a) * (s - a)
                    };
                return {
                    update: u,
                    reset: function() {
                        i = r = n ? 0 : r, a = s = 0
                    },
                    getVelocity: function(e) {
                        var t = a,
                            o = i,
                            c = x();
                        return (e || 0 === e) && e !== r && u(e), s === a || c - a > l ? 0 : (r + (n ? o : -o)) / ((n ? c : s) - t) * 1e3
                    }
                }
            }, U = function(e, t) {
                return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
            }, F = function(e) {
                var t = Math.max.apply(Math, e),
                    n = Math.min.apply(Math, e);
                return Math.abs(t) >= Math.abs(n) ? t : n
            }, k = function() {
                (c = n.core.globals().ScrollTrigger) && c.core && _()
            }, Q = function(e) {
                return n = e || g(), !r && n && "undefined" != typeof document && document.body && (i = window, a = (s = document).documentElement, o = s.body, h = [i, s, a, o], n.utils.clamp, p = n.core.context || function() {}, u = "onpointerenter" in o ? "pointer" : "mouse", l = G.isTouch = i.matchMedia && i.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in i || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, f = G.eventTypes = ("ontouchstart" in a ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in a ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
                    return A = 0
                }, 500), k(), r = 1), r
            }, R.op = D, v.cache = 0, (G = function() {
                function e(e) {
                    this.init(e)
                }
                return e.prototype.init = function(e) {
                        r || Q(n) || console.warn("Please gsap.registerPlugin(Observer)"), c || k();
                        var t = e.tolerance,
                            h = e.dragMinimum,
                            g = e.type,
                            A = e.target,
                            v = e.lineHeight,
                            y = e.debounce,
                            E = e.preventDefault,
                            _ = e.onStop,
                            b = e.onStopDelay,
                            I = e.ignore,
                            M = e.wheelSpeed,
                            B = e.event,
                            G = e.onDragStart,
                            z = e.onDragEnd,
                            H = e.onDrag,
                            V = e.onPress,
                            j = e.onRelease,
                            W = e.onRight,
                            Y = e.onLeft,
                            X = e.onUp,
                            q = e.onDown,
                            K = e.onChangeX,
                            J = e.onChangeY,
                            Z = e.onChange,
                            $ = e.onToggleX,
                            ee = e.onToggleY,
                            et = e.onHover,
                            en = e.onHoverEnd,
                            er = e.onMove,
                            ei = e.ignoreCheck,
                            es = e.isNormalizer,
                            ea = e.onGestureStart,
                            eo = e.onGestureEnd,
                            el = e.onWheel,
                            eu = e.onEnable,
                            ec = e.onDisable,
                            eh = e.onClick,
                            ed = e.scrollSpeed,
                            ef = e.capture,
                            ep = e.allowClicks,
                            eg = e.lockAxis,
                            eA = e.onLockAxis;
                        this.target = A = L(A) || a, this.vars = e, I && (I = n.utils.toArray(I)), t = t || 1e-9, h = h || 0, M = M || 1, ed = ed || 1, g = g || "wheel,touch,pointer", y = !1 !== y, v || (v = parseFloat(i.getComputedStyle(o).lineHeight) || 22);
                        var em, ev, ey, ex, eE, e_, eb, ew = this,
                            eC = 0,
                            eS = 0,
                            eI = e.passive || !E && !1 !== e.passive,
                            eM = O(A, R),
                            eT = O(A, D),
                            eB = eM(),
                            eR = eT(),
                            eD = ~g.indexOf("touch") && !~g.indexOf("pointer") && "pointerdown" === f[0],
                            eL = w(A),
                            eP = A.ownerDocument || s,
                            eO = [0, 0, 0],
                            eN = [0, 0, 0],
                            eU = 0,
                            eF = function() {
                                return eU = x()
                            },
                            ek = function(e, t) {
                                return (ew.event = e) && I && P(e.target, I) || t && eD && "touch" !== e.pointerType || ei && ei(e, t)
                            },
                            eQ = function() {
                                var e = ew.deltaX = F(eO),
                                    n = ew.deltaY = F(eN),
                                    r = Math.abs(e) >= t,
                                    i = Math.abs(n) >= t;
                                Z && (r || i) && Z(ew, e, n, eO, eN), r && (W && ew.deltaX > 0 && W(ew), Y && ew.deltaX < 0 && Y(ew), K && K(ew), $ && ew.deltaX < 0 != eC < 0 && $(ew), eC = ew.deltaX, eO[0] = eO[1] = eO[2] = 0), i && (q && ew.deltaY > 0 && q(ew), X && ew.deltaY < 0 && X(ew), J && J(ew), ee && ew.deltaY < 0 != eS < 0 && ee(ew), eS = ew.deltaY, eN[0] = eN[1] = eN[2] = 0), (ex || ey) && (er && er(ew), ey && (G && 1 === ey && G(ew), H && H(ew), ey = 0), ex = !1), e_ && (e_ = !1, 1) && eA && eA(ew), eE && (el(ew), eE = !1), em = 0
                            },
                            eG = function(e, t, n) {
                                eO[n] += e, eN[n] += t, ew._vx.update(e), ew._vy.update(t), y ? em || (em = requestAnimationFrame(eQ)) : eQ()
                            },
                            ez = function(e, t) {
                                eg && !eb && (ew.axis = eb = Math.abs(e) > Math.abs(t) ? "x" : "y", e_ = !0), "y" !== eb && (eO[2] += e, ew._vx.update(e, !0)), "x" !== eb && (eN[2] += t, ew._vy.update(t, !0)), y ? em || (em = requestAnimationFrame(eQ)) : eQ()
                            },
                            eH = function(e) {
                                if (!ek(e, 1)) {
                                    var t = (e = U(e, E)).clientX,
                                        n = e.clientY,
                                        r = t - ew.x,
                                        i = n - ew.y,
                                        s = ew.isDragging;
                                    ew.x = t, ew.y = n, (s || (r || i) && (Math.abs(ew.startX - t) >= h || Math.abs(ew.startY - n) >= h)) && (ey = s ? 2 : 1, s || (ew.isDragging = !0), ez(r, i))
                                }
                            },
                            eV = ew.onPress = function(e) {
                                ek(e, 1) || e && e.button || (ew.axis = eb = null, ev.pause(), ew.isPressed = !0, e = U(e), eC = eS = 0, ew.startX = ew.x = e.clientX, ew.startY = ew.y = e.clientY, ew._vx.reset(), ew._vy.reset(), C(es ? A : eP, f[1], eH, eI, !0), ew.deltaX = ew.deltaY = 0, V && V(ew))
                            },
                            ej = ew.onRelease = function(e) {
                                if (!ek(e, 1)) {
                                    S(es ? A : eP, f[1], eH, !0);
                                    var t = !isNaN(ew.y - ew.startY),
                                        r = ew.isDragging,
                                        s = r && (Math.abs(ew.x - ew.startX) > 3 || Math.abs(ew.y - ew.startY) > 3),
                                        a = U(e);
                                    !s && t && (ew._vx.reset(), ew._vy.reset(), E && ep && n.delayedCall(.08, function() {
                                        if (x() - eU > 300 && !e.defaultPrevented) {
                                            if (e.target.click) e.target.click();
                                            else if (eP.createEvent) {
                                                var t = eP.createEvent("MouseEvents");
                                                t.initMouseEvent("click", !0, !0, i, 1, a.screenX, a.screenY, a.clientX, a.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(t)
                                            }
                                        }
                                    })), ew.isDragging = ew.isGesturing = ew.isPressed = !1, _ && r && !es && ev.restart(!0), ey && eQ(), z && r && z(ew), j && j(ew, s)
                                }
                            },
                            eW = function(e) {
                                return e.touches && e.touches.length > 1 && (ew.isGesturing = !0) && ea(e, ew.isDragging)
                            },
                            eY = function() {
                                return ew.isGesturing = !1, eo(ew)
                            },
                            eX = function(e) {
                                if (!ek(e)) {
                                    var t = eM(),
                                        n = eT();
                                    eG((t - eB) * ed, (n - eR) * ed, 1), eB = t, eR = n, _ && ev.restart(!0)
                                }
                            },
                            eq = function(e) {
                                if (!ek(e)) {
                                    e = U(e, E), el && (eE = !0);
                                    var t = (1 === e.deltaMode ? v : 2 === e.deltaMode ? i.innerHeight : 1) * M;
                                    eG(e.deltaX * t, e.deltaY * t, 0), _ && !es && ev.restart(!0)
                                }
                            },
                            eK = function(e) {
                                if (!ek(e)) {
                                    var t = e.clientX,
                                        n = e.clientY,
                                        r = t - ew.x,
                                        i = n - ew.y;
                                    ew.x = t, ew.y = n, ex = !0, _ && ev.restart(!0), (r || i) && ez(r, i)
                                }
                            },
                            eJ = function(e) {
                                ew.event = e, et(ew)
                            },
                            eZ = function(e) {
                                ew.event = e, en(ew)
                            },
                            e$ = function(e) {
                                return ek(e) || U(e, E) && eh(ew)
                            };
                        ev = ew._dc = n.delayedCall(b || .25, function() {
                            ew._vx.reset(), ew._vy.reset(), ev.pause(), _ && _(ew)
                        }).pause(), ew.deltaX = ew.deltaY = 0, ew._vx = N(0, 50, !0), ew._vy = N(0, 50, !0), ew.scrollX = eM, ew.scrollY = eT, ew.isDragging = ew.isGesturing = ew.isPressed = !1, p(this), ew.enable = function(e) {
                            return !ew.isEnabled && (C(eL ? eP : A, "scroll", T), g.indexOf("scroll") >= 0 && C(eL ? eP : A, "scroll", eX, eI, ef), g.indexOf("wheel") >= 0 && C(A, "wheel", eq, eI, ef), (g.indexOf("touch") >= 0 && l || g.indexOf("pointer") >= 0) && (C(A, f[0], eV, eI, ef), C(eP, f[2], ej), C(eP, f[3], ej), ep && C(A, "click", eF, !0, !0), eh && C(A, "click", e$), ea && C(eP, "gesturestart", eW), eo && C(eP, "gestureend", eY), et && C(A, u + "enter", eJ), en && C(A, u + "leave", eZ), er && C(A, u + "move", eK)), ew.isEnabled = !0, ew.isDragging = ew.isGesturing = ew.isPressed = ex = ey = !1, ew._vx.reset(), ew._vy.reset(), eB = eM(), eR = eT(), e && e.type && eV(e), eu && eu(ew)), ew
                        }, ew.disable = function() {
                            ew.isEnabled && (m.filter(function(e) {
                                return e !== ew && w(e.target)
                            }).length || S(eL ? eP : A, "scroll", T), ew.isPressed && (ew._vx.reset(), ew._vy.reset(), S(es ? A : eP, f[1], eH, !0)), S(eL ? eP : A, "scroll", eX, ef), S(A, "wheel", eq, ef), S(A, f[0], eV, ef), S(eP, f[2], ej), S(eP, f[3], ej), S(A, "click", eF, !0), S(A, "click", e$), S(eP, "gesturestart", eW), S(eP, "gestureend", eY), S(A, u + "enter", eJ), S(A, u + "leave", eZ), S(A, u + "move", eK), ew.isEnabled = ew.isPressed = ew.isDragging = !1, ec && ec(ew))
                        }, ew.kill = ew.revert = function() {
                            ew.disable();
                            var e = m.indexOf(ew);
                            e >= 0 && m.splice(e, 1), d === ew && (d = 0)
                        }, m.push(ew), es && w(A) && (d = ew), ew.enable(B)
                    },
                    function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }(e.prototype, [{
                        key: "velocityX",
                        get: function() {
                            return this._vx.getVelocity()
                        }
                    }, {
                        key: "velocityY",
                        get: function() {
                            return this._vy.getVelocity()
                        }
                    }]), e
            }()).version = "3.13.0", G.create = function(e) {
                return new G(e)
            }, G.register = Q, G.getAll = function() {
                return m.slice()
            }, G.getById = function(e) {
                return m.filter(function(t) {
                    return t.vars.id === e
                })[0]
            }, g() && n.registerPlugin(G), eS = 1, eM = (eI = Date.now)(), eT = 0, eB = 0, eR = function(e, t, n) {
                var r = ej(e) && ("clamp(" === e.substr(0, 6) || e.indexOf("max") > -1);
                return n["_" + t + "Clamp"] = r, r ? e.substr(6, e.length - 7) : e
            }, eD = function(e, t) {
                return t && (!ej(e) || "clamp(" !== e.substr(0, 6)) ? "clamp(" + e + ")" : e
            }, eL = function() {
                return et = 1
            }, eP = function() {
                return et = 0
            }, eO = function(e) {
                return e
            }, eN = function(e) {
                return Math.round(1e5 * e) / 1e5 || 0
            }, eU = function() {
                return "undefined" != typeof window
            }, eF = function() {
                return z || eU() && (z = window.gsap) && z.registerPlugin && z
            }, ek = function(e) {
                return !!~X.indexOf(e)
            }, eQ = function(e) {
                return ("Height" === e ? ev : V["inner" + e]) || W["client" + e] || Y["client" + e]
            }, eG = function(e) {
                return b(e, "getBoundingClientRect") || (ek(e) ? function() {
                    return tY.width = V.innerWidth, tY.height = ev, tY
                } : function() {
                    return tr(e)
                })
            }, ez = function(e, t, n) {
                var r = n.d,
                    i = n.d2,
                    s = n.a;
                return (s = b(e, "getBoundingClientRect")) ? function() {
                    return s()[r]
                } : function() {
                    return (t ? eQ(i) : e["client" + i]) || 0
                }
            }, eH = function(e, t) {
                var n = t.s,
                    r = t.d2,
                    i = t.d,
                    s = t.a;
                return Math.max(0, (s = b(e, n = "scroll" + r)) ? s() - eG(e)()[i] : ek(e) ? (W[n] || Y[n]) - eQ(r) : e[n] - e["offset" + r])
            }, eV = function(e, t) {
                for (var n = 0; n < ea.length; n += 3)(!t || ~t.indexOf(ea[n + 1])) && e(ea[n], ea[n + 1], ea[n + 2])
            }, ej = function(e) {
                return "string" == typeof e
            }, eW = function(e) {
                return "function" == typeof e
            }, eY = function(e) {
                return "number" == typeof e
            }, eX = function(e) {
                return "object" == typeof e
            }, eq = function(e, t, n) {
                return e && e.progress(t ? 0 : 1) && n && e.pause()
            }, eK = function(e, t) {
                if (e.enabled) {
                    var n = e._ctx ? e._ctx.add(function() {
                        return t(e)
                    }) : t(e);
                    n && n.totalTime && (e.callbackAnimation = n)
                }
            }, eJ = Math.abs, eZ = "left", e$ = "right", e0 = "bottom", e1 = "width", e2 = "height", e3 = "Right", e4 = "Left", e5 = "Bottom", e6 = "padding", e8 = "margin", e9 = "Width", e7 = "Height", te = function(e) {
                return V.getComputedStyle(e)
            }, tt = function(e) {
                var t = te(e).position;
                e.style.position = "absolute" === t || "fixed" === t ? t : "relative"
            }, tn = function(e, t) {
                for (var n in t) n in e || (e[n] = t[n]);
                return e
            }, tr = function(e, t) {
                var n = t && "matrix(1, 0, 0, 1, 0, 0)" !== te(e)[en] && z.to(e, {
                        x: 0,
                        y: 0,
                        xPercent: 0,
                        yPercent: 0,
                        rotation: 0,
                        rotationX: 0,
                        rotationY: 0,
                        scale: 1,
                        skewX: 0,
                        skewY: 0
                    }).progress(1),
                    r = e.getBoundingClientRect();
                return n && n.progress(0).kill(), r
            }, ti = function(e, t) {
                var n = t.d2;
                return e["offset" + n] || e["client" + n] || 0
            }, ts = function(e) {
                var t, n = [],
                    r = e.labels,
                    i = e.duration();
                for (t in r) n.push(r[t] / i);
                return n
            }, ta = function(e) {
                var t = z.utils.snap(e),
                    n = Array.isArray(e) && e.slice(0).sort(function(e, t) {
                        return e - t
                    });
                return n ? function(e, r, i) {
                    var s;
                    if (void 0 === i && (i = .001), !r) return t(e);
                    if (r > 0) {
                        for (e -= i, s = 0; s < n.length; s++)
                            if (n[s] >= e) return n[s];
                        return n[s - 1]
                    }
                    for (s = n.length, e += i; s--;)
                        if (n[s] <= e) return n[s];
                    return n[0]
                } : function(n, r, i) {
                    void 0 === i && (i = .001);
                    var s = t(n);
                    return !r || Math.abs(s - n) < i || s - n < 0 == r < 0 ? s : t(r < 0 ? n - e : n + e)
                }
            }, to = function(e, t, n, r) {
                return n.split(",").forEach(function(n) {
                    return e(t, n, r)
                })
            }, tl = function(e, t, n, r, i) {
                return e.addEventListener(t, n, {
                    passive: !r,
                    capture: !!i
                })
            }, tu = function(e, t, n, r) {
                return e.removeEventListener(t, n, !!r)
            }, tc = function(e, t, n) {
                (n = n && n.wheelHandler) && (e(t, "wheel", n), e(t, "touchmove", n))
            }, th = {
                startColor: "green",
                endColor: "red",
                indent: 0,
                fontSize: "16px",
                fontWeight: "normal"
            }, td = {
                toggleActions: "play",
                anticipatePin: 0
            }, tf = {
                top: 0,
                left: 0,
                center: .5,
                bottom: 1,
                right: 1
            }, tp = function(e, t) {
                if (ej(e)) {
                    var n = e.indexOf("="),
                        r = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
                    ~n && (e.indexOf("%") > n && (r *= t / 100), e = e.substr(0, n - 1)), e = r + (e in tf ? tf[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
                }
                return e
            }, tg = function(e, t, n, r, i, s, a, o) {
                var l = i.startColor,
                    u = i.endColor,
                    c = i.fontSize,
                    h = i.indent,
                    d = i.fontWeight,
                    f = j.createElement("div"),
                    p = ek(n) || "fixed" === b(n, "pinType"),
                    g = -1 !== e.indexOf("scroller"),
                    A = p ? Y : n,
                    m = -1 !== e.indexOf("start"),
                    v = m ? l : u,
                    y = "border-color:" + v + ";font-size:" + c + ";color:" + v + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                return y += "position:" + ((g || o) && p ? "fixed;" : "absolute;"), (g || o || !p) && (y += (r === D ? e$ : e0) + ":" + (s + parseFloat(h)) + "px;"), a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), f._isStart = m, f.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), f.style.cssText = y, f.innerText = t || 0 === t ? e + "-" + t : e, A.children[0] ? A.insertBefore(f, A.children[0]) : A.appendChild(f), f._offset = f["offset" + r.op.d2], tA(f, 0, r, m), f
            }, tA = function(e, t, n, r) {
                var i = {
                        display: "block"
                    },
                    s = n[r ? "os2" : "p2"],
                    a = n[r ? "p2" : "os2"];
                e._isFlipped = r, i[n.a + "Percent"] = r ? -100 : 0, i[n.a] = r ? "1px" : 0, i["border" + s + e9] = 1, i["border" + a + e9] = 0, i[n.p] = t + "px", z.set(e, i)
            }, tm = [], tv = {}, ty = function() {
                return eI() - eT > 34 && (e_ || (e_ = requestAnimationFrame(tF)))
            }, tx = function() {
                ec && ec.isPressed && !(ec.startX > Y.clientWidth) || (v.cache++, ec ? e_ || (e_ = requestAnimationFrame(tF)) : tF(), eT || tS("scrollStart"), eT = eI())
            }, tE = function() {
                ef = V.innerWidth, ed = V.innerHeight
            }, t_ = function(e) {
                v.cache++, (!0 === e || !ee && !eu && !j.fullscreenElement && !j.webkitFullscreenElement && (!eh || ef !== V.innerWidth || Math.abs(V.innerHeight - ed) > .25 * V.innerHeight)) && q.restart(!0)
            }, tb = {}, tw = [], tC = function e() {
                return tu(t0, "scrollEnd", e) || tO(!0)
            }, tS = function(e) {
                return tb[e] && tb[e].map(function(e) {
                    return e()
                }) || tw
            }, tI = [], tM = function(e) {
                for (var t = 0; t < tI.length; t += 5)(!e || tI[t + 4] && tI[t + 4].query === e) && (tI[t].style.cssText = tI[t + 1], tI[t].getBBox && tI[t].setAttribute("transform", tI[t + 2] || ""), tI[t + 3].uncache = 1)
            }, tT = function(e, t) {
                var n;
                for (er = 0; er < tm.length; er++)(n = tm[er]) && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
                ey = !0, t && tM(t), t || tS("revert")
            }, tB = function(e, t) {
                v.cache++, (t || !eb) && v.forEach(function(e) {
                    return eW(e) && e.cacheID++ && (e.rec = 0)
                }), ej(e) && (V.history.scrollRestoration = eA = e)
            }, tR = 0, tD = function() {
                if (ew !== tR) {
                    var e = ew = tR;
                    requestAnimationFrame(function() {
                        return e === tR && tO(!0)
                    })
                }
            }, tL = function() {
                Y.appendChild(em), ev = !ec && em.offsetHeight || V.innerHeight, Y.removeChild(em)
            }, tP = function(e) {
                return K(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
                    return t.style.display = e ? "none" : "block"
                })
            }, tO = function(e, t) {
                if (W = j.documentElement, Y = j.body, X = [V, j, W, Y], eT && !e && !ey) {
                    tl(t0, "scrollEnd", tC);
                    return
                }
                tL(), eb = t0.isRefreshing = !0, v.forEach(function(e) {
                    return eW(e) && ++e.cacheID && (e.rec = e())
                });
                var n = tS("refreshInit");
                eo && t0.sort(), t || tT(), v.forEach(function(e) {
                    eW(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"), e(0))
                }), tm.slice(0).forEach(function(e) {
                    return e.refresh()
                }), ey = !1, tm.forEach(function(e) {
                    if (e._subPinOffset && e.pin) {
                        var t = e.vars.horizontal ? "offsetWidth" : "offsetHeight",
                            n = e.pin[t];
                        e.revert(!0, 1), e.adjustPinSpacing(e.pin[t] - n), e.refresh()
                    }
                }), ex = 1, tP(!0), tm.forEach(function(e) {
                    var t = eH(e.scroller, e._dir),
                        n = "max" === e.vars.end || e._endClamp && e.end > t,
                        r = e._startClamp && e.start >= t;
                    (n || r) && e.setPositions(r ? t - 1 : e.start, n ? Math.max(r ? t : e.start + 1, t) : e.end, !0)
                }), tP(!1), ex = 0, n.forEach(function(e) {
                    return e && e.render && e.render(-1)
                }), v.forEach(function(e) {
                    eW(e) && (e.smooth && requestAnimationFrame(function() {
                        return e.target.style.scrollBehavior = "smooth"
                    }), e.rec && e(e.rec))
                }), tB(eA, 1), q.pause(), tR++, eb = 2, tF(2), tm.forEach(function(e) {
                    return eW(e.vars.onRefresh) && e.vars.onRefresh(e)
                }), eb = t0.isRefreshing = !1, tS("refresh")
            }, tN = 0, tU = 1, tF = function(e) {
                if (2 === e || !eb && !ey) {
                    t0.isUpdating = !0, eC && eC.update(0);
                    var t = tm.length,
                        n = eI(),
                        r = n - eM >= 50,
                        i = t && tm[0].scroll();
                    if (tU = tN > i ? -1 : 1, eb || (tN = i), r && (eT && !et && n - eT > 200 && (eT = 0, tS("scrollEnd")), Z = eM, eM = n), tU < 0) {
                        for (er = t; er-- > 0;) tm[er] && tm[er].update(0, r);
                        tU = 1
                    } else
                        for (er = 0; er < t; er++) tm[er] && tm[er].update(0, r);
                    t0.isUpdating = !1
                }
                e_ = 0
            }, tQ = (tk = [eZ, "top", e0, e$, e8 + e5, e8 + e3, e8 + "Top", e8 + e4, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"]).concat([e1, e2, "boxSizing", "max" + e9, "max" + e7, "position", e8, e6, e6 + "Top", e6 + e3, e6 + e5, e6 + e4]), tG = function(e, t, n) {
                tV(n);
                var r = e._gsap;
                if (r.spacerIsNative) tV(r.spacerState);
                else if (e._gsap.swappedIn) {
                    var i = t.parentNode;
                    i && (i.insertBefore(e, t), i.removeChild(t))
                }
                e._gsap.swappedIn = !1
            }, tz = function(e, t, n, r) {
                if (!e._gsap.swappedIn) {
                    for (var i, s = tk.length, a = t.style, o = e.style; s--;) a[i = tk[s]] = n[i];
                    a.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (a.display = "inline-block"), o[e0] = o[e$] = "auto", a.flexBasis = n.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[e1] = ti(e, R) + "px", a[e2] = ti(e, D) + "px", a[e6] = o[e8] = o.top = o[eZ] = "0", tV(r), o[e1] = o["max" + e9] = n[e1], o[e2] = o["max" + e7] = n[e2], o[e6] = n[e6], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
                }
            }, tH = /([A-Z])/g, tV = function(e) {
                if (e) {
                    var t, n, r = e.t.style,
                        i = e.length,
                        s = 0;
                    for ((e.t._gsap || z.core.getCache(e.t)).uncache = 1; s < i; s += 2) n = e[s + 1], t = e[s], n ? r[t] = n : r[t] && r.removeProperty(t.replace(tH, "-$1").toLowerCase())
                }
            }, tj = function(e) {
                for (var t = tQ.length, n = e.style, r = [], i = 0; i < t; i++) r.push(tQ[i], n[tQ[i]]);
                return r.t = e, r
            }, tW = function(e, t, n) {
                for (var r, i = [], s = e.length, a = n ? 8 : 0; a < s; a += 2) r = e[a], i.push(r, r in t ? t[r] : e[a + 1]);
                return i.t = e.t, i
            }, tY = {
                left: 0,
                top: 0
            }, tX = function(e, t, n, r, i, s, a, o, l, u, c, h, d, f) {
                eW(e) && (e = e(o)), ej(e) && "max" === e.substr(0, 3) && (e = h + ("=" === e.charAt(4) ? tp("0" + e.substr(3), n) : 0));
                var p, g, A, m = d ? d.time() : 0;
                if (d && d.seek(0), isNaN(e) || (e = +e), eY(e)) d && (e = z.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, h, e)), a && tA(a, n, r, !0);
                else {
                    eW(t) && (t = t(o));
                    var v, y, x, E, _ = (e || "0").split(" ");
                    (v = tr(A = L(t, o) || Y) || {}).left || v.top || "none" !== te(A).display || (E = A.style.display, A.style.display = "block", v = tr(A), E ? A.style.display = E : A.style.removeProperty("display")), y = tp(_[0], v[r.d]), x = tp(_[1] || "0", n), e = v[r.p] - l[r.p] - u + y + i - x, a && tA(a, x, r, n - x < 20 || a._isStart && x > 20), n -= n - x
                }
                if (f && (o[f] = e || -.001, e < 0 && (e = 0)), s) {
                    var b = e + n,
                        w = s._isStart;
                    p = "scroll" + r.d2, tA(s, b, r, w && b > 20 || !w && (c ? Math.max(Y[p], W[p]) : s.parentNode[p]) <= b + 1), c && (l = tr(a), c && (s.style[r.op.p] = l[r.op.p] - r.op.m - s._offset + "px"))
                }
                return d && A && (p = tr(A), d.seek(h), g = tr(A), d._caScrollDist = p[r.p] - g[r.p], e = e / d._caScrollDist * h), d && d.seek(m), d ? e : Math.round(e)
            }, tq = /(webkit|moz|length|cssText|inset)/i, tK = function(e, t, n, r) {
                if (e.parentNode !== t) {
                    var i, s, a = e.style;
                    if (t === Y) {
                        for (i in e._stOrig = a.cssText, s = te(e)) + i || tq.test(i) || !s[i] || "string" != typeof a[i] || "0" === i || (a[i] = s[i]);
                        a.top = n, a.left = r
                    } else a.cssText = e._stOrig;
                    z.core.getCache(e).uncache = 1, t.appendChild(e)
                }
            }, tJ = function(e, t, n) {
                var r = t,
                    i = r;
                return function(t) {
                    var s = Math.round(e());
                    return s !== r && s !== i && Math.abs(s - r) > 3 && Math.abs(s - i) > 3 && (t = s, n && n()), i = r, r = Math.round(t)
                }
            }, tZ = function(e, t, n) {
                var r = {};
                r[t.p] = "+=" + n, z.set(e, r)
            }, t$ = function(e, t) {
                var n = O(e, t),
                    r = "_scroll" + t.p2,
                    i = function t(i, s, a, o, l) {
                        var u = t.tween,
                            c = s.onComplete,
                            h = {};
                        a = a || n();
                        var d = tJ(n, a, function() {
                            u.kill(), t.tween = 0
                        });
                        return l = o && l || 0, o = o || i - a, u && u.kill(), s[r] = i, s.inherit = !1, s.modifiers = h, h[r] = function() {
                            return d(a + o * u.ratio + l * u.ratio * u.ratio)
                        }, s.onUpdate = function() {
                            v.cache++, t.tween && tF()
                        }, s.onComplete = function() {
                            t.tween = 0, c && c.call(u)
                        }, u = t.tween = z.to(e, s)
                    };
                return e[r] = n, n.wheelHandler = function() {
                    return i.tween && i.tween.kill() && (i.tween = 0)
                }, tl(e, "wheel", n.wheelHandler), t0.isTouch && tl(e, "touchmove", n.wheelHandler), i
            }, (t0 = function() {
                function e(t, n) {
                    H || e.register(z) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), eg(this), this.init(t, n)
                }
                return e.prototype.init = function(t, n) {
                    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !eB) {
                        this.update = this.refresh = this.kill = eO;
                        return
                    }
                    var r, i, s, a, o, l, u, c, h, d, f, p, g, A, m, x, E, _, w, C, S, I, M, T, B, P, N, U, F, k, Q, G, H, X, q, $, en, ei, es, ea, eu, ec = t = tn(ej(t) || eY(t) || t.nodeType ? {
                            trigger: t
                        } : t, td),
                        eh = ec.onUpdate,
                        ed = ec.toggleClass,
                        ef = ec.id,
                        ep = ec.onToggle,
                        eg = ec.onRefresh,
                        eA = ec.scrub,
                        em = ec.trigger,
                        ev = ec.pin,
                        ey = ec.pinSpacing,
                        e_ = ec.invalidateOnRefresh,
                        ew = ec.anticipatePin,
                        eM = ec.onScrubComplete,
                        eL = ec.onSnapComplete,
                        eP = ec.once,
                        eU = ec.snap,
                        eF = ec.pinReparent,
                        eQ = ec.pinSpacer,
                        eV = ec.containerAnimation,
                        eZ = ec.fastScrollEnd,
                        e$ = ec.preventOverlaps,
                        e0 = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? R : D,
                        to = !eA && 0 !== eA,
                        tc = L(t.scroller || V),
                        tf = z.core.getCache(tc),
                        tA = ek(tc),
                        ty = ("pinType" in t ? t.pinType : b(tc, "pinType") || tA && "fixed") === "fixed",
                        tE = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack],
                        tb = to && t.toggleActions.split(" "),
                        tw = "markers" in t ? t.markers : td.markers,
                        tS = tA ? 0 : parseFloat(te(tc)["border" + e0.p2 + e9]) || 0,
                        tI = this,
                        tM = t.onRefreshInit && function() {
                            return t.onRefreshInit(tI)
                        },
                        tT = ez(tc, tA, e0),
                        tB = !tA || ~y.indexOf(tc) ? eG(tc) : function() {
                            return tY
                        },
                        tR = 0,
                        tL = 0,
                        tP = 0,
                        tO = O(tc, e0);
                    if (tI._startClamp = tI._endClamp = !1, tI._dir = e0, ew *= 45, tI.scroller = tc, tI.scroll = eV ? eV.time.bind(eV) : tO, l = tO(), tI.vars = t, n = n || t.animation, "refreshPriority" in t && (eo = 1, -9999 === t.refreshPriority && (eC = tI)), tf.tweenScroll = tf.tweenScroll || {
                            top: t$(tc, D),
                            left: t$(tc, R)
                        }, tI.tweenTo = s = tf.tweenScroll[e0.p], tI.scrubDuration = function(e) {
                            (q = eY(e) && e) ? X ? X.duration(e) : X = z.to(n, {
                                ease: "expo",
                                totalProgress: "+=0",
                                inherit: !1,
                                duration: q,
                                paused: !0,
                                onComplete: function() {
                                    return eM && eM(tI)
                                }
                            }): (X && X.progress(1).kill(), X = 0)
                        }, n && (n.vars.lazy = !1, n._initted && !tI.isReverted || !1 !== n.vars.immediateRender && !1 !== t.immediateRender && n.duration() && n.render(0, !0, !0), tI.animation = n.pause(), n.scrollTrigger = tI, tI.scrubDuration(eA), G = 0, ef || (ef = n.vars.id)), eU && ((!eX(eU) || eU.push) && (eU = {
                            snapTo: eU
                        }), "scrollBehavior" in Y.style && z.set(tA ? [Y, W] : tc, {
                            scrollBehavior: "auto"
                        }), v.forEach(function(e) {
                            return eW(e) && e.target === (tA ? j.scrollingElement || W : tc) && (e.smooth = !1)
                        }), o = eW(eU.snapTo) ? eU.snapTo : "labels" === eU.snapTo ? (r = n, function(e) {
                            return z.utils.snap(ts(r), e)
                        }) : "labelsDirectional" === eU.snapTo ? (i = n, function(e, t) {
                            return ta(ts(i))(e, t.direction)
                        }) : !1 !== eU.directional ? function(e, t) {
                            return ta(eU.snapTo)(e, eI() - tL < 500 ? 0 : t.direction)
                        } : z.utils.snap(eU.snapTo), $ = eX($ = eU.duration || {
                            min: .1,
                            max: 2
                        }) ? J($.min, $.max) : J($, $), en = z.delayedCall(eU.delay || q / 2 || .1, function() {
                            var e = tO(),
                                t = eI() - tL < 500,
                                r = s.tween;
                            if ((t || 10 > Math.abs(tI.getVelocity())) && !r && !et && tR !== e) {
                                var i, a, l = (e - c) / x,
                                    u = n && !to ? n.totalProgress() : l,
                                    d = t ? 0 : (u - H) / (eI() - Z) * 1e3 || 0,
                                    f = z.utils.clamp(-l, 1 - l, eJ(d / 2) * d / .185),
                                    p = l + (!1 === eU.inertia ? 0 : f),
                                    g = eU,
                                    A = g.onStart,
                                    m = g.onInterrupt,
                                    v = g.onComplete;
                                if (eY(i = o(p, tI)) || (i = p), a = Math.max(0, Math.round(c + i * x)), e <= h && e >= c && a !== e) {
                                    if (r && !r._initted && r.data <= eJ(a - e)) return;
                                    !1 === eU.inertia && (f = i - l), s(a, {
                                        duration: $(eJ(.185 * Math.max(eJ(p - u), eJ(i - u)) / d / .05 || 0)),
                                        ease: eU.ease || "power3",
                                        data: eJ(a - e),
                                        onInterrupt: function() {
                                            return en.restart(!0) && m && m(tI)
                                        },
                                        onComplete: function() {
                                            tI.update(), tR = tO(), n && !to && (X ? X.resetTo("totalProgress", i, n._tTime / n._tDur) : n.progress(i)), G = H = n && !to ? n.totalProgress() : tI.progress, eL && eL(tI), v && v(tI)
                                        }
                                    }, e, f * x, a - e - f * x), A && A(tI, s.tween)
                                }
                            } else tI.isActive && tR !== e && en.restart(!0)
                        }).pause()), ef && (tv[ef] = tI), (eu = (em = tI.trigger = L(em || !0 !== ev && ev)) && em._gsap && em._gsap.stRevert) && (eu = eu(tI)), ev = !0 === ev ? em : L(ev), ej(ed) && (ed = {
                            targets: em,
                            className: ed
                        }), ev && (!1 === ey || ey === e8 || (ey = (!!ey || !ev.parentNode || !ev.parentNode.style || "flex" !== te(ev.parentNode).display) && e6), tI.pin = ev, (a = z.core.getCache(ev)).spacer ? E = a.pinState : (eQ && ((eQ = L(eQ)) && !eQ.nodeType && (eQ = eQ.current || eQ.nativeElement), a.spacerIsNative = !!eQ, eQ && (a.spacerState = tj(eQ))), a.spacer = C = eQ || j.createElement("div"), C.classList.add("pin-spacer"), ef && C.classList.add("pin-spacer-" + ef), a.pinState = E = tj(ev)), !1 !== t.force3D && z.set(ev, {
                            force3D: !0
                        }), tI.spacer = C = a.spacer, P = (Q = te(ev))[ey + e0.os2], I = z.getProperty(ev), M = z.quickSetter(ev, e0.a, "px"), tz(ev, C, Q), w = tj(ev)), tw) {
                        A = eX(tw) ? tn(tw, th) : th, p = tg("scroller-start", ef, tc, e0, A, 0), g = tg("scroller-end", ef, tc, e0, A, 0, p), S = p["offset" + e0.op.d2];
                        var tN = L(b(tc, "content") || tc);
                        d = this.markerStart = tg("start", ef, tN, e0, A, S, 0, eV), f = this.markerEnd = tg("end", ef, tN, e0, A, S, 0, eV), eV && (ea = z.quickSetter([d, f], e0.a, "px")), ty || y.length && !0 === b(tc, "fixedMarkers") || (tt(tA ? Y : tc), z.set([p, g], {
                            force3D: !0
                        }), U = z.quickSetter(p, e0.a, "px"), k = z.quickSetter(g, e0.a, "px"))
                    }
                    if (eV) {
                        var tF = eV.vars.onUpdate,
                            tk = eV.vars.onUpdateParams;
                        eV.eventCallback("onUpdate", function() {
                            tI.update(0, 0, 1), tF && tF.apply(eV, tk || [])
                        })
                    }
                    if (tI.previous = function() {
                            return tm[tm.indexOf(tI) - 1]
                        }, tI.next = function() {
                            return tm[tm.indexOf(tI) + 1]
                        }, tI.revert = function(e, t) {
                            if (!t) return tI.kill(!0);
                            var r = !1 !== e || !tI.enabled,
                                i = ee;
                            r !== tI.isReverted && (r && (ei = Math.max(tO(), tI.scroll.rec || 0), tP = tI.progress, es = n && n.progress()), d && [d, f, p, g].forEach(function(e) {
                                return e.style.display = r ? "none" : "block"
                            }), r && (ee = tI, tI.update(r)), !ev || eF && tI.isActive || (r ? tG(ev, C, E) : tz(ev, C, te(ev), N)), r || tI.update(r), ee = i, tI.isReverted = r)
                        }, tI.refresh = function(r, i, a, o) {
                            if (!ee && tI.enabled || i) {
                                if (ev && r && eT) {
                                    tl(e, "scrollEnd", tC);
                                    return
                                }!eb && tM && tM(tI), ee = tI, s.tween && !a && (s.tween.kill(), s.tween = 0), X && X.pause(), e_ && n && (n.revert({
                                    kill: !1
                                }).invalidate(), n.getChildren && n.getChildren(!0, !0, !1).forEach(function(e) {
                                    return e.vars.immediateRender && e.render(0, !0, !0)
                                })), tI.isReverted || tI.revert(!0, !0), tI._subPinOffset = !1;
                                var A, v, y, b, S, M, P, U, k, Q, G, H, V, q = tT(),
                                    K = tB(),
                                    J = eV ? eV.duration() : eH(tc, e0),
                                    Z = x <= .01 || !x,
                                    $ = 0,
                                    et = o || 0,
                                    er = eX(a) ? a.end : t.end,
                                    ea = t.endTrigger || em,
                                    eo = eX(a) ? a.start : t.start || (0 !== t.start && em ? ev ? "0 0" : "0 100%" : 0),
                                    eu = tI.pinnedContainer = t.pinnedContainer && L(t.pinnedContainer, tI),
                                    ec = em && Math.max(0, tm.indexOf(tI)) || 0,
                                    eh = ec;
                                for (tw && eX(a) && (H = z.getProperty(p, e0.p), V = z.getProperty(g, e0.p)); eh-- > 0;)(M = tm[eh]).end || M.refresh(0, 1) || (ee = tI), (P = M.pin) && (P === em || P === ev || P === eu) && !M.isReverted && (Q || (Q = []), Q.unshift(M), M.revert(!0, !0)), M !== tm[eh] && (ec--, eh--);
                                for (eW(eo) && (eo = eo(tI)), c = tX(eo = eR(eo, "start", tI), em, q, e0, tO(), d, p, tI, K, tS, ty, J, eV, tI._startClamp && "_startClamp") || (ev ? -.001 : 0), eW(er) && (er = er(tI)), ej(er) && !er.indexOf("+=") && (~er.indexOf(" ") ? er = (ej(eo) ? eo.split(" ")[0] : "") + er : ($ = tp(er.substr(2), q), er = ej(eo) ? eo : (eV ? z.utils.mapRange(0, eV.duration(), eV.scrollTrigger.start, eV.scrollTrigger.end, c) : c) + $, ea = em)), er = eR(er, "end", tI), h = Math.max(c, tX(er || (ea ? "100% 0" : J), ea, q, e0, tO() + $, f, g, tI, K, tS, ty, J, eV, tI._endClamp && "_endClamp")) || -.001, $ = 0, eh = ec; eh--;)(P = (M = tm[eh]).pin) && M.start - M._pinPush <= c && !eV && M.end > 0 && (A = M.end - (tI._startClamp ? Math.max(0, M.start) : M.start), (P === em && M.start - M._pinPush < c || P === eu) && isNaN(eo) && ($ += A * (1 - M.progress)), P === ev && (et += A));
                                if (c += $, h += $, tI._startClamp && (tI._startClamp += $), tI._endClamp && !eb && (tI._endClamp = h || -.001, h = Math.min(h, eH(tc, e0))), x = h - c || (c -= .01) && .001, Z && (tP = z.utils.clamp(0, 1, z.utils.normalize(c, h, ei))), tI._pinPush = et, d && $ && ((A = {})[e0.a] = "+=" + $, eu && (A[e0.p] = "-=" + tO()), z.set([d, f], A)), ev && !(ex && tI.end >= eH(tc, e0))) A = te(ev), b = e0 === D, y = tO(), T = parseFloat(I(e0.a)) + et, !J && h > 1 && (G = {
                                    style: G = (tA ? j.scrollingElement || W : tc).style,
                                    value: G["overflow" + e0.a.toUpperCase()]
                                }, tA && "scroll" !== te(Y)["overflow" + e0.a.toUpperCase()] && (G.style["overflow" + e0.a.toUpperCase()] = "scroll")), tz(ev, C, A), w = tj(ev), v = tr(ev, !0), U = ty && O(tc, b ? R : D)(), ey ? ((N = [ey + e0.os2, x + et + "px"]).t = C, (eh = ey === e6 ? ti(ev, e0) + x + et : 0) && (N.push(e0.d, eh + "px"), "auto" !== C.style.flexBasis && (C.style.flexBasis = eh + "px")), tV(N), eu && tm.forEach(function(e) {
                                    e.pin === eu && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0)
                                }), ty && tO(ei)) : (eh = ti(ev, e0)) && "auto" !== C.style.flexBasis && (C.style.flexBasis = eh + "px"), ty && ((S = {
                                    top: v.top + (b ? y - c : U) + "px",
                                    left: v.left + (b ? U : y - c) + "px",
                                    boxSizing: "border-box",
                                    position: "fixed"
                                })[e1] = S["max" + e9] = Math.ceil(v.width) + "px", S[e2] = S["max" + e7] = Math.ceil(v.height) + "px", S[e8] = S[e8 + "Top"] = S[e8 + e3] = S[e8 + e5] = S[e8 + e4] = "0", S[e6] = A[e6], S[e6 + "Top"] = A[e6 + "Top"], S[e6 + e3] = A[e6 + e3], S[e6 + e5] = A[e6 + e5], S[e6 + e4] = A[e6 + e4], _ = tW(E, S, eF), eb && tO(0)), n ? (k = n._initted, el(1), n.render(n.duration(), !0, !0), B = I(e0.a) - T + x + et, F = Math.abs(x - B) > 1, ty && F && _.splice(_.length - 2, 2), n.render(0, !0, !0), k || n.invalidate(!0), n.parent || n.totalTime(n.totalTime()), el(0)) : B = x, G && (G.value ? G.style["overflow" + e0.a.toUpperCase()] = G.value : G.style.removeProperty("overflow-" + e0.a));
                                else if (em && tO() && !eV)
                                    for (v = em.parentNode; v && v !== Y;) v._pinOffset && (c -= v._pinOffset, h -= v._pinOffset), v = v.parentNode;
                                Q && Q.forEach(function(e) {
                                    return e.revert(!1, !0)
                                }), tI.start = c, tI.end = h, l = u = eb ? ei : tO(), eV || eb || (l < ei && tO(ei), tI.scroll.rec = 0), tI.revert(!1, !0), tL = eI(), en && (tR = -1, en.restart(!0)), ee = 0, n && to && (n._initted || es) && n.progress() !== es && n.progress(es || 0, !0).render(n.time(), !0, !0), (Z || tP !== tI.progress || eV || e_ || n && !n._initted) && (n && !to && (n._initted || tP || !1 !== n.vars.immediateRender) && n.totalProgress(eV && c < -.001 && !tP ? z.utils.normalize(c, h, 0) : tP, !0), tI.progress = Z || (l - c) / x === tP ? 0 : tP), ev && ey && (C._pinOffset = Math.round(tI.progress * B)), X && X.invalidate(), isNaN(H) || (H -= z.getProperty(p, e0.p), V -= z.getProperty(g, e0.p), tZ(p, e0, H), tZ(d, e0, H - (o || 0)), tZ(g, e0, V), tZ(f, e0, V - (o || 0))), Z && !eb && tI.update(), !eg || eb || m || (m = !0, eg(tI), m = !1)
                            }
                        }, tI.getVelocity = function() {
                            return (tO() - u) / (eI() - Z) * 1e3 || 0
                        }, tI.endAnimation = function() {
                            eq(tI.callbackAnimation), n && (X ? X.progress(1) : n.paused() ? to || eq(n, tI.direction < 0, 1) : eq(n, n.reversed()))
                        }, tI.labelToScroll = function(e) {
                            return n && n.labels && (c || tI.refresh() || c) + n.labels[e] / n.duration() * x || 0
                        }, tI.getTrailing = function(e) {
                            var t = tm.indexOf(tI),
                                n = tI.direction > 0 ? tm.slice(0, t).reverse() : tm.slice(t + 1);
                            return (ej(e) ? n.filter(function(t) {
                                return t.vars.preventOverlaps === e
                            }) : n).filter(function(e) {
                                return tI.direction > 0 ? e.end <= c : e.start >= h
                            })
                        }, tI.update = function(e, t, r) {
                            if (!eV || r || e) {
                                var i, a, o, d, f, g, A, m = !0 === eb ? ei : tI.scroll(),
                                    v = e ? 0 : (m - c) / x,
                                    y = v < 0 ? 0 : v > 1 ? 1 : v || 0,
                                    E = tI.progress;
                                if (t && (u = l, l = eV ? tO() : m, eU && (H = G, G = n && !to ? n.totalProgress() : y)), ew && ev && !ee && !eS && eT && (!y && c < m + (m - u) / (eI() - Z) * ew ? y = 1e-4 : 1 === y && h > m + (m - u) / (eI() - Z) * ew && (y = .9999)), y !== E && tI.enabled) {
                                    if (d = (f = (i = tI.isActive = !!y && y < 1) != (!!E && E < 1)) || !!y != !!E, tI.direction = y > E ? 1 : -1, tI.progress = y, d && !ee && (a = y && !E ? 0 : 1 === y ? 1 : 1 === E ? 2 : 3, to && (o = !f && "none" !== tb[a + 1] && tb[a + 1] || tb[a], A = n && ("complete" === o || "reset" === o || o in n))), e$ && (f || A) && (A || eA || !n) && (eW(e$) ? e$(tI) : tI.getTrailing(e$).forEach(function(e) {
                                            return e.endAnimation()
                                        })), !to && (!X || ee || eS ? n && n.totalProgress(y, !!(ee && (tL || e))) : (X._dp._time - X._start !== X._time && X.render(X._dp._time - X._start), X.resetTo ? X.resetTo("totalProgress", y, n._tTime / n._tDur) : (X.vars.totalProgress = y, X.invalidate().restart()))), ev) {
                                        if (e && ey && (C.style[ey + e0.os2] = P), ty) {
                                            if (d) {
                                                if (g = !e && y > E && h + 1 > m && m + 1 >= eH(tc, e0), eF) {
                                                    if (!e && (i || g)) {
                                                        var b = tr(ev, !0),
                                                            S = m - c;
                                                        tK(ev, Y, b.top + (e0 === D ? S : 0) + "px", b.left + (e0 === D ? 0 : S) + "px")
                                                    } else tK(ev, C)
                                                }
                                                tV(i || g ? _ : w), F && y < 1 && i || M(T + (1 !== y || g ? 0 : B))
                                            }
                                        } else M(eN(T + B * y))
                                    }!eU || s.tween || ee || eS || en.restart(!0), ed && (f || eP && y && (y < 1 || !eE)) && K(ed.targets).forEach(function(e) {
                                        return e.classList[i || eP ? "add" : "remove"](ed.className)
                                    }), !eh || to || e || eh(tI), d && !ee ? (to && (A && ("complete" === o ? n.pause().totalProgress(1) : "reset" === o ? n.restart(!0).pause() : "restart" === o ? n.restart(!0) : n[o]()), eh && eh(tI)), (f || !eE) && (ep && f && eK(tI, ep), tE[a] && eK(tI, tE[a]), eP && (1 === y ? tI.kill(!1, 1) : tE[a] = 0), !f && tE[a = 1 === y ? 1 : 3] && eK(tI, tE[a])), eZ && !i && Math.abs(tI.getVelocity()) > (eY(eZ) ? eZ : 2500) && (eq(tI.callbackAnimation), X ? X.progress(1) : eq(n, "reverse" === o ? 1 : !y, 1))) : to && eh && !ee && eh(tI)
                                }
                                if (k) {
                                    var I = eV ? m / eV.duration() * (eV._caScrollDist || 0) : m;
                                    U(I + (p._isFlipped ? 1 : 0)), k(I)
                                }
                                ea && ea(-m / eV.duration() * (eV._caScrollDist || 0))
                            }
                        }, tI.enable = function(t, n) {
                            tI.enabled || (tI.enabled = !0, tl(tc, "resize", t_), tA || tl(tc, "scroll", tx), tM && tl(e, "refreshInit", tM), !1 !== t && (tI.progress = tP = 0, l = u = tR = tO()), !1 !== n && tI.refresh())
                        }, tI.getTween = function(e) {
                            return e && s ? s.tween : X
                        }, tI.setPositions = function(e, t, n, r) {
                            if (eV) {
                                var i = eV.scrollTrigger,
                                    s = eV.duration(),
                                    a = i.end - i.start;
                                e = i.start + a * e / s, t = i.start + a * t / s
                            }
                            tI.refresh(!1, !1, {
                                start: eD(e, n && !!tI._startClamp),
                                end: eD(t, n && !!tI._endClamp)
                            }, r), tI.update()
                        }, tI.adjustPinSpacing = function(e) {
                            if (N && e) {
                                var t = N.indexOf(e0.d) + 1;
                                N[t] = parseFloat(N[t]) + e + "px", N[1] = parseFloat(N[1]) + e + "px", tV(N)
                            }
                        }, tI.disable = function(t, n) {
                            if (tI.enabled && (!1 !== t && tI.revert(!0, !0), tI.enabled = tI.isActive = !1, n || X && X.pause(), ei = 0, a && (a.uncache = 1), tM && tu(e, "refreshInit", tM), en && (en.pause(), s.tween && s.tween.kill() && (s.tween = 0)), !tA)) {
                                for (var r = tm.length; r--;)
                                    if (tm[r].scroller === tc && tm[r] !== tI) return;
                                tu(tc, "resize", t_), tA || tu(tc, "scroll", tx)
                            }
                        }, tI.kill = function(e, r) {
                            tI.disable(e, r), X && !r && X.kill(), ef && delete tv[ef];
                            var i = tm.indexOf(tI);
                            i >= 0 && tm.splice(i, 1), i === er && tU > 0 && er--, i = 0, tm.forEach(function(e) {
                                return e.scroller === tI.scroller && (i = 1)
                            }), i || eb || (tI.scroll.rec = 0), n && (n.scrollTrigger = null, e && n.revert({
                                kill: !1
                            }), r || n.kill()), d && [d, f, p, g].forEach(function(e) {
                                return e.parentNode && e.parentNode.removeChild(e)
                            }), eC === tI && (eC = 0), ev && (a && (a.uncache = 1), i = 0, tm.forEach(function(e) {
                                return e.pin === ev && i++
                            }), i || (a.spacer = 0)), t.onKill && t.onKill(tI)
                        }, tm.push(tI), tI.enable(!1, !1), eu && eu(tI), n && n.add && !x) {
                        var tQ = tI.update;
                        tI.update = function() {
                            tI.update = tQ, v.cache++, c || h || tI.refresh()
                        }, z.delayedCall(.01, tI.update), x = .01, c = h = 0
                    } else tI.refresh();
                    ev && tD()
                }, e.register = function(t) {
                    return H || (z = t || eF(), eU() && window.document && e.enable(), H = eB), H
                }, e.defaults = function(e) {
                    if (e)
                        for (var t in e) td[t] = e[t];
                    return td
                }, e.disable = function(e, t) {
                    eB = 0, tm.forEach(function(n) {
                        return n[t ? "kill" : "disable"](e)
                    }), tu(V, "wheel", tx), tu(j, "scroll", tx), clearInterval($), tu(j, "touchcancel", eO), tu(Y, "touchstart", eO), to(tu, j, "pointerdown,touchstart,mousedown", eL), to(tu, j, "pointerup,touchend,mouseup", eP), q.kill(), eV(tu);
                    for (var n = 0; n < v.length; n += 3) tc(tu, v[n], v[n + 1]), tc(tu, v[n], v[n + 2])
                }, e.enable = function() {
                    if (V = window, W = (j = document).documentElement, Y = j.body, z && (K = z.utils.toArray, J = z.utils.clamp, eg = z.core.context || eO, el = z.core.suppressOverwrites || eO, eA = V.history.scrollRestoration || "auto", tN = V.pageYOffset || 0, z.core.globals("ScrollTrigger", e), Y)) {
                        eB = 1, (em = document.createElement("div")).style.height = "100vh", em.style.position = "absolute", tL(),
                            function e() {
                                return eB && requestAnimationFrame(e)
                            }(), G.register(z), e.isTouch = G.isTouch, ep = G.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), eh = 1 === G.isTouch, tl(V, "wheel", tx), X = [V, j, W, Y], z.matchMedia ? (e.matchMedia = function(e) {
                                var t, n = z.matchMedia();
                                for (t in e) n.add(t, e[t]);
                                return n
                            }, z.addEventListener("matchMediaInit", function() {
                                return tT()
                            }), z.addEventListener("matchMediaRevert", function() {
                                return tM()
                            }), z.addEventListener("matchMedia", function() {
                                tO(0, 1), tS("matchMedia")
                            }), z.matchMedia().add("(orientation: portrait)", function() {
                                return tE(), tE
                            })) : console.warn("Requires GSAP 3.11.0 or later"), tE(), tl(j, "scroll", tx);
                        var t, n, r = Y.hasAttribute("style"),
                            i = Y.style,
                            s = i.borderTopStyle,
                            a = z.core.Animation.prototype;
                        for (a.revert || Object.defineProperty(a, "revert", {
                                value: function() {
                                    return this.time(-.01, !0)
                                }
                            }), i.borderTopStyle = "solid", t = tr(Y), D.m = Math.round(t.top + D.sc()) || 0, R.m = Math.round(t.left + R.sc()) || 0, s ? i.borderTopStyle = s : i.removeProperty("border-top-style"), r || (Y.setAttribute("style", ""), Y.removeAttribute("style")), $ = setInterval(ty, 250), z.delayedCall(.5, function() {
                                return eS = 0
                            }), tl(j, "touchcancel", eO), tl(Y, "touchstart", eO), to(tl, j, "pointerdown,touchstart,mousedown", eL), to(tl, j, "pointerup,touchend,mouseup", eP), en = z.utils.checkPrefix("transform"), tQ.push(en), H = eI(), q = z.delayedCall(.2, tO).pause(), ea = [j, "visibilitychange", function() {
                                var e = V.innerWidth,
                                    t = V.innerHeight;
                                j.hidden ? (ei = e, es = t) : (ei !== e || es !== t) && t_()
                            }, j, "DOMContentLoaded", tO, V, "load", tO, V, "resize", t_], eV(tl), tm.forEach(function(e) {
                                return e.enable(0, 1)
                            }), n = 0; n < v.length; n += 3) tc(tu, v[n], v[n + 1]), tc(tu, v[n], v[n + 2])
                    }
                }, e.config = function(t) {
                    "limitCallbacks" in t && (eE = !!t.limitCallbacks);
                    var n = t.syncInterval;
                    n && clearInterval($) || ($ = n) && setInterval(ty, n), "ignoreMobileResize" in t && (eh = 1 === e.isTouch && t.ignoreMobileResize), "autoRefreshEvents" in t && (eV(tu) || eV(tl, t.autoRefreshEvents || "none"), eu = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
                }, e.scrollerProxy = function(e, t) {
                    var n = L(e),
                        r = v.indexOf(n),
                        i = ek(n);
                    ~r && v.splice(r, i ? 6 : 2), t && (i ? y.unshift(V, t, Y, t, W, t) : y.unshift(n, t))
                }, e.clearMatchMedia = function(e) {
                    tm.forEach(function(t) {
                        return t._ctx && t._ctx.query === e && t._ctx.kill(!0, !0)
                    })
                }, e.isInViewport = function(e, t, n) {
                    var r = (ej(e) ? L(e) : e).getBoundingClientRect(),
                        i = r[n ? e1 : e2] * t || 0;
                    return n ? r.right - i > 0 && r.left + i < V.innerWidth : r.bottom - i > 0 && r.top + i < V.innerHeight
                }, e.positionInViewport = function(e, t, n) {
                    ej(e) && (e = L(e));
                    var r = e.getBoundingClientRect(),
                        i = r[n ? e1 : e2],
                        s = null == t ? i / 2 : t in tf ? tf[t] * i : ~t.indexOf("%") ? parseFloat(t) * i / 100 : parseFloat(t) || 0;
                    return n ? (r.left + s) / V.innerWidth : (r.top + s) / V.innerHeight
                }, e.killAll = function(e) {
                    if (tm.slice(0).forEach(function(e) {
                            return "ScrollSmoother" !== e.vars.id && e.kill()
                        }), !0 !== e) {
                        var t = tb.killAll || [];
                        tb = {}, t.forEach(function(e) {
                            return e()
                        })
                    }
                }, e
            }()).version = "3.13.0", t0.saveStyles = function(e) {
                return e ? K(e).forEach(function(e) {
                    if (e && e.style) {
                        var t = tI.indexOf(e);
                        t >= 0 && tI.splice(t, 5), tI.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), z.core.getCache(e), eg())
                    }
                }) : tI
            }, t0.revert = function(e, t) {
                return tT(!e, t)
            }, t0.create = function(e, t) {
                return new t0(e, t)
            }, t0.refresh = function(e) {
                return e ? t_(!0) : (H || t0.register()) && tO(!0)
            }, t0.update = function(e) {
                return ++v.cache && tF(!0 === e ? 2 : 0)
            }, t0.clearScrollMemory = tB, t0.maxScroll = function(e, t) {
                return eH(e, t ? R : D)
            }, t0.getScrollFunc = function(e, t) {
                return O(L(e), t ? R : D)
            }, t0.getById = function(e) {
                return tv[e]
            }, t0.getAll = function() {
                return tm.filter(function(e) {
                    return "ScrollSmoother" !== e.vars.id
                })
            }, t0.isScrolling = function() {
                return !!eT
            }, t0.snapDirectional = ta, t0.addEventListener = function(e, t) {
                var n = tb[e] || (tb[e] = []);
                ~n.indexOf(t) || n.push(t)
            }, t0.removeEventListener = function(e, t) {
                var n = tb[e],
                    r = n && n.indexOf(t);
                r >= 0 && n.splice(r, 1)
            }, t0.batch = function(e, t) {
                var n, r = [],
                    i = {},
                    s = t.interval || .016,
                    a = t.batchMax || 1e9,
                    o = function(e, t) {
                        var n = [],
                            r = [],
                            i = z.delayedCall(s, function() {
                                t(n, r), n = [], r = []
                            }).pause();
                        return function(e) {
                            n.length || i.restart(!0), n.push(e.trigger), r.push(e), a <= n.length && i.progress(1)
                        }
                    };
                for (n in t) i[n] = "on" === n.substr(0, 2) && eW(t[n]) && "onRefreshInit" !== n ? o(n, t[n]) : t[n];
                return eW(a) && (a = a(), tl(t0, "refresh", function() {
                    return a = t.batchMax()
                })), K(e).forEach(function(e) {
                    var t = {};
                    for (n in i) t[n] = i[n];
                    t.trigger = e, r.push(t0.create(t))
                }), r
            }, t2 = function(e, t, n, r) {
                return t > r ? e(r) : t < 0 && e(0), n > r ? (r - t) / (n - t) : n < 0 ? t / (t - n) : 1
            }, t3 = function e(t, n) {
                !0 === n ? t.style.removeProperty("touch-action") : t.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (G.isTouch ? " pinch-zoom" : "") : "none", t === W && e(Y, n)
            }, t4 = {
                auto: 1,
                scroll: 1
            }, t5 = function(e) {
                var t, n = e.event,
                    r = e.target,
                    i = e.axis,
                    s = (n.changedTouches ? n.changedTouches[0] : n).target,
                    a = s._gsap || z.core.getCache(s),
                    o = eI();
                if (!a._isScrollT || o - a._isScrollT > 2e3) {
                    for (; s && s !== Y && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(t4[(t = te(s)).overflowY] || t4[t.overflowX]));) s = s.parentNode;
                    a._isScroll = s && s !== r && !ek(s) && (t4[(t = te(s)).overflowY] || t4[t.overflowX]), a._isScrollT = o
                }(a._isScroll || "x" === i) && (n.stopPropagation(), n._gsapAllow = !0)
            }, t6 = function(e, t, n, r) {
                return G.create({
                    target: e,
                    capture: !0,
                    debounce: !1,
                    lockAxis: !0,
                    type: t,
                    onWheel: r = r && t5,
                    onPress: r,
                    onDrag: r,
                    onScroll: r,
                    onEnable: function() {
                        return n && tl(j, G.eventTypes[0], t9, !1, !0)
                    },
                    onDisable: function() {
                        return tu(j, G.eventTypes[0], t9, !0)
                    }
                })
            }, t8 = /(input|label|select|textarea)/i, t9 = function(e) {
                var t = t8.test(e.target.tagName);
                (t || t1) && (e._gsapAllow = !0, t1 = t)
            }, t7 = function(e) {
                eX(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
                var t, n, r, i, s, a, o, l, u = e,
                    c = u.normalizeScrollX,
                    h = u.momentum,
                    d = u.allowNestedScroll,
                    f = u.onRelease,
                    p = L(e.target) || W,
                    g = z.core.globals().ScrollSmoother,
                    A = g && g.get(),
                    m = ep && (e.content && L(e.content) || A && !1 !== e.content && !A.smooth() && A.content()),
                    y = O(p, D),
                    x = O(p, R),
                    E = 1,
                    _ = (G.isTouch && V.visualViewport ? V.visualViewport.scale * V.visualViewport.width : V.outerWidth) / V.innerWidth,
                    b = 0,
                    w = eW(h) ? function() {
                        return h(t)
                    } : function() {
                        return h || 2.8
                    },
                    C = t6(p, e.type, !0, d),
                    S = function() {
                        return i = !1
                    },
                    I = eO,
                    M = eO,
                    T = function() {
                        n = eH(p, D), M = J(ep ? 1 : 0, n), c && (I = J(0, eH(p, R))), r = tR
                    },
                    B = function() {
                        m._gsap.y = eN(parseFloat(m._gsap.y) + y.offset) + "px", m.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(m._gsap.y) + ", 0, 1)", y.offset = y.cacheID = 0
                    },
                    P = function() {
                        if (i) {
                            requestAnimationFrame(S);
                            var e = eN(t.deltaY / 2),
                                n = M(y.v - e);
                            if (m && n !== y.v + y.offset) {
                                y.offset = n - y.v;
                                var r = eN((parseFloat(m && m._gsap.y) || 0) - y.offset);
                                m.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + r + ", 0, 1)", m._gsap.y = r + "px", y.cacheID = v.cache, tF()
                            }
                            return !0
                        }
                        y.offset && B(), i = !0
                    },
                    N = function() {
                        T(), s.isActive() && s.vars.scrollY > n && (y() > n ? s.progress(1) && y(n) : s.resetTo("scrollY", n))
                    };
                return m && z.set(m, {
                    y: "+=0"
                }), e.ignoreCheck = function(e) {
                    return ep && "touchmove" === e.type && P() || E > 1.05 && "touchstart" !== e.type || t.isGesturing || e.touches && e.touches.length > 1
                }, e.onPress = function() {
                    i = !1;
                    var e = E;
                    E = eN((V.visualViewport && V.visualViewport.scale || 1) / _), s.pause(), e !== E && t3(p, E > 1.01 || !c && "x"), a = x(), o = y(), T(), r = tR
                }, e.onRelease = e.onGestureStart = function(e, t) {
                    if (y.offset && B(), t) {
                        v.cache++;
                        var r, i, a = w();
                        c && (i = (r = x()) + -(.05 * a * e.velocityX) / .227, a *= t2(x, r, i, eH(p, R)), s.vars.scrollX = I(i)), i = (r = y()) + -(.05 * a * e.velocityY) / .227, a *= t2(y, r, i, eH(p, D)), s.vars.scrollY = M(i), s.invalidate().duration(a).play(.01), (ep && s.vars.scrollY >= n || r >= n - 1) && z.to({}, {
                            onUpdate: N,
                            duration: a
                        })
                    } else l.restart(!0);
                    f && f(e)
                }, e.onWheel = function() {
                    s._ts && s.pause(), eI() - b > 1e3 && (r = 0, b = eI())
                }, e.onChange = function(e, t, n, i, s) {
                    if (tR !== r && T(), t && c && x(I(i[2] === t ? a + (e.startX - e.x) : x() + t - i[1])), n) {
                        y.offset && B();
                        var l = s[2] === n,
                            u = l ? o + e.startY - e.y : y() + n - s[1],
                            h = M(u);
                        l && u !== h && (o += h - u), y(h)
                    }(n || t) && tF()
                }, e.onEnable = function() {
                    t3(p, !c && "x"), t0.addEventListener("refresh", N), tl(V, "resize", N), y.smooth && (y.target.style.scrollBehavior = "auto", y.smooth = x.smooth = !1), C.enable()
                }, e.onDisable = function() {
                    t3(p, !0), tu(V, "resize", N), t0.removeEventListener("refresh", N), C.kill()
                }, e.lockAxis = !1 !== e.lockAxis, (t = new G(e)).iOS = ep, ep && !y() && y(1), ep && z.ticker.add(eO), l = t._dc, s = z.to(t, {
                    ease: "power4",
                    paused: !0,
                    inherit: !1,
                    scrollX: c ? "+=0.1" : "+=0",
                    scrollY: "+=0.1",
                    modifiers: {
                        scrollY: tJ(y, y(), function() {
                            return s.pause()
                        })
                    },
                    onUpdate: tF,
                    onComplete: l.vars.onComplete
                }), t
            }, t0.sort = function(e) {
                if (eW(e)) return tm.sort(e);
                var t = V.pageYOffset || 0;
                return t0.getAll().forEach(function(e) {
                    return e._sortY = e.trigger ? t + e.trigger.getBoundingClientRect().top : e.start + V.innerHeight
                }), tm.sort(e || function(e, t) {
                    return -1e6 * (e.vars.refreshPriority || 0) + (e.vars.containerAnimation ? 1e6 : e._sortY) - ((t.vars.containerAnimation ? 1e6 : t._sortY) + -1e6 * (t.vars.refreshPriority || 0))
                })
            }, t0.observe = function(e) {
                return new G(e)
            }, t0.normalizeScroll = function(e) {
                if (void 0 === e) return ec;
                if (!0 === e && ec) return ec.enable();
                if (!1 === e) {
                    ec && ec.kill(), ec = e;
                    return
                }
                var t = e instanceof G ? e : t7(e);
                return ec && ec.target === t.target && ec.kill(), ek(t.target) && (ec = t), t
            }, t0.core = {
                _getVelocityProp: N,
                _inputObserver: t6,
                _scrollers: v,
                _proxies: y,
                bridge: {
                    ss: function() {
                        eT || tS("scrollStart"), eT = eI()
                    },
                    ref: function() {
                        return ee
                    }
                }
            }, eF() && z.registerPlugin(t0), t.ScrollTrigger = t0, t.default = t0, "undefined" == typeof window || window !== t ? Object.defineProperty(t, "__esModule", {
                value: !0
            }) : delete window.default
        },
        630: function(e, t) {
            ! function(e) {
                "use strict";
                let t, n, r, i = () => r || x.register(window.gsap),
                    s = "undefined" != typeof Intl ? new Intl.Segmenter : 0,
                    a = e => "string" == typeof e ? a(document.querySelectorAll(e)) : "length" in e ? Array.from(e) : [e],
                    o = e => a(e).filter(e => e instanceof HTMLElement),
                    l = [],
                    u = function() {},
                    c = /\s+/g,
                    h = RegExp("\\p{RI}\\p{RI}|\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?(\\u{200D}\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?)*|.", "gu"),
                    d = {
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0
                    },
                    f = (e, t) => {
                        if (t) {
                            let n = new Set(e.join("").match(t) || l),
                                r = e.length,
                                i, s, a, o;
                            if (n.size) {
                                for (; --r > -1;)
                                    for (a of (s = e[r], n))
                                        if (a.startsWith(s) && a.length > s.length) {
                                            for (i = 0, o = s; a.startsWith(o += e[r + ++i]) && o.length < a.length;);
                                            if (i && o.length === a.length) {
                                                e[r] = a, e.splice(r + 1, i);
                                                break
                                            }
                                        }
                            }
                        }
                        return e
                    },
                    p = e => "inline" === window.getComputedStyle(e).display && (e.style.display = "inline-block"),
                    g = (e, t, n) => t.insertBefore("string" == typeof e ? document.createTextNode(e) : e, n),
                    A = (e, t, n) => {
                        let r = t[e + "sClass"] || "",
                            {
                                tag: i = "div",
                                aria: s = "auto",
                                propIndex: a = !1
                            } = t,
                            o = "line" === e ? "block" : "inline-block",
                            l = r.indexOf("++") > -1,
                            u = t => {
                                let u = document.createElement(i),
                                    c = n.length + 1;
                                return r && (u.className = r + (l ? " " + r + c : "")), a && u.style.setProperty("--" + e, c + ""), "none" !== s && u.setAttribute("aria-hidden", "true"), "span" !== i && (u.style.position = "relative", u.style.display = o), u.textContent = t, n.push(u), u
                            };
                        return l && (r = r.replace("++", "")), u.collection = n, u
                    },
                    m = (e, t, n, r) => {
                        let i = A("line", n, r),
                            s = window.getComputedStyle(e).textAlign || "left";
                        return (n, r) => {
                            let a = i("");
                            for (a.style.textAlign = s, e.insertBefore(a, t[n]); n < r; n++) a.appendChild(t[n]);
                            a.normalize()
                        }
                    },
                    v = (e, t, n, r, i, a, o, u, h, d) => {
                        var A;
                        let m = Array.from(e.childNodes),
                            y = 0,
                            {
                                wordDelimiter: x,
                                reduceWhiteSpace: E = !0,
                                prepareText: _
                            } = t,
                            b = e.getBoundingClientRect(),
                            w = b,
                            C = !E && "pre" === window.getComputedStyle(e).whiteSpace.substring(0, 3),
                            S = 0,
                            I = n.collection,
                            M, T, B, R, D, L, P, O, N, U, F, k, Q, G, z, H, V, j;
                        for ("object" == typeof x ? (B = x.delimiter || x, T = x.replaceWith || "") : T = "" === x ? "" : x || " ", M = " " !== T; y < m.length; y++)
                            if (3 === (R = m[y]).nodeType) {
                                for (z = R.textContent || "", E ? z = z.replace(c, " ") : C && (z = z.replace(/\n/g, T + "\n")), _ && (z = _(z, e)), R.textContent = z, V = (D = T || B ? z.split(B || T) : z.match(u) || l)[D.length - 1], O = M ? " " === V.slice(-1) : !V, V || D.pop(), w = b, (P = M ? " " === D[0].charAt(0) : !D[0]) && g(" ", e, R), D[0] || D.shift(), f(D, h), a && d || (R.textContent = ""), N = 1; N <= D.length; N++)
                                    if (H = D[N - 1], !E && C && "\n" === H.charAt(0) && (null == (A = R.previousSibling) || A.remove(), g(document.createElement("br"), e, R), H = H.slice(1)), E || "" !== H) {
                                        if (" " === H) e.insertBefore(document.createTextNode(" "), R);
                                        else {
                                            if (M && " " === H.charAt(0) && g(" ", e, R), S && 1 === N && !P && I.indexOf(S.parentNode) > -1 ? (L = I[I.length - 1]).appendChild(document.createTextNode(r ? "" : H)) : (g(L = n(r ? "" : H), e, R), S && 1 === N && !P && L.insertBefore(S, L.firstChild)), r)
                                                for (j = 0, F = s ? f([...s.segment(H)].map(e => e.segment), h) : H.match(u) || l; j < F.length; j++) L.appendChild(" " === F[j] ? document.createTextNode(" ") : r(F[j]));
                                            if (a && d) {
                                                if (z = R.textContent = z.substring(H.length + 1, z.length), (U = L.getBoundingClientRect()).top > w.top && U.left <= w.left) {
                                                    for (k = e.cloneNode(), Q = e.childNodes[0]; Q && Q !== L;) G = Q, Q = Q.nextSibling, k.appendChild(G);
                                                    e.parentNode.insertBefore(k, e), i && p(k)
                                                }
                                                w = U
                                            }(N < D.length || O) && g(N >= D.length ? " " : M && " " === H.slice(-1) ? " " + T : T, e, R)
                                        }
                                    } else g(T, e, R);
                                e.removeChild(R), S = 0
                            } else 1 === R.nodeType && (o && o.indexOf(R) > -1 ? (I.indexOf(R.previousSibling) > -1 && I[I.length - 1].appendChild(R), S = R) : (v(R, t, n, r, i, a, o, u, h, !0), S = 0), i && p(R))
                    },
                    y = class e {
                        constructor(e, t) {
                            this.isSplit = !1, i(), this.elements = o(e), this.chars = [], this.words = [], this.lines = [], this.masks = [], this.vars = t, this._split = () => this.isSplit && this.split(this.vars);
                            let n = [],
                                r, s = () => {
                                    let e = n.length,
                                        t;
                                    for (; e--;) {
                                        let r = (t = n[e]).element.offsetWidth;
                                        if (r !== t.width) {
                                            t.width = r, this._split();
                                            return
                                        }
                                    }
                                };
                            this._data = {
                                orig: n,
                                obs: "undefined" != typeof ResizeObserver && new ResizeObserver(() => {
                                    clearTimeout(r), r = setTimeout(s, 200)
                                })
                            }, u(this), this.split(t)
                        }
                        split(e) {
                            this.isSplit && this.revert(), this.vars = e = e || this.vars || {};
                            let {
                                type: t = "chars,words,lines",
                                aria: r = "auto",
                                deepSlice: i = !0,
                                smartWrap: s,
                                onSplit: l,
                                autoSplit: u = !1,
                                specialChars: c,
                                mask: f
                            } = this.vars, p = t.indexOf("lines") > -1, g = t.indexOf("chars") > -1, y = t.indexOf("words") > -1, x = g && !y && !p, E = c && ("push" in c ? RegExp("(?:" + c.join("|") + ")", "gu") : c), _ = E ? RegExp(E.source + "|" + h.source, "gu") : h, b = !!e.ignore && o(e.ignore), {
                                orig: w,
                                animTime: C,
                                obs: S
                            } = this._data, I;
                            return (g || y || p) && (this.elements.forEach((t, n) => {
                                w[n] = {
                                    element: t,
                                    html: t.innerHTML,
                                    ariaL: t.getAttribute("aria-label"),
                                    ariaH: t.getAttribute("aria-hidden")
                                }, "auto" === r ? t.setAttribute("aria-label", (t.textContent || "").trim()) : "hidden" === r && t.setAttribute("aria-hidden", "true");
                                let o = [],
                                    l = [],
                                    u = [],
                                    c = g ? A("char", e, o) : null,
                                    h = A("word", e, l),
                                    f, C, S, I;
                                if (v(t, e, h, c, x, i && (p || x), b, _, E, !1), p) {
                                    let n = a(t.childNodes),
                                        r = m(t, n, e, u),
                                        i, s = [],
                                        o = 0,
                                        l = n.map(e => 1 === e.nodeType ? e.getBoundingClientRect() : d),
                                        c = d;
                                    for (f = 0; f < n.length; f++) 1 === (i = n[f]).nodeType && ("BR" === i.nodeName ? (s.push(i), r(o, f + 1), c = l[o = f + 1]) : (f && l[f].top > c.top && l[f].left <= c.left && (r(o, f), o = f), c = l[f]));
                                    o < f && r(o, f), s.forEach(e => {
                                        var t;
                                        return null == (t = e.parentNode) ? void 0 : t.removeChild(e)
                                    })
                                }
                                if (!y) {
                                    for (f = 0; f < l.length; f++)
                                        if (C = l[f], g || !C.nextSibling || 3 !== C.nextSibling.nodeType) {
                                            if (s && !p) {
                                                for ((S = document.createElement("span")).style.whiteSpace = "nowrap"; C.firstChild;) S.appendChild(C.firstChild);
                                                C.replaceWith(S)
                                            } else C.replaceWith(...C.childNodes)
                                        } else(I = C.nextSibling) && 3 === I.nodeType && (I.textContent = (C.textContent || "") + (I.textContent || ""), C.remove());
                                    l.length = 0, t.normalize()
                                }
                                this.lines.push(...u), this.words.push(...l), this.chars.push(...o)
                            }), f && this[f] && this.masks.push(...this[f].map(e => {
                                let t = e.cloneNode();
                                return e.replaceWith(t), t.appendChild(e), e.className && (t.className = e.className.replace(/(\b\w+\b)/g, "$1-mask")), t.style.overflow = "clip", t
                            }))), this.isSplit = !0, n && (u ? n.addEventListener("loadingdone", this._split) : "loading" === n.status && console.warn("SplitText called before fonts loaded")), (I = l && l(this)) && I.totalTime && (this._data.anim = C ? I.totalTime(C) : I), p && u && this.elements.forEach((e, t) => {
                                w[t].width = e.offsetWidth, S && S.observe(e)
                            }), this
                        }
                        revert() {
                            var e, t;
                            let {
                                orig: r,
                                anim: i,
                                obs: s
                            } = this._data;
                            return s && s.disconnect(), r.forEach(({
                                element: e,
                                html: t,
                                ariaL: n,
                                ariaH: r
                            }) => {
                                e.innerHTML = t, n ? e.setAttribute("aria-label", n) : e.removeAttribute("aria-label"), r ? e.setAttribute("aria-hidden", r) : e.removeAttribute("aria-hidden")
                            }), this.chars.length = this.words.length = this.lines.length = r.length = this.masks.length = 0, this.isSplit = !1, null == n || n.removeEventListener("loadingdone", this._split), i && (this._data.animTime = i.totalTime(), i.revert()), null == (t = (e = this.vars).onRevert) || t.call(e, this), this
                        }
                        static create(t, n) {
                            return new e(t, n)
                        }
                        static register(e) {
                            (t = t || e || window.gsap) && (a = t.utils.toArray, u = t.core.context || u), !r && window.innerWidth > 0 && (n = document.fonts, r = !0)
                        }
                    };
                y.version = "3.13.0";
                let x = y;
                e.SplitText = x, e.default = x, Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }(t)
        },
        4970: function(e, t, n) {
            "use strict";

            function r(e) {
                if (void 0 === e) throw ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function i(e, t) {
                e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
            }
            n.d(t, {
                ZP: function() {
                    return rU
                },
                p8: function() {
                    return rU
                }
            });
            var s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x, E, _, b, w, C, S, I, M, T, B, R, D, L, P, O = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                N = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                U = 2 * Math.PI,
                F = U / 4,
                k = 0,
                Q = Math.sqrt,
                G = Math.cos,
                z = Math.sin,
                H = function(e) {
                    return "string" == typeof e
                },
                V = function(e) {
                    return "function" == typeof e
                },
                j = function(e) {
                    return "number" == typeof e
                },
                W = function(e) {
                    return void 0 === e
                },
                Y = function(e) {
                    return "object" == typeof e
                },
                X = function(e) {
                    return !1 !== e
                },
                q = function() {
                    return "undefined" != typeof window
                },
                K = function(e) {
                    return V(e) || H(e)
                },
                J = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
                Z = Array.isArray,
                $ = /(?:-?\.?\d|\.)+/gi,
                ee = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                et = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                en = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                er = /[+-]=-?[.\d]+/,
                ei = /[^,'"\[\]\s]+/gi,
                es = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                ea = {},
                eo = {},
                el = function(e) {
                    return (eo = eF(e, ea)) && nB
                },
                eu = function(e, t) {
                    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
                },
                ec = function(e, t) {
                    return !t && console.warn(e)
                },
                eh = function(e, t) {
                    return e && (ea[e] = t) && eo && (eo[e] = t) || ea
                },
                ed = function() {
                    return 0
                },
                ef = {
                    suppressEvents: !0,
                    isStart: !0,
                    kill: !1
                },
                ep = {
                    suppressEvents: !0,
                    kill: !1
                },
                eg = {
                    suppressEvents: !0
                },
                eA = {},
                em = [],
                ev = {},
                ey = {},
                ex = {},
                eE = 30,
                e_ = [],
                eb = "",
                ew = function(e) {
                    var t, n, r = e[0];
                    if (Y(r) || V(r) || (e = [e]), !(t = (r._gsap || {}).harness)) {
                        for (n = e_.length; n-- && !e_[n].targetTest(r););
                        t = e_[n]
                    }
                    for (n = e.length; n--;) e[n] && (e[n]._gsap || (e[n]._gsap = new tW(e[n], t))) || e.splice(n, 1);
                    return e
                },
                eC = function(e) {
                    return e._gsap || ew(tl(e))[0]._gsap
                },
                eS = function(e, t, n) {
                    return (n = e[t]) && V(n) ? e[t]() : W(n) && e.getAttribute && e.getAttribute(t) || n
                },
                eI = function(e, t) {
                    return (e = e.split(",")).forEach(t) || e
                },
                eM = function(e) {
                    return Math.round(1e5 * e) / 1e5 || 0
                },
                eT = function(e) {
                    return Math.round(1e7 * e) / 1e7 || 0
                },
                eB = function(e, t) {
                    var n = t.charAt(0),
                        r = parseFloat(t.substr(2));
                    return e = parseFloat(e), "+" === n ? e + r : "-" === n ? e - r : "*" === n ? e * r : e / r
                },
                eR = function(e, t) {
                    for (var n = t.length, r = 0; 0 > e.indexOf(t[r]) && ++r < n;);
                    return r < n
                },
                eD = function() {
                    var e, t, n = em.length,
                        r = em.slice(0);
                    for (e = 0, ev = {}, em.length = 0; e < n; e++)(t = r[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
                },
                eL = function(e) {
                    return !!(e._initted || e._startAt || e.add)
                },
                eP = function(e, t, n, r) {
                    em.length && !C && eD(), e.render(t, n, r || !!(C && t < 0 && eL(e))), em.length && !C && eD()
                },
                eO = function(e) {
                    var t = parseFloat(e);
                    return (t || 0 === t) && (e + "").match(ei).length < 2 ? t : H(e) ? e.trim() : e
                },
                eN = function(e) {
                    return e
                },
                eU = function(e, t) {
                    for (var n in t) n in e || (e[n] = t[n]);
                    return e
                },
                eF = function(e, t) {
                    for (var n in t) e[n] = t[n];
                    return e
                },
                ek = function e(t, n) {
                    for (var r in n) "__proto__" !== r && "constructor" !== r && "prototype" !== r && (t[r] = Y(n[r]) ? e(t[r] || (t[r] = {}), n[r]) : n[r]);
                    return t
                },
                eQ = function(e, t) {
                    var n, r = {};
                    for (n in e) n in t || (r[n] = e[n]);
                    return r
                },
                eG = function(e) {
                    var t, n = e.parent || I,
                        r = e.keyframes ? (t = Z(e.keyframes), function(e, n) {
                            for (var r in n) r in e || "duration" === r && t || "ease" === r || (e[r] = n[r])
                        }) : eU;
                    if (X(e.inherit))
                        for (; n;) r(e, n.vars.defaults), n = n.parent || n._dp;
                    return e
                },
                ez = function(e, t) {
                    for (var n = e.length, r = n === t.length; r && n-- && e[n] === t[n];);
                    return n < 0
                },
                eH = function(e, t, n, r, i) {
                    void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                    var s, a = e[r];
                    if (i)
                        for (s = t[i]; a && a[i] > s;) a = a._prev;
                    return a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = a, t.parent = t._dp = e, t
                },
                eV = function(e, t, n, r) {
                    void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                    var i = t._prev,
                        s = t._next;
                    i ? i._next = s : e[n] === t && (e[n] = s), s ? s._prev = i : e[r] === t && (e[r] = i), t._next = t._prev = t.parent = null
                },
                ej = function(e, t) {
                    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
                },
                eW = function(e, t) {
                    if (e && (!t || t._end > e._dur || t._start < 0))
                        for (var n = e; n;) n._dirty = 1, n = n.parent;
                    return e
                },
                eY = function(e) {
                    for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                    return e
                },
                eX = function(e, t, n, r) {
                    return e._startAt && (C ? e._startAt.revert(ep) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r))
                },
                eq = function(e) {
                    return e._repeat ? eK(e._tTime, e = e.duration() + e._rDelay) * e : 0
                },
                eK = function(e, t) {
                    var n = Math.floor(e = eT(e / t));
                    return e && n === e ? n - 1 : n
                },
                eJ = function(e, t) {
                    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
                },
                eZ = function(e) {
                    return e._end = eT(e._start + (e._tDur / Math.abs(e._ts || e._rts || 1e-8) || 0))
                },
                e$ = function(e, t) {
                    var n = e._dp;
                    return n && n.smoothChildTiming && e._ts && (e._start = eT(n._time - (e._ts > 0 ? t / e._ts : -(((e._dirty ? e.totalDuration() : e._tDur) - t) / e._ts))), eZ(e), n._dirty || eW(n, e)), e
                },
                e0 = function(e, t) {
                    var n;
                    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = eJ(e.rawTime(), t), (!t._dur || ti(0, t.totalDuration(), n) - t._tTime > 1e-8) && t.render(n, !0)), eW(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                        if (e._dur < e.duration())
                            for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                        e._zTime = -.00000001
                    }
                },
                e1 = function(e, t, n, r) {
                    return t.parent && ej(t), t._start = eT((j(n) ? n : n || e !== I ? tt(e, n, t) : e._time) + t._delay), t._end = eT(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), eH(e, t, "_first", "_last", e._sort ? "_start" : 0), e5(t) || (e._recent = t), r || e0(e, t), e._ts < 0 && e$(e, e._tTime), e
                },
                e2 = function(e, t) {
                    return (ea.ScrollTrigger || eu("scrollTrigger", t)) && ea.ScrollTrigger.create(t, e)
                },
                e3 = function(e, t, n, r, i) {
                    return (t5(e, t, i), e._initted) ? !n && e._pt && !C && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && D !== tR.frame ? (em.push(e), e._lazy = [i, r], 1) : void 0 : 1
                },
                e4 = function e(t) {
                    var n = t.parent;
                    return n && n._ts && n._initted && !n._lock && (0 > n.rawTime() || e(n))
                },
                e5 = function(e) {
                    var t = e.data;
                    return "isFromStart" === t || "isStart" === t
                },
                e6 = function(e, t, n, r) {
                    var i, s, a, o = e.ratio,
                        l = t < 0 || !t && (!e._start && e4(e) && !(!e._initted && e5(e)) || (e._ts < 0 || e._dp._ts < 0) && !e5(e)) ? 0 : 1,
                        u = e._rDelay,
                        c = 0;
                    if (u && e._repeat && (s = eK(c = ti(0, e._tDur, t), u), e._yoyo && 1 & s && (l = 1 - l), s !== eK(e._tTime, u) && (o = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== o || C || r || 1e-8 === e._zTime || !t && e._zTime) {
                        if (!e._initted && e3(e, t, r, n, c)) return;
                        for (a = e._zTime, e._zTime = t || (n ? 1e-8 : 0), n || (n = t && !a), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = c, i = e._pt; i;) i.r(l, i.d), i = i._next;
                        t < 0 && eX(e, t, n, !0), e._onUpdate && !n && ty(e, "onUpdate"), c && e._repeat && !n && e.parent && ty(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && ej(e, 1), n || C || (ty(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                    } else e._zTime || (e._zTime = t)
                },
                e8 = function(e, t, n) {
                    var r;
                    if (n > t)
                        for (r = e._first; r && r._start <= n;) {
                            if ("isPause" === r.data && r._start > t) return r;
                            r = r._next
                        } else
                            for (r = e._last; r && r._start >= n;) {
                                if ("isPause" === r.data && r._start < t) return r;
                                r = r._prev
                            }
                },
                e9 = function(e, t, n, r) {
                    var i = e._repeat,
                        s = eT(t) || 0,
                        a = e._tTime / e._tDur;
                    return a && !r && (e._time *= s / e._dur), e._dur = s, e._tDur = i ? i < 0 ? 1e10 : eT(s * (i + 1) + e._rDelay * i) : s, a > 0 && !r && e$(e, e._tTime = e._tDur * a), e.parent && eZ(e), n || eW(e.parent, e), e
                },
                e7 = function(e) {
                    return e instanceof tX ? eW(e) : e9(e, e._dur)
                },
                te = {
                    _start: 0,
                    endTime: ed,
                    totalDuration: ed
                },
                tt = function e(t, n, r) {
                    var i, s, a, o = t.labels,
                        l = t._recent || te,
                        u = t.duration() >= 1e8 ? l.endTime(!1) : t._dur;
                    return H(n) && (isNaN(n) || n in o) ? (s = n.charAt(0), a = "%" === n.substr(-1), i = n.indexOf("="), "<" === s || ">" === s) ? (i >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (a ? (i < 0 ? l : r).totalDuration() / 100 : 1)) : i < 0 ? (n in o || (o[n] = u), o[n]) : (s = parseFloat(n.charAt(i - 1) + n.substr(i + 1)), a && r && (s = s / 100 * (Z(r) ? r[0] : r).totalDuration()), i > 1 ? e(t, n.substr(0, i - 1), r) + s : u + s) : null == n ? u : +n
                },
                tn = function(e, t, n) {
                    var r, i, s = j(t[1]),
                        a = (s ? 2 : 1) + (e < 2 ? 0 : 1),
                        o = t[a];
                    if (s && (o.duration = t[1]), o.parent = n, e) {
                        for (r = o, i = n; i && !("immediateRender" in r);) r = i.vars.defaults || {}, i = X(i.vars.inherit) && i.parent;
                        o.immediateRender = X(r.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1]
                    }
                    return new nn(t[0], o, t[a + 1])
                },
                tr = function(e, t) {
                    return e || 0 === e ? t(e) : t
                },
                ti = function(e, t, n) {
                    return n < e ? e : n > t ? t : n
                },
                ts = function(e, t) {
                    return H(e) && (t = es.exec(e)) ? t[1] : ""
                },
                ta = [].slice,
                to = function(e, t) {
                    return e && Y(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Y(e[0])) && !e.nodeType && e !== M
                },
                tl = function(e, t, n) {
                    var r;
                    return S && !t && S.selector ? S.selector(e) : H(e) && !n && (T || !tD()) ? ta.call((t || B).querySelectorAll(e), 0) : Z(e) ? (void 0 === r && (r = []), e.forEach(function(e) {
                        var t;
                        return H(e) && !n || to(e, 1) ? (t = r).push.apply(t, tl(e)) : r.push(e)
                    }) || r) : to(e) ? ta.call(e, 0) : e ? [e] : []
                },
                tu = function(e) {
                    return e = tl(e)[0] || ec("Invalid scope") || {},
                        function(t) {
                            var n = e.current || e.nativeElement || e;
                            return tl(t, n.querySelectorAll ? n : n === e ? ec("Invalid scope") || B.createElement("div") : e)
                        }
                },
                tc = function(e) {
                    return e.sort(function() {
                        return .5 - Math.random()
                    })
                },
                th = function(e) {
                    if (V(e)) return e;
                    var t = Y(e) ? e : {
                            each: e
                        },
                        n = tG(t.ease),
                        r = t.from || 0,
                        i = parseFloat(t.base) || 0,
                        s = {},
                        a = r > 0 && r < 1,
                        o = isNaN(r) || a,
                        l = t.axis,
                        u = r,
                        c = r;
                    return H(r) ? u = c = ({
                            center: .5,
                            edges: .5,
                            end: 1
                        })[r] || 0 : !a && o && (u = r[0], c = r[1]),
                        function(e, a, h) {
                            var d, f, p, g, A, m, v, y, x, E = (h || t).length,
                                _ = s[E];
                            if (!_) {
                                if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, 1e8])[1])) {
                                    for (v = -1e8; v < (v = h[x++].getBoundingClientRect().left) && x < E;);
                                    x < E && x--
                                }
                                for (m = 0, _ = s[E] = [], d = o ? Math.min(x, E) * u - .5 : r % x, f = 1e8 === x ? 0 : o ? E * c / x - .5 : r / x | 0, v = 0, y = 1e8; m < E; m++) p = m % x - d, g = f - (m / x | 0), _[m] = A = l ? Math.abs("y" === l ? g : p) : Q(p * p + g * g), A > v && (v = A), A < y && (y = A);
                                "random" === r && tc(_), _.max = v - y, _.min = y, _.v = E = (parseFloat(t.amount) || parseFloat(t.each) * (x > E ? E - 1 : l ? "y" === l ? E / x : x : Math.max(x, E / x)) || 0) * ("edges" === r ? -1 : 1), _.b = E < 0 ? i - E : i, _.u = ts(t.amount || t.each) || 0, n = n && E < 0 ? tk(n) : n
                            }
                            return E = (_[e] - _.min) / _.max || 0, eT(_.b + (n ? n(E) : E) * _.v) + _.u
                        }
                },
                td = function(e) {
                    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
                    return function(n) {
                        var r = eT(Math.round(parseFloat(n) / e) * e * t);
                        return (r - r % 1) / t + (j(n) ? 0 : ts(n))
                    }
                },
                tf = function(e, t) {
                    var n, r, i = Z(e);
                    return !i && Y(e) && (n = i = e.radius || 1e8, e.values ? (r = !j((e = tl(e.values))[0])) && (n *= n) : e = td(e.increment)), tr(t, i ? V(e) ? function(t) {
                        return Math.abs((r = e(t)) - t) <= n ? r : t
                    } : function(t) {
                        for (var i, s, a = parseFloat(r ? t.x : t), o = parseFloat(r ? t.y : 0), l = 1e8, u = 0, c = e.length; c--;)(i = r ? (i = e[c].x - a) * i + (s = e[c].y - o) * s : Math.abs(e[c] - a)) < l && (l = i, u = c);
                        return u = !n || l <= n ? e[u] : t, r || u === t || j(t) ? u : u + ts(t)
                    } : td(e))
                },
                tp = function(e, t, n, r) {
                    return tr(Z(e) ? !t : !0 === n ? (n = 0, !1) : !r, function() {
                        return Z(e) ? e[~~(Math.random() * e.length)] : (r = (n = n || 1e-5) < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * r) / r
                    })
                },
                tg = function(e, t, n) {
                    return tr(n, function(n) {
                        return e[~~t(n)]
                    })
                },
                tA = function(e) {
                    for (var t, n, r, i, s = 0, a = ""; ~(t = e.indexOf("random(", s));) r = e.indexOf(")", t), i = "[" === e.charAt(t + 7), n = e.substr(t + 7, r - t - 7).match(i ? ei : $), a += e.substr(s, t - s) + tp(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5), s = r + 1;
                    return a + e.substr(s, e.length - s)
                },
                tm = function(e, t, n, r, i) {
                    var s = t - e,
                        a = r - n;
                    return tr(i, function(t) {
                        return n + ((t - e) / s * a || 0)
                    })
                },
                tv = function(e, t, n) {
                    var r, i, s, a = e.labels,
                        o = 1e8;
                    for (r in a)(i = a[r] - t) < 0 == !!n && i && o > (i = Math.abs(i)) && (s = r, o = i);
                    return s
                },
                ty = function(e, t, n) {
                    var r, i, s, a = e.vars,
                        o = a[t],
                        l = S,
                        u = e._ctx;
                    if (o) return r = a[t + "Params"], i = a.callbackScope || e, n && em.length && eD(), u && (S = u), s = r ? o.apply(i, r) : o.call(i), S = l, s
                },
                tx = function(e) {
                    return ej(e), e.scrollTrigger && e.scrollTrigger.kill(!!C), 1 > e.progress() && ty(e, "onInterrupt"), e
                },
                tE = [],
                t_ = function(e) {
                    if (e) {
                        if (e = !e.name && e.default || e, q() || e.headless) {
                            var t = e.name,
                                n = V(e),
                                r = t && !n && e.init ? function() {
                                    this._props = []
                                } : e,
                                i = {
                                    init: ed,
                                    render: nh,
                                    add: t2,
                                    kill: nf,
                                    modifier: nd,
                                    rawVars: 0
                                },
                                s = {
                                    targetTest: 0,
                                    get: 0,
                                    getSetter: no,
                                    aliases: {},
                                    register: 0
                                };
                            if (tD(), e !== r) {
                                if (ey[t]) return;
                                eU(r, eU(eQ(e, i), s)), eF(r.prototype, eF(i, eQ(e, s))), ey[r.prop = t] = r, e.targetTest && (e_.push(r), eA[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                            }
                            eh(t, r), e.register && e.register(nB, r, nA)
                        } else tE.push(e)
                    }
                },
                tb = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                },
                tw = function(e, t, n) {
                    return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * 255 + .5 | 0
                },
                tC = function(e, t, n) {
                    var r, i, s, a, o, l, u, c, h, d, f = e ? j(e) ? [e >> 16, e >> 8 & 255, 255 & e] : 0 : tb.black;
                    if (!f) {
                        if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), tb[e]) f = tb[e];
                        else if ("#" === e.charAt(0)) {
                            if (e.length < 6 && (e = "#" + (r = e.charAt(1)) + r + (i = e.charAt(2)) + i + (s = e.charAt(3)) + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(f = parseInt(e.substr(1, 6), 16)) >> 16, f >> 8 & 255, 255 & f, parseInt(e.substr(7), 16) / 255];
                            f = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & 255, 255 & e]
                        } else if ("hsl" === e.substr(0, 3)) {
                            if (f = d = e.match($), t) {
                                if (~e.indexOf("=")) return f = e.match(ee), n && f.length < 4 && (f[3] = 1), f
                            } else a = +f[0] % 360 / 360, o = +f[1] / 100, i = (l = +f[2] / 100) <= .5 ? l * (o + 1) : l + o - l * o, r = 2 * l - i, f.length > 3 && (f[3] *= 1), f[0] = tw(a + 1 / 3, r, i), f[1] = tw(a, r, i), f[2] = tw(a - 1 / 3, r, i)
                        } else f = e.match($) || tb.transparent;
                        f = f.map(Number)
                    }
                    return t && !d && (l = ((u = Math.max(r = f[0] / 255, i = f[1] / 255, s = f[2] / 255)) + (c = Math.min(r, i, s))) / 2, u === c ? a = o = 0 : (h = u - c, o = l > .5 ? h / (2 - u - c) : h / (u + c), a = (u === r ? (i - s) / h + (i < s ? 6 : 0) : u === i ? (s - r) / h + 2 : (r - i) / h + 4) * 60), f[0] = ~~(a + .5), f[1] = ~~(100 * o + .5), f[2] = ~~(100 * l + .5)), n && f.length < 4 && (f[3] = 1), f
                },
                tS = function(e) {
                    var t = [],
                        n = [],
                        r = -1;
                    return e.split(tM).forEach(function(e) {
                        var i = e.match(et) || [];
                        t.push.apply(t, i), n.push(r += i.length + 1)
                    }), t.c = n, t
                },
                tI = function(e, t, n) {
                    var r, i, s, a, o = "",
                        l = (e + o).match(tM),
                        u = t ? "hsla(" : "rgba(",
                        c = 0;
                    if (!l) return e;
                    if (l = l.map(function(e) {
                            return (e = tC(e, t, 1)) && u + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
                        }), n && (s = tS(e), (r = n.c).join(o) !== s.c.join(o)))
                        for (a = (i = e.replace(tM, "1").split(et)).length - 1; c < a; c++) o += i[c] + (~r.indexOf(c) ? l.shift() || u + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
                    if (!i)
                        for (a = (i = e.split(tM)).length - 1; c < a; c++) o += i[c] + l[c];
                    return o + i[a]
                },
                tM = function() {
                    var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                    for (e in tb) t += "|" + e + "\\b";
                    return RegExp(t + ")", "gi")
                }(),
                tT = /hsl[a]?\(/,
                tB = function(e) {
                    var t, n = e.join(" ");
                    if (tM.lastIndex = 0, tM.test(n)) return t = tT.test(n), e[1] = tI(e[1], t), e[0] = tI(e[0], t, tS(e[1])), !0
                },
                tR = (g = Date.now, A = 500, m = 33, y = v = g(), x = 1e3 / 240, E = 1e3 / 240, _ = [], b = function e(t) {
                    var n, r, i, s, a = g() - y,
                        o = !0 === t;
                    if ((a > A || a < 0) && (v += a - m), y += a, ((n = (i = y - v) - E) > 0 || o) && (s = ++d.frame, f = i - 1e3 * d.time, d.time = i /= 1e3, E += n + (n >= x ? 4 : x - n), r = 1), o || (u = c(e)), r)
                        for (p = 0; p < _.length; p++) _[p](i, f, s, t)
                }, d = {
                    time: 0,
                    frame: 0,
                    tick: function() {
                        b(!0)
                    },
                    deltaRatio: function(e) {
                        return f / (1e3 / (e || 60))
                    },
                    wake: function() {
                        R && (!T && q() && (B = (M = T = window).document || {}, ea.gsap = nB, (M.gsapVersions || (M.gsapVersions = [])).push(nB.version), el(eo || M.GreenSockGlobals || !M.gsap && M || {}), tE.forEach(t_)), h = "undefined" != typeof requestAnimationFrame && requestAnimationFrame, u && d.sleep(), c = h || function(e) {
                            return setTimeout(e, E - 1e3 * d.time + 1 | 0)
                        }, P = 1, b(2))
                    },
                    sleep: function() {
                        (h ? cancelAnimationFrame : clearTimeout)(u), P = 0, c = ed
                    },
                    lagSmoothing: function(e, t) {
                        m = Math.min(t || 33, A = e || 1 / 0)
                    },
                    fps: function(e) {
                        x = 1e3 / (e || 240), E = 1e3 * d.time + x
                    },
                    add: function(e, t, n) {
                        var r = t ? function(t, n, i, s) {
                            e(t, n, i, s), d.remove(r)
                        } : e;
                        return d.remove(e), _[n ? "unshift" : "push"](r), tD(), r
                    },
                    remove: function(e, t) {
                        ~(t = _.indexOf(e)) && _.splice(t, 1) && p >= t && p--
                    },
                    _listeners: _
                }),
                tD = function() {
                    return !P && tR.wake()
                },
                tL = {},
                tP = /^[\d.\-M][\d.\-,\s]/,
                tO = /["']/g,
                tN = function(e) {
                    for (var t, n, r, i = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++) n = s[o], t = o !== l - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, t), i[a] = isNaN(r) ? r.replace(tO, "").trim() : +r, a = n.substr(t + 1).trim();
                    return i
                },
                tU = function(e) {
                    var t = e.indexOf("(") + 1,
                        n = e.indexOf(")"),
                        r = e.indexOf("(", t);
                    return e.substring(t, ~r && r < n ? e.indexOf(")", n + 1) : n)
                },
                tF = function(e) {
                    var t = (e + "").split("("),
                        n = tL[t[0]];
                    return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [tN(t[1])] : tU(e).split(",").map(eO)) : tL._CE && tP.test(e) ? tL._CE("", e) : n
                },
                tk = function(e) {
                    return function(t) {
                        return 1 - e(1 - t)
                    }
                },
                tQ = function e(t, n) {
                    for (var r, i = t._first; i;) i instanceof tX ? e(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? e(i.timeline, n) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = n)), i = i._next
                },
                tG = function(e, t) {
                    return e && (V(e) ? e : tL[e] || tF(e)) || t
                },
                tz = function(e, t, n, r) {
                    void 0 === n && (n = function(e) {
                        return 1 - t(1 - e)
                    }), void 0 === r && (r = function(e) {
                        return e < .5 ? t(2 * e) / 2 : 1 - t((1 - e) * 2) / 2
                    });
                    var i, s = {
                        easeIn: t,
                        easeOut: n,
                        easeInOut: r
                    };
                    return eI(e, function(e) {
                        for (var t in tL[e] = ea[e] = s, tL[i = e.toLowerCase()] = n, s) tL[i + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = tL[e + "." + t] = s[t]
                    }), s
                },
                tH = function(e) {
                    return function(t) {
                        return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e((t - .5) * 2) / 2
                    }
                },
                tV = function e(t, n, r) {
                    var i = n >= 1 ? n : 1,
                        s = (r || (t ? .3 : .45)) / (n < 1 ? n : 1),
                        a = s / U * (Math.asin(1 / i) || 0),
                        o = function(e) {
                            return 1 === e ? 1 : i * Math.pow(2, -10 * e) * z((e - a) * s) + 1
                        },
                        l = "out" === t ? o : "in" === t ? function(e) {
                            return 1 - o(1 - e)
                        } : tH(o);
                    return s = U / s, l.config = function(n, r) {
                        return e(t, n, r)
                    }, l
                },
                tj = function e(t, n) {
                    void 0 === n && (n = 1.70158);
                    var r = function(e) {
                            return e ? --e * e * ((n + 1) * e + n) + 1 : 0
                        },
                        i = "out" === t ? r : "in" === t ? function(e) {
                            return 1 - r(1 - e)
                        } : tH(r);
                    return i.config = function(n) {
                        return e(t, n)
                    }, i
                };
            eI("Linear,Quad,Cubic,Quart,Quint,Strong", function(e, t) {
                var n = t < 5 ? t + 1 : t;
                tz(e + ",Power" + (n - 1), t ? function(e) {
                    return Math.pow(e, n)
                } : function(e) {
                    return e
                }, function(e) {
                    return 1 - Math.pow(1 - e, n)
                }, function(e) {
                    return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow((1 - e) * 2, n) / 2
                })
            }), tL.Linear.easeNone = tL.none = tL.Linear.easeIn, tz("Elastic", tV("in"), tV("out"), tV()), tK = 2 * (tq = 1 / 2.75), tJ = 2.5 * tq, tz("Bounce", function(e) {
                return 1 - tZ(1 - e)
            }, tZ = function(e) {
                return e < tq ? 7.5625 * e * e : e < tK ? 7.5625 * Math.pow(e - 1.5 / 2.75, 2) + .75 : e < tJ ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * Math.pow(e - 2.625 / 2.75, 2) + .984375
            }), tz("Expo", function(e) {
                return Math.pow(2, 10 * (e - 1)) * e + e * e * e * e * e * e * (1 - e)
            }), tz("Circ", function(e) {
                return -(Q(1 - e * e) - 1)
            }), tz("Sine", function(e) {
                return 1 === e ? 1 : -G(e * F) + 1
            }), tz("Back", tj("in"), tj("out"), tj()), tL.SteppedEase = tL.steps = ea.SteppedEase = {
                config: function(e, t) {
                    void 0 === e && (e = 1);
                    var n = 1 / e,
                        r = e + (t ? 0 : 1),
                        i = t ? 1 : 0;
                    return function(e) {
                        return ((r * ti(0, .99999999, e) | 0) + i) * n
                    }
                }
            }, N.ease = tL["quad.out"], eI("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(e) {
                return eb += e + "," + e + "Params,"
            });
            var tW = function(e, t) {
                    this.id = k++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : eS, this.set = t ? t.getSetter : no
                },
                tY = function() {
                    function e(e) {
                        this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, e9(this, +e.duration, 1, 1), this.data = e.data, S && (this._ctx = S, S.data.push(this)), P || tR.wake()
                    }
                    var t = e.prototype;
                    return t.delay = function(e) {
                        return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
                    }, t.duration = function(e) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
                    }, t.totalDuration = function(e) {
                        return arguments.length ? (this._dirty = 0, e9(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                    }, t.totalTime = function(e, t) {
                        if (tD(), !arguments.length) return this._tTime;
                        var n = this._dp;
                        if (n && n.smoothChildTiming && this._ts) {
                            for (e$(this, e), !n._dp || n.parent || e0(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : -((n.totalDuration() - n._tTime) / n._ts)) && n.totalTime(n._tTime, !0), n = n.parent;
                            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && e1(this._dp, this, this._start - this._delay)
                        }
                        return this._tTime === e && (this._dur || t) && (!this._initted || 1e-8 !== Math.abs(this._zTime)) && (e || this._initted || !this.add && !this._ptLookup) || (this._ts || (this._pTime = e), eP(this, e, t)), this
                    }, t.time = function(e, t) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + eq(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
                    }, t.totalProgress = function(e, t) {
                        return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
                    }, t.progress = function(e, t) {
                        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(1 & this.iteration()) ? 1 - e : e) + eq(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                    }, t.iteration = function(e, t) {
                        var n = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? eK(this._tTime, n) + 1 : 1
                    }, t.timeScale = function(e, t) {
                        if (!arguments.length) return -.00000001 === this._rts ? 0 : this._rts;
                        if (this._rts === e) return this;
                        var n = this.parent && this._ts ? eJ(this.parent._time, this) : this._tTime;
                        return this._rts = +e || 0, this._ts = this._ps || -.00000001 === e ? 0 : this._rts, this.totalTime(ti(-Math.abs(this._delay), this.totalDuration(), n), !1 !== t), eZ(this), eY(this)
                    }, t.paused = function(e) {
                        return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (tD(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && 1e-8 !== Math.abs(this._zTime) && (this._tTime -= 1e-8)))), this) : this._ps
                    }, t.startTime = function(e) {
                        if (arguments.length) {
                            this._start = e;
                            var t = this.parent || this._dp;
                            return t && (t._sort || !this.parent) && e1(t, this, e - this._delay), this
                        }
                        return this._start
                    }, t.endTime = function(e) {
                        return this._start + (X(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                    }, t.rawTime = function(e) {
                        var t = this.parent || this._dp;
                        return t ? e && (!this._ts || this._repeat && this._time && 1 > this.totalProgress()) ? this._tTime % (this._dur + this._rDelay) : this._ts ? eJ(t.rawTime(e), this) : this._tTime : this._tTime
                    }, t.revert = function(e) {
                        void 0 === e && (e = eg);
                        var t = C;
                        return C = e, eL(this) && (this.timeline && this.timeline.revert(e), this.totalTime(-.01, e.suppressEvents)), "nested" !== this.data && !1 !== e.kill && this.kill(), C = t, this
                    }, t.globalTime = function(e) {
                        for (var t = this, n = arguments.length ? e : t.rawTime(); t;) n = t._start + n / (Math.abs(t._ts) || 1), t = t._dp;
                        return !this.parent && this._sat ? this._sat.globalTime(e) : n
                    }, t.repeat = function(e) {
                        return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, e7(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                    }, t.repeatDelay = function(e) {
                        if (arguments.length) {
                            var t = this._time;
                            return this._rDelay = e, e7(this), t ? this.time(t) : this
                        }
                        return this._rDelay
                    }, t.yoyo = function(e) {
                        return arguments.length ? (this._yoyo = e, this) : this._yoyo
                    }, t.seek = function(e, t) {
                        return this.totalTime(tt(this, e), X(t))
                    }, t.restart = function(e, t) {
                        return this.play().totalTime(e ? -this._delay : 0, X(t)), this._dur || (this._zTime = -.00000001), this
                    }, t.play = function(e, t) {
                        return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                    }, t.reverse = function(e, t) {
                        return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                    }, t.pause = function(e, t) {
                        return null != e && this.seek(e, t), this.paused(!0)
                    }, t.resume = function() {
                        return this.paused(!1)
                    }, t.reversed = function(e) {
                        return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -.00000001 : 0)), this) : this._rts < 0
                    }, t.invalidate = function() {
                        return this._initted = this._act = 0, this._zTime = -.00000001, this
                    }, t.isActive = function() {
                        var e, t = this.parent || this._dp,
                            n = this._start;
                        return !!(!t || this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - 1e-8)
                    }, t.eventCallback = function(e, t, n) {
                        var r = this.vars;
                        return arguments.length > 1 ? (t ? (r[e] = t, n && (r[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete r[e], this) : r[e]
                    }, t.then = function(e) {
                        var t = this;
                        return new Promise(function(n) {
                            var r = V(e) ? e : eN,
                                i = function() {
                                    var e = t.then;
                                    t.then = null, V(r) && (r = r(t)) && (r.then || r === t) && (t.then = e), n(r), t.then = e
                                };
                            t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? i() : t._prom = i
                        })
                    }, t.kill = function() {
                        tx(this)
                    }, e
                }();
            eU(tY.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -.00000001,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var tX = function(e) {
                function t(t, n) {
                    var i;
                    return void 0 === t && (t = {}), (i = e.call(this, t) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = X(t.sortChildren), I && e1(t.parent || I, r(i), n), t.reversed && i.reverse(), t.paused && i.paused(!0), t.scrollTrigger && e2(r(i), t.scrollTrigger), i
                }
                i(t, e);
                var n = t.prototype;
                return n.to = function(e, t, n) {
                    return tn(0, arguments, this), this
                }, n.from = function(e, t, n) {
                    return tn(1, arguments, this), this
                }, n.fromTo = function(e, t, n, r) {
                    return tn(2, arguments, this), this
                }, n.set = function(e, t, n) {
                    return t.duration = 0, t.parent = this, eG(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new nn(e, t, tt(this, n), 1), this
                }, n.call = function(e, t, n) {
                    return e1(this, nn.delayedCall(0, e, t), n)
                }, n.staggerTo = function(e, t, n, r, i, s, a) {
                    return n.duration = t, n.stagger = n.stagger || r, n.onComplete = s, n.onCompleteParams = a, n.parent = this, new nn(e, n, tt(this, i)), this
                }, n.staggerFrom = function(e, t, n, r, i, s, a) {
                    return n.runBackwards = 1, eG(n).immediateRender = X(n.immediateRender), this.staggerTo(e, t, n, r, i, s, a)
                }, n.staggerFromTo = function(e, t, n, r, i, s, a, o) {
                    return r.startAt = n, eG(r).immediateRender = X(r.immediateRender), this.staggerTo(e, t, r, i, s, a, o)
                }, n.render = function(e, t, n) {
                    var r, i, s, a, o, l, u, c, h, d, f, p, g = this._time,
                        A = this._dirty ? this.totalDuration() : this._tDur,
                        m = this._dur,
                        v = e <= 0 ? 0 : eT(e),
                        y = this._zTime < 0 != e < 0 && (this._initted || !m);
                    if (this !== I && v > A && e >= 0 && (v = A), v !== this._tTime || n || y) {
                        if (g !== this._time && m && (v += this._time - g, e += this._time - g), r = v, h = this._start, l = !(c = this._ts), y && (m || (g = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) {
                            if (f = this._yoyo, o = m + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * o + e, t, n);
                            if (r = eT(v % o), v === A ? (a = this._repeat, r = m) : ((a = ~~(d = eT(v / o))) && a === d && (r = m, a--), r > m && (r = m)), d = eK(this._tTime, o), !g && this._tTime && d !== a && this._tTime - d * o - this._dur <= 0 && (d = a), f && 1 & a && (r = m - r, p = 1), a !== d && !this._lock) {
                                var x = f && 1 & d,
                                    E = x === (f && 1 & a);
                                if (a < d && (x = !x), g = x ? 0 : v % m ? m : v, this._lock = 1, this.render(g || (p ? 0 : eT(a * o)), t, !m)._lock = 0, this._tTime = v, !t && this.parent && ty(this, "onRepeat"), this.vars.repeatRefresh && !p && (this.invalidate()._lock = 1), g && g !== this._time || !this._ts !== l || this.vars.onRepeat && !this.parent && !this._act || (m = this._dur, A = this._tDur, E && (this._lock = 2, g = x ? m : -.0001, this.render(g, !0), this.vars.repeatRefresh && !p && this.invalidate()), this._lock = 0, !this._ts && !l)) return this;
                                tQ(this, p)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (u = e8(this, eT(g), eT(r))) && (v -= r - (r = u._start)), this._tTime = v, this._time = r, this._act = !c, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, g = 0), !g && v && !t && !d && (ty(this, "onStart"), this._tTime !== v)) return this;
                        if (r >= g && e >= 0)
                            for (i = this._first; i;) {
                                if (s = i._next, (i._act || r >= i._start) && i._ts && u !== i) {
                                    if (i.parent !== this) return this.render(e, t, n);
                                    if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, t, n), r !== this._time || !this._ts && !l) {
                                        u = 0, s && (v += this._zTime = -.00000001);
                                        break
                                    }
                                }
                                i = s
                            } else {
                                i = this._last;
                                for (var _ = e < 0 ? e : r; i;) {
                                    if (s = i._prev, (i._act || _ <= i._end) && i._ts && u !== i) {
                                        if (i.parent !== this) return this.render(e, t, n);
                                        if (i.render(i._ts > 0 ? (_ - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (_ - i._start) * i._ts, t, n || C && eL(i)), r !== this._time || !this._ts && !l) {
                                            u = 0, s && (v += this._zTime = _ ? -.00000001 : 1e-8);
                                            break
                                        }
                                    }
                                    i = s
                                }
                            }
                        if (u && !t && (this.pause(), u.render(r >= g ? 0 : -.00000001)._zTime = r >= g ? 1 : -1, this._ts)) return this._start = h, eZ(this), this.render(e, t, n);
                        this._onUpdate && !t && ty(this, "onUpdate", !0), (v === A && this._tTime >= this.totalDuration() || !v && g) && (h === this._start || Math.abs(c) !== Math.abs(this._ts)) && !this._lock && ((e || !m) && (v === A && this._ts > 0 || !v && this._ts < 0) && ej(this, 1), t || e < 0 && !g || !v && !g && A || (ty(this, v === A && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < A && this.timeScale() > 0) && this._prom()))
                    }
                    return this
                }, n.add = function(e, t) {
                    var n = this;
                    if (j(t) || (t = tt(this, t, e)), !(e instanceof tY)) {
                        if (Z(e)) return e.forEach(function(e) {
                            return n.add(e, t)
                        }), this;
                        if (H(e)) return this.addLabel(e, t);
                        if (!V(e)) return this;
                        e = nn.delayedCall(0, e)
                    }
                    return this !== e ? e1(this, e, t) : this
                }, n.getChildren = function(e, t, n, r) {
                    void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === r && (r = -1e8);
                    for (var i = [], s = this._first; s;) s._start >= r && (s instanceof nn ? t && i.push(s) : (n && i.push(s), e && i.push.apply(i, s.getChildren(!0, t, n)))), s = s._next;
                    return i
                }, n.getById = function(e) {
                    for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)
                        if (t[n].vars.id === e) return t[n]
                }, n.remove = function(e) {
                    return H(e) ? this.removeLabel(e) : V(e) ? this.killTweensOf(e) : (e.parent === this && eV(this, e), e === this._recent && (this._recent = this._last), eW(this))
                }, n.totalTime = function(t, n) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = eT(tR.time - (this._ts > 0 ? t / this._ts : -((this.totalDuration() - t) / this._ts)))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime
                }, n.addLabel = function(e, t) {
                    return this.labels[e] = tt(this, t), this
                }, n.removeLabel = function(e) {
                    return delete this.labels[e], this
                }, n.addPause = function(e, t, n) {
                    var r = nn.delayedCall(0, t || ed, n);
                    return r.data = "isPause", this._hasPause = 1, e1(this, r, tt(this, e))
                }, n.removePause = function(e) {
                    var t = this._first;
                    for (e = tt(this, e); t;) t._start === e && "isPause" === t.data && ej(t), t = t._next
                }, n.killTweensOf = function(e, t, n) {
                    for (var r = this.getTweensOf(e, n), i = r.length; i--;) t$ !== r[i] && r[i].kill(e, t);
                    return this
                }, n.getTweensOf = function(e, t) {
                    for (var n, r = [], i = tl(e), s = this._first, a = j(t); s;) s instanceof nn ? eR(s._targets, i) && (a ? (!t$ || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && r.push(s) : (n = s.getTweensOf(i, t)).length && r.push.apply(r, n), s = s._next;
                    return r
                }, n.tweenTo = function(e, t) {
                    t = t || {};
                    var n, r = this,
                        i = tt(r, e),
                        s = t,
                        a = s.startAt,
                        o = s.onStart,
                        l = s.onStartParams,
                        u = s.immediateRender,
                        c = nn.to(r, eU({
                            ease: t.ease || "none",
                            lazy: !1,
                            immediateRender: !1,
                            time: i,
                            overwrite: "auto",
                            duration: t.duration || Math.abs((i - (a && "time" in a ? a.time : r._time)) / r.timeScale()) || 1e-8,
                            onStart: function() {
                                if (r.pause(), !n) {
                                    var e = t.duration || Math.abs((i - (a && "time" in a ? a.time : r._time)) / r.timeScale());
                                    c._dur !== e && e9(c, e, 0, 1).render(c._time, !0, !0), n = 1
                                }
                                o && o.apply(c, l || [])
                            }
                        }, t));
                    return u ? c.render(0) : c
                }, n.tweenFromTo = function(e, t, n) {
                    return this.tweenTo(t, eU({
                        startAt: {
                            time: tt(this, e)
                        }
                    }, n))
                }, n.recent = function() {
                    return this._recent
                }, n.nextLabel = function(e) {
                    return void 0 === e && (e = this._time), tv(this, tt(this, e))
                }, n.previousLabel = function(e) {
                    return void 0 === e && (e = this._time), tv(this, tt(this, e), 1)
                }, n.currentLabel = function(e) {
                    return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + 1e-8)
                }, n.shiftChildren = function(e, t, n) {
                    void 0 === n && (n = 0);
                    for (var r, i = this._first, s = this.labels; i;) i._start >= n && (i._start += e, i._end += e), i = i._next;
                    if (t)
                        for (r in s) s[r] >= n && (s[r] += e);
                    return eW(this)
                }, n.invalidate = function(t) {
                    var n = this._first;
                    for (this._lock = 0; n;) n.invalidate(t), n = n._next;
                    return e.prototype.invalidate.call(this, t)
                }, n.clear = function(e) {
                    void 0 === e && (e = !0);
                    for (var t, n = this._first; n;) t = n._next, this.remove(n), n = t;
                    return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), eW(this)
                }, n.totalDuration = function(e) {
                    var t, n, r, i = 0,
                        s = this._last,
                        a = 1e8;
                    if (arguments.length) return this.timeScale((this._repeat < 0 ? this.duration() : this.totalDuration()) / (this.reversed() ? -e : e));
                    if (this._dirty) {
                        for (r = this.parent; s;) t = s._prev, s._dirty && s.totalDuration(), (n = s._start) > a && this._sort && s._ts && !this._lock ? (this._lock = 1, e1(this, s, n - s._delay, 1)._lock = 0) : a = n, n < 0 && s._ts && (i -= n, (!r && !this._dp || r && r.smoothChildTiming) && (this._start += n / this._ts, this._time -= n, this._tTime -= n), this.shiftChildren(-n, !1, -Infinity), a = 0), s._end > i && s._ts && (i = s._end), s = t;
                        e9(this, this === I && this._time > i ? this._time : i, 1, 1), this._dirty = 0
                    }
                    return this._tDur
                }, t.updateRoot = function(e) {
                    if (I._ts && (eP(I, eJ(e, I)), D = tR.frame), tR.frame >= eE) {
                        eE += O.autoSleep || 120;
                        var t = I._first;
                        if ((!t || !t._ts) && O.autoSleep && tR._listeners.length < 2) {
                            for (; t && !t._ts;) t = t._next;
                            t || tR.sleep()
                        }
                    }
                }, t
            }(tY);
            eU(tX.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var tq, tK, tJ, tZ, t$, t0, t1 = function(e, t, n, r, i, s, a) {
                    var o, l, u, c, h, d, f, p, g = new nA(this._pt, e, t, 0, 1, nc, null, i),
                        A = 0,
                        m = 0;
                    for (g.b = n, g.e = r, n += "", r += "", (f = ~r.indexOf("random(")) && (r = tA(r)), s && (s(p = [n, r], e, t), n = p[0], r = p[1]), l = n.match(en) || []; o = en.exec(r);) c = o[0], h = r.substring(A, o.index), u ? u = (u + 1) % 5 : "rgba(" === h.substr(-5) && (u = 1), c !== l[m++] && (d = parseFloat(l[m - 1]) || 0, g._pt = {
                        _next: g._pt,
                        p: h || 1 === m ? h : ",",
                        s: d,
                        c: "=" === c.charAt(1) ? eB(d, c) - d : parseFloat(c) - d,
                        m: u && u < 4 ? Math.round : 0
                    }, A = en.lastIndex);
                    return g.c = A < r.length ? r.substring(A, r.length) : "", g.fp = a, (er.test(r) || f) && (g.e = 0), this._pt = g, g
                },
                t2 = function(e, t, n, r, i, s, a, o, l, u) {
                    V(r) && (r = r(i || 0, e, s));
                    var c, h = e[t],
                        d = "get" !== n ? n : V(h) ? l ? e[t.indexOf("set") || !V(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : h,
                        f = V(h) ? l ? ns : ni : nr;
                    if (H(r) && (~r.indexOf("random(") && (r = tA(r)), "=" === r.charAt(1) && ((c = eB(d, r) + (ts(d) || 0)) || 0 === c) && (r = c)), !u || d !== r || t0) return isNaN(d * r) || "" === r ? (h || t in e || eu(t, r), t1.call(this, e, t, d, r, f, o || O.stringFilter, l)) : (c = new nA(this._pt, e, t, +d || 0, r - (d || 0), "boolean" == typeof h ? nu : nl, 0, f), l && (c.fp = l), a && c.modifier(a, this, e), this._pt = c)
                },
                t3 = function(e, t, n, r, i) {
                    if (V(e) && (e = t7(e, i, t, n, r)), !Y(e) || e.style && e.nodeType || Z(e) || J(e)) return H(e) ? t7(e, i, t, n, r) : e;
                    var s, a = {};
                    for (s in e) a[s] = t7(e[s], i, t, n, r);
                    return a
                },
                t4 = function(e, t, n, r, i, s) {
                    var a, o, l, u;
                    if (ey[e] && !1 !== (a = new ey[e]).init(i, a.rawVars ? t[e] : t3(t[e], r, i, s, n), n, r, s) && (n._pt = o = new nA(n._pt, i, e, 0, 1, a.render, a, 0, a.priority), n !== L))
                        for (l = n._ptLookup[n._targets.indexOf(i)], u = a._props.length; u--;) l[a._props[u]] = o;
                    return a
                },
                t5 = function e(t, n, r) {
                    var i, s, a, o, l, u, c, h, d, f, p, g, A, m = t.vars,
                        v = m.ease,
                        y = m.startAt,
                        x = m.immediateRender,
                        E = m.lazy,
                        _ = m.onUpdate,
                        b = m.runBackwards,
                        S = m.yoyoEase,
                        M = m.keyframes,
                        T = m.autoRevert,
                        B = t._dur,
                        R = t._startAt,
                        D = t._targets,
                        L = t.parent,
                        P = L && "nested" === L.data ? L.vars.targets : D,
                        O = "auto" === t._overwrite && !w,
                        U = t.timeline;
                    if (!U || M && v || (v = "none"), t._ease = tG(v, N.ease), t._yEase = S ? tk(tG(!0 === S ? v : S, N.ease)) : 0, S && t._yoyo && !t._repeat && (S = t._yEase, t._yEase = t._ease, t._ease = S), t._from = !U && !!m.runBackwards, !U || M && !m.stagger) {
                        if (g = (h = D[0] ? eC(D[0]).harness : 0) && m[h.prop], i = eQ(m, eA), R && (R._zTime < 0 && R.progress(1), n < 0 && b && x && !T ? R.render(-1, !0) : R.revert(b && B ? ep : ef), R._lazy = 0), y) {
                            if (ej(t._startAt = nn.set(D, eU({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: L,
                                    immediateRender: !0,
                                    lazy: !R && X(E),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: _ && function() {
                                        return ty(t, "onUpdate")
                                    },
                                    stagger: 0
                                }, y))), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (C || !x && !T) && t._startAt.revert(ep), x && B && n <= 0 && r <= 0) {
                                n && (t._zTime = n);
                                return
                            }
                        } else if (b && B && !R) {
                            if (n && (x = !1), a = eU({
                                    overwrite: !1,
                                    data: "isFromStart",
                                    lazy: x && !R && X(E),
                                    immediateRender: x,
                                    stagger: 0,
                                    parent: L
                                }, i), g && (a[h.prop] = g), ej(t._startAt = nn.set(D, a)), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (C ? t._startAt.revert(ep) : t._startAt.render(-1, !0)), t._zTime = n, x) {
                                if (!n) return
                            } else e(t._startAt, 1e-8, 1e-8)
                        }
                        for (s = 0, t._pt = t._ptCache = 0, E = B && X(E) || E && !B; s < D.length; s++) {
                            if (c = (l = D[s])._gsap || ew(D)[s]._gsap, t._ptLookup[s] = f = {}, ev[c.id] && em.length && eD(), p = P === D ? s : P.indexOf(l), h && !1 !== (d = new h).init(l, g || i, t, p, P) && (t._pt = o = new nA(t._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach(function(e) {
                                    f[e] = o
                                }), d.priority && (u = 1)), !h || g)
                                for (a in i) ey[a] && (d = t4(a, i, t, p, l, P)) ? d.priority && (u = 1) : f[a] = o = t2.call(t, l, a, "get", i[a], p, P, 0, m.stringFilter);
                            t._op && t._op[s] && t.kill(l, t._op[s]), O && t._pt && (t$ = t, I.killTweensOf(l, f, t.globalTime(n)), A = !t.parent, t$ = 0), t._pt && E && (ev[c.id] = 1)
                        }
                        u && ng(t), t._onInit && t._onInit(t)
                    }
                    t._onUpdate = _, t._initted = (!t._op || t._pt) && !A, M && n <= 0 && U.render(1e8, !0, !0)
                },
                t6 = function(e, t, n, r, i, s, a, o) {
                    var l, u, c, h, d = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                    if (!d)
                        for (d = e._ptCache[t] = [], c = e._ptLookup, h = e._targets.length; h--;) {
                            if ((l = c[h][t]) && l.d && l.d._pt)
                                for (l = l.d._pt; l && l.p !== t && l.fp !== t;) l = l._next;
                            if (!l) return t0 = 1, e.vars[t] = "+=0", t5(e, a), t0 = 0, o ? ec(t + " not eligible for reset") : 1;
                            d.push(l)
                        }
                    for (h = d.length; h--;)(l = (u = d[h])._pt || u).s = (r || 0 === r) && !i ? r : l.s + (r || 0) + s * l.c, l.c = n - l.s, u.e && (u.e = eM(n) + ts(u.e)), u.b && (u.b = l.s + ts(u.b))
                },
                t8 = function(e, t) {
                    var n, r, i, s, a = e[0] ? eC(e[0]).harness : 0,
                        o = a && a.aliases;
                    if (!o) return t;
                    for (r in n = eF({}, t), o)
                        if (r in n)
                            for (i = (s = o[r].split(",")).length; i--;) n[s[i]] = n[r];
                    return n
                },
                t9 = function(e, t, n, r) {
                    var i, s, a = t.ease || r || "power1.inOut";
                    if (Z(t)) s = n[e] || (n[e] = []), t.forEach(function(e, n) {
                        return s.push({
                            t: n / (t.length - 1) * 100,
                            v: e,
                            e: a
                        })
                    });
                    else
                        for (i in t) s = n[i] || (n[i] = []), "ease" === i || s.push({
                            t: parseFloat(e),
                            v: t[i],
                            e: a
                        })
                },
                t7 = function(e, t, n, r, i) {
                    return V(e) ? e.call(t, n, r, i) : H(e) && ~e.indexOf("random(") ? tA(e) : e
                },
                ne = eb + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                nt = {};
            eI(ne + ",id,stagger,delay,duration,paused,scrollTrigger", function(e) {
                return nt[e] = 1
            });
            var nn = function(e) {
                function t(t, n, i, s) {
                    "number" == typeof n && (i.duration = n, n = i, i = null);
                    var a, o, l, u, c, h, d, f, p, g = (a = e.call(this, s ? n : eG(n)) || this).vars,
                        A = g.duration,
                        m = g.delay,
                        v = g.immediateRender,
                        y = g.stagger,
                        x = g.overwrite,
                        E = g.keyframes,
                        _ = g.defaults,
                        b = g.scrollTrigger,
                        C = g.yoyoEase,
                        S = n.parent || I,
                        M = (Z(t) || J(t) ? j(t[0]) : "length" in n) ? [t] : tl(t);
                    if (a._targets = M.length ? ew(M) : ec("GSAP target " + t + " not found. https://gsap.com", !O.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = x, E || y || K(A) || K(m)) {
                        if (n = a.vars, (o = a.timeline = new tX({
                                data: "nested",
                                defaults: _ || {},
                                targets: S && "nested" === S.data ? S.vars.targets : M
                            })).kill(), o.parent = o._dp = r(a), o._start = 0, y || K(A) || K(m)) {
                            if (c = M.length, f = y && th(y), Y(y))
                                for (h in y) ~ne.indexOf(h) && (p || (p = {}), p[h] = y[h]);
                            for (l = 0; l < c; l++)(u = eQ(n, nt)).stagger = 0, C && (u.yoyoEase = C), p && eF(u, p), d = M[l], u.duration = +t7(A, r(a), l, d, M), u.delay = (+t7(m, r(a), l, d, M) || 0) - a._delay, !y && 1 === c && u.delay && (a._delay = m = u.delay, a._start += m, u.delay = 0), o.to(d, u, f ? f(l, d, M) : 0), o._ease = tL.none;
                            o.duration() ? A = m = 0 : a.timeline = 0
                        } else if (E) {
                            eG(eU(o.vars.defaults, {
                                ease: "none"
                            })), o._ease = tG(E.ease || n.ease || "none");
                            var T, B, R, D = 0;
                            if (Z(E)) E.forEach(function(e) {
                                return o.to(M, e, ">")
                            }), o.duration();
                            else {
                                for (h in u = {}, E) "ease" === h || "easeEach" === h || t9(h, E[h], u, E.easeEach);
                                for (h in u)
                                    for (l = 0, T = u[h].sort(function(e, t) {
                                            return e.t - t.t
                                        }), D = 0; l < T.length; l++)(R = {
                                        ease: (B = T[l]).e,
                                        duration: (B.t - (l ? T[l - 1].t : 0)) / 100 * A
                                    })[h] = B.v, o.to(M, R, D), D += R.duration;
                                o.duration() < A && o.to({}, {
                                    duration: A - o.duration()
                                })
                            }
                        }
                        A || a.duration(A = o.duration())
                    } else a.timeline = 0;
                    return !0 !== x || w || (t$ = r(a), I.killTweensOf(M), t$ = 0), e1(S, r(a), i), n.reversed && a.reverse(), n.paused && a.paused(!0), (v || !A && !E && a._start === eT(S._time) && X(v) && function e(t) {
                        return !t || t._ts && e(t.parent)
                    }(r(a)) && "nested" !== S.data) && (a._tTime = -.00000001, a.render(Math.max(0, -m) || 0)), b && e2(r(a), b), a
                }
                i(t, e);
                var n = t.prototype;
                return n.render = function(e, t, n) {
                    var r, i, s, a, o, l, u, c, h, d = this._time,
                        f = this._tDur,
                        p = this._dur,
                        g = e < 0,
                        A = e > f - 1e-8 && !g ? f : e < 1e-8 ? 0 : e;
                    if (p) {
                        if (A !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g || this._lazy) {
                            if (r = A, c = this.timeline, this._repeat) {
                                if (a = p + this._rDelay, this._repeat < -1 && g) return this.totalTime(100 * a + e, t, n);
                                if (r = eT(A % a), A === f ? (s = this._repeat, r = p) : (s = ~~(o = eT(A / a))) && s === o ? (r = p, s--) : r > p && (r = p), (l = this._yoyo && 1 & s) && (h = this._yEase, r = p - r), o = eK(this._tTime, a), r === d && !n && this._initted && s === o) return this._tTime = A, this;
                                s !== o && (c && this._yEase && tQ(c, l), this.vars.repeatRefresh && !l && !this._lock && r !== a && this._initted && (this._lock = n = 1, this.render(eT(a * s), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (e3(this, g ? e : r, n, t, A)) return this._tTime = 0, this;
                                if (d !== this._time && !(n && this.vars.repeatRefresh && s !== o)) return this;
                                if (p !== this._dur) return this.render(e, t, n)
                            }
                            if (this._tTime = A, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = u = (h || this._ease)(r / p), this._from && (this.ratio = u = 1 - u), !d && A && !t && !o && (ty(this, "onStart"), this._tTime !== A)) return this;
                            for (i = this._pt; i;) i.r(u, i.d), i = i._next;
                            c && c.render(e < 0 ? e : c._dur * c._ease(r / this._dur), t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (g && eX(this, e, t, n), ty(this, "onUpdate")), this._repeat && s !== o && this.vars.onRepeat && !t && this.parent && ty(this, "onRepeat"), (A === this._tDur || !A) && this._tTime === A && (g && !this._onUpdate && eX(this, e, !0, !0), (e || !p) && (A === this._tDur && this._ts > 0 || !A && this._ts < 0) && ej(this, 1), !t && !(g && !d) && (A || d || l) && (ty(this, A === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(A < f && this.timeScale() > 0) && this._prom()))
                        }
                    } else e6(this, e, t, n);
                    return this
                }, n.targets = function() {
                    return this._targets
                }, n.invalidate = function(t) {
                    return t && this.vars.runBackwards || (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), e.prototype.invalidate.call(this, t)
                }, n.resetTo = function(e, t, n, r, i) {
                    P || tR.wake(), this._ts || this.play();
                    var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                    return (this._initted || t5(this, s), t6(this, e, t, n, r, this._ease(s / this._dur), s, i)) ? this.resetTo(e, t, n, r, 1) : (e$(this, 0), this.parent || eH(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
                }, n.kill = function(e, t) {
                    if (void 0 === t && (t = "all"), !e && (!t || "all" === t)) return this._lazy = this._pt = 0, this.parent ? tx(this) : this.scrollTrigger && this.scrollTrigger.kill(!!C), this;
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(e, t, t$ && !0 !== t$.vars.overwrite)._first || tx(this), this.parent && n !== this.timeline.totalDuration() && e9(this, this._dur * this.timeline._tDur / n, 0, 1), this
                    }
                    var r, i, s, a, o, l, u, c = this._targets,
                        h = e ? tl(e) : c,
                        d = this._ptLookup,
                        f = this._pt;
                    if ((!t || "all" === t) && ez(c, h)) return "all" === t && (this._pt = 0), tx(this);
                    for (r = this._op = this._op || [], "all" !== t && (H(t) && (o = {}, eI(t, function(e) {
                            return o[e] = 1
                        }), t = o), t = t8(c, t)), u = c.length; u--;)
                        if (~h.indexOf(c[u]))
                            for (o in i = d[u], "all" === t ? (r[u] = t, a = i, s = {}) : (s = r[u] = r[u] || {}, a = t), a)(l = i && i[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || eV(this, l, "_pt"), delete i[o]), "all" !== s && (s[o] = 1);
                    return this._initted && !this._pt && f && tx(this), this
                }, t.to = function(e, n) {
                    return new t(e, n, arguments[2])
                }, t.from = function(e, t) {
                    return tn(1, arguments)
                }, t.delayedCall = function(e, n, r, i) {
                    return new t(n, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: e,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: r,
                        onReverseCompleteParams: r,
                        callbackScope: i
                    })
                }, t.fromTo = function(e, t, n) {
                    return tn(2, arguments)
                }, t.set = function(e, n) {
                    return n.duration = 0, n.repeatDelay || (n.repeat = 0), new t(e, n)
                }, t.killTweensOf = function(e, t, n) {
                    return I.killTweensOf(e, t, n)
                }, t
            }(tY);
            eU(nn.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), eI("staggerTo,staggerFrom,staggerFromTo", function(e) {
                nn[e] = function() {
                    var t = new tX,
                        n = ta.call(arguments, 0);
                    return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
                }
            });
            var nr = function(e, t, n) {
                    return e[t] = n
                },
                ni = function(e, t, n) {
                    return e[t](n)
                },
                ns = function(e, t, n, r) {
                    return e[t](r.fp, n)
                },
                na = function(e, t, n) {
                    return e.setAttribute(t, n)
                },
                no = function(e, t) {
                    return V(e[t]) ? ni : W(e[t]) && e.setAttribute ? na : nr
                },
                nl = function(e, t) {
                    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
                },
                nu = function(e, t) {
                    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
                },
                nc = function(e, t) {
                    var n = t._pt,
                        r = "";
                    if (!e && t.b) r = t.b;
                    else if (1 === e && t.e) r = t.e;
                    else {
                        for (; n;) r = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + r, n = n._next;
                        r += t.c
                    }
                    t.set(t.t, t.p, r, t)
                },
                nh = function(e, t) {
                    for (var n = t._pt; n;) n.r(e, n.d), n = n._next
                },
                nd = function(e, t, n, r) {
                    for (var i, s = this._pt; s;) i = s._next, s.p === r && s.modifier(e, t, n), s = i
                },
                nf = function(e) {
                    for (var t, n, r = this._pt; r;) n = r._next, (r.p !== e || r.op) && r.op !== e ? r.dep || (t = 1) : eV(this, r, "_pt"), r = n;
                    return !t
                },
                np = function(e, t, n, r) {
                    r.mSet(e, t, r.m.call(r.tween, n, r.mt), r)
                },
                ng = function(e) {
                    for (var t, n, r, i, s = e._pt; s;) {
                        for (t = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                        (s._prev = n ? n._prev : i) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : i = s, s = t
                    }
                    e._pt = r
                },
                nA = function() {
                    function e(e, t, n, r, i, s, a, o, l) {
                        this.t = t, this.s = r, this.c = i, this.p = n, this.r = s || nl, this.d = a || this, this.set = o || nr, this.pr = l || 0, this._next = e, e && (e._prev = this)
                    }
                    return e.prototype.modifier = function(e, t, n) {
                        this.mSet = this.mSet || this.set, this.set = np, this.m = e, this.mt = n, this.tween = t
                    }, e
                }();
            eI(eb + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(e) {
                return eA[e] = 1
            }), ea.TweenMax = ea.TweenLite = nn, ea.TimelineLite = ea.TimelineMax = tX, I = new tX({
                sortChildren: !1,
                defaults: N,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), O.stringFilter = tB;
            var nm = [],
                nv = {},
                ny = [],
                nx = 0,
                nE = 0,
                n_ = function(e) {
                    return (nv[e] || ny).map(function(e) {
                        return e()
                    })
                },
                nb = function() {
                    var e = Date.now(),
                        t = [];
                    e - nx > 2 && (n_("matchMediaInit"), nm.forEach(function(e) {
                        var n, r, i, s, a = e.queries,
                            o = e.conditions;
                        for (r in a)(n = M.matchMedia(a[r]).matches) && (i = 1), n !== o[r] && (o[r] = n, s = 1);
                        s && (e.revert(), i && t.push(e))
                    }), n_("matchMediaRevert"), t.forEach(function(e) {
                        return e.onMatch(e, function(t) {
                            return e.add(null, t)
                        })
                    }), nx = e, n_("matchMedia"))
                },
                nw = function() {
                    function e(e, t) {
                        this.selector = t && tu(t), this.data = [], this._r = [], this.isReverted = !1, this.id = nE++, e && this.add(e)
                    }
                    var t = e.prototype;
                    return t.add = function(e, t, n) {
                        V(e) && (n = t, t = e, e = V);
                        var r = this,
                            i = function() {
                                var e, i = S,
                                    s = r.selector;
                                return i && i !== r && i.data.push(r), n && (r.selector = tu(n)), S = r, e = t.apply(r, arguments), V(e) && r._r.push(e), S = i, r.selector = s, r.isReverted = !1, e
                            };
                        return r.last = i, e === V ? i(r, function(e) {
                            return r.add(null, e)
                        }) : e ? r[e] = i : i
                    }, t.ignore = function(e) {
                        var t = S;
                        S = null, e(this), S = t
                    }, t.getTweens = function() {
                        var t = [];
                        return this.data.forEach(function(n) {
                            return n instanceof e ? t.push.apply(t, n.getTweens()) : n instanceof nn && !(n.parent && "nested" === n.parent.data) && t.push(n)
                        }), t
                    }, t.clear = function() {
                        this._r.length = this.data.length = 0
                    }, t.kill = function(e, t) {
                        var n = this;
                        if (e ? function() {
                                for (var t, r = n.getTweens(), i = n.data.length; i--;) "isFlip" === (t = n.data[i]).data && (t.revert(), t.getChildren(!0, !0, !1).forEach(function(e) {
                                    return r.splice(r.indexOf(e), 1)
                                }));
                                for (r.map(function(e) {
                                        return {
                                            g: e._dur || e._delay || e._sat && !e._sat.vars.immediateRender ? e.globalTime(0) : -1 / 0,
                                            t: e
                                        }
                                    }).sort(function(e, t) {
                                        return t.g - e.g || -1 / 0
                                    }).forEach(function(t) {
                                        return t.t.revert(e)
                                    }), i = n.data.length; i--;)(t = n.data[i]) instanceof tX ? "nested" !== t.data && (t.scrollTrigger && t.scrollTrigger.revert(), t.kill()) : t instanceof nn || !t.revert || t.revert(e);
                                n._r.forEach(function(t) {
                                    return t(e, n)
                                }), n.isReverted = !0
                            }() : this.data.forEach(function(e) {
                                return e.kill && e.kill()
                            }), this.clear(), t)
                            for (var r = nm.length; r--;) nm[r].id === this.id && nm.splice(r, 1)
                    }, t.revert = function(e) {
                        this.kill(e || {})
                    }, e
                }(),
                nC = function() {
                    function e(e) {
                        this.contexts = [], this.scope = e, S && S.data.push(this)
                    }
                    var t = e.prototype;
                    return t.add = function(e, t, n) {
                        Y(e) || (e = {
                            matches: e
                        });
                        var r, i, s, a = new nw(0, n || this.scope),
                            o = a.conditions = {};
                        for (i in S && !a.selector && (a.selector = S.selector), this.contexts.push(a), t = a.add("onMatch", t), a.queries = e, e) "all" === i ? s = 1 : (r = M.matchMedia(e[i])) && (0 > nm.indexOf(a) && nm.push(a), (o[i] = r.matches) && (s = 1), r.addListener ? r.addListener(nb) : r.addEventListener("change", nb));
                        return s && t(a, function(e) {
                            return a.add(null, e)
                        }), this
                    }, t.revert = function(e) {
                        this.kill(e || {})
                    }, t.kill = function(e) {
                        this.contexts.forEach(function(t) {
                            return t.kill(e, !0)
                        })
                    }, e
                }(),
                nS = {
                    registerPlugin: function() {
                        for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        t.forEach(function(e) {
                            return t_(e)
                        })
                    },
                    timeline: function(e) {
                        return new tX(e)
                    },
                    getTweensOf: function(e, t) {
                        return I.getTweensOf(e, t)
                    },
                    getProperty: function(e, t, n, r) {
                        H(e) && (e = tl(e)[0]);
                        var i = eC(e || {}).get,
                            s = n ? eN : eO;
                        return "native" === n && (n = ""), e ? t ? s((ey[t] && ey[t].get || i)(e, t, n, r)) : function(t, n, r) {
                            return s((ey[t] && ey[t].get || i)(e, t, n, r))
                        } : e
                    },
                    quickSetter: function(e, t, n) {
                        if ((e = tl(e)).length > 1) {
                            var r = e.map(function(e) {
                                    return nB.quickSetter(e, t, n)
                                }),
                                i = r.length;
                            return function(e) {
                                for (var t = i; t--;) r[t](e)
                            }
                        }
                        e = e[0] || {};
                        var s = ey[t],
                            a = eC(e),
                            o = a.harness && (a.harness.aliases || {})[t] || t,
                            l = s ? function(t) {
                                var r = new s;
                                L._pt = 0, r.init(e, n ? t + n : t, L, 0, [e]), r.render(1, r), L._pt && nh(1, L)
                            } : a.set(e, o);
                        return s ? l : function(t) {
                            return l(e, o, n ? t + n : t, a, 1)
                        }
                    },
                    quickTo: function(e, t, n) {
                        var r, i = nB.to(e, eU(((r = {})[t] = "+=0.1", r.paused = !0, r.stagger = 0, r), n || {})),
                            s = function(e, n, r) {
                                return i.resetTo(t, e, n, r)
                            };
                        return s.tween = i, s
                    },
                    isTweening: function(e) {
                        return I.getTweensOf(e, !0).length > 0
                    },
                    defaults: function(e) {
                        return e && e.ease && (e.ease = tG(e.ease, N.ease)), ek(N, e || {})
                    },
                    config: function(e) {
                        return ek(O, e || {})
                    },
                    registerEffect: function(e) {
                        var t = e.name,
                            n = e.effect,
                            r = e.plugins,
                            i = e.defaults,
                            s = e.extendTimeline;
                        (r || "").split(",").forEach(function(e) {
                            return e && !ey[e] && !ea[e] && ec(t + " effect requires " + e + " plugin.")
                        }), ex[t] = function(e, t, r) {
                            return n(tl(e), eU(t || {}, i), r)
                        }, s && (tX.prototype[t] = function(e, n, r) {
                            return this.add(ex[t](e, Y(n) ? n : (r = n) && {}, this), r)
                        })
                    },
                    registerEase: function(e, t) {
                        tL[e] = tG(t)
                    },
                    parseEase: function(e, t) {
                        return arguments.length ? tG(e, t) : tL
                    },
                    getById: function(e) {
                        return I.getById(e)
                    },
                    exportRoot: function(e, t) {
                        void 0 === e && (e = {});
                        var n, r, i = new tX(e);
                        for (i.smoothChildTiming = X(e.smoothChildTiming), I.remove(i), i._dp = 0, i._time = i._tTime = I._time, n = I._first; n;) r = n._next, (t || !(!n._dur && n instanceof nn && n.vars.onComplete === n._targets[0])) && e1(i, n, n._start - n._delay), n = r;
                        return e1(I, i, 0), i
                    },
                    context: function(e, t) {
                        return e ? new nw(e, t) : S
                    },
                    matchMedia: function(e) {
                        return new nC(e)
                    },
                    matchMediaRefresh: function() {
                        return nm.forEach(function(e) {
                            var t, n, r = e.conditions;
                            for (n in r) r[n] && (r[n] = !1, t = 1);
                            t && e.revert()
                        }) || nb()
                    },
                    addEventListener: function(e, t) {
                        var n = nv[e] || (nv[e] = []);
                        ~n.indexOf(t) || n.push(t)
                    },
                    removeEventListener: function(e, t) {
                        var n = nv[e],
                            r = n && n.indexOf(t);
                        r >= 0 && n.splice(r, 1)
                    },
                    utils: {
                        wrap: function e(t, n, r) {
                            var i = n - t;
                            return Z(t) ? tg(t, e(0, t.length), n) : tr(r, function(e) {
                                return (i + (e - t) % i) % i + t
                            })
                        },
                        wrapYoyo: function e(t, n, r) {
                            var i = n - t,
                                s = 2 * i;
                            return Z(t) ? tg(t, e(0, t.length - 1), n) : tr(r, function(e) {
                                return e = (s + (e - t) % s) % s || 0, t + (e > i ? s - e : e)
                            })
                        },
                        distribute: th,
                        random: tp,
                        snap: tf,
                        normalize: function(e, t, n) {
                            return tm(e, t, 0, 1, n)
                        },
                        getUnit: ts,
                        clamp: function(e, t, n) {
                            return tr(n, function(n) {
                                return ti(e, t, n)
                            })
                        },
                        splitColor: tC,
                        toArray: tl,
                        selector: tu,
                        mapRange: tm,
                        pipe: function() {
                            for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                            return function(e) {
                                return t.reduce(function(e, t) {
                                    return t(e)
                                }, e)
                            }
                        },
                        unitize: function(e, t) {
                            return function(n) {
                                return e(parseFloat(n)) + (t || ts(n))
                            }
                        },
                        interpolate: function e(t, n, r, i) {
                            var s = isNaN(t + n) ? 0 : function(e) {
                                return (1 - e) * t + e * n
                            };
                            if (!s) {
                                var a, o, l, u, c, h = H(t),
                                    d = {};
                                if (!0 === r && (i = 1) && (r = null), h) t = {
                                    p: t
                                }, n = {
                                    p: n
                                };
                                else if (Z(t) && !Z(n)) {
                                    for (o = 1, l = [], c = (u = t.length) - 2; o < u; o++) l.push(e(t[o - 1], t[o]));
                                    u--, s = function(e) {
                                        var t = Math.min(c, ~~(e *= u));
                                        return l[t](e - t)
                                    }, r = n
                                } else i || (t = eF(Z(t) ? [] : {}, t));
                                if (!l) {
                                    for (a in n) t2.call(d, t, a, "get", n[a]);
                                    s = function(e) {
                                        return nh(e, d) || (h ? t.p : t)
                                    }
                                }
                            }
                            return tr(r, s)
                        },
                        shuffle: tc
                    },
                    install: el,
                    effects: ex,
                    ticker: tR,
                    updateRoot: tX.updateRoot,
                    plugins: ey,
                    globalTimeline: I,
                    core: {
                        PropTween: nA,
                        globals: eh,
                        Tween: nn,
                        Timeline: tX,
                        Animation: tY,
                        getCache: eC,
                        _removeLinkedListItem: eV,
                        reverting: function() {
                            return C
                        },
                        context: function(e) {
                            return e && S && (S.data.push(e), e._ctx = S), S
                        },
                        suppressOverwrites: function(e) {
                            return w = e
                        }
                    }
                };
            eI("to,from,fromTo,delayedCall,set,killTweensOf", function(e) {
                return nS[e] = nn[e]
            }), tR.add(tX.updateRoot), L = nS.to({}, {
                duration: 0
            });
            var nI = function(e, t) {
                    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
                    return n
                },
                nM = function(e, t) {
                    var n, r, i, s = e._targets;
                    for (n in t)
                        for (r = s.length; r--;)(i = e._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = nI(i, n)), i && i.modifier && i.modifier(t[n], e, s[r], n))
                },
                nT = function(e, t) {
                    return {
                        name: e,
                        headless: 1,
                        rawVars: 1,
                        init: function(e, n, r) {
                            r._onInit = function(e) {
                                var r, i;
                                if (H(n) && (r = {}, eI(n, function(e) {
                                        return r[e] = 1
                                    }), n = r), t) {
                                    for (i in r = {}, n) r[i] = t(n[i]);
                                    n = r
                                }
                                nM(e, n)
                            }
                        }
                    }
                },
                nB = nS.registerPlugin({
                    name: "attr",
                    init: function(e, t, n, r, i) {
                        var s, a, o;
                        for (s in this.tween = n, t) o = e.getAttribute(s) || "", (a = this.add(e, "setAttribute", (o || 0) + "", t[s], r, i, 0, 0, s)).op = s, a.b = o, this._props.push(s)
                    },
                    render: function(e, t) {
                        for (var n = t._pt; n;) C ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next
                    }
                }, {
                    name: "endArray",
                    headless: 1,
                    init: function(e, t) {
                        for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
                    }
                }, nT("roundProps", td), nT("modifiers"), nT("snap", tf)) || nS;
            nn.version = tX.version = nB.version = "3.13.0", R = 1, q() && tD(), tL.Power0, tL.Power1, tL.Power2, tL.Power3, tL.Power4, tL.Linear, tL.Quad, tL.Cubic, tL.Quart, tL.Quint, tL.Strong, tL.Elastic, tL.Back, tL.SteppedEase, tL.Bounce, tL.Sine, tL.Expo, tL.Circ;
            var nR, nD, nL, nP, nO, nN, nU, nF = {},
                nk = 180 / Math.PI,
                nQ = Math.PI / 180,
                nG = Math.atan2,
                nz = /([A-Z])/g,
                nH = /(left|right|width|margin|padding|x)/i,
                nV = /[\s,\(]\S/,
                nj = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                nW = function(e, t) {
                    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
                },
                nY = function(e, t) {
                    return t.set(t.t, t.p, 1 === e ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
                },
                nX = function(e, t) {
                    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
                },
                nq = function(e, t) {
                    var n = t.s + t.c * e;
                    t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
                },
                nK = function(e, t) {
                    return t.set(t.t, t.p, e ? t.e : t.b, t)
                },
                nJ = function(e, t) {
                    return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
                },
                nZ = function(e, t, n) {
                    return e.style[t] = n
                },
                n$ = function(e, t, n) {
                    return e.style.setProperty(t, n)
                },
                n0 = function(e, t, n) {
                    return e._gsap[t] = n
                },
                n1 = function(e, t, n) {
                    return e._gsap.scaleX = e._gsap.scaleY = n
                },
                n2 = function(e, t, n, r, i) {
                    var s = e._gsap;
                    s.scaleX = s.scaleY = n, s.renderTransform(i, s)
                },
                n3 = function(e, t, n, r, i) {
                    var s = e._gsap;
                    s[t] = n, s.renderTransform(i, s)
                },
                n4 = "transform",
                n5 = n4 + "Origin",
                n6 = function e(t, n) {
                    var r = this,
                        i = this.target,
                        s = i.style,
                        a = i._gsap;
                    if (t in nF && s) {
                        if (this.tfm = this.tfm || {}, "transform" === t) return nj.transform.split(",").forEach(function(t) {
                            return e.call(r, t, n)
                        });
                        if (~(t = nj[t] || t).indexOf(",") ? t.split(",").forEach(function(e) {
                                return r.tfm[e] = rp(i, e)
                            }) : this.tfm[t] = a.x ? a[t] : rp(i, t), t === n5 && (this.tfm.zOrigin = a.zOrigin), this.props.indexOf(n4) >= 0) return;
                        a.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(n5, n, "")), t = n4
                    }(s || n) && this.props.push(t, n, s[t])
                },
                n8 = function(e) {
                    e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
                },
                n9 = function() {
                    var e, t, n = this.props,
                        r = this.target,
                        i = r.style,
                        s = r._gsap;
                    for (e = 0; e < n.length; e += 3) n[e + 1] ? 2 === n[e + 1] ? r[n[e]](n[e + 2]) : r[n[e]] = n[e + 2] : n[e + 2] ? i[n[e]] = n[e + 2] : i.removeProperty("--" === n[e].substr(0, 2) ? n[e] : n[e].replace(nz, "-$1").toLowerCase());
                    if (this.tfm) {
                        for (t in this.tfm) s[t] = this.tfm[t];
                        s.svg && (s.renderTransform(), r.setAttribute("data-svg-origin", this.svgo || "")), (e = nN()) && e.isStart || i[n4] || (n8(i), s.zOrigin && i[n5] && (i[n5] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1)
                    }
                },
                n7 = function(e, t) {
                    var n = {
                        target: e,
                        props: [],
                        revert: n9,
                        save: n6
                    };
                    return e._gsap || nB.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(e) {
                        return n.save(e)
                    }), n
                },
                re = function(e, t) {
                    var n = nR.createElementNS ? nR.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : nR.createElement(e);
                    return n && n.style ? n : nR.createElement(e)
                },
                rt = function e(t, n, r) {
                    var i = getComputedStyle(t);
                    return i[n] || i.getPropertyValue(n.replace(nz, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && e(t, rr(n) || n, 1) || ""
                },
                rn = "O,Moz,ms,Ms,Webkit".split(","),
                rr = function(e, t, n) {
                    var r = (t || nP).style,
                        i = 5;
                    if (e in r && !n) return e;
                    for (e = e.charAt(0).toUpperCase() + e.substr(1); i-- && !(rn[i] + e in r););
                    return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? rn[i] : "") + e
                },
                ri = function() {
                    "undefined" != typeof window && window.document && (nD = (nR = window.document).documentElement, nP = re("div") || {
                        style: {}
                    }, re("div"), n5 = (n4 = rr(n4)) + "Origin", nP.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", nU = !!rr("perspective"), nN = nB.core.reverting, nL = 1)
                },
                rs = function(e) {
                    var t, n = e.ownerSVGElement,
                        r = re("svg", n && n.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        i = e.cloneNode(!0);
                    i.style.display = "block", r.appendChild(i), nD.appendChild(r);
                    try {
                        t = i.getBBox()
                    } catch (e) {}
                    return r.removeChild(i), nD.removeChild(r), t
                },
                ra = function(e, t) {
                    for (var n = t.length; n--;)
                        if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
                },
                ro = function(e) {
                    var t, n;
                    try {
                        t = e.getBBox()
                    } catch (r) {
                        t = rs(e), n = 1
                    }
                    return t && (t.width || t.height) || n || (t = rs(e)), !t || t.width || t.x || t.y ? t : {
                        x: +ra(e, ["x", "cx", "x1"]) || 0,
                        y: +ra(e, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    }
                },
                rl = function(e) {
                    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && ro(e))
                },
                ru = function(e, t) {
                    if (t) {
                        var n, r = e.style;
                        t in nF && t !== n5 && (t = n4), r.removeProperty ? (("ms" === (n = t.substr(0, 2)) || "webkit" === t.substr(0, 6)) && (t = "-" + t), r.removeProperty("--" === n ? t : t.replace(nz, "-$1").toLowerCase())) : r.removeAttribute(t)
                    }
                },
                rc = function(e, t, n, r, i, s) {
                    var a = new nA(e._pt, t, n, 0, 1, s ? nJ : nK);
                    return e._pt = a, a.b = r, a.e = i, e._props.push(n), a
                },
                rh = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                rd = {
                    grid: 1,
                    flex: 1
                },
                rf = function e(t, n, r, i) {
                    var s, a, o, l, u = parseFloat(r) || 0,
                        c = (r + "").trim().substr((u + "").length) || "px",
                        h = nP.style,
                        d = nH.test(n),
                        f = "svg" === t.tagName.toLowerCase(),
                        p = (f ? "client" : "offset") + (d ? "Width" : "Height"),
                        g = "px" === i,
                        A = "%" === i;
                    if (i === c || !u || rh[i] || rh[c]) return u;
                    if ("px" === c || g || (u = e(t, n, r, "px")), l = t.getCTM && rl(t), (A || "%" === c) && (nF[n] || ~n.indexOf("adius"))) return s = l ? t.getBBox()[d ? "width" : "height"] : t[p], eM(A ? u / s * 100 : u / 100 * s);
                    if (h[d ? "width" : "height"] = 100 + (g ? c : i), a = "rem" !== i && ~n.indexOf("adius") || "em" === i && t.appendChild && !f ? t : t.parentNode, l && (a = (t.ownerSVGElement || {}).parentNode), a && a !== nR && a.appendChild || (a = nR.body), (o = a._gsap) && A && o.width && d && o.time === tR.time && !o.uncache) return eM(u / o.width * 100);
                    if (A && ("height" === n || "width" === n)) {
                        var m = t.style[n];
                        t.style[n] = 100 + i, s = t[p], m ? t.style[n] = m : ru(t, n)
                    } else(A || "%" === c) && !rd[rt(a, "display")] && (h.position = rt(t, "position")), a === t && (h.position = "static"), a.appendChild(nP), s = nP[p], a.removeChild(nP), h.position = "absolute";
                    return d && A && ((o = eC(a)).time = tR.time, o.width = a[p]), eM(g ? s * u / 100 : s && u ? 100 / s * u : 0)
                },
                rp = function(e, t, n, r) {
                    var i;
                    return nL || ri(), t in nj && "transform" !== t && ~(t = nj[t]).indexOf(",") && (t = t.split(",")[0]), nF[t] && "transform" !== t ? (i = rS(e, r), i = "transformOrigin" !== t ? i[t] : i.svg ? i.origin : rI(rt(e, n5)) + " " + i.zOrigin + "px") : (!(i = e.style[t]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = ry[t] && ry[t](e, t, n) || rt(e, t) || eS(e, t) || ("opacity" === t ? 1 : 0)), n && !~(i + "").trim().indexOf(" ") ? rf(e, t, i, n) + n : i
                },
                rg = function(e, t, n, r) {
                    if (!n || "none" === n) {
                        var i = rr(t, e, 1),
                            s = i && rt(e, i, 1);
                        s && s !== n ? (t = i, n = s) : "borderColor" === t && (n = rt(e, "borderTopColor"))
                    }
                    var a, o, l, u, c, h, d, f, p, g, A, m = new nA(this._pt, e.style, t, 0, 1, nc),
                        v = 0,
                        y = 0;
                    if (m.b = n, m.e = r, n += "", "var(--" === (r += "").substring(0, 6) && (r = rt(e, r.substring(4, r.indexOf(")")))), "auto" === r && (h = e.style[t], e.style[t] = r, r = rt(e, t) || r, h ? e.style[t] = h : ru(e, t)), tB(a = [n, r]), n = a[0], r = a[1], l = n.match(et) || [], (r.match(et) || []).length) {
                        for (; o = et.exec(r);) d = o[0], p = r.substring(v, o.index), c ? c = (c + 1) % 5 : ("rgba(" === p.substr(-5) || "hsla(" === p.substr(-5)) && (c = 1), d !== (h = l[y++] || "") && (u = parseFloat(h) || 0, A = h.substr((u + "").length), "=" === d.charAt(1) && (d = eB(u, d) + A), f = parseFloat(d), g = d.substr((f + "").length), v = et.lastIndex - g.length, g || (g = g || O.units[t] || A, v !== r.length || (r += g, m.e += g)), A !== g && (u = rf(e, t, h, g) || 0), m._pt = {
                            _next: m._pt,
                            p: p || 1 === y ? p : ",",
                            s: u,
                            c: f - u,
                            m: c && c < 4 || "zIndex" === t ? Math.round : 0
                        });
                        m.c = v < r.length ? r.substring(v, r.length) : ""
                    } else m.r = "display" === t && "none" === r ? nJ : nK;
                    return er.test(r) && (m.e = 0), this._pt = m, m
                },
                rA = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                rm = function(e) {
                    var t = e.split(" "),
                        n = t[0],
                        r = t[1] || "50%";
                    return ("top" === n || "bottom" === n || "left" === r || "right" === r) && (e = n, n = r, r = e), t[0] = rA[n] || n, t[1] = rA[r] || r, t.join(" ")
                },
                rv = function(e, t) {
                    if (t.tween && t.tween._time === t.tween._dur) {
                        var n, r, i, s = t.t,
                            a = s.style,
                            o = t.u,
                            l = s._gsap;
                        if ("all" === o || !0 === o) a.cssText = "", r = 1;
                        else
                            for (i = (o = o.split(",")).length; --i > -1;) nF[n = o[i]] && (r = 1, n = "transformOrigin" === n ? n5 : n4), ru(s, n);
                        r && (ru(s, n4), l && (l.svg && s.removeAttribute("transform"), a.scale = a.rotate = a.translate = "none", rS(s, 1), l.uncache = 1, n8(a)))
                    }
                },
                ry = {
                    clearProps: function(e, t, n, r, i) {
                        if ("isFromStart" !== i.data) {
                            var s = e._pt = new nA(e._pt, t, n, 0, 0, rv);
                            return s.u = r, s.pr = -10, s.tween = i, e._props.push(n), 1
                        }
                    }
                },
                rx = [1, 0, 0, 1, 0, 0],
                rE = {},
                r_ = function(e) {
                    return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
                },
                rb = function(e) {
                    var t = rt(e, n4);
                    return r_(t) ? rx : t.substr(7).match(ee).map(eM)
                },
                rw = function(e, t) {
                    var n, r, i, s, a = e._gsap || eC(e),
                        o = e.style,
                        l = rb(e);
                    return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(i = e.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? rx : l : (l !== rx || e.offsetParent || e === nD || a.svg || (i = o.display, o.display = "block", (n = e.parentNode) && (e.offsetParent || e.getBoundingClientRect().width) || (s = 1, r = e.nextElementSibling, nD.appendChild(e)), l = rb(e), i ? o.display = i : ru(e, "display"), s && (r ? n.insertBefore(e, r) : n ? n.appendChild(e) : nD.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
                },
                rC = function(e, t, n, r, i, s) {
                    var a, o, l, u, c = e._gsap,
                        h = i || rw(e, !0),
                        d = c.xOrigin || 0,
                        f = c.yOrigin || 0,
                        p = c.xOffset || 0,
                        g = c.yOffset || 0,
                        A = h[0],
                        m = h[1],
                        v = h[2],
                        y = h[3],
                        x = h[4],
                        E = h[5],
                        _ = t.split(" "),
                        b = parseFloat(_[0]) || 0,
                        w = parseFloat(_[1]) || 0;
                    n ? h !== rx && (o = A * y - m * v) && (l = y / o * b + -v / o * w + (v * E - y * x) / o, u = -m / o * b + A / o * w - (A * E - m * x) / o, b = l, w = u) : (b = (a = ro(e)).x + (~_[0].indexOf("%") ? b / 100 * a.width : b), w = a.y + (~(_[1] || _[0]).indexOf("%") ? w / 100 * a.height : w)), r || !1 !== r && c.smooth ? (x = b - d, E = w - f, c.xOffset = p + (x * A + E * v) - x, c.yOffset = g + (x * m + E * y) - E) : c.xOffset = c.yOffset = 0, c.xOrigin = b, c.yOrigin = w, c.smooth = !!r, c.origin = t, c.originIsAbsolute = !!n, e.style[n5] = "0px 0px", s && (rc(s, c, "xOrigin", d, b), rc(s, c, "yOrigin", f, w), rc(s, c, "xOffset", p, c.xOffset), rc(s, c, "yOffset", g, c.yOffset)), e.setAttribute("data-svg-origin", b + " " + w)
                },
                rS = function(e, t) {
                    var n = e._gsap || new tW(e);
                    if ("x" in n && !t && !n.uncache) return n;
                    var r, i, s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x, E, _, b, w, C, S, I, M, T, B, R, D, L, P, N = e.style,
                        U = n.scaleX < 0,
                        F = getComputedStyle(e),
                        k = rt(e, n5) || "0";
                    return r = i = s = l = u = c = h = d = f = 0, a = o = 1, n.svg = !!(e.getCTM && rl(e)), F.translate && (("none" !== F.translate || "none" !== F.scale || "none" !== F.rotate) && (N[n4] = ("none" !== F.translate ? "translate3d(" + (F.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== F.rotate ? "rotate(" + F.rotate + ") " : "") + ("none" !== F.scale ? "scale(" + F.scale.split(" ").join(",") + ") " : "") + ("none" !== F[n4] ? F[n4] : "")), N.scale = N.rotate = N.translate = "none"), A = rw(e, n.svg), n.svg && (n.uncache ? (I = e.getBBox(), k = n.xOrigin - I.x + "px " + (n.yOrigin - I.y) + "px", S = "") : S = !t && e.getAttribute("data-svg-origin"), rC(e, S || k, !!S || n.originIsAbsolute, !1 !== n.smooth, A)), p = n.xOrigin || 0, g = n.yOrigin || 0, A !== rx && (x = A[0], E = A[1], _ = A[2], b = A[3], r = w = A[4], i = C = A[5], 6 === A.length ? (a = Math.sqrt(x * x + E * E), o = Math.sqrt(b * b + _ * _), l = x || E ? nG(E, x) * nk : 0, (h = _ || b ? nG(_, b) * nk + l : 0) && (o *= Math.abs(Math.cos(h * nQ))), n.svg && (r -= p - (p * x + g * _), i -= g - (p * E + g * b))) : (P = A[6], D = A[7], T = A[8], B = A[9], R = A[10], L = A[11], r = A[12], i = A[13], s = A[14], u = (m = nG(P, R)) * nk, m && (S = w * (v = Math.cos(-m)) + T * (y = Math.sin(-m)), I = C * v + B * y, M = P * v + R * y, T = -(w * y) + T * v, B = -(C * y) + B * v, R = -(P * y) + R * v, L = -(D * y) + L * v, w = S, C = I, P = M), c = (m = nG(-_, R)) * nk, m && (S = x * (v = Math.cos(-m)) - T * (y = Math.sin(-m)), I = E * v - B * y, M = _ * v - R * y, L = b * y + L * v, x = S, E = I, _ = M), l = (m = nG(E, x)) * nk, m && (S = x * (v = Math.cos(m)) + E * (y = Math.sin(m)), I = w * v + C * y, E = E * v - x * y, C = C * v - w * y, x = S, w = I), u && Math.abs(u) + Math.abs(l) > 359.9 && (u = l = 0, c = 180 - c), a = eM(Math.sqrt(x * x + E * E + _ * _)), o = eM(Math.sqrt(C * C + P * P)), h = Math.abs(m = nG(w, C)) > 2e-4 ? m * nk : 0, f = L ? 1 / (L < 0 ? -L : L) : 0), n.svg && (S = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !r_(rt(e, n4)), S && e.setAttribute("transform", S))), Math.abs(h) > 90 && 270 > Math.abs(h) && (U ? (a *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, h += h <= 0 ? 180 : -180)), t = t || n.uncache, n.x = r - ((n.xPercent = r && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + "px", n.y = i - ((n.yPercent = i && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + "px", n.z = s + "px", n.scaleX = eM(a), n.scaleY = eM(o), n.rotation = eM(l) + "deg", n.rotationX = eM(u) + "deg", n.rotationY = eM(c) + "deg", n.skewX = h + "deg", n.skewY = d + "deg", n.transformPerspective = f + "px", (n.zOrigin = parseFloat(k.split(" ")[2]) || !t && n.zOrigin || 0) && (N[n5] = rI(k)), n.xOffset = n.yOffset = 0, n.force3D = O.force3D, n.renderTransform = n.svg ? rD : nU ? rR : rT, n.uncache = 0, n
                },
                rI = function(e) {
                    return (e = e.split(" "))[0] + " " + e[1]
                },
                rM = function(e, t, n) {
                    var r = ts(t);
                    return eM(parseFloat(t) + parseFloat(rf(e, "x", n + "px", r))) + r
                },
                rT = function(e, t) {
                    t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, rR(e, t)
                },
                rB = "0deg",
                rR = function(e, t) {
                    var n = t || this,
                        r = n.xPercent,
                        i = n.yPercent,
                        s = n.x,
                        a = n.y,
                        o = n.z,
                        l = n.rotation,
                        u = n.rotationY,
                        c = n.rotationX,
                        h = n.skewX,
                        d = n.skewY,
                        f = n.scaleX,
                        p = n.scaleY,
                        g = n.transformPerspective,
                        A = n.force3D,
                        m = n.target,
                        v = n.zOrigin,
                        y = "",
                        x = "auto" === A && e && 1 !== e || !0 === A;
                    if (v && (c !== rB || u !== rB)) {
                        var E, _ = parseFloat(u) * nQ,
                            b = Math.sin(_),
                            w = Math.cos(_);
                        s = rM(m, s, -(b * (E = Math.cos(_ = parseFloat(c) * nQ)) * v)), a = rM(m, a, -(-Math.sin(_) * v)), o = rM(m, o, -(w * E * v) + v)
                    }
                    "0px" !== g && (y += "perspective(" + g + ") "), (r || i) && (y += "translate(" + r + "%, " + i + "%) "), (x || "0px" !== s || "0px" !== a || "0px" !== o) && (y += "0px" !== o || x ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + ") "), l !== rB && (y += "rotate(" + l + ") "), u !== rB && (y += "rotateY(" + u + ") "), c !== rB && (y += "rotateX(" + c + ") "), (h !== rB || d !== rB) && (y += "skew(" + h + ", " + d + ") "), (1 !== f || 1 !== p) && (y += "scale(" + f + ", " + p + ") "), m.style[n4] = y || "translate(0, 0)"
                },
                rD = function(e, t) {
                    var n, r, i, s, a, o = t || this,
                        l = o.xPercent,
                        u = o.yPercent,
                        c = o.x,
                        h = o.y,
                        d = o.rotation,
                        f = o.skewX,
                        p = o.skewY,
                        g = o.scaleX,
                        A = o.scaleY,
                        m = o.target,
                        v = o.xOrigin,
                        y = o.yOrigin,
                        x = o.xOffset,
                        E = o.yOffset,
                        _ = o.forceCSS,
                        b = parseFloat(c),
                        w = parseFloat(h);
                    d = parseFloat(d), f = parseFloat(f), (p = parseFloat(p)) && (f += p = parseFloat(p), d += p), d || f ? (d *= nQ, f *= nQ, n = Math.cos(d) * g, r = Math.sin(d) * g, i = -(Math.sin(d - f) * A), s = Math.cos(d - f) * A, f && (p *= nQ, i *= a = Math.sqrt(1 + (a = Math.tan(f - p)) * a), s *= a, p && (n *= a = Math.sqrt(1 + (a = Math.tan(p)) * a), r *= a)), n = eM(n), r = eM(r), i = eM(i), s = eM(s)) : (n = g, s = A, r = i = 0), (b && !~(c + "").indexOf("px") || w && !~(h + "").indexOf("px")) && (b = rf(m, "x", c, "px"), w = rf(m, "y", h, "px")), (v || y || x || E) && (b = eM(b + v - (v * n + y * i) + x), w = eM(w + y - (v * r + y * s) + E)), (l || u) && (b = eM(b + l / 100 * (a = m.getBBox()).width), w = eM(w + u / 100 * a.height)), a = "matrix(" + n + "," + r + "," + i + "," + s + "," + b + "," + w + ")", m.setAttribute("transform", a), _ && (m.style[n4] = a)
                },
                rL = function(e, t, n, r, i) {
                    var s, a, o = H(i),
                        l = parseFloat(i) * (o && ~i.indexOf("rad") ? nk : 1) - r,
                        u = r + l + "deg";
                    return o && ("short" === (s = i.split("_")[1]) && (l %= 360) != l % 180 && (l += l < 0 ? 360 : -360), "cw" === s && l < 0 ? l = (l + 36e9) % 360 - 360 * ~~(l / 360) : "ccw" === s && l > 0 && (l = (l - 36e9) % 360 - 360 * ~~(l / 360))), e._pt = a = new nA(e._pt, t, n, r, l, nY), a.e = u, a.u = "deg", e._props.push(n), a
                },
                rP = function(e, t) {
                    for (var n in t) e[n] = t[n];
                    return e
                },
                rO = function(e, t, n) {
                    var r, i, s, a, o, l, u, c = rP({}, n._gsap),
                        h = n.style;
                    for (i in c.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), h[n4] = t, r = rS(n, 1), ru(n, n4), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[n4], h[n4] = t, r = rS(n, 1), h[n4] = s), nF)(s = c[i]) !== (a = r[i]) && 0 > "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) && (o = ts(s) !== (u = ts(a)) ? rf(n, i, s, u) : parseFloat(s), l = parseFloat(a), e._pt = new nA(e._pt, r, i, o, l - o, nW), e._pt.u = u || 0, e._props.push(i));
                    rP(r, c)
                };
            eI("padding,margin,Width,Radius", function(e, t) {
                var n = "Right",
                    r = "Bottom",
                    i = "Left",
                    s = (t < 3 ? ["Top", n, r, i] : ["Top" + i, "Top" + n, r + n, r + i]).map(function(n) {
                        return t < 2 ? e + n : "border" + n + e
                    });
                ry[t > 1 ? "border" + e : e] = function(e, t, n, r, i) {
                    var a, o;
                    if (arguments.length < 4) return 5 === (o = (a = s.map(function(t) {
                        return rp(e, t, n)
                    })).join(" ")).split(a[0]).length ? a[0] : o;
                    a = (r + "").split(" "), o = {}, s.forEach(function(e, t) {
                        return o[e] = a[t] = a[t] || a[(t - 1) / 2 | 0]
                    }), e.init(t, o, i)
                }
            });
            var rN = {
                name: "css",
                register: ri,
                targetTest: function(e) {
                    return e.style && e.nodeType
                },
                init: function(e, t, n, r, i) {
                    var s, a, o, l, u, c, h, d, f, p, g, A, m, v, y, x, E = this._props,
                        _ = e.style,
                        b = n.vars.startAt;
                    for (h in nL || ri(), this.styles = this.styles || n7(e), x = this.styles.props, this.tween = n, t)
                        if ("autoRound" !== h && (a = t[h], !(ey[h] && t4(h, t, n, r, e, i)))) {
                            if (u = typeof a, c = ry[h], "function" === u && (u = typeof(a = a.call(n, r, e, i))), "string" === u && ~a.indexOf("random(") && (a = tA(a)), c) c(this, e, h, a, n) && (y = 1);
                            else if ("--" === h.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(h) + "").trim(), a += "", tM.lastIndex = 0, tM.test(s) || (d = ts(s), f = ts(a)), f ? d !== f && (s = rf(e, h, s, f) + f) : d && (a += d), this.add(_, "setProperty", s, a, r, i, 0, 0, h), E.push(h), x.push(h, 0, _[h]);
                            else if ("undefined" !== u) {
                                if (b && h in b ? (H(s = "function" == typeof b[h] ? b[h].call(n, r, e, i) : b[h]) && ~s.indexOf("random(") && (s = tA(s)), ts(s + "") || "auto" === s || (s += O.units[h] || ts(rp(e, h)) || ""), "=" === (s + "").charAt(1) && (s = rp(e, h))) : s = rp(e, h), l = parseFloat(s), (p = "string" === u && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)), o = parseFloat(a), h in nj && ("autoAlpha" === h && (1 === l && "hidden" === rp(e, "visibility") && o && (l = 0), x.push("visibility", 0, _.visibility), rc(this, _, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== h && "transform" !== h && ~(h = nj[h]).indexOf(",") && (h = h.split(",")[0])), g = h in nF) {
                                    if (this.styles.save(h), "string" === u && "var(--" === a.substring(0, 6) && (o = parseFloat(a = rt(e, a.substring(4, a.indexOf(")"))))), A || ((m = e._gsap).renderTransform && !t.parseTransform || rS(e, t.parseTransform), v = !1 !== t.smoothOrigin && m.smooth, (A = this._pt = new nA(this._pt, _, n4, 0, 1, m.renderTransform, m, 0, -1)).dep = 1), "scale" === h) this._pt = new nA(this._pt, m, "scaleY", m.scaleY, (p ? eB(m.scaleY, p + o) : o) - m.scaleY || 0, nW), this._pt.u = 0, E.push("scaleY", h), h += "X";
                                    else if ("transformOrigin" === h) {
                                        x.push(n5, 0, _[n5]), a = rm(a), m.svg ? rC(e, a, 0, v, 0, this) : ((f = parseFloat(a.split(" ")[2]) || 0) !== m.zOrigin && rc(this, m, "zOrigin", m.zOrigin, f), rc(this, _, h, rI(s), rI(a)));
                                        continue
                                    } else if ("svgOrigin" === h) {
                                        rC(e, a, 1, v, 0, this);
                                        continue
                                    } else if (h in rE) {
                                        rL(this, m, h, l, p ? eB(l, p + a) : a);
                                        continue
                                    } else if ("smoothOrigin" === h) {
                                        rc(this, m, "smooth", m.smooth, a);
                                        continue
                                    } else if ("force3D" === h) {
                                        m[h] = a;
                                        continue
                                    } else if ("transform" === h) {
                                        rO(this, a, e);
                                        continue
                                    }
                                } else h in _ || (h = rr(h) || h);
                                if (g || (o || 0 === o) && (l || 0 === l) && !nV.test(a) && h in _) d = (s + "").substr((l + "").length), o || (o = 0), f = ts(a) || (h in O.units ? O.units[h] : d), d !== f && (l = rf(e, h, s, f)), this._pt = new nA(this._pt, g ? m : _, h, l, (p ? eB(l, p + o) : o) - l, g || "px" !== f && "zIndex" !== h || !1 === t.autoRound ? nW : nq), this._pt.u = f || 0, d !== f && "%" !== f && (this._pt.b = s, this._pt.r = nX);
                                else if (h in _) rg.call(this, e, h, s, p ? p + a : a);
                                else if (h in e) this.add(e, h, s || e[h], p ? p + a : a, r, i);
                                else if ("parseTransform" !== h) {
                                    eu(h, a);
                                    continue
                                }
                                g || (h in _ ? x.push(h, 0, _[h]) : "function" == typeof e[h] ? x.push(h, 2, e[h]()) : x.push(h, 1, s || e[h])), E.push(h)
                            }
                        }
                    y && ng(this)
                },
                render: function(e, t) {
                    if (t.tween._time || !nN())
                        for (var n = t._pt; n;) n.r(e, n.d), n = n._next;
                    else t.styles.revert()
                },
                get: rp,
                aliases: nj,
                getSetter: function(e, t, n) {
                    var r = nj[t];
                    return r && 0 > r.indexOf(",") && (t = r), t in nF && t !== n5 && (e._gsap.x || rp(e, "x")) ? n && nO === n ? "scale" === t ? n1 : n0 : (nO = n || {}, "scale" === t ? n2 : n3) : e.style && !W(e.style[t]) ? nZ : ~t.indexOf("-") ? n$ : no(e, t)
                },
                core: {
                    _removeProperty: ru,
                    _getMatrix: rw
                }
            };
            nB.utils.checkPrefix = rr, nB.core.getStyleSaver = n7, o = "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", l = eI((s = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (a = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(e) {
                nF[e] = 1
            }), eI(a, function(e) {
                O.units[e] = "deg", rE[e] = 1
            }), nj[l[13]] = s + "," + a, eI(o, function(e) {
                var t = e.split(":");
                nj[t[1]] = l[t[0]]
            }), eI("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(e) {
                O.units[e] = "px"
            }), nB.registerPlugin(rN);
            var rU = nB.registerPlugin(rN) || nB;
            rU.core.Tween
        },
        2535: function(e, t, n) {
            "use strict";
            var r = n(6237),
                i = {
                    childContextTypes: !0,
                    contextType: !0,
                    contextTypes: !0,
                    defaultProps: !0,
                    displayName: !0,
                    getDefaultProps: !0,
                    getDerivedStateFromError: !0,
                    getDerivedStateFromProps: !0,
                    mixins: !0,
                    propTypes: !0,
                    type: !0
                },
                s = {
                    name: !0,
                    length: !0,
                    prototype: !0,
                    caller: !0,
                    callee: !0,
                    arguments: !0,
                    arity: !0
                },
                a = {
                    $$typeof: !0,
                    compare: !0,
                    defaultProps: !0,
                    displayName: !0,
                    propTypes: !0,
                    type: !0
                },
                o = {};

            function l(e) {
                return r.isMemo(e) ? a : o[e.$$typeof] || i
            }
            o[r.ForwardRef] = {
                $$typeof: !0,
                render: !0,
                defaultProps: !0,
                displayName: !0,
                propTypes: !0
            }, o[r.Memo] = a;
            var u = Object.defineProperty,
                c = Object.getOwnPropertyNames,
                h = Object.getOwnPropertySymbols,
                d = Object.getOwnPropertyDescriptor,
                f = Object.getPrototypeOf,
                p = Object.prototype;
            e.exports = function e(t, n, r) {
                if ("string" != typeof n) {
                    if (p) {
                        var i = f(n);
                        i && i !== p && e(t, i, r)
                    }
                    var a = c(n);
                    h && (a = a.concat(h(n)));
                    for (var o = l(t), g = l(n), A = 0; A < a.length; ++A) {
                        var m = a[A];
                        if (!s[m] && !(r && r[m]) && !(g && g[m]) && !(o && o[m])) {
                            var v = d(n, m);
                            try {
                                u(t, m, v)
                            } catch (e) {}
                        }
                    }
                }
                return t
            }
        },
        9365: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES = void 0, t.CASE_SENSITIVE_TAG_NAMES = ["animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"], t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES.reduce(function(e, t) {
                return e[t.toLowerCase()] = t, e
            }, {})
        },
        7968: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function(e) {
                var t, h, d = e.match(a),
                    f = d && d[1] ? d[1].toLowerCase() : "";
                switch (f) {
                    case r:
                        var p = c(e);
                        if (!o.test(e)) {
                            var g = p.querySelector(i);
                            null === (t = null == g ? void 0 : g.parentNode) || void 0 === t || t.removeChild(g)
                        }
                        if (!l.test(e)) {
                            var g = p.querySelector(s);
                            null === (h = null == g ? void 0 : g.parentNode) || void 0 === h || h.removeChild(g)
                        }
                        return p.querySelectorAll(r);
                    case i:
                    case s:
                        var A = u(e).querySelectorAll(f);
                        if (l.test(e) && o.test(e)) return A[0].parentNode.childNodes;
                        return A;
                    default:
                        if (n) return n(e);
                        var g = u(e, s).querySelector(s);
                        return g.childNodes
                }
            };
            var n, r = "html",
                i = "head",
                s = "body",
                a = /<([a-zA-Z]+[0-9]?)/,
                o = /<head[^]*>/i,
                l = /<body[^]*>/i,
                u = function(e, t) {
                    throw Error("This browser does not support `document.implementation.createHTMLDocument`")
                },
                c = function(e, t) {
                    throw Error("This browser does not support `DOMParser.prototype.parseFromString`")
                },
                h = "object" == typeof window && window.DOMParser;
            if ("function" == typeof h) {
                var d = new h;
                u = c = function(e, t) {
                    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), d.parseFromString(e, "text/html")
                }
            }
            if ("object" == typeof document && document.implementation) {
                var f = document.implementation.createHTMLDocument();
                u = function(e, t) {
                    if (t) {
                        var n = f.documentElement.querySelector(t);
                        return n && (n.innerHTML = e), f
                    }
                    return f.documentElement.innerHTML = e, f
                }
            }
            var p = "object" == typeof document && document.createElement("template");
            p && p.content && (n = function(e) {
                return p.innerHTML = e, p.content.childNodes
            })
        },
        3634: function(e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function(e) {
                if ("string" != typeof e) throw TypeError("First argument must be a string");
                if (!e) return [];
                var t = e.match(a),
                    n = t ? t[1] : void 0;
                return (0, s.formatDOM)((0, i.default)(e), null, n)
            };
            var i = r(n(7968)),
                s = n(5141),
                a = /<(![a-zA-Z\s]+)>/
        },
        5141: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.formatAttributes = s, t.formatDOM = function e(t, n, a) {
                void 0 === n && (n = null);
                for (var o, l = [], u = 0, c = t.length; u < c; u++) {
                    var h = t[u];
                    switch (h.nodeType) {
                        case 1:
                            var d = function(e) {
                                var t;
                                return t = e = e.toLowerCase(), i.CASE_SENSITIVE_TAG_NAMES_MAP[t] || e
                            }(h.nodeName);
                            (o = new r.Element(d, s(h.attributes))).children = e("template" === d ? h.content.childNodes : h.childNodes, o);
                            break;
                        case 3:
                            o = new r.Text(h.nodeValue);
                            break;
                        case 8:
                            o = new r.Comment(h.nodeValue);
                            break;
                        default:
                            continue
                    }
                    var f = l[u - 1] || null;
                    f && (f.next = o), o.parent = n, o.prev = f, o.next = null, l.push(o)
                }
                return a && ((o = new r.ProcessingInstruction(a.substring(0, a.indexOf(" ")).toLowerCase(), a)).next = l[0] || null, o.parent = n, l.unshift(o), l[1] && (l[1].prev = l[0])), l
            };
            var r = n(1612),
                i = n(9365);

            function s(e) {
                for (var t = {}, n = 0, r = e.length; n < r; n++) {
                    var i = e[n];
                    t[i.name] = i.value
                }
                return t
            }
        },
        159: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function(e, t) {
                void 0 === e && (e = {});
                var n = {},
                    u = !!(e.type && o[e.type]);
                for (var c in e) {
                    var h = e[c];
                    if ((0, r.isCustomAttribute)(c)) {
                        n[c] = h;
                        continue
                    }
                    var d = c.toLowerCase(),
                        f = l(d);
                    if (f) {
                        var p = (0, r.getPropertyInfo)(f);
                        switch (s.includes(f) && a.includes(t) && !u && (f = l("default" + d)), n[f] = h, p && p.type) {
                            case r.BOOLEAN:
                                n[f] = !0;
                                break;
                            case r.OVERLOADED_BOOLEAN:
                                "" === h && (n[f] = !0)
                        }
                        continue
                    }
                    i.PRESERVE_CUSTOM_ATTRIBUTES && (n[c] = h)
                }
                return (0, i.setStyleProp)(e.style, n), n
            };
            var r = n(7068),
                i = n(7347),
                s = ["checked", "value"],
                a = ["input", "select", "textarea"],
                o = {
                    reset: !0,
                    submit: !0
                };

            function l(e) {
                return r.possibleStandardNames[e]
            }
        },
        6195: function(e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function e(t, n) {
                void 0 === n && (n = {});
                for (var r = [], i = "function" == typeof n.replace, l = n.transform || a.returnFirstArg, u = n.library || o, c = u.cloneElement, h = u.createElement, d = u.isValidElement, f = t.length, p = 0; p < f; p++) {
                    var g = t[p];
                    if (i) {
                        var A = n.replace(g, p);
                        if (d(A)) {
                            f > 1 && (A = c(A, {
                                key: A.key || p
                            })), r.push(l(A, g, p));
                            continue
                        }
                    }
                    if ("text" === g.type) {
                        var m = !g.data.trim().length;
                        if (m && g.parent && !(0, a.canTextBeChildOfNode)(g.parent) || n.trim && m) continue;
                        r.push(l(g.data, g, p));
                        continue
                    }
                    var v = {};
                    a.PRESERVE_CUSTOM_ATTRIBUTES && "tag" === g.type && (0, a.isCustomComponent)(g.name, g.attribs) ? ((0, a.setStyleProp)(g.attribs.style, g.attribs), v = g.attribs) : g.attribs && (v = (0, s.default)(g.attribs, g.name));
                    var y = void 0;
                    switch (g.type) {
                        case "script":
                        case "style":
                            g.children[0] && (v.dangerouslySetInnerHTML = {
                                __html: g.children[0].data
                            });
                            break;
                        case "tag":
                            "textarea" === g.name && g.children[0] ? v.defaultValue = g.children[0].data : g.children && g.children.length && (y = e(g.children, n));
                            break;
                        default:
                            continue
                    }
                    f > 1 && (v.key = p), r.push(l(h(g.name, v, y), g, p))
                }
                return 1 === r.length ? r[0] : r
            };
            var i = n(959),
                s = r(n(159)),
                a = n(7347),
                o = {
                    cloneElement: i.cloneElement,
                    createElement: i.createElement,
                    isValidElement: i.isValidElement
                }
        },
        6913: function(e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.htmlToDOM = t.domToReact = t.attributesToProps = t.Text = t.ProcessingInstruction = t.Element = t.Comment = void 0, t.default = function(e, t) {
                if ("string" != typeof e) throw TypeError("First argument must be a string");
                return e ? (0, a.default)((0, i.default)(e, (null == t ? void 0 : t.htmlparser2) || l), t) : []
            };
            var i = r(n(3634));
            t.htmlToDOM = i.default;
            var s = r(n(159));
            t.attributesToProps = s.default;
            var a = r(n(6195));
            t.domToReact = a.default;
            var o = n(1612);
            Object.defineProperty(t, "Comment", {
                enumerable: !0,
                get: function() {
                    return o.Comment
                }
            }), Object.defineProperty(t, "Element", {
                enumerable: !0,
                get: function() {
                    return o.Element
                }
            }), Object.defineProperty(t, "ProcessingInstruction", {
                enumerable: !0,
                get: function() {
                    return o.ProcessingInstruction
                }
            }), Object.defineProperty(t, "Text", {
                enumerable: !0,
                get: function() {
                    return o.Text
                }
            });
            var l = {
                lowerCaseAttributeNames: !1
            }
        },
        7347: function(e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.returnFirstArg = t.canTextBeChildOfNode = t.ELEMENTS_WITH_NO_TEXT_CHILDREN = t.PRESERVE_CUSTOM_ATTRIBUTES = void 0, t.isCustomComponent = function(e, t) {
                return e.includes("-") ? !a.has(e) : !!(t && "string" == typeof t.is)
            }, t.setStyleProp = function(e, t) {
                if ("string" == typeof e) {
                    if (!e.trim()) {
                        t.style = {};
                        return
                    }
                    try {
                        t.style = (0, s.default)(e, o)
                    } catch (e) {
                        t.style = {}
                    }
                }
            };
            var i = n(959),
                s = r(n(6263)),
                a = new Set(["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"]),
                o = {
                    reactCompat: !0
                };
            t.PRESERVE_CUSTOM_ATTRIBUTES = Number(i.version.split(".")[0]) >= 16, t.ELEMENTS_WITH_NO_TEXT_CHILDREN = new Set(["tr", "tbody", "thead", "tfoot", "colgroup", "table", "head", "html", "frameset"]), t.canTextBeChildOfNode = function(e) {
                return !t.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(e.name)
            }, t.returnFirstArg = function(e) {
                return e
            }
        },
        551: function(e, t) {
            t.read = function(e, t, n, r, i) {
                var s, a, o = 8 * i - r - 1,
                    l = (1 << o) - 1,
                    u = l >> 1,
                    c = -7,
                    h = n ? i - 1 : 0,
                    d = n ? -1 : 1,
                    f = e[t + h];
                for (h += d, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + e[t + h], h += d, c -= 8);
                for (a = s & (1 << -c) - 1, s >>= -c, c += r; c > 0; a = 256 * a + e[t + h], h += d, c -= 8);
                if (0 === s) s = 1 - u;
                else {
                    if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);
                    a += Math.pow(2, r), s -= u
                }
                return (f ? -1 : 1) * a * Math.pow(2, s - r)
            }, t.write = function(e, t, n, r, i, s) {
                var a, o, l, u = 8 * s - i - 1,
                    c = (1 << u) - 1,
                    h = c >> 1,
                    d = 23 === i ? 5960464477539062e-23 : 0,
                    f = r ? 0 : s - 1,
                    p = r ? 1 : -1,
                    g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (isNaN(t = Math.abs(t)) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + h >= 1 ? t += d / l : t += d * Math.pow(2, 1 - h), t * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (t * l - 1) * Math.pow(2, i), a += h) : (o = t * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; e[n + f] = 255 & o, f += p, o /= 256, i -= 8);
                for (a = a << i | o, u += i; u > 0; e[n + f] = 255 & a, f += p, a /= 256, u -= 8);
                e[n + f - p] |= 128 * g
            }
        },
        2640: function(e) {
            var t = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
                n = /\n/g,
                r = /^\s*/,
                i = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
                s = /^:\s*/,
                a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
                o = /^[;\s]*/,
                l = /^\s+|\s+$/g;

            function u(e) {
                return e ? e.replace(l, "") : ""
            }
            e.exports = function(e, l) {
                if ("string" != typeof e) throw TypeError("First argument must be a string");
                if (!e) return [];
                l = l || {};
                var c = 1,
                    h = 1;

                function d(e) {
                    var t = e.match(n);
                    t && (c += t.length);
                    var r = e.lastIndexOf("\n");
                    h = ~r ? e.length - r : h + e.length
                }

                function f() {
                    var e = {
                        line: c,
                        column: h
                    };
                    return function(t) {
                        return t.position = new p(e), m(r), t
                    }
                }

                function p(e) {
                    this.start = e, this.end = {
                        line: c,
                        column: h
                    }, this.source = l.source
                }
                p.prototype.content = e;
                var g = [];

                function A(t) {
                    var n = Error(l.source + ":" + c + ":" + h + ": " + t);
                    if (n.reason = t, n.filename = l.source, n.line = c, n.column = h, n.source = e, l.silent) g.push(n);
                    else throw n
                }

                function m(t) {
                    var n = t.exec(e);
                    if (n) {
                        var r = n[0];
                        return d(r), e = e.slice(r.length), n
                    }
                }

                function v(e) {
                    var t;
                    for (e = e || []; t = y();) !1 !== t && e.push(t);
                    return e
                }

                function y() {
                    var t = f();
                    if ("/" == e.charAt(0) && "*" == e.charAt(1)) {
                        for (var n = 2;
                            "" != e.charAt(n) && ("*" != e.charAt(n) || "/" != e.charAt(n + 1));) ++n;
                        if (n += 2, "" === e.charAt(n - 1)) return A("End of comment missing");
                        var r = e.slice(2, n - 2);
                        return h += 2, d(r), e = e.slice(n), h += 2, t({
                            type: "comment",
                            comment: r
                        })
                    }
                }
                return m(r),
                    function() {
                        var e, n = [];
                        for (v(n); e = function() {
                                var e = f(),
                                    n = m(i);
                                if (n) {
                                    if (y(), !m(s)) return A("property missing ':'");
                                    var r = m(a),
                                        l = e({
                                            type: "declaration",
                                            property: u(n[0].replace(t, "")),
                                            value: r ? u(r[0].replace(t, "")) : ""
                                        });
                                    return m(o), l
                                }
                            }();) !1 !== e && (n.push(e), v(n));
                        return n
                    }()
            }
        },
        7269: function(e, t, n) {
            var r = n(7758)(n(9165), "DataView");
            e.exports = r
        },
        8987: function(e, t, n) {
            var r = n(5075),
                i = n(2999),
                s = n(6111),
                a = n(506),
                o = n(845);

            function l(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }
            l.prototype.clear = r, l.prototype.delete = i, l.prototype.get = s, l.prototype.has = a, l.prototype.set = o, e.exports = l
        },
        175: function(e, t, n) {
            var r = n(2173),
                i = n(3752),
                s = n(548),
                a = n(4318),
                o = n(3564);

            function l(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }
            l.prototype.clear = r, l.prototype.delete = i, l.prototype.get = s, l.prototype.has = a, l.prototype.set = o, e.exports = l
        },
        5922: function(e, t, n) {
            var r = n(7758)(n(9165), "Map");
            e.exports = r
        },
        9440: function(e, t, n) {
            var r = n(7140),
                i = n(6504),
                s = n(8833),
                a = n(953),
                o = n(724);

            function l(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }
            l.prototype.clear = r, l.prototype.delete = i, l.prototype.get = s, l.prototype.has = a, l.prototype.set = o, e.exports = l
        },
        6795: function(e, t, n) {
            var r = n(7758)(n(9165), "Promise");
            e.exports = r
        },
        1956: function(e, t, n) {
            var r = n(7758)(n(9165), "Set");
            e.exports = r
        },
        8188: function(e, t, n) {
            var r = n(9440),
                i = n(6659),
                s = n(7230);

            function a(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.__data__ = new r; ++t < n;) this.add(e[t])
            }
            a.prototype.add = a.prototype.push = i, a.prototype.has = s, e.exports = a
        },
        5929: function(e, t, n) {
            var r = n(175),
                i = n(2810),
                s = n(5575),
                a = n(7694),
                o = n(6220),
                l = n(8958);

            function u(e) {
                var t = this.__data__ = new r(e);
                this.size = t.size
            }
            u.prototype.clear = i, u.prototype.delete = s, u.prototype.get = a, u.prototype.has = o, u.prototype.set = l, e.exports = u
        },
        4396: function(e, t, n) {
            var r = n(9165).Symbol;
            e.exports = r
        },
        2210: function(e, t, n) {
            var r = n(9165).Uint8Array;
            e.exports = r
        },
        9477: function(e, t, n) {
            var r = n(7758)(n(9165), "WeakMap");
            e.exports = r
        },
        3501: function(e) {
            e.exports = function(e, t, n) {
                switch (n.length) {
                    case 0:
                        return e.call(t);
                    case 1:
                        return e.call(t, n[0]);
                    case 2:
                        return e.call(t, n[0], n[1]);
                    case 3:
                        return e.call(t, n[0], n[1], n[2])
                }
                return e.apply(t, n)
            }
        },
        1662: function(e) {
            e.exports = function(e, t) {
                for (var n = -1, r = null == e ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e););
                return e
            }
        },
        8969: function(e) {
            e.exports = function(e, t) {
                for (var n = -1, r = null == e ? 0 : e.length, i = 0, s = []; ++n < r;) {
                    var a = e[n];
                    t(a, n, e) && (s[i++] = a)
                }
                return s
            }
        },
        9809: function(e, t, n) {
            var r = n(9739),
                i = n(353),
                s = n(4669),
                a = n(1563),
                o = n(1010),
                l = n(3806),
                u = Object.prototype.hasOwnProperty;
            e.exports = function(e, t) {
                var n = s(e),
                    c = !n && i(e),
                    h = !n && !c && a(e),
                    d = !n && !c && !h && l(e),
                    f = n || c || h || d,
                    p = f ? r(e.length, String) : [],
                    g = p.length;
                for (var A in e)(t || u.call(e, A)) && !(f && ("length" == A || h && ("offset" == A || "parent" == A) || d && ("buffer" == A || "byteLength" == A || "byteOffset" == A) || o(A, g))) && p.push(A);
                return p
            }
        },
        5697: function(e) {
            e.exports = function(e, t) {
                for (var n = -1, r = null == e ? 0 : e.length, i = Array(r); ++n < r;) i[n] = t(e[n], n, e);
                return i
            }
        },
        8486: function(e) {
            e.exports = function(e, t) {
                for (var n = -1, r = t.length, i = e.length; ++n < r;) e[i + n] = t[n];
                return e
            }
        },
        4330: function(e) {
            e.exports = function(e, t) {
                for (var n = -1, r = null == e ? 0 : e.length; ++n < r;)
                    if (t(e[n], n, e)) return !0;
                return !1
            }
        },
        2340: function(e, t, n) {
            var r = n(404),
                i = n(2448);
            e.exports = function(e, t, n) {
                (void 0 === n || i(e[t], n)) && (void 0 !== n || t in e) || r(e, t, n)
            }
        },
        3719: function(e, t, n) {
            var r = n(404),
                i = n(2448),
                s = Object.prototype.hasOwnProperty;
            e.exports = function(e, t, n) {
                var a = e[t];
                s.call(e, t) && i(a, n) && (void 0 !== n || t in e) || r(e, t, n)
            }
        },
        2718: function(e, t, n) {
            var r = n(2448);
            e.exports = function(e, t) {
                for (var n = e.length; n--;)
                    if (r(e[n][0], t)) return n;
                return -1
            }
        },
        404: function(e, t, n) {
            var r = n(4082);
            e.exports = function(e, t, n) {
                "__proto__" == t && r ? r(e, t, {
                    configurable: !0,
                    enumerable: !0,
                    value: n,
                    writable: !0
                }) : e[t] = n
            }
        },
        1348: function(e, t, n) {
            var r = n(6838),
                i = Object.create,
                s = function() {
                    function e() {}
                    return function(t) {
                        if (!r(t)) return {};
                        if (i) return i(t);
                        e.prototype = t;
                        var n = new e;
                        return e.prototype = void 0, n
                    }
                }();
            e.exports = s
        },
        438: function(e, t, n) {
            var r = n(1343),
                i = n(8202)(r);
            e.exports = i
        },
        1030: function(e, t, n) {
            var r = n(29)();
            e.exports = r
        },
        1343: function(e, t, n) {
            var r = n(1030),
                i = n(579);
            e.exports = function(e, t) {
                return e && r(e, t, i)
            }
        },
        7499: function(e, t, n) {
            var r = n(399),
                i = n(7817);
            e.exports = function(e, t) {
                t = r(t, e);
                for (var n = 0, s = t.length; null != e && n < s;) e = e[i(t[n++])];
                return n && n == s ? e : void 0
            }
        },
        8084: function(e, t, n) {
            var r = n(8486),
                i = n(4669);
            e.exports = function(e, t, n) {
                var s = t(e);
                return i(e) ? s : r(s, n(e))
            }
        },
        732: function(e, t, n) {
            var r = n(4396),
                i = n(1239),
                s = n(7058),
                a = r ? r.toStringTag : void 0;
            e.exports = function(e) {
                return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : a && a in Object(e) ? i(e) : s(e)
            }
        },
        1664: function(e) {
            e.exports = function(e, t) {
                return null != e && t in Object(e)
            }
        },
        4742: function(e, t, n) {
            var r = n(732),
                i = n(5073);
            e.exports = function(e) {
                return i(e) && "[object Arguments]" == r(e)
            }
        },
        6620: function(e, t, n) {
            var r = n(3977),
                i = n(5073);
            e.exports = function e(t, n, s, a, o) {
                return t === n || (null != t && null != n && (i(t) || i(n)) ? r(t, n, s, a, e, o) : t != t && n != n)
            }
        },
        3977: function(e, t, n) {
            var r = n(5929),
                i = n(2684),
                s = n(7456),
                a = n(8120),
                o = n(1887),
                l = n(4669),
                u = n(1563),
                c = n(3806),
                h = "[object Arguments]",
                d = "[object Array]",
                f = "[object Object]",
                p = Object.prototype.hasOwnProperty;
            e.exports = function(e, t, n, g, A, m) {
                var v = l(e),
                    y = l(t),
                    x = v ? d : o(e),
                    E = y ? d : o(t);
                x = x == h ? f : x, E = E == h ? f : E;
                var _ = x == f,
                    b = E == f,
                    w = x == E;
                if (w && u(e)) {
                    if (!u(t)) return !1;
                    v = !0, _ = !1
                }
                if (w && !_) return m || (m = new r), v || c(e) ? i(e, t, n, g, A, m) : s(e, t, x, n, g, A, m);
                if (!(1 & n)) {
                    var C = _ && p.call(e, "__wrapped__"),
                        S = b && p.call(t, "__wrapped__");
                    if (C || S) {
                        var I = C ? e.value() : e,
                            M = S ? t.value() : t;
                        return m || (m = new r), A(I, M, n, g, m)
                    }
                }
                return !!w && (m || (m = new r), a(e, t, n, g, A, m))
            }
        },
        7122: function(e, t, n) {
            var r = n(5929),
                i = n(6620);
            e.exports = function(e, t, n, s) {
                var a = n.length,
                    o = a,
                    l = !s;
                if (null == e) return !o;
                for (e = Object(e); a--;) {
                    var u = n[a];
                    if (l && u[2] ? u[1] !== e[u[0]] : !(u[0] in e)) return !1
                }
                for (; ++a < o;) {
                    var c = (u = n[a])[0],
                        h = e[c],
                        d = u[1];
                    if (l && u[2]) {
                        if (void 0 === h && !(c in e)) return !1
                    } else {
                        var f = new r;
                        if (s) var p = s(h, d, c, e, t, f);
                        if (!(void 0 === p ? i(d, h, 3, s, f) : p)) return !1
                    }
                }
                return !0
            }
        },
        8939: function(e, t, n) {
            var r = n(2042),
                i = n(654),
                s = n(6838),
                a = n(1059),
                o = /^\[object .+?Constructor\]$/,
                l = Object.prototype,
                u = Function.prototype.toString,
                c = l.hasOwnProperty,
                h = RegExp("^" + u.call(c).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            e.exports = function(e) {
                return !(!s(e) || i(e)) && (r(e) ? h : o).test(a(e))
            }
        },
        2882: function(e, t, n) {
            var r = n(732),
                i = n(7216),
                s = n(5073),
                a = {};
            a["[object Float32Array]"] = a["[object Float64Array]"] = a["[object Int8Array]"] = a["[object Int16Array]"] = a["[object Int32Array]"] = a["[object Uint8Array]"] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a["[object Uint32Array]"] = !0, a["[object Arguments]"] = a["[object Array]"] = a["[object ArrayBuffer]"] = a["[object Boolean]"] = a["[object DataView]"] = a["[object Date]"] = a["[object Error]"] = a["[object Function]"] = a["[object Map]"] = a["[object Number]"] = a["[object Object]"] = a["[object RegExp]"] = a["[object Set]"] = a["[object String]"] = a["[object WeakMap]"] = !1, e.exports = function(e) {
                return s(e) && i(e.length) && !!a[r(e)]
            }
        },
        5673: function(e, t, n) {
            var r = n(3772),
                i = n(493),
                s = n(8148),
                a = n(4669),
                o = n(1798);
            e.exports = function(e) {
                return "function" == typeof e ? e : null == e ? s : "object" == typeof e ? a(e) ? i(e[0], e[1]) : r(e) : o(e)
            }
        },
        7473: function(e, t, n) {
            var r = n(2963),
                i = n(4457),
                s = Object.prototype.hasOwnProperty;
            e.exports = function(e) {
                if (!r(e)) return i(e);
                var t = [];
                for (var n in Object(e)) s.call(e, n) && "constructor" != n && t.push(n);
                return t
            }
        },
        2506: function(e, t, n) {
            var r = n(6838),
                i = n(2963),
                s = n(814),
                a = Object.prototype.hasOwnProperty;
            e.exports = function(e) {
                if (!r(e)) return s(e);
                var t = i(e),
                    n = [];
                for (var o in e) "constructor" == o && (t || !a.call(e, o)) || n.push(o);
                return n
            }
        },
        6494: function(e, t, n) {
            var r = n(438),
                i = n(7428);
            e.exports = function(e, t) {
                var n = -1,
                    s = i(e) ? Array(e.length) : [];
                return r(e, function(e, r, i) {
                    s[++n] = t(e, r, i)
                }), s
            }
        },
        3772: function(e, t, n) {
            var r = n(7122),
                i = n(7487),
                s = n(8857);
            e.exports = function(e) {
                var t = i(e);
                return 1 == t.length && t[0][2] ? s(t[0][0], t[0][1]) : function(n) {
                    return n === e || r(n, e, t)
                }
            }
        },
        493: function(e, t, n) {
            var r = n(6620),
                i = n(5439),
                s = n(8281),
                a = n(2610),
                o = n(2769),
                l = n(8857),
                u = n(7817);
            e.exports = function(e, t) {
                return a(e) && o(t) ? l(u(e), t) : function(n) {
                    var a = i(n, e);
                    return void 0 === a && a === t ? s(n, e) : r(t, a, 3)
                }
            }
        },
        7254: function(e, t, n) {
            var r = n(5929),
                i = n(2340),
                s = n(1030),
                a = n(715),
                o = n(6838),
                l = n(7390),
                u = n(2014);
            e.exports = function e(t, n, c, h, d) {
                t !== n && s(n, function(s, l) {
                    if (d || (d = new r), o(s)) a(t, n, l, c, e, h, d);
                    else {
                        var f = h ? h(u(t, l), s, l + "", t, n, d) : void 0;
                        void 0 === f && (f = s), i(t, l, f)
                    }
                }, l)
            }
        },
        715: function(e, t, n) {
            var r = n(2340),
                i = n(9767),
                s = n(7136),
                a = n(7165),
                o = n(6404),
                l = n(353),
                u = n(4669),
                c = n(7348),
                h = n(1563),
                d = n(2042),
                f = n(6838),
                p = n(9143),
                g = n(3806),
                A = n(2014),
                m = n(5111);
            e.exports = function(e, t, n, v, y, x, E) {
                var _ = A(e, n),
                    b = A(t, n),
                    w = E.get(b);
                if (w) {
                    r(e, n, w);
                    return
                }
                var C = x ? x(_, b, n + "", e, t, E) : void 0,
                    S = void 0 === C;
                if (S) {
                    var I = u(b),
                        M = !I && h(b),
                        T = !I && !M && g(b);
                    C = b, I || M || T ? u(_) ? C = _ : c(_) ? C = a(_) : M ? (S = !1, C = i(b, !0)) : T ? (S = !1, C = s(b, !0)) : C = [] : p(b) || l(b) ? (C = _, l(_) ? C = m(_) : (!f(_) || d(_)) && (C = o(b))) : S = !1
                }
                S && (E.set(b, C), y(C, b, v, x, E), E.delete(b)), r(e, n, C)
            }
        },
        7498: function(e) {
            e.exports = function(e) {
                return function(t) {
                    return null == t ? void 0 : t[e]
                }
            }
        },
        1e3: function(e, t, n) {
            var r = n(7499);
            e.exports = function(e) {
                return function(t) {
                    return r(t, e)
                }
            }
        },
        5125: function(e, t, n) {
            var r = n(8148),
                i = n(323),
                s = n(1564);
            e.exports = function(e, t) {
                return s(i(e, t, r), e + "")
            }
        },
        6447: function(e, t, n) {
            var r = n(4806),
                i = n(4082),
                s = n(8148),
                a = i ? function(e, t) {
                    return i(e, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: r(t),
                        writable: !0
                    })
                } : s;
            e.exports = a
        },
        9739: function(e) {
            e.exports = function(e, t) {
                for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n);
                return r
            }
        },
        3150: function(e, t, n) {
            var r = n(4396),
                i = n(5697),
                s = n(4669),
                a = n(6764),
                o = 1 / 0,
                l = r ? r.prototype : void 0,
                u = l ? l.toString : void 0;
            e.exports = function e(t) {
                if ("string" == typeof t) return t;
                if (s(t)) return i(t, e) + "";
                if (a(t)) return u ? u.call(t) : "";
                var n = t + "";
                return "0" == n && 1 / t == -o ? "-0" : n
            }
        },
        8792: function(e) {
            e.exports = function(e) {
                return function(t) {
                    return e(t)
                }
            }
        },
        9880: function(e) {
            e.exports = function(e, t) {
                return e.has(t)
            }
        },
        7008: function(e, t, n) {
            var r = n(8148);
            e.exports = function(e) {
                return "function" == typeof e ? e : r
            }
        },
        399: function(e, t, n) {
            var r = n(4669),
                i = n(2610),
                s = n(7057),
                a = n(8389);
            e.exports = function(e, t) {
                return r(e) ? e : i(e, t) ? [e] : s(a(e))
            }
        },
        8925: function(e, t, n) {
            var r = n(2210);
            e.exports = function(e) {
                var t = new e.constructor(e.byteLength);
                return new r(t).set(new r(e)), t
            }
        },
        9767: function(e, t, n) {
            e = n.nmd(e);
            var r = n(9165),
                i = t && !t.nodeType && t,
                s = i && e && !e.nodeType && e,
                a = s && s.exports === i ? r.Buffer : void 0,
                o = a ? a.allocUnsafe : void 0;
            e.exports = function(e, t) {
                if (t) return e.slice();
                var n = e.length,
                    r = o ? o(n) : new e.constructor(n);
                return e.copy(r), r
            }
        },
        7136: function(e, t, n) {
            var r = n(8925);
            e.exports = function(e, t) {
                var n = t ? r(e.buffer) : e.buffer;
                return new e.constructor(n, e.byteOffset, e.length)
            }
        },
        7165: function(e) {
            e.exports = function(e, t) {
                var n = -1,
                    r = e.length;
                for (t || (t = Array(r)); ++n < r;) t[n] = e[n];
                return t
            }
        },
        2434: function(e, t, n) {
            var r = n(3719),
                i = n(404);
            e.exports = function(e, t, n, s) {
                var a = !n;
                n || (n = {});
                for (var o = -1, l = t.length; ++o < l;) {
                    var u = t[o],
                        c = s ? s(n[u], e[u], u, n, e) : void 0;
                    void 0 === c && (c = e[u]), a ? i(n, u, c) : r(n, u, c)
                }
                return n
            }
        },
        6633: function(e, t, n) {
            var r = n(9165)["__core-js_shared__"];
            e.exports = r
        },
        7991: function(e, t, n) {
            var r = n(5125),
                i = n(7616);
            e.exports = function(e) {
                return r(function(t, n) {
                    var r = -1,
                        s = n.length,
                        a = s > 1 ? n[s - 1] : void 0,
                        o = s > 2 ? n[2] : void 0;
                    for (a = e.length > 3 && "function" == typeof a ? (s--, a) : void 0, o && i(n[0], n[1], o) && (a = s < 3 ? void 0 : a, s = 1), t = Object(t); ++r < s;) {
                        var l = n[r];
                        l && e(t, l, r, a)
                    }
                    return t
                })
            }
        },
        8202: function(e, t, n) {
            var r = n(7428);
            e.exports = function(e, t) {
                return function(n, i) {
                    if (null == n) return n;
                    if (!r(n)) return e(n, i);
                    for (var s = n.length, a = t ? s : -1, o = Object(n);
                        (t ? a-- : ++a < s) && !1 !== i(o[a], a, o););
                    return n
                }
            }
        },
        29: function(e) {
            e.exports = function(e) {
                return function(t, n, r) {
                    for (var i = -1, s = Object(t), a = r(t), o = a.length; o--;) {
                        var l = a[e ? o : ++i];
                        if (!1 === n(s[l], l, s)) break
                    }
                    return t
                }
            }
        },
        4082: function(e, t, n) {
            var r = n(7758),
                i = function() {
                    try {
                        var e = r(Object, "defineProperty");
                        return e({}, "", {}), e
                    } catch (e) {}
                }();
            e.exports = i
        },
        2684: function(e, t, n) {
            var r = n(8188),
                i = n(4330),
                s = n(9880);
            e.exports = function(e, t, n, a, o, l) {
                var u = 1 & n,
                    c = e.length,
                    h = t.length;
                if (c != h && !(u && h > c)) return !1;
                var d = l.get(e),
                    f = l.get(t);
                if (d && f) return d == t && f == e;
                var p = -1,
                    g = !0,
                    A = 2 & n ? new r : void 0;
                for (l.set(e, t), l.set(t, e); ++p < c;) {
                    var m = e[p],
                        v = t[p];
                    if (a) var y = u ? a(v, m, p, t, e, l) : a(m, v, p, e, t, l);
                    if (void 0 !== y) {
                        if (y) continue;
                        g = !1;
                        break
                    }
                    if (A) {
                        if (!i(t, function(e, t) {
                                if (!s(A, t) && (m === e || o(m, e, n, a, l))) return A.push(t)
                            })) {
                            g = !1;
                            break
                        }
                    } else if (!(m === v || o(m, v, n, a, l))) {
                        g = !1;
                        break
                    }
                }
                return l.delete(e), l.delete(t), g
            }
        },
        7456: function(e, t, n) {
            var r = n(4396),
                i = n(2210),
                s = n(2448),
                a = n(2684),
                o = n(7523),
                l = n(9967),
                u = r ? r.prototype : void 0,
                c = u ? u.valueOf : void 0;
            e.exports = function(e, t, n, r, u, h, d) {
                switch (n) {
                    case "[object DataView]":
                        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) break;
                        e = e.buffer, t = t.buffer;
                    case "[object ArrayBuffer]":
                        if (e.byteLength != t.byteLength || !h(new i(e), new i(t))) break;
                        return !0;
                    case "[object Boolean]":
                    case "[object Date]":
                    case "[object Number]":
                        return s(+e, +t);
                    case "[object Error]":
                        return e.name == t.name && e.message == t.message;
                    case "[object RegExp]":
                    case "[object String]":
                        return e == t + "";
                    case "[object Map]":
                        var f = o;
                    case "[object Set]":
                        var p = 1 & r;
                        if (f || (f = l), e.size != t.size && !p) break;
                        var g = d.get(e);
                        if (g) return g == t;
                        r |= 2, d.set(e, t);
                        var A = a(f(e), f(t), r, u, h, d);
                        return d.delete(e), A;
                    case "[object Symbol]":
                        if (c) return c.call(e) == c.call(t)
                }
                return !1
            }
        },
        8120: function(e, t, n) {
            var r = n(9698),
                i = Object.prototype.hasOwnProperty;
            e.exports = function(e, t, n, s, a, o) {
                var l = 1 & n,
                    u = r(e),
                    c = u.length;
                if (c != r(t).length && !l) return !1;
                for (var h = c; h--;) {
                    var d = u[h];
                    if (!(l ? d in t : i.call(t, d))) return !1
                }
                var f = o.get(e),
                    p = o.get(t);
                if (f && p) return f == t && p == e;
                var g = !0;
                o.set(e, t), o.set(t, e);
                for (var A = l; ++h < c;) {
                    var m = e[d = u[h]],
                        v = t[d];
                    if (s) var y = l ? s(v, m, d, t, e, o) : s(m, v, d, e, t, o);
                    if (!(void 0 === y ? m === v || a(m, v, n, s, o) : y)) {
                        g = !1;
                        break
                    }
                    A || (A = "constructor" == d)
                }
                if (g && !A) {
                    var x = e.constructor,
                        E = t.constructor;
                    x != E && "constructor" in e && "constructor" in t && !("function" == typeof x && x instanceof x && "function" == typeof E && E instanceof E) && (g = !1)
                }
                return o.delete(e), o.delete(t), g
            }
        },
        6476: function(e, t, n) {
            var r = "object" == typeof n.g && n.g && n.g.Object === Object && n.g;
            e.exports = r
        },
        9698: function(e, t, n) {
            var r = n(8084),
                i = n(7482),
                s = n(579);
            e.exports = function(e) {
                return r(e, s, i)
            }
        },
        7707: function(e, t, n) {
            var r = n(3880);
            e.exports = function(e, t) {
                var n = e.__data__;
                return r(t) ? n["string" == typeof t ? "string" : "hash"] : n.map
            }
        },
        7487: function(e, t, n) {
            var r = n(2769),
                i = n(579);
            e.exports = function(e) {
                for (var t = i(e), n = t.length; n--;) {
                    var s = t[n],
                        a = e[s];
                    t[n] = [s, a, r(a)]
                }
                return t
            }
        },
        7758: function(e, t, n) {
            var r = n(8939),
                i = n(9149);
            e.exports = function(e, t) {
                var n = i(e, t);
                return r(n) ? n : void 0
            }
        },
        1389: function(e, t, n) {
            var r = n(5542)(Object.getPrototypeOf, Object);
            e.exports = r
        },
        1239: function(e, t, n) {
            var r = n(4396),
                i = Object.prototype,
                s = i.hasOwnProperty,
                a = i.toString,
                o = r ? r.toStringTag : void 0;
            e.exports = function(e) {
                var t = s.call(e, o),
                    n = e[o];
                try {
                    e[o] = void 0;
                    var r = !0
                } catch (e) {}
                var i = a.call(e);
                return r && (t ? e[o] = n : delete e[o]), i
            }
        },
        7482: function(e, t, n) {
            var r = n(8969),
                i = n(8036),
                s = Object.prototype.propertyIsEnumerable,
                a = Object.getOwnPropertySymbols,
                o = a ? function(e) {
                    return null == e ? [] : r(a(e = Object(e)), function(t) {
                        return s.call(e, t)
                    })
                } : i;
            e.exports = o
        },
        1887: function(e, t, n) {
            var r = n(7269),
                i = n(5922),
                s = n(6795),
                a = n(1956),
                o = n(9477),
                l = n(732),
                u = n(1059),
                c = "[object Map]",
                h = "[object Promise]",
                d = "[object Set]",
                f = "[object WeakMap]",
                p = "[object DataView]",
                g = u(r),
                A = u(i),
                m = u(s),
                v = u(a),
                y = u(o),
                x = l;
            (r && x(new r(new ArrayBuffer(1))) != p || i && x(new i) != c || s && x(s.resolve()) != h || a && x(new a) != d || o && x(new o) != f) && (x = function(e) {
                var t = l(e),
                    n = "[object Object]" == t ? e.constructor : void 0,
                    r = n ? u(n) : "";
                if (r) switch (r) {
                    case g:
                        return p;
                    case A:
                        return c;
                    case m:
                        return h;
                    case v:
                        return d;
                    case y:
                        return f
                }
                return t
            }), e.exports = x
        },
        9149: function(e) {
            e.exports = function(e, t) {
                return null == e ? void 0 : e[t]
            }
        },
        8554: function(e, t, n) {
            var r = n(399),
                i = n(353),
                s = n(4669),
                a = n(1010),
                o = n(7216),
                l = n(7817);
            e.exports = function(e, t, n) {
                t = r(t, e);
                for (var u = -1, c = t.length, h = !1; ++u < c;) {
                    var d = l(t[u]);
                    if (!(h = null != e && n(e, d))) break;
                    e = e[d]
                }
                return h || ++u != c ? h : !!(c = null == e ? 0 : e.length) && o(c) && a(d, c) && (s(e) || i(e))
            }
        },
        5075: function(e, t, n) {
            var r = n(7722);
            e.exports = function() {
                this.__data__ = r ? r(null) : {}, this.size = 0
            }
        },
        2999: function(e) {
            e.exports = function(e) {
                var t = this.has(e) && delete this.__data__[e];
                return this.size -= t ? 1 : 0, t
            }
        },
        6111: function(e, t, n) {
            var r = n(7722),
                i = Object.prototype.hasOwnProperty;
            e.exports = function(e) {
                var t = this.__data__;
                if (r) {
                    var n = t[e];
                    return "__lodash_hash_undefined__" === n ? void 0 : n
                }
                return i.call(t, e) ? t[e] : void 0
            }
        },
        506: function(e, t, n) {
            var r = n(7722),
                i = Object.prototype.hasOwnProperty;
            e.exports = function(e) {
                var t = this.__data__;
                return r ? void 0 !== t[e] : i.call(t, e)
            }
        },
        845: function(e, t, n) {
            var r = n(7722);
            e.exports = function(e, t) {
                var n = this.__data__;
                return this.size += this.has(e) ? 0 : 1, n[e] = r && void 0 === t ? "__lodash_hash_undefined__" : t, this
            }
        },
        6404: function(e, t, n) {
            var r = n(1348),
                i = n(1389),
                s = n(2963);
            e.exports = function(e) {
                return "function" != typeof e.constructor || s(e) ? {} : r(i(e))
            }
        },
        1010: function(e) {
            var t = /^(?:0|[1-9]\d*)$/;
            e.exports = function(e, n) {
                var r = typeof e;
                return !!(n = null == n ? 9007199254740991 : n) && ("number" == r || "symbol" != r && t.test(e)) && e > -1 && e % 1 == 0 && e < n
            }
        },
        7616: function(e, t, n) {
            var r = n(2448),
                i = n(7428),
                s = n(1010),
                a = n(6838);
            e.exports = function(e, t, n) {
                if (!a(n)) return !1;
                var o = typeof t;
                return ("number" == o ? !!(i(n) && s(t, n.length)) : "string" == o && t in n) && r(n[t], e)
            }
        },
        2610: function(e, t, n) {
            var r = n(4669),
                i = n(6764),
                s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                a = /^\w*$/;
            e.exports = function(e, t) {
                if (r(e)) return !1;
                var n = typeof e;
                return !!("number" == n || "symbol" == n || "boolean" == n || null == e || i(e)) || a.test(e) || !s.test(e) || null != t && e in Object(t)
            }
        },
        3880: function(e) {
            e.exports = function(e) {
                var t = typeof e;
                return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e
            }
        },
        654: function(e, t, n) {
            var r, i = n(6633),
                s = (r = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || "")) ? "Symbol(src)_1." + r : "";
            e.exports = function(e) {
                return !!s && s in e
            }
        },
        2963: function(e) {
            var t = Object.prototype;
            e.exports = function(e) {
                var n = e && e.constructor;
                return e === ("function" == typeof n && n.prototype || t)
            }
        },
        2769: function(e, t, n) {
            var r = n(6838);
            e.exports = function(e) {
                return e == e && !r(e)
            }
        },
        2173: function(e) {
            e.exports = function() {
                this.__data__ = [], this.size = 0
            }
        },
        3752: function(e, t, n) {
            var r = n(2718),
                i = Array.prototype.splice;
            e.exports = function(e) {
                var t = this.__data__,
                    n = r(t, e);
                return !(n < 0) && (n == t.length - 1 ? t.pop() : i.call(t, n, 1), --this.size, !0)
            }
        },
        548: function(e, t, n) {
            var r = n(2718);
            e.exports = function(e) {
                var t = this.__data__,
                    n = r(t, e);
                return n < 0 ? void 0 : t[n][1]
            }
        },
        4318: function(e, t, n) {
            var r = n(2718);
            e.exports = function(e) {
                return r(this.__data__, e) > -1
            }
        },
        3564: function(e, t, n) {
            var r = n(2718);
            e.exports = function(e, t) {
                var n = this.__data__,
                    i = r(n, e);
                return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
            }
        },
        7140: function(e, t, n) {
            var r = n(8987),
                i = n(175),
                s = n(5922);
            e.exports = function() {
                this.size = 0, this.__data__ = {
                    hash: new r,
                    map: new(s || i),
                    string: new r
                }
            }
        },
        6504: function(e, t, n) {
            var r = n(7707);
            e.exports = function(e) {
                var t = r(this, e).delete(e);
                return this.size -= t ? 1 : 0, t
            }
        },
        8833: function(e, t, n) {
            var r = n(7707);
            e.exports = function(e) {
                return r(this, e).get(e)
            }
        },
        953: function(e, t, n) {
            var r = n(7707);
            e.exports = function(e) {
                return r(this, e).has(e)
            }
        },
        724: function(e, t, n) {
            var r = n(7707);
            e.exports = function(e, t) {
                var n = r(this, e),
                    i = n.size;
                return n.set(e, t), this.size += n.size == i ? 0 : 1, this
            }
        },
        7523: function(e) {
            e.exports = function(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach(function(e, r) {
                    n[++t] = [r, e]
                }), n
            }
        },
        8857: function(e) {
            e.exports = function(e, t) {
                return function(n) {
                    return null != n && n[e] === t && (void 0 !== t || e in Object(n))
                }
            }
        },
        5171: function(e, t, n) {
            var r = n(4736);
            e.exports = function(e) {
                var t = r(e, function(e) {
                        return 500 === n.size && n.clear(), e
                    }),
                    n = t.cache;
                return t
            }
        },
        7722: function(e, t, n) {
            var r = n(7758)(Object, "create");
            e.exports = r
        },
        4457: function(e, t, n) {
            var r = n(5542)(Object.keys, Object);
            e.exports = r
        },
        814: function(e) {
            e.exports = function(e) {
                var t = [];
                if (null != e)
                    for (var n in Object(e)) t.push(n);
                return t
            }
        },
        8478: function(e, t, n) {
            e = n.nmd(e);
            var r = n(6476),
                i = t && !t.nodeType && t,
                s = i && e && !e.nodeType && e,
                a = s && s.exports === i && r.process,
                o = function() {
                    try {
                        var e = s && s.require && s.require("util").types;
                        if (e) return e;
                        return a && a.binding && a.binding("util")
                    } catch (e) {}
                }();
            e.exports = o
        },
        7058: function(e) {
            var t = Object.prototype.toString;
            e.exports = function(e) {
                return t.call(e)
            }
        },
        5542: function(e) {
            e.exports = function(e, t) {
                return function(n) {
                    return e(t(n))
                }
            }
        },
        323: function(e, t, n) {
            var r = n(3501),
                i = Math.max;
            e.exports = function(e, t, n) {
                return t = i(void 0 === t ? e.length - 1 : t, 0),
                    function() {
                        for (var s = arguments, a = -1, o = i(s.length - t, 0), l = Array(o); ++a < o;) l[a] = s[t + a];
                        a = -1;
                        for (var u = Array(t + 1); ++a < t;) u[a] = s[a];
                        return u[t] = n(l), r(e, this, u)
                    }
            }
        },
        9165: function(e, t, n) {
            var r = n(6476),
                i = "object" == typeof self && self && self.Object === Object && self,
                s = r || i || Function("return this")();
            e.exports = s
        },
        2014: function(e) {
            e.exports = function(e, t) {
                if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t) return e[t]
            }
        },
        6659: function(e) {
            e.exports = function(e) {
                return this.__data__.set(e, "__lodash_hash_undefined__"), this
            }
        },
        7230: function(e) {
            e.exports = function(e) {
                return this.__data__.has(e)
            }
        },
        9967: function(e) {
            e.exports = function(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach(function(e) {
                    n[++t] = e
                }), n
            }
        },
        1564: function(e, t, n) {
            var r = n(6447),
                i = n(5509)(r);
            e.exports = i
        },
        5509: function(e) {
            var t = Date.now;
            e.exports = function(e) {
                var n = 0,
                    r = 0;
                return function() {
                    var i = t(),
                        s = 16 - (i - r);
                    if (r = i, s > 0) {
                        if (++n >= 800) return arguments[0]
                    } else n = 0;
                    return e.apply(void 0, arguments)
                }
            }
        },
        2810: function(e, t, n) {
            var r = n(175);
            e.exports = function() {
                this.__data__ = new r, this.size = 0
            }
        },
        5575: function(e) {
            e.exports = function(e) {
                var t = this.__data__,
                    n = t.delete(e);
                return this.size = t.size, n
            }
        },
        7694: function(e) {
            e.exports = function(e) {
                return this.__data__.get(e)
            }
        },
        6220: function(e) {
            e.exports = function(e) {
                return this.__data__.has(e)
            }
        },
        8958: function(e, t, n) {
            var r = n(175),
                i = n(5922),
                s = n(9440);
            e.exports = function(e, t) {
                var n = this.__data__;
                if (n instanceof r) {
                    var a = n.__data__;
                    if (!i || a.length < 199) return a.push([e, t]), this.size = ++n.size, this;
                    n = this.__data__ = new s(a)
                }
                return n.set(e, t), this.size = n.size, this
            }
        },
        7057: function(e, t, n) {
            var r = n(5171),
                i = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                s = /\\(\\)?/g,
                a = r(function(e) {
                    var t = [];
                    return 46 === e.charCodeAt(0) && t.push(""), e.replace(i, function(e, n, r, i) {
                        t.push(r ? i.replace(s, "$1") : n || e)
                    }), t
                });
            e.exports = a
        },
        7817: function(e, t, n) {
            var r = n(6764),
                i = 1 / 0;
            e.exports = function(e) {
                if ("string" == typeof e || r(e)) return e;
                var t = e + "";
                return "0" == t && 1 / e == -i ? "-0" : t
            }
        },
        1059: function(e) {
            var t = Function.prototype.toString;
            e.exports = function(e) {
                if (null != e) {
                    try {
                        return t.call(e)
                    } catch (e) {}
                    try {
                        return e + ""
                    } catch (e) {}
                }
                return ""
            }
        },
        4806: function(e) {
            e.exports = function(e) {
                return function() {
                    return e
                }
            }
        },
        2448: function(e) {
            e.exports = function(e, t) {
                return e === t || e != e && t != t
            }
        },
        7489: function(e, t, n) {
            var r = n(1662),
                i = n(438),
                s = n(7008),
                a = n(4669);
            e.exports = function(e, t) {
                return (a(e) ? r : i)(e, s(t))
            }
        },
        5439: function(e, t, n) {
            var r = n(7499);
            e.exports = function(e, t, n) {
                var i = null == e ? void 0 : r(e, t);
                return void 0 === i ? n : i
            }
        },
        8281: function(e, t, n) {
            var r = n(1664),
                i = n(8554);
            e.exports = function(e, t) {
                return null != e && i(e, t, r)
            }
        },
        8148: function(e) {
            e.exports = function(e) {
                return e
            }
        },
        353: function(e, t, n) {
            var r = n(4742),
                i = n(5073),
                s = Object.prototype,
                a = s.hasOwnProperty,
                o = s.propertyIsEnumerable,
                l = r(function() {
                    return arguments
                }()) ? r : function(e) {
                    return i(e) && a.call(e, "callee") && !o.call(e, "callee")
                };
            e.exports = l
        },
        4669: function(e) {
            var t = Array.isArray;
            e.exports = t
        },
        7428: function(e, t, n) {
            var r = n(2042),
                i = n(7216);
            e.exports = function(e) {
                return null != e && i(e.length) && !r(e)
            }
        },
        7348: function(e, t, n) {
            var r = n(7428),
                i = n(5073);
            e.exports = function(e) {
                return i(e) && r(e)
            }
        },
        1563: function(e, t, n) {
            e = n.nmd(e);
            var r = n(9165),
                i = n(4193),
                s = t && !t.nodeType && t,
                a = s && e && !e.nodeType && e,
                o = a && a.exports === s ? r.Buffer : void 0,
                l = o ? o.isBuffer : void 0;
            e.exports = l || i
        },
        2042: function(e, t, n) {
            var r = n(732),
                i = n(6838);
            e.exports = function(e) {
                if (!i(e)) return !1;
                var t = r(e);
                return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
            }
        },
        7216: function(e) {
            e.exports = function(e) {
                return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
            }
        },
        6838: function(e) {
            e.exports = function(e) {
                var t = typeof e;
                return null != e && ("object" == t || "function" == t)
            }
        },
        5073: function(e) {
            e.exports = function(e) {
                return null != e && "object" == typeof e
            }
        },
        9143: function(e, t, n) {
            var r = n(732),
                i = n(1389),
                s = n(5073),
                a = Object.prototype,
                o = Function.prototype.toString,
                l = a.hasOwnProperty,
                u = o.call(Object);
            e.exports = function(e) {
                if (!s(e) || "[object Object]" != r(e)) return !1;
                var t = i(e);
                if (null === t) return !0;
                var n = l.call(t, "constructor") && t.constructor;
                return "function" == typeof n && n instanceof n && o.call(n) == u
            }
        },
        6764: function(e, t, n) {
            var r = n(732),
                i = n(5073);
            e.exports = function(e) {
                return "symbol" == typeof e || i(e) && "[object Symbol]" == r(e)
            }
        },
        3806: function(e, t, n) {
            var r = n(2882),
                i = n(8792),
                s = n(8478),
                a = s && s.isTypedArray,
                o = a ? i(a) : r;
            e.exports = o
        },
        579: function(e, t, n) {
            var r = n(9809),
                i = n(7473),
                s = n(7428);
            e.exports = function(e) {
                return s(e) ? r(e) : i(e)
            }
        },
        7390: function(e, t, n) {
            var r = n(9809),
                i = n(2506),
                s = n(7428);
            e.exports = function(e) {
                return s(e) ? r(e, !0) : i(e)
            }
        },
        3194: function(e, t, n) {
            var r = n(5697),
                i = n(5673),
                s = n(6494),
                a = n(4669);
            e.exports = function(e, t) {
                return (a(e) ? r : s)(e, i(t, 3))
            }
        },
        4736: function(e, t, n) {
            var r = n(9440);

            function i(e, t) {
                if ("function" != typeof e || null != t && "function" != typeof t) throw TypeError("Expected a function");
                var n = function() {
                    var r = arguments,
                        i = t ? t.apply(this, r) : r[0],
                        s = n.cache;
                    if (s.has(i)) return s.get(i);
                    var a = e.apply(this, r);
                    return n.cache = s.set(i, a) || s, a
                };
                return n.cache = new(i.Cache || r), n
            }
            i.Cache = r, e.exports = i
        },
        7929: function(e, t, n) {
            var r = n(7254),
                i = n(7991)(function(e, t, n) {
                    r(e, t, n)
                });
            e.exports = i
        },
        1798: function(e, t, n) {
            var r = n(7498),
                i = n(1e3),
                s = n(2610),
                a = n(7817);
            e.exports = function(e) {
                return s(e) ? r(a(e)) : i(e)
            }
        },
        8036: function(e) {
            e.exports = function() {
                return []
            }
        },
        4193: function(e) {
            e.exports = function() {
                return !1
            }
        },
        5111: function(e, t, n) {
            var r = n(2434),
                i = n(7390);
            e.exports = function(e) {
                return r(e, i(e))
            }
        },
        8389: function(e, t, n) {
            var r = n(3150);
            e.exports = function(e) {
                return null == e ? "" : r(e)
            }
        },
        7899: function(e, t, n) {
            e.exports = n(3101)
        },
        4507: function(e, t, n) {
            "use strict";
            var r, i;
            e.exports = (null == (r = n.g.process) ? void 0 : r.env) && "object" == typeof(null == (i = n.g.process) ? void 0 : i.env) ? n.g.process : n(9775)
        },
        7466: function(e, t, n) {
            (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function() {
                return n(6495)
            }])
        },
        5523: function(e, t, n) {
            "use strict";
            let r, i, s, a, o;
            n.d(t, {
                e: function() {
                    return tx
                }
            });
            var l, u, c, h, d, f = {};

            function p(e, t) {
                return function() {
                    return e.apply(t, arguments)
                }
            }
            n.r(f), n.d(f, {
                hasBrowserEnv: function() {
                    return ey
                },
                hasStandardBrowserEnv: function() {
                    return eE
                },
                hasStandardBrowserWebWorkerEnv: function() {
                    return e_
                },
                navigator: function() {
                    return ex
                },
                origin: function() {
                    return eb
                }
            });
            var g = n(4507);
            let {
                toString: A
            } = Object.prototype, {
                getPrototypeOf: m
            } = Object, v = (r = Object.create(null), e => {
                let t = A.call(e);
                return r[t] || (r[t] = t.slice(8, -1).toLowerCase())
            }), y = e => (e = e.toLowerCase(), t => v(t) === e), x = e => t => typeof t === e, {
                isArray: E
            } = Array, _ = x("undefined"), b = y("ArrayBuffer"), w = x("string"), C = x("function"), S = x("number"), I = e => null !== e && "object" == typeof e, M = e => {
                if ("object" !== v(e)) return !1;
                let t = m(e);
                return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
            }, T = y("Date"), B = y("File"), R = y("Blob"), D = y("FileList"), L = y("URLSearchParams"), [P, O, N, U] = ["ReadableStream", "Request", "Response", "Headers"].map(y);

            function F(e, t, {
                allOwnKeys: n = !1
            } = {}) {
                let r, i;
                if (null != e) {
                    if ("object" != typeof e && (e = [e]), E(e))
                        for (r = 0, i = e.length; r < i; r++) t.call(null, e[r], r, e);
                    else {
                        let i;
                        let s = n ? Object.getOwnPropertyNames(e) : Object.keys(e),
                            a = s.length;
                        for (r = 0; r < a; r++) i = s[r], t.call(null, e[i], i, e)
                    }
                }
            }

            function k(e, t) {
                let n;
                t = t.toLowerCase();
                let r = Object.keys(e),
                    i = r.length;
                for (; i-- > 0;)
                    if (t === (n = r[i]).toLowerCase()) return n;
                return null
            }
            let Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global,
                G = e => !_(e) && e !== Q,
                z = (i = "undefined" != typeof Uint8Array && m(Uint8Array), e => i && e instanceof i),
                H = y("HTMLFormElement"),
                V = (({
                    hasOwnProperty: e
                }) => (t, n) => e.call(t, n))(Object.prototype),
                j = y("RegExp"),
                W = (e, t) => {
                    let n = Object.getOwnPropertyDescriptors(e),
                        r = {};
                    F(n, (n, i) => {
                        let s;
                        !1 !== (s = t(n, i, e)) && (r[i] = s || n)
                    }), Object.defineProperties(e, r)
                },
                Y = "abcdefghijklmnopqrstuvwxyz",
                X = "0123456789",
                q = {
                    DIGIT: X,
                    ALPHA: Y,
                    ALPHA_DIGIT: Y + Y.toUpperCase() + X
                },
                K = y("AsyncFunction"),
                J = (l = "function" == typeof setImmediate, u = C(Q.postMessage), l ? setImmediate : u ? (c = `axios@${Math.random()}`, h = [], Q.addEventListener("message", ({
                    source: e,
                    data: t
                }) => {
                    e === Q && t === c && h.length && h.shift()()
                }, !1), e => {
                    h.push(e), Q.postMessage(c, "*")
                }) : e => setTimeout(e)),
                Z = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(Q) : void 0 !== g && g.nextTick || J;
            var $ = {
                isArray: E,
                isArrayBuffer: b,
                isBuffer: function(e) {
                    return null !== e && !_(e) && null !== e.constructor && !_(e.constructor) && C(e.constructor.isBuffer) && e.constructor.isBuffer(e)
                },
                isFormData: e => {
                    let t;
                    return e && ("function" == typeof FormData && e instanceof FormData || C(e.append) && ("formdata" === (t = v(e)) || "object" === t && C(e.toString) && "[object FormData]" === e.toString()))
                },
                isArrayBufferView: function(e) {
                    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && b(e.buffer)
                },
                isString: w,
                isNumber: S,
                isBoolean: e => !0 === e || !1 === e,
                isObject: I,
                isPlainObject: M,
                isReadableStream: P,
                isRequest: O,
                isResponse: N,
                isHeaders: U,
                isUndefined: _,
                isDate: T,
                isFile: B,
                isBlob: R,
                isRegExp: j,
                isFunction: C,
                isStream: e => I(e) && C(e.pipe),
                isURLSearchParams: L,
                isTypedArray: z,
                isFileList: D,
                forEach: F,
                merge: function e() {
                    let {
                        caseless: t
                    } = G(this) && this || {}, n = {}, r = (r, i) => {
                        let s = t && k(n, i) || i;
                        M(n[s]) && M(r) ? n[s] = e(n[s], r) : M(r) ? n[s] = e({}, r) : E(r) ? n[s] = r.slice() : n[s] = r
                    };
                    for (let e = 0, t = arguments.length; e < t; e++) arguments[e] && F(arguments[e], r);
                    return n
                },
                extend: (e, t, n, {
                    allOwnKeys: r
                } = {}) => (F(t, (t, r) => {
                    n && C(t) ? e[r] = p(t, n) : e[r] = t
                }, {
                    allOwnKeys: r
                }), e),
                trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
                stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
                inherits: (e, t, n, r) => {
                    e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
                        value: t.prototype
                    }), n && Object.assign(e.prototype, n)
                },
                toFlatObject: (e, t, n, r) => {
                    let i, s, a;
                    let o = {};
                    if (t = t || {}, null == e) return t;
                    do {
                        for (s = (i = Object.getOwnPropertyNames(e)).length; s-- > 0;) a = i[s], (!r || r(a, e, t)) && !o[a] && (t[a] = e[a], o[a] = !0);
                        e = !1 !== n && m(e)
                    } while (e && (!n || n(e, t)) && e !== Object.prototype);
                    return t
                },
                kindOf: v,
                kindOfTest: y,
                endsWith: (e, t, n) => {
                    e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length;
                    let r = e.indexOf(t, n);
                    return -1 !== r && r === n
                },
                toArray: e => {
                    if (!e) return null;
                    if (E(e)) return e;
                    let t = e.length;
                    if (!S(t)) return null;
                    let n = Array(t);
                    for (; t-- > 0;) n[t] = e[t];
                    return n
                },
                forEachEntry: (e, t) => {
                    let n;
                    let r = (e && e[Symbol.iterator]).call(e);
                    for (;
                        (n = r.next()) && !n.done;) {
                        let r = n.value;
                        t.call(e, r[0], r[1])
                    }
                },
                matchAll: (e, t) => {
                    let n;
                    let r = [];
                    for (; null !== (n = e.exec(t));) r.push(n);
                    return r
                },
                isHTMLForm: H,
                hasOwnProperty: V,
                hasOwnProp: V,
                reduceDescriptors: W,
                freezeMethods: e => {
                    W(e, (t, n) => {
                        if (C(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1;
                        if (C(e[n])) {
                            if (t.enumerable = !1, "writable" in t) {
                                t.writable = !1;
                                return
                            }
                            t.set || (t.set = () => {
                                throw Error("Can not rewrite read-only method '" + n + "'")
                            })
                        }
                    })
                },
                toObjectSet: (e, t) => {
                    let n = {};
                    return (e => {
                        e.forEach(e => {
                            n[e] = !0
                        })
                    })(E(e) ? e : String(e).split(t)), n
                },
                toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e, t, n) {
                    return t.toUpperCase() + n
                }),
                noop: () => {},
                toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t,
                findKey: k,
                global: Q,
                isContextDefined: G,
                ALPHABET: q,
                generateString: (e = 16, t = q.ALPHA_DIGIT) => {
                    let n = "",
                        {
                            length: r
                        } = t;
                    for (; e--;) n += t[Math.random() * r | 0];
                    return n
                },
                isSpecCompliantForm: function(e) {
                    return !!(e && C(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
                },
                toJSONObject: e => {
                    let t = Array(10),
                        n = (e, r) => {
                            if (I(e)) {
                                if (t.indexOf(e) >= 0) return;
                                if (!("toJSON" in e)) {
                                    t[r] = e;
                                    let i = E(e) ? [] : {};
                                    return F(e, (e, t) => {
                                        let s = n(e, r + 1);
                                        _(s) || (i[t] = s)
                                    }), t[r] = void 0, i
                                }
                            }
                            return e
                        };
                    return n(e, 0)
                },
                isAsyncFn: K,
                isThenable: e => e && (I(e) || C(e)) && C(e.then) && C(e.catch),
                setImmediate: J,
                asap: Z
            };

            function ee(e, t, n, r, i) {
                Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null)
            }
            $.inherits(ee, Error, {
                toJSON: function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: $.toJSONObject(this.config),
                        code: this.code,
                        status: this.status
                    }
                }
            });
            let et = ee.prototype,
                en = {};
            ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
                en[e] = {
                    value: e
                }
            }), Object.defineProperties(ee, en), Object.defineProperty(et, "isAxiosError", {
                value: !0
            }), ee.from = (e, t, n, r, i, s) => {
                let a = Object.create(et);
                return $.toFlatObject(e, a, function(e) {
                    return e !== Error.prototype
                }, e => "isAxiosError" !== e), ee.call(a, e.message, t, n, r, i), a.cause = e, a.name = e.name, s && Object.assign(a, s), a
            };
            var er = n(5872).lW;

            function ei(e) {
                return $.isPlainObject(e) || $.isArray(e)
            }

            function es(e) {
                return $.endsWith(e, "[]") ? e.slice(0, -2) : e
            }

            function ea(e, t, n) {
                return e ? e.concat(t).map(function(e, t) {
                    return e = es(e), !n && t ? "[" + e + "]" : e
                }).join(n ? "." : "") : t
            }
            let eo = $.toFlatObject($, {}, null, function(e) {
                return /^is[A-Z]/.test(e)
            });
            var el = function(e, t, n) {
                if (!$.isObject(e)) throw TypeError("target must be an object");
                t = t || new FormData;
                let r = (n = $.toFlatObject(n, {
                        metaTokens: !0,
                        dots: !1,
                        indexes: !1
                    }, !1, function(e, t) {
                        return !$.isUndefined(t[e])
                    })).metaTokens,
                    i = n.visitor || u,
                    s = n.dots,
                    a = n.indexes,
                    o = (n.Blob || "undefined" != typeof Blob && Blob) && $.isSpecCompliantForm(t);
                if (!$.isFunction(i)) throw TypeError("visitor must be a function");

                function l(e) {
                    if (null === e) return "";
                    if ($.isDate(e)) return e.toISOString();
                    if (!o && $.isBlob(e)) throw new ee("Blob is not supported. Use a Buffer instead.");
                    return $.isArrayBuffer(e) || $.isTypedArray(e) ? o && "function" == typeof Blob ? new Blob([e]) : er.from(e) : e
                }

                function u(e, n, i) {
                    let o = e;
                    if (e && !i && "object" == typeof e) {
                        if ($.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e);
                        else {
                            var u;
                            if ($.isArray(e) && (u = e, $.isArray(u) && !u.some(ei)) || ($.isFileList(e) || $.endsWith(n, "[]")) && (o = $.toArray(e))) return n = es(n), o.forEach(function(e, r) {
                                $.isUndefined(e) || null === e || t.append(!0 === a ? ea([n], r, s) : null === a ? n : n + "[]", l(e))
                            }), !1
                        }
                    }
                    return !!ei(e) || (t.append(ea(i, n, s), l(e)), !1)
                }
                let c = [],
                    h = Object.assign(eo, {
                        defaultVisitor: u,
                        convertValue: l,
                        isVisitable: ei
                    });
                if (!$.isObject(e)) throw TypeError("data must be an object");
                return ! function e(n, r) {
                    if (!$.isUndefined(n)) {
                        if (-1 !== c.indexOf(n)) throw Error("Circular reference detected in " + r.join("."));
                        c.push(n), $.forEach(n, function(n, s) {
                            !0 === (!($.isUndefined(n) || null === n) && i.call(t, n, $.isString(s) ? s.trim() : s, r, h)) && e(n, r ? r.concat(s) : [s])
                        }), c.pop()
                    }
                }(e), t
            };

            function eu(e) {
                let t = {
                    "!": "%21",
                    "'": "%27",
                    "(": "%28",
                    ")": "%29",
                    "~": "%7E",
                    "%20": "+",
                    "%00": "\0"
                };
                return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(e) {
                    return t[e]
                })
            }

            function ec(e, t) {
                this._pairs = [], e && el(e, this, t)
            }
            let eh = ec.prototype;

            function ed(e) {
                return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }

            function ef(e, t, n) {
                let r;
                if (!t) return e;
                let i = n && n.encode || ed;
                $.isFunction(n) && (n = {
                    serialize: n
                });
                let s = n && n.serialize;
                if (r = s ? s(t, n) : $.isURLSearchParams(t) ? t.toString() : new ec(t, n).toString(i)) {
                    let t = e.indexOf("#"); - 1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + r
                }
                return e
            }
            eh.append = function(e, t) {
                this._pairs.push([e, t])
            }, eh.toString = function(e) {
                let t = e ? function(t) {
                    return e.call(this, t, eu)
                } : eu;
                return this._pairs.map(function(e) {
                    return t(e[0]) + "=" + t(e[1])
                }, "").join("&")
            };
            class ep {
                constructor() {
                    this.handlers = []
                }
                use(e, t, n) {
                    return this.handlers.push({
                        fulfilled: e,
                        rejected: t,
                        synchronous: !!n && n.synchronous,
                        runWhen: n ? n.runWhen : null
                    }), this.handlers.length - 1
                }
                eject(e) {
                    this.handlers[e] && (this.handlers[e] = null)
                }
                clear() {
                    this.handlers && (this.handlers = [])
                }
                forEach(e) {
                    $.forEach(this.handlers, function(t) {
                        null !== t && e(t)
                    })
                }
            }
            var eg = {
                    silentJSONParsing: !0,
                    forcedJSONParsing: !0,
                    clarifyTimeoutError: !1
                },
                eA = "undefined" != typeof URLSearchParams ? URLSearchParams : ec,
                em = "undefined" != typeof FormData ? FormData : null,
                ev = "undefined" != typeof Blob ? Blob : null;
            let ey = "undefined" != typeof window && "undefined" != typeof document,
                ex = "object" == typeof navigator && navigator || void 0,
                eE = ey && (!ex || 0 > ["ReactNative", "NativeScript", "NS"].indexOf(ex.product)),
                e_ = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
                eb = ey && window.location.href || "http://localhost";
            var ew = { ...f,
                    isBrowser: !0,
                    classes: {
                        URLSearchParams: eA,
                        FormData: em,
                        Blob: ev
                    },
                    protocols: ["http", "https", "file", "blob", "url", "data"]
                },
                eC = function(e) {
                    if ($.isFormData(e) && $.isFunction(e.entries)) {
                        let t = {};
                        return $.forEachEntry(e, (e, n) => {
                            ! function e(t, n, r, i) {
                                let s = t[i++];
                                if ("__proto__" === s) return !0;
                                let a = Number.isFinite(+s),
                                    o = i >= t.length;
                                return (s = !s && $.isArray(r) ? r.length : s, o) ? $.hasOwnProp(r, s) ? r[s] = [r[s], n] : r[s] = n : (r[s] && $.isObject(r[s]) || (r[s] = []), e(t, n, r[s], i) && $.isArray(r[s]) && (r[s] = function(e) {
                                    let t, n;
                                    let r = {},
                                        i = Object.keys(e),
                                        s = i.length;
                                    for (t = 0; t < s; t++) r[n = i[t]] = e[n];
                                    return r
                                }(r[s]))), !a
                            }($.matchAll(/\w+|\[(\w*)]/g, e).map(e => "[]" === e[0] ? "" : e[1] || e[0]), n, t, 0)
                        }), t
                    }
                    return null
                };
            let eS = {
                transitional: eg,
                adapter: ["xhr", "http", "fetch"],
                transformRequest: [function(e, t) {
                    let n;
                    let r = t.getContentType() || "",
                        i = r.indexOf("application/json") > -1,
                        s = $.isObject(e);
                    if (s && $.isHTMLForm(e) && (e = new FormData(e)), $.isFormData(e)) return i ? JSON.stringify(eC(e)) : e;
                    if ($.isArrayBuffer(e) || $.isBuffer(e) || $.isStream(e) || $.isFile(e) || $.isBlob(e) || $.isReadableStream(e)) return e;
                    if ($.isArrayBufferView(e)) return e.buffer;
                    if ($.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
                    if (s) {
                        if (r.indexOf("application/x-www-form-urlencoded") > -1) {
                            var a, o;
                            return (a = e, o = this.formSerializer, el(a, new ew.classes.URLSearchParams, Object.assign({
                                visitor: function(e, t, n, r) {
                                    return ew.isNode && $.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments)
                                }
                            }, o))).toString()
                        }
                        if ((n = $.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                            let t = this.env && this.env.FormData;
                            return el(n ? {
                                "files[]": e
                            } : e, t && new t, this.formSerializer)
                        }
                    }
                    return s || i ? (t.setContentType("application/json", !1), function(e, t, n) {
                        if ($.isString(e)) try {
                            return (0, JSON.parse)(e), $.trim(e)
                        } catch (e) {
                            if ("SyntaxError" !== e.name) throw e
                        }
                        return (0, JSON.stringify)(e)
                    }(e)) : e
                }],
                transformResponse: [function(e) {
                    let t = this.transitional || eS.transitional,
                        n = t && t.forcedJSONParsing,
                        r = "json" === this.responseType;
                    if ($.isResponse(e) || $.isReadableStream(e)) return e;
                    if (e && $.isString(e) && (n && !this.responseType || r)) {
                        let n = t && t.silentJSONParsing;
                        try {
                            return JSON.parse(e)
                        } catch (e) {
                            if (!n && r) {
                                if ("SyntaxError" === e.name) throw ee.from(e, ee.ERR_BAD_RESPONSE, this, null, this.response);
                                throw e
                            }
                        }
                    }
                    return e
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: ew.classes.FormData,
                    Blob: ew.classes.Blob
                },
                validateStatus: function(e) {
                    return e >= 200 && e < 300
                },
                headers: {
                    common: {
                        Accept: "application/json, text/plain, */*",
                        "Content-Type": void 0
                    }
                }
            };
            $.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
                eS.headers[e] = {}
            });
            let eI = $.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
            var eM = e => {
                let t, n, r;
                let i = {};
                return e && e.split("\n").forEach(function(e) {
                    r = e.indexOf(":"), t = e.substring(0, r).trim().toLowerCase(), n = e.substring(r + 1).trim(), !t || i[t] && eI[t] || ("set-cookie" === t ? i[t] ? i[t].push(n) : i[t] = [n] : i[t] = i[t] ? i[t] + ", " + n : n)
                }), i
            };
            let eT = Symbol("internals");

            function eB(e) {
                return e && String(e).trim().toLowerCase()
            }

            function eR(e) {
                return !1 === e || null == e ? e : $.isArray(e) ? e.map(eR) : String(e)
            }
            let eD = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());

            function eL(e, t, n, r, i) {
                if ($.isFunction(r)) return r.call(this, t, n);
                if (i && (t = n), $.isString(t)) {
                    if ($.isString(r)) return -1 !== t.indexOf(r);
                    if ($.isRegExp(r)) return r.test(t)
                }
            }
            class eP {
                constructor(e) {
                    e && this.set(e)
                }
                set(e, t, n) {
                    let r = this;

                    function i(e, t, n) {
                        let i = eB(t);
                        if (!i) throw Error("header name must be a non-empty string");
                        let s = $.findKey(r, i);
                        s && void 0 !== r[s] && !0 !== n && (void 0 !== n || !1 === r[s]) || (r[s || t] = eR(e))
                    }
                    let s = (e, t) => $.forEach(e, (e, n) => i(e, n, t));
                    if ($.isPlainObject(e) || e instanceof this.constructor) s(e, t);
                    else if ($.isString(e) && (e = e.trim()) && !eD(e)) s(eM(e), t);
                    else if ($.isHeaders(e))
                        for (let [t, r] of e.entries()) i(r, t, n);
                    else null != e && i(t, e, n);
                    return this
                }
                get(e, t) {
                    if (e = eB(e)) {
                        let n = $.findKey(this, e);
                        if (n) {
                            let e = this[n];
                            if (!t) return e;
                            if (!0 === t) return function(e) {
                                let t;
                                let n = Object.create(null),
                                    r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                for (; t = r.exec(e);) n[t[1]] = t[2];
                                return n
                            }(e);
                            if ($.isFunction(t)) return t.call(this, e, n);
                            if ($.isRegExp(t)) return t.exec(e);
                            throw TypeError("parser must be boolean|regexp|function")
                        }
                    }
                }
                has(e, t) {
                    if (e = eB(e)) {
                        let n = $.findKey(this, e);
                        return !!(n && void 0 !== this[n] && (!t || eL(this, this[n], n, t)))
                    }
                    return !1
                }
                delete(e, t) {
                    let n = this,
                        r = !1;

                    function i(e) {
                        if (e = eB(e)) {
                            let i = $.findKey(n, e);
                            i && (!t || eL(n, n[i], i, t)) && (delete n[i], r = !0)
                        }
                    }
                    return $.isArray(e) ? e.forEach(i) : i(e), r
                }
                clear(e) {
                    let t = Object.keys(this),
                        n = t.length,
                        r = !1;
                    for (; n--;) {
                        let i = t[n];
                        (!e || eL(this, this[i], i, e, !0)) && (delete this[i], r = !0)
                    }
                    return r
                }
                normalize(e) {
                    let t = this,
                        n = {};
                    return $.forEach(this, (r, i) => {
                        let s = $.findKey(n, i);
                        if (s) {
                            t[s] = eR(r), delete t[i];
                            return
                        }
                        let a = e ? i.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n) : String(i).trim();
                        a !== i && delete t[i], t[a] = eR(r), n[a] = !0
                    }), this
                }
                concat(...e) {
                    return this.constructor.concat(this, ...e)
                }
                toJSON(e) {
                    let t = Object.create(null);
                    return $.forEach(this, (n, r) => {
                        null != n && !1 !== n && (t[r] = e && $.isArray(n) ? n.join(", ") : n)
                    }), t
                }[Symbol.iterator]() {
                    return Object.entries(this.toJSON())[Symbol.iterator]()
                }
                toString() {
                    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join("\n")
                }
                get[Symbol.toStringTag]() {
                    return "AxiosHeaders"
                }
                static from(e) {
                    return e instanceof this ? e : new this(e)
                }
                static concat(e, ...t) {
                    let n = new this(e);
                    return t.forEach(e => n.set(e)), n
                }
                static accessor(e) {
                    let t = (this[eT] = this[eT] = {
                            accessors: {}
                        }).accessors,
                        n = this.prototype;

                    function r(e) {
                        let r = eB(e);
                        t[r] || (! function(e, t) {
                            let n = $.toCamelCase(" " + t);
                            ["get", "set", "has"].forEach(r => {
                                Object.defineProperty(e, r + n, {
                                    value: function(e, n, i) {
                                        return this[r].call(this, t, e, n, i)
                                    },
                                    configurable: !0
                                })
                            })
                        }(n, e), t[r] = !0)
                    }
                    return $.isArray(e) ? e.forEach(r) : r(e), this
                }
            }

            function eO(e, t) {
                let n = this || eS,
                    r = t || n,
                    i = eP.from(r.headers),
                    s = r.data;
                return $.forEach(e, function(e) {
                    s = e.call(n, s, i.normalize(), t ? t.status : void 0)
                }), i.normalize(), s
            }

            function eN(e) {
                return !!(e && e.__CANCEL__)
            }

            function eU(e, t, n) {
                ee.call(this, null == e ? "canceled" : e, ee.ERR_CANCELED, t, n), this.name = "CanceledError"
            }

            function eF(e, t, n) {
                let r = n.config.validateStatus;
                !n.status || !r || r(n.status) ? e(n) : t(new ee("Request failed with status code " + n.status, [ee.ERR_BAD_REQUEST, ee.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n))
            }
            eP.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), $.reduceDescriptors(eP.prototype, ({
                value: e
            }, t) => {
                let n = t[0].toUpperCase() + t.slice(1);
                return {
                    get: () => e,
                    set(e) {
                        this[n] = e
                    }
                }
            }), $.freezeMethods(eP), $.inherits(eU, ee, {
                __CANCEL__: !0
            });
            var ek = function(e, t) {
                    let n;
                    let r = Array(e = e || 10),
                        i = Array(e),
                        s = 0,
                        a = 0;
                    return t = void 0 !== t ? t : 1e3,
                        function(o) {
                            let l = Date.now(),
                                u = i[a];
                            n || (n = l), r[s] = o, i[s] = l;
                            let c = a,
                                h = 0;
                            for (; c !== s;) h += r[c++], c %= e;
                            if ((s = (s + 1) % e) === a && (a = (a + 1) % e), l - n < t) return;
                            let d = u && l - u;
                            return d ? Math.round(1e3 * h / d) : void 0
                        }
                },
                eQ = function(e, t) {
                    let n, r, i = 0,
                        s = 1e3 / t,
                        a = (t, s = Date.now()) => {
                            i = s, n = null, r && (clearTimeout(r), r = null), e.apply(null, t)
                        };
                    return [(...e) => {
                        let t = Date.now(),
                            o = t - i;
                        o >= s ? a(e, t) : (n = e, r || (r = setTimeout(() => {
                            r = null, a(n)
                        }, s - o)))
                    }, () => n && a(n)]
                };
            let eG = (e, t, n = 3) => {
                    let r = 0,
                        i = ek(50, 250);
                    return eQ(n => {
                        let s = n.loaded,
                            a = n.lengthComputable ? n.total : void 0,
                            o = s - r,
                            l = i(o);
                        r = s, e({
                            loaded: s,
                            total: a,
                            progress: a ? s / a : void 0,
                            bytes: o,
                            rate: l || void 0,
                            estimated: l && a && s <= a ? (a - s) / l : void 0,
                            event: n,
                            lengthComputable: null != a,
                            [t ? "download" : "upload"]: !0
                        })
                    }, n)
                },
                ez = (e, t) => {
                    let n = null != e;
                    return [r => t[0]({
                        lengthComputable: n,
                        total: e,
                        loaded: r
                    }), t[1]]
                },
                eH = e => (...t) => $.asap(() => e(...t));
            var eV = ew.hasStandardBrowserEnv ? (s = new URL(ew.origin), a = ew.navigator && /(msie|trident)/i.test(ew.navigator.userAgent), e => (e = new URL(e, ew.origin), s.protocol === e.protocol && s.host === e.host && (a || s.port === e.port))) : () => !0,
                ej = ew.hasStandardBrowserEnv ? {
                    write(e, t, n, r, i, s) {
                        let a = [e + "=" + encodeURIComponent(t)];
                        $.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), $.isString(r) && a.push("path=" + r), $.isString(i) && a.push("domain=" + i), !0 === s && a.push("secure"), document.cookie = a.join("; ")
                    },
                    read(e) {
                        let t = document.cookie.match(RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                        return t ? decodeURIComponent(t[3]) : null
                    },
                    remove(e) {
                        this.write(e, "", Date.now() - 864e5)
                    }
                } : {
                    write() {},
                    read: () => null,
                    remove() {}
                };

            function eW(e, t) {
                return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e : t
            }
            let eY = e => e instanceof eP ? { ...e
            } : e;

            function eX(e, t) {
                t = t || {};
                let n = {};

                function r(e, t, n, r) {
                    return $.isPlainObject(e) && $.isPlainObject(t) ? $.merge.call({
                        caseless: r
                    }, e, t) : $.isPlainObject(t) ? $.merge({}, t) : $.isArray(t) ? t.slice() : t
                }

                function i(e, t, n, i) {
                    return $.isUndefined(t) ? $.isUndefined(e) ? void 0 : r(void 0, e, n, i) : r(e, t, n, i)
                }

                function s(e, t) {
                    if (!$.isUndefined(t)) return r(void 0, t)
                }

                function a(e, t) {
                    return $.isUndefined(t) ? $.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t)
                }

                function o(n, i, s) {
                    return s in t ? r(n, i) : s in e ? r(void 0, n) : void 0
                }
                let l = {
                    url: s,
                    method: s,
                    data: s,
                    baseURL: a,
                    transformRequest: a,
                    transformResponse: a,
                    paramsSerializer: a,
                    timeout: a,
                    timeoutMessage: a,
                    withCredentials: a,
                    withXSRFToken: a,
                    adapter: a,
                    responseType: a,
                    xsrfCookieName: a,
                    xsrfHeaderName: a,
                    onUploadProgress: a,
                    onDownloadProgress: a,
                    decompress: a,
                    maxContentLength: a,
                    maxBodyLength: a,
                    beforeRedirect: a,
                    transport: a,
                    httpAgent: a,
                    httpsAgent: a,
                    cancelToken: a,
                    socketPath: a,
                    responseEncoding: a,
                    validateStatus: o,
                    headers: (e, t, n) => i(eY(e), eY(t), n, !0)
                };
                return $.forEach(Object.keys(Object.assign({}, e, t)), function(r) {
                    let s = l[r] || i,
                        a = s(e[r], t[r], r);
                    $.isUndefined(a) && s !== o || (n[r] = a)
                }), n
            }
            var eq = e => {
                    let t;
                    let n = eX({}, e),
                        {
                            data: r,
                            withXSRFToken: i,
                            xsrfHeaderName: s,
                            xsrfCookieName: a,
                            headers: o,
                            auth: l
                        } = n;
                    if (n.headers = o = eP.from(o), n.url = ef(eW(n.baseURL, n.url), e.params, e.paramsSerializer), l && o.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))), $.isFormData(r)) {
                        if (ew.hasStandardBrowserEnv || ew.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0);
                        else if (!1 !== (t = o.getContentType())) {
                            let [e, ...n] = t ? t.split(";").map(e => e.trim()).filter(Boolean) : [];
                            o.setContentType([e || "multipart/form-data", ...n].join("; "))
                        }
                    }
                    if (ew.hasStandardBrowserEnv && (i && $.isFunction(i) && (i = i(n)), i || !1 !== i && eV(n.url))) {
                        let e = s && a && ej.read(a);
                        e && o.set(s, e)
                    }
                    return n
                },
                eK = "undefined" != typeof XMLHttpRequest && function(e) {
                    return new Promise(function(t, n) {
                        let r, i, s, a, o;
                        let l = eq(e),
                            u = l.data,
                            c = eP.from(l.headers).normalize(),
                            {
                                responseType: h,
                                onUploadProgress: d,
                                onDownloadProgress: f
                            } = l;

                        function p() {
                            a && a(), o && o(), l.cancelToken && l.cancelToken.unsubscribe(r), l.signal && l.signal.removeEventListener("abort", r)
                        }
                        let g = new XMLHttpRequest;

                        function A() {
                            if (!g) return;
                            let r = eP.from("getAllResponseHeaders" in g && g.getAllResponseHeaders());
                            eF(function(e) {
                                t(e), p()
                            }, function(e) {
                                n(e), p()
                            }, {
                                data: h && "text" !== h && "json" !== h ? g.response : g.responseText,
                                status: g.status,
                                statusText: g.statusText,
                                headers: r,
                                config: e,
                                request: g
                            }), g = null
                        }
                        g.open(l.method.toUpperCase(), l.url, !0), g.timeout = l.timeout, "onloadend" in g ? g.onloadend = A : g.onreadystatechange = function() {
                            g && 4 === g.readyState && (0 !== g.status || g.responseURL && 0 === g.responseURL.indexOf("file:")) && setTimeout(A)
                        }, g.onabort = function() {
                            g && (n(new ee("Request aborted", ee.ECONNABORTED, e, g)), g = null)
                        }, g.onerror = function() {
                            n(new ee("Network Error", ee.ERR_NETWORK, e, g)), g = null
                        }, g.ontimeout = function() {
                            let t = l.timeout ? "timeout of " + l.timeout + "ms exceeded" : "timeout exceeded",
                                r = l.transitional || eg;
                            l.timeoutErrorMessage && (t = l.timeoutErrorMessage), n(new ee(t, r.clarifyTimeoutError ? ee.ETIMEDOUT : ee.ECONNABORTED, e, g)), g = null
                        }, void 0 === u && c.setContentType(null), "setRequestHeader" in g && $.forEach(c.toJSON(), function(e, t) {
                            g.setRequestHeader(t, e)
                        }), $.isUndefined(l.withCredentials) || (g.withCredentials = !!l.withCredentials), h && "json" !== h && (g.responseType = l.responseType), f && ([s, o] = eG(f, !0), g.addEventListener("progress", s)), d && g.upload && ([i, a] = eG(d), g.upload.addEventListener("progress", i), g.upload.addEventListener("loadend", a)), (l.cancelToken || l.signal) && (r = t => {
                            g && (n(!t || t.type ? new eU(null, e, g) : t), g.abort(), g = null)
                        }, l.cancelToken && l.cancelToken.subscribe(r), l.signal && (l.signal.aborted ? r() : l.signal.addEventListener("abort", r)));
                        let m = function(e) {
                            let t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                            return t && t[1] || ""
                        }(l.url);
                        if (m && -1 === ew.protocols.indexOf(m)) {
                            n(new ee("Unsupported protocol " + m + ":", ee.ERR_BAD_REQUEST, e));
                            return
                        }
                        g.send(u || null)
                    })
                },
                eJ = (e, t) => {
                    let {
                        length: n
                    } = e = e ? e.filter(Boolean) : [];
                    if (t || n) {
                        let n, r = new AbortController,
                            i = function(e) {
                                if (!n) {
                                    n = !0, a();
                                    let t = e instanceof Error ? e : this.reason;
                                    r.abort(t instanceof ee ? t : new eU(t instanceof Error ? t.message : t))
                                }
                            },
                            s = t && setTimeout(() => {
                                s = null, i(new ee(`timeout ${t} of ms exceeded`, ee.ETIMEDOUT))
                            }, t),
                            a = () => {
                                e && (s && clearTimeout(s), s = null, e.forEach(e => {
                                    e.unsubscribe ? e.unsubscribe(i) : e.removeEventListener("abort", i)
                                }), e = null)
                            };
                        e.forEach(e => e.addEventListener("abort", i));
                        let {
                            signal: o
                        } = r;
                        return o.unsubscribe = () => $.asap(a), o
                    }
                };
            let eZ = function*(e, t) {
                    let n, r = e.byteLength;
                    if (!t || r < t) {
                        yield e;
                        return
                    }
                    let i = 0;
                    for (; i < r;) n = i + t, yield e.slice(i, n), i = n
                },
                e$ = async function*(e, t) {
                    for await (let n of e0(e)) yield* eZ(n, t)
                },
                e0 = async function*(e) {
                    if (e[Symbol.asyncIterator]) {
                        yield* e;
                        return
                    }
                    let t = e.getReader();
                    try {
                        for (;;) {
                            let {
                                done: e,
                                value: n
                            } = await t.read();
                            if (e) break;
                            yield n
                        }
                    } finally {
                        await t.cancel()
                    }
                },
                e1 = (e, t, n, r) => {
                    let i;
                    let s = e$(e, t),
                        a = 0,
                        o = e => {
                            !i && (i = !0, r && r(e))
                        };
                    return new ReadableStream({
                        async pull(e) {
                            try {
                                let {
                                    done: t,
                                    value: r
                                } = await s.next();
                                if (t) {
                                    o(), e.close();
                                    return
                                }
                                let i = r.byteLength;
                                if (n) {
                                    let e = a += i;
                                    n(e)
                                }
                                e.enqueue(new Uint8Array(r))
                            } catch (e) {
                                throw o(e), e
                            }
                        },
                        cancel: e => (o(e), s.return())
                    }, {
                        highWaterMark: 2
                    })
                },
                e2 = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response,
                e3 = e2 && "function" == typeof ReadableStream,
                e4 = e2 && ("function" == typeof TextEncoder ? (o = new TextEncoder, e => o.encode(e)) : async e => new Uint8Array(await new Response(e).arrayBuffer())),
                e5 = (e, ...t) => {
                    try {
                        return !!e(...t)
                    } catch (e) {
                        return !1
                    }
                },
                e6 = e3 && e5(() => {
                    let e = !1,
                        t = new Request(ew.origin, {
                            body: new ReadableStream,
                            method: "POST",
                            get duplex() {
                                return e = !0, "half"
                            }
                        }).headers.has("Content-Type");
                    return e && !t
                }),
                e8 = e3 && e5(() => $.isReadableStream(new Response("").body)),
                e9 = {
                    stream: e8 && (e => e.body)
                };
            e2 && (d = new Response, ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
                e9[e] || (e9[e] = $.isFunction(d[e]) ? t => t[e]() : (t, n) => {
                    throw new ee(`Response type '${e}' is not supported`, ee.ERR_NOT_SUPPORT, n)
                })
            }));
            let e7 = async e => {
                    if (null == e) return 0;
                    if ($.isBlob(e)) return e.size;
                    if ($.isSpecCompliantForm(e)) {
                        let t = new Request(ew.origin, {
                            method: "POST",
                            body: e
                        });
                        return (await t.arrayBuffer()).byteLength
                    }
                    return $.isArrayBufferView(e) || $.isArrayBuffer(e) ? e.byteLength : ($.isURLSearchParams(e) && (e += ""), $.isString(e)) ? (await e4(e)).byteLength : void 0
                },
                te = async (e, t) => {
                    let n = $.toFiniteNumber(e.getContentLength());
                    return null == n ? e7(t) : n
                },
                tt = {
                    http: null,
                    xhr: eK,
                    fetch: e2 && (async e => {
                        let t, n, {
                            url: r,
                            method: i,
                            data: s,
                            signal: a,
                            cancelToken: o,
                            timeout: l,
                            onDownloadProgress: u,
                            onUploadProgress: c,
                            responseType: h,
                            headers: d,
                            withCredentials: f = "same-origin",
                            fetchOptions: p
                        } = eq(e);
                        h = h ? (h + "").toLowerCase() : "text";
                        let g = eJ([a, o && o.toAbortSignal()], l),
                            A = g && g.unsubscribe && (() => {
                                g.unsubscribe()
                            });
                        try {
                            if (c && e6 && "get" !== i && "head" !== i && 0 !== (n = await te(d, s))) {
                                let e, t = new Request(r, {
                                    method: "POST",
                                    body: s,
                                    duplex: "half"
                                });
                                if ($.isFormData(s) && (e = t.headers.get("content-type")) && d.setContentType(e), t.body) {
                                    let [e, r] = ez(n, eG(eH(c)));
                                    s = e1(t.body, 65536, e, r)
                                }
                            }
                            $.isString(f) || (f = f ? "include" : "omit");
                            let a = "credentials" in Request.prototype;
                            t = new Request(r, { ...p,
                                signal: g,
                                method: i.toUpperCase(),
                                headers: d.normalize().toJSON(),
                                body: s,
                                duplex: "half",
                                credentials: a ? f : void 0
                            });
                            let o = await fetch(t),
                                l = e8 && ("stream" === h || "response" === h);
                            if (e8 && (u || l && A)) {
                                let e = {};
                                ["status", "statusText", "headers"].forEach(t => {
                                    e[t] = o[t]
                                });
                                let t = $.toFiniteNumber(o.headers.get("content-length")),
                                    [n, r] = u && ez(t, eG(eH(u), !0)) || [];
                                o = new Response(e1(o.body, 65536, n, () => {
                                    r && r(), A && A()
                                }), e)
                            }
                            h = h || "text";
                            let m = await e9[$.findKey(e9, h) || "text"](o, e);
                            return !l && A && A(), await new Promise((n, r) => {
                                eF(n, r, {
                                    data: m,
                                    headers: eP.from(o.headers),
                                    status: o.status,
                                    statusText: o.statusText,
                                    config: e,
                                    request: t
                                })
                            })
                        } catch (n) {
                            if (A && A(), n && "TypeError" === n.name && /fetch/i.test(n.message)) throw Object.assign(new ee("Network Error", ee.ERR_NETWORK, e, t), {
                                cause: n.cause || n
                            });
                            throw ee.from(n, n && n.code, e, t)
                        }
                    })
                };
            $.forEach(tt, (e, t) => {
                if (e) {
                    try {
                        Object.defineProperty(e, "name", {
                            value: t
                        })
                    } catch (e) {}
                    Object.defineProperty(e, "adapterName", {
                        value: t
                    })
                }
            });
            let tn = e => `- ${e}`,
                tr = e => $.isFunction(e) || null === e || !1 === e;
            var ti = e => {
                let t, n;
                let {
                    length: r
                } = e = $.isArray(e) ? e : [e], i = {};
                for (let s = 0; s < r; s++) {
                    let r;
                    if (n = t = e[s], !tr(t) && void 0 === (n = tt[(r = String(t)).toLowerCase()])) throw new ee(`Unknown adapter '${r}'`);
                    if (n) break;
                    i[r || "#" + s] = n
                }
                if (!n) {
                    let e = Object.entries(i).map(([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"));
                    throw new ee("There is no suitable adapter to dispatch the request " + (r ? e.length > 1 ? "since :\n" + e.map(tn).join("\n") : " " + tn(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT")
                }
                return n
            };

            function ts(e) {
                if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new eU(null, e)
            }

            function ta(e) {
                return ts(e), e.headers = eP.from(e.headers), e.data = eO.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1), ti(e.adapter || eS.adapter)(e).then(function(t) {
                    return ts(e), t.data = eO.call(e, e.transformResponse, t), t.headers = eP.from(t.headers), t
                }, function(t) {
                    return !eN(t) && (ts(e), t && t.response && (t.response.data = eO.call(e, e.transformResponse, t.response), t.response.headers = eP.from(t.response.headers))), Promise.reject(t)
                })
            }
            let to = "1.7.9",
                tl = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
                tl[e] = function(n) {
                    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
                }
            });
            let tu = {};
            tl.transitional = function(e, t, n) {
                function r(e, t) {
                    return "[Axios v" + to + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
                }
                return (n, i, s) => {
                    if (!1 === e) throw new ee(r(i, " has been removed" + (t ? " in " + t : "")), ee.ERR_DEPRECATED);
                    return t && !tu[i] && (tu[i] = !0, console.warn(r(i, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, i, s)
                }
            }, tl.spelling = function(e) {
                return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0)
            };
            var tc = {
                assertOptions: function(e, t, n) {
                    if ("object" != typeof e) throw new ee("options must be an object", ee.ERR_BAD_OPTION_VALUE);
                    let r = Object.keys(e),
                        i = r.length;
                    for (; i-- > 0;) {
                        let s = r[i],
                            a = t[s];
                        if (a) {
                            let t = e[s],
                                n = void 0 === t || a(t, s, e);
                            if (!0 !== n) throw new ee("option " + s + " must be " + n, ee.ERR_BAD_OPTION_VALUE);
                            continue
                        }
                        if (!0 !== n) throw new ee("Unknown option " + s, ee.ERR_BAD_OPTION)
                    }
                },
                validators: tl
            };
            let th = tc.validators;
            class td {
                constructor(e) {
                    this.defaults = e, this.interceptors = {
                        request: new ep,
                        response: new ep
                    }
                }
                async request(e, t) {
                    try {
                        return await this._request(e, t)
                    } catch (e) {
                        if (e instanceof Error) {
                            let t = {};
                            Error.captureStackTrace ? Error.captureStackTrace(t) : t = Error();
                            let n = t.stack ? t.stack.replace(/^.+\n/, "") : "";
                            try {
                                e.stack ? n && !String(e.stack).endsWith(n.replace(/^.+\n.+\n/, "")) && (e.stack += "\n" + n) : e.stack = n
                            } catch (e) {}
                        }
                        throw e
                    }
                }
                _request(e, t) {
                    let n, r;
                    "string" == typeof e ? (t = t || {}).url = e : t = e || {};
                    let {
                        transitional: i,
                        paramsSerializer: s,
                        headers: a
                    } = t = eX(this.defaults, t);
                    void 0 !== i && tc.assertOptions(i, {
                        silentJSONParsing: th.transitional(th.boolean),
                        forcedJSONParsing: th.transitional(th.boolean),
                        clarifyTimeoutError: th.transitional(th.boolean)
                    }, !1), null != s && ($.isFunction(s) ? t.paramsSerializer = {
                        serialize: s
                    } : tc.assertOptions(s, {
                        encode: th.function,
                        serialize: th.function
                    }, !0)), tc.assertOptions(t, {
                        baseUrl: th.spelling("baseURL"),
                        withXsrfToken: th.spelling("withXSRFToken")
                    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
                    let o = a && $.merge(a.common, a[t.method]);
                    a && $.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => {
                        delete a[e]
                    }), t.headers = eP.concat(o, a);
                    let l = [],
                        u = !0;
                    this.interceptors.request.forEach(function(e) {
                        ("function" != typeof e.runWhen || !1 !== e.runWhen(t)) && (u = u && e.synchronous, l.unshift(e.fulfilled, e.rejected))
                    });
                    let c = [];
                    this.interceptors.response.forEach(function(e) {
                        c.push(e.fulfilled, e.rejected)
                    });
                    let h = 0;
                    if (!u) {
                        let e = [ta.bind(this), void 0];
                        for (e.unshift.apply(e, l), e.push.apply(e, c), r = e.length, n = Promise.resolve(t); h < r;) n = n.then(e[h++], e[h++]);
                        return n
                    }
                    r = l.length;
                    let d = t;
                    for (h = 0; h < r;) {
                        let e = l[h++],
                            t = l[h++];
                        try {
                            d = e(d)
                        } catch (e) {
                            t.call(this, e);
                            break
                        }
                    }
                    try {
                        n = ta.call(this, d)
                    } catch (e) {
                        return Promise.reject(e)
                    }
                    for (h = 0, r = c.length; h < r;) n = n.then(c[h++], c[h++]);
                    return n
                }
                getUri(e) {
                    return ef(eW((e = eX(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
                }
            }
            $.forEach(["delete", "get", "head", "options"], function(e) {
                td.prototype[e] = function(t, n) {
                    return this.request(eX(n || {}, {
                        method: e,
                        url: t,
                        data: (n || {}).data
                    }))
                }
            }), $.forEach(["post", "put", "patch"], function(e) {
                function t(t) {
                    return function(n, r, i) {
                        return this.request(eX(i || {}, {
                            method: e,
                            headers: t ? {
                                "Content-Type": "multipart/form-data"
                            } : {},
                            url: n,
                            data: r
                        }))
                    }
                }
                td.prototype[e] = t(), td.prototype[e + "Form"] = t(!0)
            });
            class tf {
                constructor(e) {
                    let t;
                    if ("function" != typeof e) throw TypeError("executor must be a function.");
                    this.promise = new Promise(function(e) {
                        t = e
                    });
                    let n = this;
                    this.promise.then(e => {
                        if (!n._listeners) return;
                        let t = n._listeners.length;
                        for (; t-- > 0;) n._listeners[t](e);
                        n._listeners = null
                    }), this.promise.then = e => {
                        let t;
                        let r = new Promise(e => {
                            n.subscribe(e), t = e
                        }).then(e);
                        return r.cancel = function() {
                            n.unsubscribe(t)
                        }, r
                    }, e(function(e, r, i) {
                        n.reason || (n.reason = new eU(e, r, i), t(n.reason))
                    })
                }
                throwIfRequested() {
                    if (this.reason) throw this.reason
                }
                subscribe(e) {
                    if (this.reason) {
                        e(this.reason);
                        return
                    }
                    this._listeners ? this._listeners.push(e) : this._listeners = [e]
                }
                unsubscribe(e) {
                    if (!this._listeners) return;
                    let t = this._listeners.indexOf(e); - 1 !== t && this._listeners.splice(t, 1)
                }
                toAbortSignal() {
                    let e = new AbortController,
                        t = t => {
                            e.abort(t)
                        };
                    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal
                }
                static source() {
                    let e;
                    return {
                        token: new tf(function(t) {
                            e = t
                        }),
                        cancel: e
                    }
                }
            }
            let tp = {
                Continue: 100,
                SwitchingProtocols: 101,
                Processing: 102,
                EarlyHints: 103,
                Ok: 200,
                Created: 201,
                Accepted: 202,
                NonAuthoritativeInformation: 203,
                NoContent: 204,
                ResetContent: 205,
                PartialContent: 206,
                MultiStatus: 207,
                AlreadyReported: 208,
                ImUsed: 226,
                MultipleChoices: 300,
                MovedPermanently: 301,
                Found: 302,
                SeeOther: 303,
                NotModified: 304,
                UseProxy: 305,
                Unused: 306,
                TemporaryRedirect: 307,
                PermanentRedirect: 308,
                BadRequest: 400,
                Unauthorized: 401,
                PaymentRequired: 402,
                Forbidden: 403,
                NotFound: 404,
                MethodNotAllowed: 405,
                NotAcceptable: 406,
                ProxyAuthenticationRequired: 407,
                RequestTimeout: 408,
                Conflict: 409,
                Gone: 410,
                LengthRequired: 411,
                PreconditionFailed: 412,
                PayloadTooLarge: 413,
                UriTooLong: 414,
                UnsupportedMediaType: 415,
                RangeNotSatisfiable: 416,
                ExpectationFailed: 417,
                ImATeapot: 418,
                MisdirectedRequest: 421,
                UnprocessableEntity: 422,
                Locked: 423,
                FailedDependency: 424,
                TooEarly: 425,
                UpgradeRequired: 426,
                PreconditionRequired: 428,
                TooManyRequests: 429,
                RequestHeaderFieldsTooLarge: 431,
                UnavailableForLegalReasons: 451,
                InternalServerError: 500,
                NotImplemented: 501,
                BadGateway: 502,
                ServiceUnavailable: 503,
                GatewayTimeout: 504,
                HttpVersionNotSupported: 505,
                VariantAlsoNegotiates: 506,
                InsufficientStorage: 507,
                LoopDetected: 508,
                NotExtended: 510,
                NetworkAuthenticationRequired: 511
            };
            Object.entries(tp).forEach(([e, t]) => {
                tp[t] = e
            });
            let tg = function e(t) {
                let n = new td(t),
                    r = p(td.prototype.request, n);
                return $.extend(r, td.prototype, n, {
                    allOwnKeys: !0
                }), $.extend(r, n, null, {
                    allOwnKeys: !0
                }), r.create = function(n) {
                    return e(eX(t, n))
                }, r
            }(eS);
            tg.Axios = td, tg.CanceledError = eU, tg.CancelToken = tf, tg.isCancel = eN, tg.VERSION = to, tg.toFormData = el, tg.AxiosError = ee, tg.Cancel = tg.CanceledError, tg.all = function(e) {
                return Promise.all(e)
            }, tg.spread = function(e) {
                return function(t) {
                    return e.apply(null, t)
                }
            }, tg.isAxiosError = function(e) {
                return $.isObject(e) && !0 === e.isAxiosError
            }, tg.mergeConfig = eX, tg.AxiosHeaders = eP, tg.formToJSON = e => eC($.isHTMLForm(e) ? new FormData(e) : e), tg.getAdapter = ti, tg.HttpStatusCode = tp, tg.default = tg;
            var tA = n(8020),
                tm = n(5872).lW;
            let tv = "".concat(tA.Fn.GF_CONSUMER_KEY, ":").concat(tA.Fn.GF_CONSUMER_SECRET),
                ty = tm.from(tv).toString("base64"),
                tx = tg.create({
                    baseURL: tA.CT,
                    headers: {
                        Authorization: "Basic ".concat(ty)
                    }
                });
            tg.create({
                baseURL: tA.I6
            }).defaults.headers.common.Env = "production"
        },
        3142: function(e, t, n) {
            "use strict";
            var r = n(1527),
                i = n(959),
                s = n(9310),
                a = n(2808),
                o = n(989);
            let l = (0, a.j)(["group relative", "flex items-center justify-center flex-nowrap rounded-[.8rem] px-spacing-md py-spacing-sm", "[&>*]:relative [&>*]:flex [&>*]:overflow-hidden [&>*]:!-my-[0.36em]", "transition-colors duration-300 ease-in-out"], {
                    variants: {
                        variant: {
                            primary: ["bg-surface-primary-dark text-text-button-primary-dark hover:bg-text-accent-light-dark"],
                            secondary: ["bg-transparent text-text-primary-dark"]
                        }
                    },
                    defaultVariants: {
                        variant: "primary"
                    }
                }),
                u = (0, i.forwardRef)((e, t) => {
                    let {
                        children: n,
                        variant: i,
                        endIcon: a,
                        className: u,
                        asChild: c = !1,
                        ...h
                    } = e, d = c ? s.g7 : "button";
                    return (0, r.jsxs)(d, {
                        ref: t,
                        className: (0, o.cn)(l({
                            variant: i,
                            className: u
                        })),
                        ...h,
                        children: [(0, r.jsx)(s.A4, {
                            children: n
                        }), a ? (0, r.jsxs)("span", {
                            className: "relative ml-spacing-xxs flex items-center justify-center overflow-hidden",
                            children: [(0, r.jsx)("span", {
                                className: (0, o.cn)("flex translate-x-0 pl-spacing-xxs", "transition-transform duration-300 ease-out-cubic", "group-hover:translate-x-full"),
                                children: a
                            }), (0, r.jsx)("span", {
                                className: (0, o.cn)("absolute inset-0 -translate-x-full pl-spacing-xxs", "transition-transform duration-300 ease-out-cubic", "group-hover:translate-x-0"),
                                children: a
                            })]
                        }) : null]
                    })
                });
            t.Z = u
        },
        5478: function(e, t, n) {
            "use strict";
            let r, i, s, a;
            n.d(t, {
                Z: function() {
                    return sH
                }
            });
            var o, l, u, c, h, d, f, p, g, A, m = n(1527),
                v = n(959),
                y = function(e) {
                    var t;
                    return !!e && "object" == typeof e && "[object RegExp]" !== (t = Object.prototype.toString.call(e)) && "[object Date]" !== t && e.$$typeof !== x
                },
                x = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;

            function E(e, t) {
                return !1 !== t.clone && t.isMergeableObject(e) ? b(Array.isArray(e) ? [] : {}, e, t) : e
            }

            function _(e, t, n) {
                return e.concat(t).map(function(e) {
                    return E(e, n)
                })
            }

            function b(e, t, n) {
                (n = n || {}).arrayMerge = n.arrayMerge || _, n.isMergeableObject = n.isMergeableObject || y;
                var r, i, s = Array.isArray(t);
                return s !== Array.isArray(e) ? E(t, n) : s ? n.arrayMerge(e, t, n) : (i = {}, (r = n).isMergeableObject(e) && Object.keys(e).forEach(function(t) {
                    i[t] = E(e[t], r)
                }), Object.keys(t).forEach(function(n) {
                    r.isMergeableObject(t[n]) && e[n] ? i[n] = b(e[n], t[n], r) : i[n] = E(t[n], r)
                }), i)
            }
            b.all = function(e, t) {
                if (!Array.isArray(e)) throw Error("first argument should be an array");
                return e.reduce(function(e, n) {
                    return b(e, n, t)
                }, {})
            };
            var w = b,
                C = "object" == typeof global && global && global.Object === Object && global,
                S = "object" == typeof self && self && self.Object === Object && self,
                I = C || S || Function("return this")(),
                M = I.Symbol,
                T = Object.prototype,
                B = T.hasOwnProperty,
                R = T.toString,
                D = M ? M.toStringTag : void 0,
                L = function(e) {
                    var t = B.call(e, D),
                        n = e[D];
                    try {
                        e[D] = void 0;
                        var r = !0
                    } catch (e) {}
                    var i = R.call(e);
                    return r && (t ? e[D] = n : delete e[D]), i
                },
                P = Object.prototype.toString,
                O = M ? M.toStringTag : void 0,
                N = function(e) {
                    return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : O && O in Object(e) ? L(e) : P.call(e)
                },
                U = function(e, t) {
                    return function(n) {
                        return e(t(n))
                    }
                },
                F = U(Object.getPrototypeOf, Object),
                k = function(e) {
                    return null != e && "object" == typeof e
                },
                Q = Object.prototype,
                G = Function.prototype.toString,
                z = Q.hasOwnProperty,
                H = G.call(Object),
                V = function(e) {
                    if (!k(e) || "[object Object]" != N(e)) return !1;
                    var t = F(e);
                    if (null === t) return !0;
                    var n = z.call(t, "constructor") && t.constructor;
                    return "function" == typeof n && n instanceof n && G.call(n) == H
                },
                j = function(e, t) {
                    return e === t || e != e && t != t
                },
                W = function(e, t) {
                    for (var n = e.length; n--;)
                        if (j(e[n][0], t)) return n;
                    return -1
                },
                Y = Array.prototype.splice;

            function X(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }
            X.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, X.prototype.delete = function(e) {
                var t = this.__data__,
                    n = W(t, e);
                return !(n < 0) && (n == t.length - 1 ? t.pop() : Y.call(t, n, 1), --this.size, !0)
            }, X.prototype.get = function(e) {
                var t = this.__data__,
                    n = W(t, e);
                return n < 0 ? void 0 : t[n][1]
            }, X.prototype.has = function(e) {
                return W(this.__data__, e) > -1
            }, X.prototype.set = function(e, t) {
                var n = this.__data__,
                    r = W(n, e);
                return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this
            };
            var q = function(e) {
                    var t = typeof e;
                    return null != e && ("object" == t || "function" == t)
                },
                K = function(e) {
                    if (!q(e)) return !1;
                    var t = N(e);
                    return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
                },
                J = I["__core-js_shared__"],
                Z = (o = /[^.]+$/.exec(J && J.keys && J.keys.IE_PROTO || "")) ? "Symbol(src)_1." + o : "",
                $ = Function.prototype.toString,
                ee = function(e) {
                    if (null != e) {
                        try {
                            return $.call(e)
                        } catch (e) {}
                        try {
                            return e + ""
                        } catch (e) {}
                    }
                    return ""
                },
                et = /^\[object .+?Constructor\]$/,
                en = Object.prototype,
                er = Function.prototype.toString,
                ei = en.hasOwnProperty,
                es = RegExp("^" + er.call(ei).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                ea = function(e, t) {
                    var n, r = null == e ? void 0 : e[t];
                    return q(n = r) && (!Z || !(Z in n)) && (K(n) ? es : et).test(ee(n)) ? r : void 0
                },
                eo = ea(I, "Map"),
                el = ea(Object, "create"),
                eu = Object.prototype.hasOwnProperty,
                ec = Object.prototype.hasOwnProperty;

            function eh(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }
            eh.prototype.clear = function() {
                this.__data__ = el ? el(null) : {}, this.size = 0
            }, eh.prototype.delete = function(e) {
                var t = this.has(e) && delete this.__data__[e];
                return this.size -= t ? 1 : 0, t
            }, eh.prototype.get = function(e) {
                var t = this.__data__;
                if (el) {
                    var n = t[e];
                    return "__lodash_hash_undefined__" === n ? void 0 : n
                }
                return eu.call(t, e) ? t[e] : void 0
            }, eh.prototype.has = function(e) {
                var t = this.__data__;
                return el ? void 0 !== t[e] : ec.call(t, e)
            }, eh.prototype.set = function(e, t) {
                var n = this.__data__;
                return this.size += this.has(e) ? 0 : 1, n[e] = el && void 0 === t ? "__lodash_hash_undefined__" : t, this
            };
            var ed = function(e) {
                    var t = typeof e;
                    return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e
                },
                ef = function(e, t) {
                    var n = e.__data__;
                    return ed(t) ? n["string" == typeof t ? "string" : "hash"] : n.map
                };

            function ep(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }

            function eg(e) {
                var t = this.__data__ = new X(e);
                this.size = t.size
            }
            ep.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new eh,
                    map: new(eo || X),
                    string: new eh
                }
            }, ep.prototype.delete = function(e) {
                var t = ef(this, e).delete(e);
                return this.size -= t ? 1 : 0, t
            }, ep.prototype.get = function(e) {
                return ef(this, e).get(e)
            }, ep.prototype.has = function(e) {
                return ef(this, e).has(e)
            }, ep.prototype.set = function(e, t) {
                var n = ef(this, e),
                    r = n.size;
                return n.set(e, t), this.size += n.size == r ? 0 : 1, this
            }, eg.prototype.clear = function() {
                this.__data__ = new X, this.size = 0
            }, eg.prototype.delete = function(e) {
                var t = this.__data__,
                    n = t.delete(e);
                return this.size = t.size, n
            }, eg.prototype.get = function(e) {
                return this.__data__.get(e)
            }, eg.prototype.has = function(e) {
                return this.__data__.has(e)
            }, eg.prototype.set = function(e, t) {
                var n = this.__data__;
                if (n instanceof X) {
                    var r = n.__data__;
                    if (!eo || r.length < 199) return r.push([e, t]), this.size = ++n.size, this;
                    n = this.__data__ = new ep(r)
                }
                return n.set(e, t), this.size = n.size, this
            };
            var eA = function(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e););
                    return e
                },
                em = function() {
                    try {
                        var e = ea(Object, "defineProperty");
                        return e({}, "", {}), e
                    } catch (e) {}
                }(),
                ev = function(e, t, n) {
                    "__proto__" == t && em ? em(e, t, {
                        configurable: !0,
                        enumerable: !0,
                        value: n,
                        writable: !0
                    }) : e[t] = n
                },
                ey = Object.prototype.hasOwnProperty,
                ex = function(e, t, n) {
                    var r = e[t];
                    ey.call(e, t) && j(r, n) && (void 0 !== n || t in e) || ev(e, t, n)
                },
                eE = function(e, t, n, r) {
                    var i = !n;
                    n || (n = {});
                    for (var s = -1, a = t.length; ++s < a;) {
                        var o = t[s],
                            l = r ? r(n[o], e[o], o, n, e) : void 0;
                        void 0 === l && (l = e[o]), i ? ev(n, o, l) : ex(n, o, l)
                    }
                    return n
                },
                e_ = function(e, t) {
                    for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n);
                    return r
                },
                eb = function(e) {
                    return k(e) && "[object Arguments]" == N(e)
                },
                ew = Object.prototype,
                eC = ew.hasOwnProperty,
                eS = ew.propertyIsEnumerable,
                eI = eb(function() {
                    return arguments
                }()) ? eb : function(e) {
                    return k(e) && eC.call(e, "callee") && !eS.call(e, "callee")
                },
                eM = Array.isArray,
                eT = "object" == typeof exports && exports && !exports.nodeType && exports,
                eB = eT && "object" == typeof module && module && !module.nodeType && module,
                eR = eB && eB.exports === eT ? I.Buffer : void 0,
                eD = (eR ? eR.isBuffer : void 0) || function() {
                    return !1
                },
                eL = /^(?:0|[1-9]\d*)$/,
                eP = function(e, t) {
                    var n = typeof e;
                    return !!(t = null == t ? 9007199254740991 : t) && ("number" == n || "symbol" != n && eL.test(e)) && e > -1 && e % 1 == 0 && e < t
                },
                eO = function(e) {
                    return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
                },
                eN = {};
            eN["[object Float32Array]"] = eN["[object Float64Array]"] = eN["[object Int8Array]"] = eN["[object Int16Array]"] = eN["[object Int32Array]"] = eN["[object Uint8Array]"] = eN["[object Uint8ClampedArray]"] = eN["[object Uint16Array]"] = eN["[object Uint32Array]"] = !0, eN["[object Arguments]"] = eN["[object Array]"] = eN["[object ArrayBuffer]"] = eN["[object Boolean]"] = eN["[object DataView]"] = eN["[object Date]"] = eN["[object Error]"] = eN["[object Function]"] = eN["[object Map]"] = eN["[object Number]"] = eN["[object Object]"] = eN["[object RegExp]"] = eN["[object Set]"] = eN["[object String]"] = eN["[object WeakMap]"] = !1;
            var eU = function(e) {
                    return function(t) {
                        return e(t)
                    }
                },
                eF = "object" == typeof exports && exports && !exports.nodeType && exports,
                ek = eF && "object" == typeof module && module && !module.nodeType && module,
                eQ = ek && ek.exports === eF && C.process,
                eG = function() {
                    try {
                        var e = ek && ek.require && ek.require("util").types;
                        if (e) return e;
                        return eQ && eQ.binding && eQ.binding("util")
                    } catch (e) {}
                }(),
                ez = eG && eG.isTypedArray,
                eH = ez ? eU(ez) : function(e) {
                    return k(e) && eO(e.length) && !!eN[N(e)]
                },
                eV = Object.prototype.hasOwnProperty,
                ej = function(e, t) {
                    var n = eM(e),
                        r = !n && eI(e),
                        i = !n && !r && eD(e),
                        s = !n && !r && !i && eH(e),
                        a = n || r || i || s,
                        o = a ? e_(e.length, String) : [],
                        l = o.length;
                    for (var u in e)(t || eV.call(e, u)) && !(a && ("length" == u || i && ("offset" == u || "parent" == u) || s && ("buffer" == u || "byteLength" == u || "byteOffset" == u) || eP(u, l))) && o.push(u);
                    return o
                },
                eW = Object.prototype,
                eY = function(e) {
                    var t = e && e.constructor;
                    return e === ("function" == typeof t && t.prototype || eW)
                },
                eX = U(Object.keys, Object),
                eq = Object.prototype.hasOwnProperty,
                eK = function(e) {
                    if (!eY(e)) return eX(e);
                    var t = [];
                    for (var n in Object(e)) eq.call(e, n) && "constructor" != n && t.push(n);
                    return t
                },
                eJ = function(e) {
                    return null != e && eO(e.length) && !K(e)
                },
                eZ = function(e) {
                    return eJ(e) ? ej(e) : eK(e)
                },
                e$ = function(e) {
                    var t = [];
                    if (null != e)
                        for (var n in Object(e)) t.push(n);
                    return t
                },
                e0 = Object.prototype.hasOwnProperty,
                e1 = function(e) {
                    if (!q(e)) return e$(e);
                    var t = eY(e),
                        n = [];
                    for (var r in e) "constructor" == r && (t || !e0.call(e, r)) || n.push(r);
                    return n
                },
                e2 = function(e) {
                    return eJ(e) ? ej(e, !0) : e1(e)
                },
                e3 = "object" == typeof exports && exports && !exports.nodeType && exports,
                e4 = e3 && "object" == typeof module && module && !module.nodeType && module,
                e5 = e4 && e4.exports === e3 ? I.Buffer : void 0,
                e6 = e5 ? e5.allocUnsafe : void 0,
                e8 = function(e, t) {
                    if (t) return e.slice();
                    var n = e.length,
                        r = e6 ? e6(n) : new e.constructor(n);
                    return e.copy(r), r
                },
                e9 = function(e, t) {
                    var n = -1,
                        r = e.length;
                    for (t || (t = Array(r)); ++n < r;) t[n] = e[n];
                    return t
                },
                e7 = function(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length, i = 0, s = []; ++n < r;) {
                        var a = e[n];
                        t(a, n, e) && (s[i++] = a)
                    }
                    return s
                },
                te = function() {
                    return []
                },
                tt = Object.prototype.propertyIsEnumerable,
                tn = Object.getOwnPropertySymbols,
                tr = tn ? function(e) {
                    return null == e ? [] : e7(tn(e = Object(e)), function(t) {
                        return tt.call(e, t)
                    })
                } : te,
                ti = function(e, t) {
                    for (var n = -1, r = t.length, i = e.length; ++n < r;) e[i + n] = t[n];
                    return e
                },
                ts = Object.getOwnPropertySymbols ? function(e) {
                    for (var t = []; e;) ti(t, tr(e)), e = F(e);
                    return t
                } : te,
                ta = function(e, t, n) {
                    var r = t(e);
                    return eM(e) ? r : ti(r, n(e))
                },
                to = function(e) {
                    return ta(e, eZ, tr)
                },
                tl = function(e) {
                    return ta(e, e2, ts)
                },
                tu = ea(I, "DataView"),
                tc = ea(I, "Promise"),
                th = ea(I, "Set"),
                td = ea(I, "WeakMap"),
                tf = "[object Map]",
                tp = "[object Promise]",
                tg = "[object Set]",
                tA = "[object WeakMap]",
                tm = "[object DataView]",
                tv = ee(tu),
                ty = ee(eo),
                tx = ee(tc),
                tE = ee(th),
                t_ = ee(td),
                tb = N;
            (tu && tb(new tu(new ArrayBuffer(1))) != tm || eo && tb(new eo) != tf || tc && tb(tc.resolve()) != tp || th && tb(new th) != tg || td && tb(new td) != tA) && (tb = function(e) {
                var t = N(e),
                    n = "[object Object]" == t ? e.constructor : void 0,
                    r = n ? ee(n) : "";
                if (r) switch (r) {
                    case tv:
                        return tm;
                    case ty:
                        return tf;
                    case tx:
                        return tp;
                    case tE:
                        return tg;
                    case t_:
                        return tA
                }
                return t
            });
            var tw = tb,
                tC = Object.prototype.hasOwnProperty,
                tS = function(e) {
                    var t = e.length,
                        n = new e.constructor(t);
                    return t && "string" == typeof e[0] && tC.call(e, "index") && (n.index = e.index, n.input = e.input), n
                },
                tI = I.Uint8Array,
                tM = function(e) {
                    var t = new e.constructor(e.byteLength);
                    return new tI(t).set(new tI(e)), t
                },
                tT = function(e, t) {
                    var n = t ? tM(e.buffer) : e.buffer;
                    return new e.constructor(n, e.byteOffset, e.byteLength)
                },
                tB = /\w*$/,
                tR = function(e) {
                    var t = new e.constructor(e.source, tB.exec(e));
                    return t.lastIndex = e.lastIndex, t
                },
                tD = M ? M.prototype : void 0,
                tL = tD ? tD.valueOf : void 0,
                tP = function(e, t) {
                    var n = t ? tM(e.buffer) : e.buffer;
                    return new e.constructor(n, e.byteOffset, e.length)
                },
                tO = function(e, t, n) {
                    var r = e.constructor;
                    switch (t) {
                        case "[object ArrayBuffer]":
                            return tM(e);
                        case "[object Boolean]":
                        case "[object Date]":
                            return new r(+e);
                        case "[object DataView]":
                            return tT(e, n);
                        case "[object Float32Array]":
                        case "[object Float64Array]":
                        case "[object Int8Array]":
                        case "[object Int16Array]":
                        case "[object Int32Array]":
                        case "[object Uint8Array]":
                        case "[object Uint8ClampedArray]":
                        case "[object Uint16Array]":
                        case "[object Uint32Array]":
                            return tP(e, n);
                        case "[object Map]":
                        case "[object Set]":
                            return new r;
                        case "[object Number]":
                        case "[object String]":
                            return new r(e);
                        case "[object RegExp]":
                            return tR(e);
                        case "[object Symbol]":
                            return tL ? Object(tL.call(e)) : {}
                    }
                },
                tN = Object.create,
                tU = function() {
                    function e() {}
                    return function(t) {
                        if (!q(t)) return {};
                        if (tN) return tN(t);
                        e.prototype = t;
                        var n = new e;
                        return e.prototype = void 0, n
                    }
                }(),
                tF = eG && eG.isMap,
                tk = tF ? eU(tF) : function(e) {
                    return k(e) && "[object Map]" == tw(e)
                },
                tQ = eG && eG.isSet,
                tG = tQ ? eU(tQ) : function(e) {
                    return k(e) && "[object Set]" == tw(e)
                },
                tz = "[object Arguments]",
                tH = "[object Function]",
                tV = "[object Object]",
                tj = {};
            tj[tz] = tj["[object Array]"] = tj["[object ArrayBuffer]"] = tj["[object DataView]"] = tj["[object Boolean]"] = tj["[object Date]"] = tj["[object Float32Array]"] = tj["[object Float64Array]"] = tj["[object Int8Array]"] = tj["[object Int16Array]"] = tj["[object Int32Array]"] = tj["[object Map]"] = tj["[object Number]"] = tj[tV] = tj["[object RegExp]"] = tj["[object Set]"] = tj["[object String]"] = tj["[object Symbol]"] = tj["[object Uint8Array]"] = tj["[object Uint8ClampedArray]"] = tj["[object Uint16Array]"] = tj["[object Uint32Array]"] = !0, tj["[object Error]"] = tj[tH] = tj["[object WeakMap]"] = !1;
            var tW = function e(t, n, r, i, s, a) {
                    var o, l = 1 & n,
                        u = 2 & n,
                        c = 4 & n;
                    if (r && (o = s ? r(t, i, s, a) : r(t)), void 0 !== o) return o;
                    if (!q(t)) return t;
                    var h = eM(t);
                    if (h) {
                        if (o = tS(t), !l) return e9(t, o)
                    } else {
                        var d, f, p, g, A = tw(t),
                            m = A == tH || "[object GeneratorFunction]" == A;
                        if (eD(t)) return e8(t, l);
                        if (A == tV || A == tz || m && !s) {
                            if (o = u || m ? {} : "function" != typeof t.constructor || eY(t) ? {} : tU(F(t)), !l) return u ? (f = (d = o) && eE(t, e2(t), d), eE(t, ts(t), f)) : (g = (p = o) && eE(t, eZ(t), p), eE(t, tr(t), g))
                        } else {
                            if (!tj[A]) return s ? t : {};
                            o = tO(t, A, l)
                        }
                    }
                    a || (a = new eg);
                    var v = a.get(t);
                    if (v) return v;
                    a.set(t, o), tG(t) ? t.forEach(function(i) {
                        o.add(e(i, n, r, i, t, a))
                    }) : tk(t) && t.forEach(function(i, s) {
                        o.set(s, e(i, n, r, s, t, a))
                    });
                    var y = c ? u ? tl : to : u ? e2 : eZ,
                        x = h ? void 0 : y(t);
                    return eA(x || t, function(i, s) {
                        x && (i = t[s = i]), ex(o, s, e(i, n, r, s, t, a))
                    }), o
                },
                tY = function(e) {
                    return tW(e, 5)
                },
                tX = n(1456),
                tq = n.n(tX),
                tK = function(e, t) {},
                tJ = function(e) {
                    return tW(e, 4)
                },
                tZ = function(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length, i = Array(r); ++n < r;) i[n] = t(e[n], n, e);
                    return i
                },
                t$ = function(e) {
                    return "symbol" == typeof e || k(e) && "[object Symbol]" == N(e)
                };

            function t0(e, t) {
                if ("function" != typeof e || null != t && "function" != typeof t) throw TypeError("Expected a function");
                var n = function() {
                    var r = arguments,
                        i = t ? t.apply(this, r) : r[0],
                        s = n.cache;
                    if (s.has(i)) return s.get(i);
                    var a = e.apply(this, r);
                    return n.cache = s.set(i, a) || s, a
                };
                return n.cache = new(t0.Cache || ep), n
            }
            t0.Cache = ep;
            var t1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                t2 = /\\(\\)?/g,
                t3 = (u = (l = t0(function(e) {
                    var t = [];
                    return 46 === e.charCodeAt(0) && t.push(""), e.replace(t1, function(e, n, r, i) {
                        t.push(r ? i.replace(t2, "$1") : n || e)
                    }), t
                }, function(e) {
                    return 500 === u.size && u.clear(), e
                })).cache, l),
                t4 = 1 / 0,
                t5 = function(e) {
                    if ("string" == typeof e || t$(e)) return e;
                    var t = e + "";
                    return "0" == t && 1 / e == -t4 ? "-0" : t
                },
                t6 = 1 / 0,
                t8 = M ? M.prototype : void 0,
                t9 = t8 ? t8.toString : void 0,
                t7 = function e(t) {
                    if ("string" == typeof t) return t;
                    if (eM(t)) return tZ(t, e) + "";
                    if (t$(t)) return t9 ? t9.call(t) : "";
                    var n = t + "";
                    return "0" == n && 1 / t == -t6 ? "-0" : n
                },
                ne = function(e) {
                    return eM(e) ? tZ(e, t5) : t$(e) ? [e] : e9(t3(null == e ? "" : t7(e)))
                };

            function nt() {
                return (nt = Object.assign || function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }).apply(this, arguments)
            }

            function nn(e, t) {
                if (null == e) return {};
                var n, r, i = {},
                    s = Object.keys(e);
                for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                return i
            }

            function nr(e) {
                if (void 0 === e) throw ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }
            n(2535);
            var ni = (0, v.createContext)(void 0);
            ni.displayName = "FormikContext", ni.Provider, ni.Consumer;
            var ns = function(e) {
                    return Array.isArray(e) && 0 === e.length
                },
                na = function(e) {
                    return "function" == typeof e
                },
                no = function(e) {
                    return null !== e && "object" == typeof e
                },
                nl = function(e) {
                    return "[object String]" === Object.prototype.toString.call(e)
                },
                nu = function(e) {
                    return no(e) && na(e.then)
                };

            function nc(e, t, n, r) {
                void 0 === r && (r = 0);
                for (var i = ne(t); e && r < i.length;) e = e[i[r++]];
                return r === i.length || e ? void 0 === e ? n : e : n
            }

            function nh(e, t, n) {
                for (var r = tJ(e), i = r, s = 0, a = ne(t); s < a.length - 1; s++) {
                    var o = a[s],
                        l = nc(e, a.slice(0, s + 1));
                    if (l && (no(l) || Array.isArray(l))) i = i[o] = tJ(l);
                    else {
                        var u = a[s + 1];
                        i = i[o] = String(Math.floor(Number(u))) === u && Number(u) >= 0 ? [] : {}
                    }
                }
                return (0 === s ? e : i)[a[s]] === n ? e : (void 0 === n ? delete i[a[s]] : i[a[s]] = n, 0 === s && void 0 === n && delete r[a[s]], r)
            }
            var nd = {},
                nf = {};

            function np(e, t, n) {
                var r = e.slice();
                return t.forEach(function(t, i) {
                    if (void 0 === r[i]) {
                        var s = !1 !== n.clone && n.isMergeableObject(t);
                        r[i] = s ? w(Array.isArray(t) ? [] : {}, t, n) : t
                    } else n.isMergeableObject(t) ? r[i] = w(e[i], t, n) : -1 === e.indexOf(t) && r.push(t)
                }), r
            }
            var ng = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement ? v.useLayoutEffect : v.useEffect;

            function nA(e) {
                var t = (0, v.useRef)(e);
                return ng(function() {
                    t.current = e
                }), (0, v.useCallback)(function() {
                    for (var e = arguments.length, n = Array(e), r = 0; r < e; r++) n[r] = arguments[r];
                    return t.current.apply(void 0, n)
                }, [])
            }(0, v.forwardRef)(function(e, t) {
                var n, r = e.action,
                    i = nn(e, ["action"]),
                    s = ((n = (0, v.useContext)(ni)) || tK(!1), n),
                    a = s.handleReset,
                    o = s.handleSubmit;
                return (0, v.createElement)("form", nt({
                    onSubmit: o,
                    ref: t,
                    onReset: a,
                    action: null != r ? r : "#"
                }, i))
            }).displayName = "Form";
            var nm = function(e, t, n) {
                    var r = nE(e),
                        i = r[t];
                    return r.splice(t, 1), r.splice(n, 0, i), r
                },
                nv = function(e, t, n) {
                    var r = nE(e),
                        i = r[t];
                    return r[t] = r[n], r[n] = i, r
                },
                ny = function(e, t, n) {
                    var r = nE(e);
                    return r.splice(t, 0, n), r
                },
                nx = function(e, t, n) {
                    var r = nE(e);
                    return r[t] = n, r
                },
                nE = function(e) {
                    if (!e) return [];
                    if (Array.isArray(e)) return [].concat(e);
                    var t = Object.keys(e).map(function(e) {
                        return parseInt(e)
                    }).reduce(function(e, t) {
                        return t > e ? t : e
                    }, 0);
                    return Array.from(nt({}, e, {
                        length: t + 1
                    }))
                },
                n_ = function(e, t) {
                    var n = "function" == typeof e ? e : t;
                    return function(e) {
                        return Array.isArray(e) || no(e) ? n(nE(e)) : e
                    }
                };
            (function(e) {
                function t(t) {
                    var n;
                    return (n = e.call(this, t) || this).updateArrayField = function(e, t, r) {
                        var i = n.props,
                            s = i.name;
                        (0, i.formik.setFormikState)(function(n) {
                            var i = n_(r, e),
                                a = n_(t, e),
                                o = nh(n.values, s, e(nc(n.values, s))),
                                l = r ? i(nc(n.errors, s)) : void 0,
                                u = t ? a(nc(n.touched, s)) : void 0;
                            return ns(l) && (l = void 0), ns(u) && (u = void 0), nt({}, n, {
                                values: o,
                                errors: r ? nh(n.errors, s, l) : n.errors,
                                touched: t ? nh(n.touched, s, u) : n.touched
                            })
                        })
                    }, n.push = function(e) {
                        return n.updateArrayField(function(t) {
                            return [].concat(nE(t), [tY(e)])
                        }, !1, !1)
                    }, n.handlePush = function(e) {
                        return function() {
                            return n.push(e)
                        }
                    }, n.swap = function(e, t) {
                        return n.updateArrayField(function(n) {
                            return nv(n, e, t)
                        }, !0, !0)
                    }, n.handleSwap = function(e, t) {
                        return function() {
                            return n.swap(e, t)
                        }
                    }, n.move = function(e, t) {
                        return n.updateArrayField(function(n) {
                            return nm(n, e, t)
                        }, !0, !0)
                    }, n.handleMove = function(e, t) {
                        return function() {
                            return n.move(e, t)
                        }
                    }, n.insert = function(e, t) {
                        return n.updateArrayField(function(n) {
                            return ny(n, e, t)
                        }, function(t) {
                            return ny(t, e, null)
                        }, function(t) {
                            return ny(t, e, null)
                        })
                    }, n.handleInsert = function(e, t) {
                        return function() {
                            return n.insert(e, t)
                        }
                    }, n.replace = function(e, t) {
                        return n.updateArrayField(function(n) {
                            return nx(n, e, t)
                        }, !1, !1)
                    }, n.handleReplace = function(e, t) {
                        return function() {
                            return n.replace(e, t)
                        }
                    }, n.unshift = function(e) {
                        var t = -1;
                        return n.updateArrayField(function(n) {
                            var r = n ? [e].concat(n) : [e];
                            return t = r.length, r
                        }, function(e) {
                            return e ? [null].concat(e) : [null]
                        }, function(e) {
                            return e ? [null].concat(e) : [null]
                        }), t
                    }, n.handleUnshift = function(e) {
                        return function() {
                            return n.unshift(e)
                        }
                    }, n.handleRemove = function(e) {
                        return function() {
                            return n.remove(e)
                        }
                    }, n.handlePop = function() {
                        return function() {
                            return n.pop()
                        }
                    }, n.remove = n.remove.bind(nr(n)), n.pop = n.pop.bind(nr(n)), n
                }
                t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
                var n = t.prototype;
                return n.componentDidUpdate = function(e) {
                    this.props.validateOnChange && this.props.formik.validateOnChange && !tq()(nc(e.formik.values, e.name), nc(this.props.formik.values, this.props.name)) && this.props.formik.validateForm(this.props.formik.values)
                }, n.remove = function(e) {
                    var t;
                    return this.updateArrayField(function(n) {
                        var r = n ? nE(n) : [];
                        return t || (t = r[e]), na(r.splice) && r.splice(e, 1), na(r.every) && r.every(function(e) {
                            return void 0 === e
                        }) ? [] : r
                    }, !0, !0), t
                }, n.pop = function() {
                    var e;
                    return this.updateArrayField(function(t) {
                        var n = t.slice();
                        return e || (e = n && n.pop && n.pop()), n
                    }, !0, !0), e
                }, n.render = function() {
                    var e = {
                            push: this.push,
                            pop: this.pop,
                            swap: this.swap,
                            move: this.move,
                            insert: this.insert,
                            replace: this.replace,
                            unshift: this.unshift,
                            remove: this.remove,
                            handlePush: this.handlePush,
                            handlePop: this.handlePop,
                            handleSwap: this.handleSwap,
                            handleMove: this.handleMove,
                            handleInsert: this.handleInsert,
                            handleReplace: this.handleReplace,
                            handleUnshift: this.handleUnshift,
                            handleRemove: this.handleRemove
                        },
                        t = this.props,
                        n = t.component,
                        r = t.render,
                        i = t.children,
                        s = t.name,
                        a = nn(t.formik, ["validate", "validationSchema"]),
                        o = nt({}, e, {
                            form: a,
                            name: s
                        });
                    return n ? (0, v.createElement)(n, o) : r ? r(o) : i ? "function" == typeof i ? i(o) : 0 === v.Children.count(i) ? null : v.Children.only(i) : null
                }, t
            })(v.Component).defaultProps = {
                validateOnChange: !0
            };
            var nb = n(8349),
                nw = n(422);

            function nC(e, [t, n]) {
                return Math.min(n, Math.max(t, e))
            }
            var nS = n(5061),
                nI = n(1354),
                nM = n(3079),
                nT = n(9310),
                nB = n(9650),
                nR = v.createContext(void 0),
                nD = n(3190),
                nL = 0;

            function nP() {
                let e = document.createElement("span");
                return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e
            }
            var nO = n(5176),
                nN = n(5203),
                nU = "focusScope.autoFocusOnMount",
                nF = "focusScope.autoFocusOnUnmount",
                nk = {
                    bubbles: !1,
                    cancelable: !0
                },
                nQ = v.forwardRef((e, t) => {
                    let {
                        loop: n = !1,
                        trapped: r = !1,
                        onMountAutoFocus: i,
                        onUnmountAutoFocus: s,
                        ...a
                    } = e, [o, l] = v.useState(null), u = (0, nN.W)(i), c = (0, nN.W)(s), h = v.useRef(null), d = (0, nM.e)(t, e => l(e)), f = v.useRef({
                        paused: !1,
                        pause() {
                            this.paused = !0
                        },
                        resume() {
                            this.paused = !1
                        }
                    }).current;
                    v.useEffect(() => {
                        if (r) {
                            let e = function(e) {
                                    if (f.paused || !o) return;
                                    let t = e.target;
                                    o.contains(t) ? h.current = t : nH(h.current, {
                                        select: !0
                                    })
                                },
                                t = function(e) {
                                    if (f.paused || !o) return;
                                    let t = e.relatedTarget;
                                    null === t || o.contains(t) || nH(h.current, {
                                        select: !0
                                    })
                                };
                            document.addEventListener("focusin", e), document.addEventListener("focusout", t);
                            let n = new MutationObserver(function(e) {
                                if (document.activeElement === document.body)
                                    for (let t of e) t.removedNodes.length > 0 && nH(o)
                            });
                            return o && n.observe(o, {
                                childList: !0,
                                subtree: !0
                            }), () => {
                                document.removeEventListener("focusin", e), document.removeEventListener("focusout", t), n.disconnect()
                            }
                        }
                    }, [r, o, f.paused]), v.useEffect(() => {
                        if (o) {
                            nV.add(f);
                            let e = document.activeElement;
                            if (!o.contains(e)) {
                                let t = new CustomEvent(nU, nk);
                                o.addEventListener(nU, u), o.dispatchEvent(t), t.defaultPrevented || (function(e, {
                                    select: t = !1
                                } = {}) {
                                    let n = document.activeElement;
                                    for (let r of e)
                                        if (nH(r, {
                                                select: t
                                            }), document.activeElement !== n) return
                                }(nG(o).filter(e => "A" !== e.tagName), {
                                    select: !0
                                }), document.activeElement === e && nH(o))
                            }
                            return () => {
                                o.removeEventListener(nU, u), setTimeout(() => {
                                    let t = new CustomEvent(nF, nk);
                                    o.addEventListener(nF, c), o.dispatchEvent(t), t.defaultPrevented || nH(e ? ? document.body, {
                                        select: !0
                                    }), o.removeEventListener(nF, c), nV.remove(f)
                                }, 0)
                            }
                        }
                    }, [o, u, c, f]);
                    let p = v.useCallback(e => {
                        if (!n && !r || f.paused) return;
                        let t = "Tab" === e.key && !e.altKey && !e.ctrlKey && !e.metaKey,
                            i = document.activeElement;
                        if (t && i) {
                            let t = e.currentTarget,
                                [r, s] = function(e) {
                                    let t = nG(e);
                                    return [nz(t, e), nz(t.reverse(), e)]
                                }(t);
                            r && s ? e.shiftKey || i !== s ? e.shiftKey && i === r && (e.preventDefault(), n && nH(s, {
                                select: !0
                            })) : (e.preventDefault(), n && nH(r, {
                                select: !0
                            })) : i === t && e.preventDefault()
                        }
                    }, [n, r, f.paused]);
                    return (0, m.jsx)(nO.WV.div, {
                        tabIndex: -1,
                        ...a,
                        ref: d,
                        onKeyDown: p
                    })
                });

            function nG(e) {
                let t = [],
                    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
                        acceptNode: e => {
                            let t = "INPUT" === e.tagName && "hidden" === e.type;
                            return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
                        }
                    });
                for (; n.nextNode();) t.push(n.currentNode);
                return t
            }

            function nz(e, t) {
                for (let n of e)
                    if (! function(e, {
                            upTo: t
                        }) {
                            if ("hidden" === getComputedStyle(e).visibility) return !0;
                            for (; e && (void 0 === t || e !== t);) {
                                if ("none" === getComputedStyle(e).display) return !0;
                                e = e.parentElement
                            }
                            return !1
                        }(n, {
                            upTo: t
                        })) return n
            }

            function nH(e, {
                select: t = !1
            } = {}) {
                if (e && e.focus) {
                    var n;
                    let r = document.activeElement;
                    e.focus({
                        preventScroll: !0
                    }), e !== r && (n = e) instanceof HTMLInputElement && "select" in n && t && e.select()
                }
            }
            nQ.displayName = "FocusScope";
            var nV = (a = [], {
                add(e) {
                    let t = a[0];
                    e !== t && t ? .pause(), (a = nj(a, e)).unshift(e)
                },
                remove(e) {
                    a = nj(a, e), a[0] ? .resume()
                }
            });

            function nj(e, t) {
                let n = [...e],
                    r = n.indexOf(t);
                return -1 !== r && n.splice(r, 1), n
            }
            var nW = n(4774),
                nY = n(9429),
                nX = n(1120),
                nq = n(5611),
                nK = n(4898),
                nJ = n(3409),
                nZ = new WeakMap,
                n$ = new WeakMap,
                n0 = {},
                n1 = 0,
                n2 = function(e) {
                    return e && (e.host || n2(e.parentNode))
                },
                n3 = function(e, t, n, r) {
                    var i = (Array.isArray(e) ? e : [e]).map(function(e) {
                        if (t.contains(e)) return e;
                        var n = n2(e);
                        return n && t.contains(n) ? n : (console.error("aria-hidden", e, "in not contained inside", t, ". Doing nothing"), null)
                    }).filter(function(e) {
                        return !!e
                    });
                    n0[n] || (n0[n] = new WeakMap);
                    var s = n0[n],
                        a = [],
                        o = new Set,
                        l = new Set(i),
                        u = function(e) {
                            !e || o.has(e) || (o.add(e), u(e.parentNode))
                        };
                    i.forEach(u);
                    var c = function(e) {
                        !e || l.has(e) || Array.prototype.forEach.call(e.children, function(e) {
                            if (o.has(e)) c(e);
                            else try {
                                var t = e.getAttribute(r),
                                    i = null !== t && "false" !== t,
                                    l = (nZ.get(e) || 0) + 1,
                                    u = (s.get(e) || 0) + 1;
                                nZ.set(e, l), s.set(e, u), a.push(e), 1 === l && i && n$.set(e, !0), 1 === u && e.setAttribute(n, "true"), i || e.setAttribute(r, "true")
                            } catch (t) {
                                console.error("aria-hidden: cannot operate on ", e, t)
                            }
                        })
                    };
                    return c(t), o.clear(), n1++,
                        function() {
                            a.forEach(function(e) {
                                var t = nZ.get(e) - 1,
                                    i = s.get(e) - 1;
                                nZ.set(e, t), s.set(e, i), t || (n$.has(e) || e.removeAttribute(r), n$.delete(e)), i || e.removeAttribute(n)
                            }), --n1 || (nZ = new WeakMap, nZ = new WeakMap, n$ = new WeakMap, n0 = {})
                        }
                },
                n4 = function(e, t, n) {
                    void 0 === n && (n = "data-aria-hidden");
                    var r = Array.from(Array.isArray(e) ? e : [e]),
                        i = t || ("undefined" == typeof document ? null : (Array.isArray(e) ? e[0] : e).ownerDocument.body);
                    return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), n3(r, i, n, "aria-hidden")) : function() {
                        return null
                    }
                },
                n5 = n(6871),
                n6 = "right-scroll-bar-position",
                n8 = "width-before-scroll-bar";

            function n9(e, t) {
                return "function" == typeof e ? e(t) : e && (e.current = t), e
            }
            var n7 = "undefined" != typeof window ? v.useLayoutEffect : v.useEffect,
                re = new WeakMap,
                rt = (void 0 === c && (c = {}), (void 0 === h && (h = function(e) {
                    return e
                }), d = [], f = !1, p = {
                    read: function() {
                        if (f) throw Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
                        return d.length ? d[d.length - 1] : null
                    },
                    useMedium: function(e) {
                        var t = h(e, f);
                        return d.push(t),
                            function() {
                                d = d.filter(function(e) {
                                    return e !== t
                                })
                            }
                    },
                    assignSyncMedium: function(e) {
                        for (f = !0; d.length;) {
                            var t = d;
                            d = [], t.forEach(e)
                        }
                        d = {
                            push: function(t) {
                                return e(t)
                            },
                            filter: function() {
                                return d
                            }
                        }
                    },
                    assignMedium: function(e) {
                        f = !0;
                        var t = [];
                        if (d.length) {
                            var n = d;
                            d = [], n.forEach(e), t = d
                        }
                        var r = function() {
                                var n = t;
                                t = [], n.forEach(e)
                            },
                            i = function() {
                                return Promise.resolve().then(r)
                            };
                        i(), d = {
                            push: function(e) {
                                t.push(e), i()
                            },
                            filter: function(e) {
                                return t = t.filter(e), d
                            }
                        }
                    }
                }).options = (0, n5.pi)({
                    async: !0,
                    ssr: !1
                }, c), p),
                rn = function() {},
                rr = v.forwardRef(function(e, t) {
                    var n, r, i, s, a = v.useRef(null),
                        o = v.useState({
                            onScrollCapture: rn,
                            onWheelCapture: rn,
                            onTouchMoveCapture: rn
                        }),
                        l = o[0],
                        u = o[1],
                        c = e.forwardProps,
                        h = e.children,
                        d = e.className,
                        f = e.removeScrollBar,
                        p = e.enabled,
                        g = e.shards,
                        A = e.sideCar,
                        m = e.noIsolation,
                        y = e.inert,
                        x = e.allowPinchZoom,
                        E = e.as,
                        _ = e.gapMode,
                        b = (0, n5._T)(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]),
                        w = (n = [a, t], r = function(e) {
                            return n.forEach(function(t) {
                                return n9(t, e)
                            })
                        }, (i = (0, v.useState)(function() {
                            return {
                                value: null,
                                callback: r,
                                facade: {
                                    get current() {
                                        return i.value
                                    },
                                    set current(value) {
                                        var e = i.value;
                                        e !== value && (i.value = value, i.callback(value, e))
                                    }
                                }
                            }
                        })[0]).callback = r, s = i.facade, n7(function() {
                            var e = re.get(s);
                            if (e) {
                                var t = new Set(e),
                                    r = new Set(n),
                                    i = s.current;
                                t.forEach(function(e) {
                                    r.has(e) || n9(e, null)
                                }), r.forEach(function(e) {
                                    t.has(e) || n9(e, i)
                                })
                            }
                            re.set(s, n)
                        }, [n]), s),
                        C = (0, n5.pi)((0, n5.pi)({}, b), l);
                    return v.createElement(v.Fragment, null, p && v.createElement(A, {
                        sideCar: rt,
                        removeScrollBar: f,
                        shards: g,
                        noIsolation: m,
                        inert: y,
                        setCallbacks: u,
                        allowPinchZoom: !!x,
                        lockRef: a,
                        gapMode: _
                    }), c ? v.cloneElement(v.Children.only(h), (0, n5.pi)((0, n5.pi)({}, C), {
                        ref: w
                    })) : v.createElement(void 0 === E ? "div" : E, (0, n5.pi)({}, C, {
                        className: d,
                        ref: w
                    }), h))
                });
            rr.defaultProps = {
                enabled: !0,
                removeScrollBar: !0,
                inert: !1
            }, rr.classNames = {
                fullWidth: n8,
                zeroRight: n6
            };
            var ri = function(e) {
                var t = e.sideCar,
                    n = (0, n5._T)(e, ["sideCar"]);
                if (!t) throw Error("Sidecar: please provide `sideCar` property to import the right car");
                var r = t.read();
                if (!r) throw Error("Sidecar medium not found");
                return v.createElement(r, (0, n5.pi)({}, n))
            };
            ri.isSideCarExport = !0;
            var rs = function() {
                    var e = 0,
                        t = null;
                    return {
                        add: function(r) {
                            if (0 == e && (t = function() {
                                    if (!document) return null;
                                    var e = document.createElement("style");
                                    e.type = "text/css";
                                    var t = A || n.nc;
                                    return t && e.setAttribute("nonce", t), e
                                }())) {
                                var i, s;
                                (i = t).styleSheet ? i.styleSheet.cssText = r : i.appendChild(document.createTextNode(r)), s = t, (document.head || document.getElementsByTagName("head")[0]).appendChild(s)
                            }
                            e++
                        },
                        remove: function() {
                            --e || !t || (t.parentNode && t.parentNode.removeChild(t), t = null)
                        }
                    }
                },
                ra = function() {
                    var e = rs();
                    return function(t, n) {
                        v.useEffect(function() {
                            return e.add(t),
                                function() {
                                    e.remove()
                                }
                        }, [t && n])
                    }
                },
                ro = function() {
                    var e = ra();
                    return function(t) {
                        return e(t.styles, t.dynamic), null
                    }
                },
                rl = {
                    left: 0,
                    top: 0,
                    right: 0,
                    gap: 0
                },
                ru = function(e) {
                    return parseInt(e || "", 10) || 0
                },
                rc = function(e) {
                    var t = window.getComputedStyle(document.body),
                        n = t["padding" === e ? "paddingLeft" : "marginLeft"],
                        r = t["padding" === e ? "paddingTop" : "marginTop"],
                        i = t["padding" === e ? "paddingRight" : "marginRight"];
                    return [ru(n), ru(r), ru(i)]
                },
                rh = function(e) {
                    if (void 0 === e && (e = "margin"), "undefined" == typeof window) return rl;
                    var t = rc(e),
                        n = document.documentElement.clientWidth,
                        r = window.innerWidth;
                    return {
                        left: t[0],
                        top: t[1],
                        right: t[2],
                        gap: Math.max(0, r - n + t[2] - t[0])
                    }
                },
                rd = ro(),
                rf = "data-scroll-locked",
                rp = function(e, t, n, r) {
                    var i = e.left,
                        s = e.top,
                        a = e.right,
                        o = e.gap;
                    return void 0 === n && (n = "margin"), "\n  .".concat("with-scroll-bars-hidden", " {\n   overflow: hidden ").concat(r, ";\n   padding-right: ").concat(o, "px ").concat(r, ";\n  }\n  body[").concat(rf, "] {\n    overflow: hidden ").concat(r, ";\n    overscroll-behavior: contain;\n    ").concat([t && "position: relative ".concat(r, ";"), "margin" === n && "\n    padding-left: ".concat(i, "px;\n    padding-top: ").concat(s, "px;\n    padding-right: ").concat(a, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(o, "px ").concat(r, ";\n    "), "padding" === n && "padding-right: ".concat(o, "px ").concat(r, ";")].filter(Boolean).join(""), "\n  }\n  \n  .").concat(n6, " {\n    right: ").concat(o, "px ").concat(r, ";\n  }\n  \n  .").concat(n8, " {\n    margin-right: ").concat(o, "px ").concat(r, ";\n  }\n  \n  .").concat(n6, " .").concat(n6, " {\n    right: 0 ").concat(r, ";\n  }\n  \n  .").concat(n8, " .").concat(n8, " {\n    margin-right: 0 ").concat(r, ";\n  }\n  \n  body[").concat(rf, "] {\n    ").concat("--removed-body-scroll-bar-size", ": ").concat(o, "px;\n  }\n")
                },
                rg = function() {
                    var e = parseInt(document.body.getAttribute(rf) || "0", 10);
                    return isFinite(e) ? e : 0
                },
                rA = function() {
                    v.useEffect(function() {
                        return document.body.setAttribute(rf, (rg() + 1).toString()),
                            function() {
                                var e = rg() - 1;
                                e <= 0 ? document.body.removeAttribute(rf) : document.body.setAttribute(rf, e.toString())
                            }
                    }, [])
                },
                rm = function(e) {
                    var t = e.noRelative,
                        n = e.noImportant,
                        r = e.gapMode,
                        i = void 0 === r ? "margin" : r;
                    rA();
                    var s = v.useMemo(function() {
                        return rh(i)
                    }, [i]);
                    return v.createElement(rd, {
                        styles: rp(s, !t, i, n ? "" : "!important")
                    })
                },
                rv = !1;
            if ("undefined" != typeof window) try {
                var ry = Object.defineProperty({}, "passive", {
                    get: function() {
                        return rv = !0, !0
                    }
                });
                window.addEventListener("test", ry, ry), window.removeEventListener("test", ry, ry)
            } catch (e) {
                rv = !1
            }
            var rx = !!rv && {
                    passive: !1
                },
                rE = function(e, t) {
                    if (!(e instanceof Element)) return !1;
                    var n = window.getComputedStyle(e);
                    return "hidden" !== n[t] && !(n.overflowY === n.overflowX && "TEXTAREA" !== e.tagName && "visible" === n[t])
                },
                r_ = function(e, t) {
                    var n = t.ownerDocument,
                        r = t;
                    do {
                        if ("undefined" != typeof ShadowRoot && r instanceof ShadowRoot && (r = r.host), rb(e, r)) {
                            var i = rw(e, r);
                            if (i[1] > i[2]) return !0
                        }
                        r = r.parentNode
                    } while (r && r !== n.body);
                    return !1
                },
                rb = function(e, t) {
                    return "v" === e ? rE(t, "overflowY") : rE(t, "overflowX")
                },
                rw = function(e, t) {
                    return "v" === e ? [t.scrollTop, t.scrollHeight, t.clientHeight] : [t.scrollLeft, t.scrollWidth, t.clientWidth]
                },
                rC = function(e, t, n, r, i) {
                    var s, a = (s = window.getComputedStyle(t).direction, "h" === e && "rtl" === s ? -1 : 1),
                        o = a * r,
                        l = n.target,
                        u = t.contains(l),
                        c = !1,
                        h = o > 0,
                        d = 0,
                        f = 0;
                    do {
                        var p = rw(e, l),
                            g = p[0],
                            A = p[1] - p[2] - a * g;
                        (g || A) && rb(e, l) && (d += A, f += g), l instanceof ShadowRoot ? l = l.host : l = l.parentNode
                    } while (!u && l !== document.body || u && (t.contains(l) || t === l));
                    return h && (i && 1 > Math.abs(d) || !i && o > d) ? c = !0 : !h && (i && 1 > Math.abs(f) || !i && -o > f) && (c = !0), c
                },
                rS = function(e) {
                    return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0]
                },
                rI = function(e) {
                    return [e.deltaX, e.deltaY]
                },
                rM = function(e) {
                    return e && "current" in e ? e.current : e
                },
                rT = 0,
                rB = [],
                rR = (g = function(e) {
                    var t = v.useRef([]),
                        n = v.useRef([0, 0]),
                        r = v.useRef(),
                        i = v.useState(rT++)[0],
                        s = v.useState(ro)[0],
                        a = v.useRef(e);
                    v.useEffect(function() {
                        a.current = e
                    }, [e]), v.useEffect(function() {
                        if (e.inert) {
                            document.body.classList.add("block-interactivity-".concat(i));
                            var t = (0, n5.ev)([e.lockRef.current], (e.shards || []).map(rM), !0).filter(Boolean);
                            return t.forEach(function(e) {
                                    return e.classList.add("allow-interactivity-".concat(i))
                                }),
                                function() {
                                    document.body.classList.remove("block-interactivity-".concat(i)), t.forEach(function(e) {
                                        return e.classList.remove("allow-interactivity-".concat(i))
                                    })
                                }
                        }
                    }, [e.inert, e.lockRef.current, e.shards]);
                    var o = v.useCallback(function(e, t) {
                            if ("touches" in e && 2 === e.touches.length || "wheel" === e.type && e.ctrlKey) return !a.current.allowPinchZoom;
                            var i, s = rS(e),
                                o = n.current,
                                l = "deltaX" in e ? e.deltaX : o[0] - s[0],
                                u = "deltaY" in e ? e.deltaY : o[1] - s[1],
                                c = e.target,
                                h = Math.abs(l) > Math.abs(u) ? "h" : "v";
                            if ("touches" in e && "h" === h && "range" === c.type) return !1;
                            var d = r_(h, c);
                            if (!d) return !0;
                            if (d ? i = h : (i = "v" === h ? "h" : "v", d = r_(h, c)), !d) return !1;
                            if (!r.current && "changedTouches" in e && (l || u) && (r.current = i), !i) return !0;
                            var f = r.current || i;
                            return rC(f, t, e, "h" === f ? l : u, !0)
                        }, []),
                        l = v.useCallback(function(e) {
                            if (rB.length && rB[rB.length - 1] === s) {
                                var n = "deltaY" in e ? rI(e) : rS(e),
                                    r = t.current.filter(function(t) {
                                        var r;
                                        return t.name === e.type && (t.target === e.target || e.target === t.shadowParent) && (r = t.delta)[0] === n[0] && r[1] === n[1]
                                    })[0];
                                if (r && r.should) {
                                    e.cancelable && e.preventDefault();
                                    return
                                }
                                if (!r) {
                                    var i = (a.current.shards || []).map(rM).filter(Boolean).filter(function(t) {
                                        return t.contains(e.target)
                                    });
                                    (i.length > 0 ? o(e, i[0]) : !a.current.noIsolation) && e.cancelable && e.preventDefault()
                                }
                            }
                        }, []),
                        u = v.useCallback(function(e, n, r, i) {
                            var s = {
                                name: e,
                                delta: n,
                                target: r,
                                should: i,
                                shadowParent: function(e) {
                                    for (var t = null; null !== e;) e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
                                    return t
                                }(r)
                            };
                            t.current.push(s), setTimeout(function() {
                                t.current = t.current.filter(function(e) {
                                    return e !== s
                                })
                            }, 1)
                        }, []),
                        c = v.useCallback(function(e) {
                            n.current = rS(e), r.current = void 0
                        }, []),
                        h = v.useCallback(function(t) {
                            u(t.type, rI(t), t.target, o(t, e.lockRef.current))
                        }, []),
                        d = v.useCallback(function(t) {
                            u(t.type, rS(t), t.target, o(t, e.lockRef.current))
                        }, []);
                    v.useEffect(function() {
                        return rB.push(s), e.setCallbacks({
                                onScrollCapture: h,
                                onWheelCapture: h,
                                onTouchMoveCapture: d
                            }), document.addEventListener("wheel", l, rx), document.addEventListener("touchmove", l, rx), document.addEventListener("touchstart", c, rx),
                            function() {
                                rB = rB.filter(function(e) {
                                    return e !== s
                                }), document.removeEventListener("wheel", l, rx), document.removeEventListener("touchmove", l, rx), document.removeEventListener("touchstart", c, rx)
                            }
                    }, []);
                    var f = e.removeScrollBar,
                        p = e.inert;
                    return v.createElement(v.Fragment, null, p ? v.createElement(s, {
                        styles: "\n  .block-interactivity-".concat(i, " {pointer-events: none;}\n  .allow-interactivity-").concat(i, " {pointer-events: all;}\n")
                    }) : null, f ? v.createElement(rm, {
                        gapMode: e.gapMode
                    }) : null)
                }, rt.useMedium(g), ri),
                rD = v.forwardRef(function(e, t) {
                    return v.createElement(rr, (0, n5.pi)({}, e, {
                        ref: t,
                        sideCar: rR
                    }))
                });
            rD.classNames = rr.classNames;
            var rL = [" ", "Enter", "ArrowUp", "ArrowDown"],
                rP = [" ", "Enter"],
                rO = "Select",
                [rN, rU, rF] = function(e) {
                    let t = e + "CollectionProvider",
                        [n, r] = (0, nI.b)(t),
                        [i, s] = n(t, {
                            collectionRef: {
                                current: null
                            },
                            itemMap: new Map
                        }),
                        a = e => {
                            let {
                                scope: t,
                                children: n
                            } = e, r = v.useRef(null), s = v.useRef(new Map).current;
                            return (0, m.jsx)(i, {
                                scope: t,
                                itemMap: s,
                                collectionRef: r,
                                children: n
                            })
                        };
                    a.displayName = t;
                    let o = e + "CollectionSlot",
                        l = v.forwardRef((e, t) => {
                            let {
                                scope: n,
                                children: r
                            } = e, i = s(o, n), a = (0, nM.e)(t, i.collectionRef);
                            return (0, m.jsx)(nT.g7, {
                                ref: a,
                                children: r
                            })
                        });
                    l.displayName = o;
                    let u = e + "CollectionItemSlot",
                        c = "data-radix-collection-item",
                        h = v.forwardRef((e, t) => {
                            let {
                                scope: n,
                                children: r,
                                ...i
                            } = e, a = v.useRef(null), o = (0, nM.e)(t, a), l = s(u, n);
                            return v.useEffect(() => (l.itemMap.set(a, {
                                ref: a,
                                ...i
                            }), () => void l.itemMap.delete(a))), (0, m.jsx)(nT.g7, {
                                [c]: "",
                                ref: o,
                                children: r
                            })
                        });
                    return h.displayName = u, [{
                        Provider: a,
                        Slot: l,
                        ItemSlot: h
                    }, function(t) {
                        let n = s(e + "CollectionConsumer", t);
                        return v.useCallback(() => {
                            let e = n.collectionRef.current;
                            if (!e) return [];
                            let t = Array.from(e.querySelectorAll(`[${c}]`));
                            return Array.from(n.itemMap.values()).sort((e, n) => t.indexOf(e.ref.current) - t.indexOf(n.ref.current))
                        }, [n.collectionRef, n.itemMap])
                    }, r]
                }(rO),
                [rk, rQ] = (0, nB.b)(rO, [rF, nY.D7]),
                rG = (0, nY.D7)(),
                [rz, rH] = rk(rO),
                [rV, rj] = rk(rO),
                rW = e => {
                    let {
                        __scopeSelect: t,
                        children: n,
                        open: r,
                        defaultOpen: i,
                        onOpenChange: s,
                        value: a,
                        defaultValue: o,
                        onValueChange: l,
                        dir: u,
                        name: c,
                        autoComplete: h,
                        disabled: d,
                        required: f,
                        form: p
                    } = e, g = rG(t), [A, y] = v.useState(null), [x, E] = v.useState(null), [_, b] = v.useState(!1), w = function(e) {
                        let t = v.useContext(nR);
                        return e || t || "ltr"
                    }(u), [C = !1, S] = (0, nq.T)({
                        prop: r,
                        defaultProp: i,
                        onChange: s
                    }), [I, M] = (0, nq.T)({
                        prop: a,
                        defaultProp: o,
                        onChange: l
                    }), T = v.useRef(null), B = !A || p || !!A.closest("form"), [R, D] = v.useState(new Set), L = Array.from(R).map(e => e.props.value).join(";");
                    return (0, m.jsx)(nY.fC, { ...g,
                        children: (0, m.jsxs)(rz, {
                            required: f,
                            scope: t,
                            trigger: A,
                            onTriggerChange: y,
                            valueNode: x,
                            onValueNodeChange: E,
                            valueNodeHasChildren: _,
                            onValueNodeHasChildrenChange: b,
                            contentId: (0, nW.M)(),
                            value: I,
                            onValueChange: M,
                            open: C,
                            onOpenChange: S,
                            dir: w,
                            triggerPointerDownPosRef: T,
                            disabled: d,
                            children: [(0, m.jsx)(rN.Provider, {
                                scope: t,
                                children: (0, m.jsx)(rV, {
                                    scope: e.__scopeSelect,
                                    onNativeOptionAdd: v.useCallback(e => {
                                        D(t => new Set(t).add(e))
                                    }, []),
                                    onNativeOptionRemove: v.useCallback(e => {
                                        D(t => {
                                            let n = new Set(t);
                                            return n.delete(e), n
                                        })
                                    }, []),
                                    children: n
                                })
                            }), B ? (0, m.jsxs)(iv, {
                                "aria-hidden": !0,
                                required: f,
                                tabIndex: -1,
                                name: c,
                                autoComplete: h,
                                value: I,
                                onChange: e => M(e.target.value),
                                disabled: d,
                                form: p,
                                children: [void 0 === I ? (0, m.jsx)("option", {
                                    value: ""
                                }) : null, Array.from(R)]
                            }, L) : null]
                        })
                    })
                };
            rW.displayName = rO;
            var rY = "SelectTrigger",
                rX = v.forwardRef((e, t) => {
                    let {
                        __scopeSelect: n,
                        disabled: r = !1,
                        ...i
                    } = e, s = rG(n), a = rH(rY, n), o = a.disabled || r, l = (0, nM.e)(t, a.onTriggerChange), u = rU(n), c = v.useRef("touch"), [h, d, f] = iy(e => {
                        let t = u().filter(e => !e.disabled),
                            n = t.find(e => e.value === a.value),
                            r = ix(t, e, n);
                        void 0 !== r && a.onValueChange(r.value)
                    }), p = e => {
                        o || (a.onOpenChange(!0), f()), e && (a.triggerPointerDownPosRef.current = {
                            x: Math.round(e.pageX),
                            y: Math.round(e.pageY)
                        })
                    };
                    return (0, m.jsx)(nY.ee, {
                        asChild: !0,
                        ...s,
                        children: (0, m.jsx)(nO.WV.button, {
                            type: "button",
                            role: "combobox",
                            "aria-controls": a.contentId,
                            "aria-expanded": a.open,
                            "aria-required": a.required,
                            "aria-autocomplete": "none",
                            dir: a.dir,
                            "data-state": a.open ? "open" : "closed",
                            disabled: o,
                            "data-disabled": o ? "" : void 0,
                            "data-placeholder": im(a.value) ? "" : void 0,
                            ...i,
                            ref: l,
                            onClick: (0, nS.M)(i.onClick, e => {
                                e.currentTarget.focus(), "mouse" !== c.current && p(e)
                            }),
                            onPointerDown: (0, nS.M)(i.onPointerDown, e => {
                                c.current = e.pointerType;
                                let t = e.target;
                                t.hasPointerCapture(e.pointerId) && t.releasePointerCapture(e.pointerId), 0 === e.button && !1 === e.ctrlKey && "mouse" === e.pointerType && (p(e), e.preventDefault())
                            }),
                            onKeyDown: (0, nS.M)(i.onKeyDown, e => {
                                let t = "" !== h.current;
                                e.ctrlKey || e.altKey || e.metaKey || 1 !== e.key.length || d(e.key), (!t || " " !== e.key) && rL.includes(e.key) && (p(), e.preventDefault())
                            })
                        })
                    })
                });
            rX.displayName = rY;
            var rq = "SelectValue",
                rK = v.forwardRef((e, t) => {
                    let {
                        __scopeSelect: n,
                        className: r,
                        style: i,
                        children: s,
                        placeholder: a = "",
                        ...o
                    } = e, l = rH(rq, n), {
                        onValueNodeHasChildrenChange: u
                    } = l, c = void 0 !== s, h = (0, nM.e)(t, l.onValueNodeChange);
                    return (0, nK.b)(() => {
                        u(c)
                    }, [u, c]), (0, m.jsx)(nO.WV.span, { ...o,
                        ref: h,
                        style: {
                            pointerEvents: "none"
                        },
                        children: im(l.value) ? (0, m.jsx)(m.Fragment, {
                            children: a
                        }) : s
                    })
                });
            rK.displayName = rq;
            var rJ = v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    children: r,
                    ...i
                } = e;
                return (0, m.jsx)(nO.WV.span, {
                    "aria-hidden": !0,
                    ...i,
                    ref: t,
                    children: r || ""
                })
            });
            rJ.displayName = "SelectIcon";
            var rZ = e => (0, m.jsx)(nX.h, {
                asChild: !0,
                ...e
            });
            rZ.displayName = "SelectPortal";
            var r$ = "SelectContent",
                r0 = v.forwardRef((e, t) => {
                    let n = rH(r$, e.__scopeSelect),
                        [r, i] = v.useState();
                    return ((0, nK.b)(() => {
                        i(new DocumentFragment)
                    }, []), n.open) ? (0, m.jsx)(r3, { ...e,
                        ref: t
                    }) : r ? nw.createPortal((0, m.jsx)(r1, {
                        scope: e.__scopeSelect,
                        children: (0, m.jsx)(rN.Slot, {
                            scope: e.__scopeSelect,
                            children: (0, m.jsx)("div", {
                                children: e.children
                            })
                        })
                    }), r) : null
                });
            r0.displayName = r$;
            var [r1, r2] = rk(r$), r3 = v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    position: r = "item-aligned",
                    onCloseAutoFocus: i,
                    onEscapeKeyDown: s,
                    onPointerDownOutside: a,
                    side: o,
                    sideOffset: l,
                    align: u,
                    alignOffset: c,
                    arrowPadding: h,
                    collisionBoundary: d,
                    collisionPadding: f,
                    sticky: p,
                    hideWhenDetached: g,
                    avoidCollisions: A,
                    ...y
                } = e, x = rH(r$, n), [E, _] = v.useState(null), [b, w] = v.useState(null), C = (0, nM.e)(t, e => _(e)), [S, I] = v.useState(null), [M, T] = v.useState(null), B = rU(n), [R, D] = v.useState(!1), L = v.useRef(!1);
                v.useEffect(() => {
                    if (E) return n4(E)
                }, [E]), v.useEffect(() => {
                    let e = document.querySelectorAll("[data-radix-focus-guard]");
                    return document.body.insertAdjacentElement("afterbegin", e[0] ? ? nP()), document.body.insertAdjacentElement("beforeend", e[1] ? ? nP()), nL++, () => {
                        1 === nL && document.querySelectorAll("[data-radix-focus-guard]").forEach(e => e.remove()), nL--
                    }
                }, []);
                let P = v.useCallback(e => {
                        let [t, ...n] = B().map(e => e.ref.current), [r] = n.slice(-1), i = document.activeElement;
                        for (let n of e)
                            if (n === i || (n ? .scrollIntoView({
                                    block: "nearest"
                                }), n === t && b && (b.scrollTop = 0), n === r && b && (b.scrollTop = b.scrollHeight), n ? .focus(), document.activeElement !== i)) return
                    }, [B, b]),
                    O = v.useCallback(() => P([S, E]), [P, S, E]);
                v.useEffect(() => {
                    R && O()
                }, [R, O]);
                let {
                    onOpenChange: N,
                    triggerPointerDownPosRef: U
                } = x;
                v.useEffect(() => {
                    if (E) {
                        let e = {
                                x: 0,
                                y: 0
                            },
                            t = t => {
                                e = {
                                    x: Math.abs(Math.round(t.pageX) - (U.current ? .x ? ? 0)),
                                    y: Math.abs(Math.round(t.pageY) - (U.current ? .y ? ? 0))
                                }
                            },
                            n = n => {
                                e.x <= 10 && e.y <= 10 ? n.preventDefault() : E.contains(n.target) || N(!1), document.removeEventListener("pointermove", t), U.current = null
                            };
                        return null !== U.current && (document.addEventListener("pointermove", t), document.addEventListener("pointerup", n, {
                            capture: !0,
                            once: !0
                        })), () => {
                            document.removeEventListener("pointermove", t), document.removeEventListener("pointerup", n, {
                                capture: !0
                            })
                        }
                    }
                }, [E, N, U]), v.useEffect(() => {
                    let e = () => N(!1);
                    return window.addEventListener("blur", e), window.addEventListener("resize", e), () => {
                        window.removeEventListener("blur", e), window.removeEventListener("resize", e)
                    }
                }, [N]);
                let [F, k] = iy(e => {
                    let t = B().filter(e => !e.disabled),
                        n = t.find(e => e.ref.current === document.activeElement),
                        r = ix(t, e, n);
                    r && setTimeout(() => r.ref.current.focus())
                }), Q = v.useCallback((e, t, n) => {
                    let r = !L.current && !n;
                    (void 0 !== x.value && x.value === t || r) && (I(e), r && (L.current = !0))
                }, [x.value]), G = v.useCallback(() => E ? .focus(), [E]), z = v.useCallback((e, t, n) => {
                    let r = !L.current && !n;
                    (void 0 !== x.value && x.value === t || r) && T(e)
                }, [x.value]), H = "popper" === r ? r5 : r4, V = H === r5 ? {
                    side: o,
                    sideOffset: l,
                    align: u,
                    alignOffset: c,
                    arrowPadding: h,
                    collisionBoundary: d,
                    collisionPadding: f,
                    sticky: p,
                    hideWhenDetached: g,
                    avoidCollisions: A
                } : {};
                return (0, m.jsx)(r1, {
                    scope: n,
                    content: E,
                    viewport: b,
                    onViewportChange: w,
                    itemRefCallback: Q,
                    selectedItem: S,
                    onItemLeave: G,
                    itemTextRefCallback: z,
                    focusSelectedItem: O,
                    selectedItemText: M,
                    position: r,
                    isPositioned: R,
                    searchRef: F,
                    children: (0, m.jsx)(rD, {
                        as: nT.g7,
                        allowPinchZoom: !0,
                        children: (0, m.jsx)(nQ, {
                            asChild: !0,
                            trapped: x.open,
                            onMountAutoFocus: e => {
                                e.preventDefault()
                            },
                            onUnmountAutoFocus: (0, nS.M)(i, e => {
                                x.trigger ? .focus({
                                    preventScroll: !0
                                }), e.preventDefault()
                            }),
                            children: (0, m.jsx)(nD.XB, {
                                asChild: !0,
                                disableOutsidePointerEvents: !0,
                                onEscapeKeyDown: s,
                                onPointerDownOutside: a,
                                onFocusOutside: e => e.preventDefault(),
                                onDismiss: () => x.onOpenChange(!1),
                                children: (0, m.jsx)(H, {
                                    role: "listbox",
                                    id: x.contentId,
                                    "data-state": x.open ? "open" : "closed",
                                    dir: x.dir,
                                    onContextMenu: e => e.preventDefault(),
                                    ...y,
                                    ...V,
                                    onPlaced: () => D(!0),
                                    ref: C,
                                    style: {
                                        display: "flex",
                                        flexDirection: "column",
                                        outline: "none",
                                        ...y.style
                                    },
                                    onKeyDown: (0, nS.M)(y.onKeyDown, e => {
                                        let t = e.ctrlKey || e.altKey || e.metaKey;
                                        if ("Tab" === e.key && e.preventDefault(), t || 1 !== e.key.length || k(e.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(e.key)) {
                                            let t = B().filter(e => !e.disabled).map(e => e.ref.current);
                                            if (["ArrowUp", "End"].includes(e.key) && (t = t.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(e.key)) {
                                                let n = e.target,
                                                    r = t.indexOf(n);
                                                t = t.slice(r + 1)
                                            }
                                            setTimeout(() => P(t)), e.preventDefault()
                                        }
                                    })
                                })
                            })
                        })
                    })
                })
            });
            r3.displayName = "SelectContentImpl";
            var r4 = v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    onPlaced: r,
                    ...i
                } = e, s = rH(r$, n), a = r2(r$, n), [o, l] = v.useState(null), [u, c] = v.useState(null), h = (0, nM.e)(t, e => c(e)), d = rU(n), f = v.useRef(!1), p = v.useRef(!0), {
                    viewport: g,
                    selectedItem: A,
                    selectedItemText: y,
                    focusSelectedItem: x
                } = a, E = v.useCallback(() => {
                    if (s.trigger && s.valueNode && o && u && g && A && y) {
                        let e = s.trigger.getBoundingClientRect(),
                            t = u.getBoundingClientRect(),
                            n = s.valueNode.getBoundingClientRect(),
                            i = y.getBoundingClientRect();
                        if ("rtl" !== s.dir) {
                            let r = i.left - t.left,
                                s = n.left - r,
                                a = e.left - s,
                                l = e.width + a,
                                u = Math.max(l, t.width),
                                c = nC(s, [10, Math.max(10, window.innerWidth - 10 - u)]);
                            o.style.minWidth = l + "px", o.style.left = c + "px"
                        } else {
                            let r = t.right - i.right,
                                s = window.innerWidth - n.right - r,
                                a = window.innerWidth - e.right - s,
                                l = e.width + a,
                                u = Math.max(l, t.width),
                                c = nC(s, [10, Math.max(10, window.innerWidth - 10 - u)]);
                            o.style.minWidth = l + "px", o.style.right = c + "px"
                        }
                        let a = d(),
                            l = window.innerHeight - 20,
                            c = g.scrollHeight,
                            h = window.getComputedStyle(u),
                            p = parseInt(h.borderTopWidth, 10),
                            m = parseInt(h.paddingTop, 10),
                            v = parseInt(h.borderBottomWidth, 10),
                            x = p + m + c + parseInt(h.paddingBottom, 10) + v,
                            E = Math.min(5 * A.offsetHeight, x),
                            _ = window.getComputedStyle(g),
                            b = parseInt(_.paddingTop, 10),
                            w = parseInt(_.paddingBottom, 10),
                            C = e.top + e.height / 2 - 10,
                            S = A.offsetHeight / 2,
                            I = p + m + (A.offsetTop + S);
                        if (I <= C) {
                            let e = a.length > 0 && A === a[a.length - 1].ref.current;
                            o.style.bottom = "0px";
                            let t = Math.max(l - C, S + (e ? w : 0) + (u.clientHeight - g.offsetTop - g.offsetHeight) + v);
                            o.style.height = I + t + "px"
                        } else {
                            let e = a.length > 0 && A === a[0].ref.current;
                            o.style.top = "0px";
                            let t = Math.max(C, p + g.offsetTop + (e ? b : 0) + S);
                            o.style.height = t + (x - I) + "px", g.scrollTop = I - C + g.offsetTop
                        }
                        o.style.margin = "10px 0", o.style.minHeight = E + "px", o.style.maxHeight = l + "px", r ? .(), requestAnimationFrame(() => f.current = !0)
                    }
                }, [d, s.trigger, s.valueNode, o, u, g, A, y, s.dir, r]);
                (0, nK.b)(() => E(), [E]);
                let [_, b] = v.useState();
                (0, nK.b)(() => {
                    u && b(window.getComputedStyle(u).zIndex)
                }, [u]);
                let w = v.useCallback(e => {
                    e && !0 === p.current && (E(), x ? .(), p.current = !1)
                }, [E, x]);
                return (0, m.jsx)(r6, {
                    scope: n,
                    contentWrapper: o,
                    shouldExpandOnScrollRef: f,
                    onScrollButtonChange: w,
                    children: (0, m.jsx)("div", {
                        ref: l,
                        style: {
                            display: "flex",
                            flexDirection: "column",
                            position: "fixed",
                            zIndex: _
                        },
                        children: (0, m.jsx)(nO.WV.div, { ...i,
                            ref: h,
                            style: {
                                boxSizing: "border-box",
                                maxHeight: "100%",
                                ...i.style
                            }
                        })
                    })
                })
            });
            r4.displayName = "SelectItemAlignedPosition";
            var r5 = v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    align: r = "start",
                    collisionPadding: i = 10,
                    ...s
                } = e, a = rG(n);
                return (0, m.jsx)(nY.VY, { ...a,
                    ...s,
                    ref: t,
                    align: r,
                    collisionPadding: i,
                    style: {
                        boxSizing: "border-box",
                        ...s.style,
                        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
                        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
                        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
                        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
                        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
                    }
                })
            });
            r5.displayName = "SelectPopperPosition";
            var [r6, r8] = rk(r$, {}), r9 = "SelectViewport", r7 = v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    nonce: r,
                    ...i
                } = e, s = r2(r9, n), a = r8(r9, n), o = (0, nM.e)(t, s.onViewportChange), l = v.useRef(0);
                return (0, m.jsxs)(m.Fragment, {
                    children: [(0, m.jsx)("style", {
                        dangerouslySetInnerHTML: {
                            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
                        },
                        nonce: r
                    }), (0, m.jsx)(rN.Slot, {
                        scope: n,
                        children: (0, m.jsx)(nO.WV.div, {
                            "data-radix-select-viewport": "",
                            role: "presentation",
                            ...i,
                            ref: o,
                            style: {
                                position: "relative",
                                flex: 1,
                                overflow: "hidden auto",
                                ...i.style
                            },
                            onScroll: (0, nS.M)(i.onScroll, e => {
                                let t = e.currentTarget,
                                    {
                                        contentWrapper: n,
                                        shouldExpandOnScrollRef: r
                                    } = a;
                                if (r ? .current && n) {
                                    let e = Math.abs(l.current - t.scrollTop);
                                    if (e > 0) {
                                        let r = window.innerHeight - 20,
                                            i = Math.max(parseFloat(n.style.minHeight), parseFloat(n.style.height));
                                        if (i < r) {
                                            let s = i + e,
                                                a = Math.min(r, s),
                                                o = s - a;
                                            n.style.height = a + "px", "0px" === n.style.bottom && (t.scrollTop = o > 0 ? o : 0, n.style.justifyContent = "flex-end")
                                        }
                                    }
                                }
                                l.current = t.scrollTop
                            })
                        })
                    })]
                })
            });
            r7.displayName = r9;
            var ie = "SelectGroup",
                [it, ir] = rk(ie);
            v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    ...r
                } = e, i = (0, nW.M)();
                return (0, m.jsx)(it, {
                    scope: n,
                    id: i,
                    children: (0, m.jsx)(nO.WV.div, {
                        role: "group",
                        "aria-labelledby": i,
                        ...r,
                        ref: t
                    })
                })
            }).displayName = ie;
            var ii = "SelectLabel";
            v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    ...r
                } = e, i = ir(ii, n);
                return (0, m.jsx)(nO.WV.div, {
                    id: i.id,
                    ...r,
                    ref: t
                })
            }).displayName = ii;
            var is = "SelectItem",
                [ia, io] = rk(is),
                il = v.forwardRef((e, t) => {
                    let {
                        __scopeSelect: n,
                        value: r,
                        disabled: i = !1,
                        textValue: s,
                        ...a
                    } = e, o = rH(is, n), l = r2(is, n), u = o.value === r, [c, h] = v.useState(s ? ? ""), [d, f] = v.useState(!1), p = (0, nM.e)(t, e => l.itemRefCallback ? .(e, r, i)), g = (0, nW.M)(), A = v.useRef("touch"), y = () => {
                        i || (o.onValueChange(r), o.onOpenChange(!1))
                    };
                    if ("" === r) throw Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
                    return (0, m.jsx)(ia, {
                        scope: n,
                        value: r,
                        disabled: i,
                        textId: g,
                        isSelected: u,
                        onItemTextChange: v.useCallback(e => {
                            h(t => t || (e ? .textContent ? ? "").trim())
                        }, []),
                        children: (0, m.jsx)(rN.ItemSlot, {
                            scope: n,
                            value: r,
                            disabled: i,
                            textValue: c,
                            children: (0, m.jsx)(nO.WV.div, {
                                role: "option",
                                "aria-labelledby": g,
                                "data-highlighted": d ? "" : void 0,
                                "aria-selected": u && d,
                                "data-state": u ? "checked" : "unchecked",
                                "aria-disabled": i || void 0,
                                "data-disabled": i ? "" : void 0,
                                tabIndex: i ? void 0 : -1,
                                ...a,
                                ref: p,
                                onFocus: (0, nS.M)(a.onFocus, () => f(!0)),
                                onBlur: (0, nS.M)(a.onBlur, () => f(!1)),
                                onClick: (0, nS.M)(a.onClick, () => {
                                    "mouse" !== A.current && y()
                                }),
                                onPointerUp: (0, nS.M)(a.onPointerUp, () => {
                                    "mouse" === A.current && y()
                                }),
                                onPointerDown: (0, nS.M)(a.onPointerDown, e => {
                                    A.current = e.pointerType
                                }),
                                onPointerMove: (0, nS.M)(a.onPointerMove, e => {
                                    A.current = e.pointerType, i ? l.onItemLeave ? .() : "mouse" === A.current && e.currentTarget.focus({
                                        preventScroll: !0
                                    })
                                }),
                                onPointerLeave: (0, nS.M)(a.onPointerLeave, e => {
                                    e.currentTarget === document.activeElement && l.onItemLeave ? .()
                                }),
                                onKeyDown: (0, nS.M)(a.onKeyDown, e => {
                                    l.searchRef ? .current !== "" && " " === e.key || (rP.includes(e.key) && y(), " " === e.key && e.preventDefault())
                                })
                            })
                        })
                    })
                });
            il.displayName = is;
            var iu = "SelectItemText",
                ic = v.forwardRef((e, t) => {
                    let {
                        __scopeSelect: n,
                        className: r,
                        style: i,
                        ...s
                    } = e, a = rH(iu, n), o = r2(iu, n), l = io(iu, n), u = rj(iu, n), [c, h] = v.useState(null), d = (0, nM.e)(t, e => h(e), l.onItemTextChange, e => o.itemTextRefCallback ? .(e, l.value, l.disabled)), f = c ? .textContent, p = v.useMemo(() => (0, m.jsx)("option", {
                        value: l.value,
                        disabled: l.disabled,
                        children: f
                    }, l.value), [l.disabled, l.value, f]), {
                        onNativeOptionAdd: g,
                        onNativeOptionRemove: A
                    } = u;
                    return (0, nK.b)(() => (g(p), () => A(p)), [g, A, p]), (0, m.jsxs)(m.Fragment, {
                        children: [(0, m.jsx)(nO.WV.span, {
                            id: l.textId,
                            ...s,
                            ref: d
                        }), l.isSelected && a.valueNode && !a.valueNodeHasChildren ? nw.createPortal(s.children, a.valueNode) : null]
                    })
                });
            ic.displayName = iu;
            var ih = "SelectItemIndicator";
            v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    ...r
                } = e;
                return io(ih, n).isSelected ? (0, m.jsx)(nO.WV.span, {
                    "aria-hidden": !0,
                    ...r,
                    ref: t
                }) : null
            }).displayName = ih;
            var id = "SelectScrollUpButton";
            v.forwardRef((e, t) => {
                let n = r2(id, e.__scopeSelect),
                    r = r8(id, e.__scopeSelect),
                    [i, s] = v.useState(!1),
                    a = (0, nM.e)(t, r.onScrollButtonChange);
                return (0, nK.b)(() => {
                    if (n.viewport && n.isPositioned) {
                        let e = function() {
                                s(t.scrollTop > 0)
                            },
                            t = n.viewport;
                        return e(), t.addEventListener("scroll", e), () => t.removeEventListener("scroll", e)
                    }
                }, [n.viewport, n.isPositioned]), i ? (0, m.jsx)(ig, { ...e,
                    ref: a,
                    onAutoScroll: () => {
                        let {
                            viewport: e,
                            selectedItem: t
                        } = n;
                        e && t && (e.scrollTop = e.scrollTop - t.offsetHeight)
                    }
                }) : null
            }).displayName = id;
            var ip = "SelectScrollDownButton";
            v.forwardRef((e, t) => {
                let n = r2(ip, e.__scopeSelect),
                    r = r8(ip, e.__scopeSelect),
                    [i, s] = v.useState(!1),
                    a = (0, nM.e)(t, r.onScrollButtonChange);
                return (0, nK.b)(() => {
                    if (n.viewport && n.isPositioned) {
                        let e = function() {
                                let e = t.scrollHeight - t.clientHeight;
                                s(Math.ceil(t.scrollTop) < e)
                            },
                            t = n.viewport;
                        return e(), t.addEventListener("scroll", e), () => t.removeEventListener("scroll", e)
                    }
                }, [n.viewport, n.isPositioned]), i ? (0, m.jsx)(ig, { ...e,
                    ref: a,
                    onAutoScroll: () => {
                        let {
                            viewport: e,
                            selectedItem: t
                        } = n;
                        e && t && (e.scrollTop = e.scrollTop + t.offsetHeight)
                    }
                }) : null
            }).displayName = ip;
            var ig = v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    onAutoScroll: r,
                    ...i
                } = e, s = r2("SelectScrollButton", n), a = v.useRef(null), o = rU(n), l = v.useCallback(() => {
                    null !== a.current && (window.clearInterval(a.current), a.current = null)
                }, []);
                return v.useEffect(() => () => l(), [l]), (0, nK.b)(() => {
                    let e = o().find(e => e.ref.current === document.activeElement);
                    e ? .ref.current ? .scrollIntoView({
                        block: "nearest"
                    })
                }, [o]), (0, m.jsx)(nO.WV.div, {
                    "aria-hidden": !0,
                    ...i,
                    ref: t,
                    style: {
                        flexShrink: 0,
                        ...i.style
                    },
                    onPointerDown: (0, nS.M)(i.onPointerDown, () => {
                        null === a.current && (a.current = window.setInterval(r, 50))
                    }),
                    onPointerMove: (0, nS.M)(i.onPointerMove, () => {
                        s.onItemLeave ? .(), null === a.current && (a.current = window.setInterval(r, 50))
                    }),
                    onPointerLeave: (0, nS.M)(i.onPointerLeave, () => {
                        l()
                    })
                })
            });
            v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    ...r
                } = e;
                return (0, m.jsx)(nO.WV.div, {
                    "aria-hidden": !0,
                    ...r,
                    ref: t
                })
            }).displayName = "SelectSeparator";
            var iA = "SelectArrow";

            function im(e) {
                return "" === e || void 0 === e
            }
            v.forwardRef((e, t) => {
                let {
                    __scopeSelect: n,
                    ...r
                } = e, i = rG(n), s = rH(iA, n), a = r2(iA, n);
                return s.open && "popper" === a.position ? (0, m.jsx)(nY.Eh, { ...i,
                    ...r,
                    ref: t
                }) : null
            }).displayName = iA;
            var iv = v.forwardRef((e, t) => {
                let {
                    value: n,
                    ...r
                } = e, i = v.useRef(null), s = (0, nM.e)(t, i), a = function(e) {
                    let t = v.useRef({
                        value: e,
                        previous: e
                    });
                    return v.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e])
                }(n);
                return v.useEffect(() => {
                    let e = i.current,
                        t = Object.getOwnPropertyDescriptor(window.HTMLSelectElement.prototype, "value").set;
                    if (a !== n && t) {
                        let r = new Event("change", {
                            bubbles: !0
                        });
                        t.call(e, n), e.dispatchEvent(r)
                    }
                }, [a, n]), (0, m.jsx)(nJ.T, {
                    asChild: !0,
                    children: (0, m.jsx)("select", { ...r,
                        ref: s,
                        defaultValue: n
                    })
                })
            });

            function iy(e) {
                let t = (0, nN.W)(e),
                    n = v.useRef(""),
                    r = v.useRef(0),
                    i = v.useCallback(e => {
                        let i = n.current + e;
                        t(i),
                            function e(t) {
                                n.current = t, window.clearTimeout(r.current), "" !== t && (r.current = window.setTimeout(() => e(""), 1e3))
                            }(i)
                    }, [t]),
                    s = v.useCallback(() => {
                        n.current = "", window.clearTimeout(r.current)
                    }, []);
                return v.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, s]
            }

            function ix(e, t, n) {
                var r;
                let i = t.length > 1 && Array.from(t).every(e => e === t[0]) ? t[0] : t,
                    s = (r = Math.max(n ? e.indexOf(n) : -1, 0), e.map((t, n) => e[(r + n) % e.length]));
                1 === i.length && (s = s.filter(e => e !== n));
                let a = s.find(e => e.textValue.toLowerCase().startsWith(i.toLowerCase()));
                return a !== n ? a : void 0
            }
            iv.displayName = "BubbleSelect";
            let iE = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
                i_ = function() {
                    for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    return t.filter((e, t, n) => !!e && "" !== e.trim() && n.indexOf(e) === t).join(" ").trim()
                };
            var ib = {
                xmlns: "http://www.w3.org/2000/svg",
                width: 24,
                height: 24,
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: 2,
                strokeLinecap: "round",
                strokeLinejoin: "round"
            };
            let iw = (0, v.forwardRef)((e, t) => {
                    let {
                        color: n = "currentColor",
                        size: r = 24,
                        strokeWidth: i = 2,
                        absoluteStrokeWidth: s,
                        className: a = "",
                        children: o,
                        iconNode: l,
                        ...u
                    } = e;
                    return (0, v.createElement)("svg", {
                        ref: t,
                        ...ib,
                        width: r,
                        height: r,
                        stroke: n,
                        strokeWidth: s ? 24 * Number(i) / Number(r) : i,
                        className: i_("lucide", a),
                        ...u
                    }, [...l.map(e => {
                        let [t, n] = e;
                        return (0, v.createElement)(t, n)
                    }), ...Array.isArray(o) ? o : [o]])
                }),
                iC = (e, t) => {
                    let n = (0, v.forwardRef)((n, r) => {
                        let {
                            className: i,
                            ...s
                        } = n;
                        return (0, v.createElement)(iw, {
                            ref: r,
                            iconNode: t,
                            className: i_("lucide-".concat(iE(e)), i),
                            ...s
                        })
                    });
                    return n.displayName = "".concat(e), n
                },
                iS = iC("X", [
                    ["path", {
                        d: "M18 6 6 18",
                        key: "1bl5f8"
                    }],
                    ["path", {
                        d: "m6 6 12 12",
                        key: "d8bk6v"
                    }]
                ]),
                iI = iC("ChevronDown", [
                    ["path", {
                        d: "m6 9 6 6 6-6",
                        key: "qrunsl"
                    }]
                ]);
            var iM = n(989);
            let iT = (0, v.forwardRef)((e, t) => {
                let {
                    options: n,
                    placeholder: r,
                    value: i,
                    onChange: s,
                    onReset: a,
                    error: o,
                    disabled: l,
                    resetKey: u
                } = e;
                return (0, m.jsxs)(rW, {
                    value: i,
                    onValueChange: e => {
                        null == s || s(e)
                    },
                    disabled: l,
                    children: [(0, m.jsxs)(rX, {
                        ref: t,
                        className: (0, iM.cn)("flex w-full items-center justify-between rounded-[0.4rem] px-spacing-xs py-[0.9rem] font-roboto text-regular", "border border-text-primary-dark/20 text-text-primary-dark", "focus:border-text-primary-dark/80 focus:ring-2 focus:ring-text-primary-dark/30", {
                            "border-error focus:ring-error/50": o,
                            "pointer-events-none opacity-40": l
                        }),
                        children: [(0, m.jsx)(rK, {
                            placeholder: r
                        }), (0, m.jsxs)("div", {
                            className: "flex items-center space-x-2",
                            children: [i && a && (0, m.jsx)("button", {
                                type: "button",
                                onClick: e => {
                                    e.stopPropagation(), null == a || a()
                                },
                                className: "text-text-primary-dark/50 hover:text-text-primary-dark",
                                children: (0, m.jsx)(iS, {
                                    size: 16
                                })
                            }), (0, m.jsx)(rJ, {
                                children: (0, m.jsx)(iI, {})
                            })]
                        })]
                    }), (0, m.jsx)(rZ, {
                        children: (0, m.jsx)(r0, {
                            position: "popper",
                            className: (0, iM.cn)("z-10 w-full rounded-[0.4rem] bg-text-button-primary-dark", "border border-text-primary-dark/20", "w-[var(--radix-select-trigger-width)]"),
                            children: (0, m.jsx)(r7, {
                                className: "p-1",
                                children: n.map(e => (0, m.jsx)(il, {
                                    value: e.value,
                                    className: (0, iM.cn)("cursor-pointer px-4 py-2 font-roboto text-text-primary-dark", "data-[highlighted]:bg-text-primary-dark/10 data-[state=checked]:bg-text-primary-dark/20"),
                                    children: (0, m.jsx)(ic, {
                                        children: e.text
                                    })
                                }, e.value))
                            })
                        })
                    })]
                }, u)
            });
            iT.displayName = "CustomSelect";
            var iB = n(5026),
                iR = n(7146);
            let iD = (0, v.forwardRef)((e, t) => {
                let {
                    id: n,
                    type: r,
                    label: i,
                    checked: s,
                    choices: a,
                    placeholder: o,
                    className: l,
                    children: u,
                    error: c,
                    ...h
                } = e;
                return (0, m.jsxs)("div", {
                    className: (0, iM.cn)(l, {
                        hidden: "hidden" === r
                    }),
                    children: ["consent" === r ? (0, m.jsxs)("label", {
                        className: (0, iM.cn)(["relative flex items-start space-x-[1.6rem]", {
                            "pointer-events-none opacity-40": h.disabled
                        }]),
                        children: [(0, m.jsx)("input", {
                            id: n,
                            type: "checkbox",
                            checked: s,
                            className: (0, iM.cn)(["h-[2.4rem] w-[2.4rem] opacity-0 [&:checked+svg]:opacity-100"]),
                            ...h
                        }), (0, m.jsx)(iR.Z, {
                            symbol: "check-icon",
                            className: "absolute left-[0.4rem] top-[0.4rem] !m-0 h-[1.6rem] w-[1.6rem] fill-text-primary-dark opacity-0"
                        }), (0, m.jsx)("div", {
                            className: (0, iM.cn)(["absolute -top-0 left-0 !m-0 h-[2.4rem] w-[2.4rem] shrink-0 cursor-pointer rounded-radius-minimal border border-text-primary-dark/20", {
                                "border-error": c
                            }])
                        }), (0, m.jsx)(iB.Z, {
                            variant: "small",
                            className: (0, iM.cn)(["mt-[0.4rem] max-w-[90%] text-text-secondary-dark", "[&>#required-data]:mt-[1rem] [&>#required-data]:inline-block", "[&>a:hover]:text-text-primary-dark [&>a]:underline", "[&>a]:transition-colors [&>a]:duration-300 [&>a]:ease-out-cubic", {
                                "!text-error": c
                            }]),
                            children: i
                        })]
                    }) : "select" === r ? (0, m.jsx)(iT, {
                        ref: t,
                        options: (null == a ? void 0 : a.map(e => ({
                            value: e.value,
                            text: e.text
                        }))) || [],
                        placeholder: o,
                        onChange: h.onChange,
                        onReset: () => {
                            var e;
                            return null === (e = h.onChange) || void 0 === e ? void 0 : e.call(h, null)
                        },
                        error: c,
                        disabled: h.disabled,
                        resetKey: h.resetKey
                    }) : (0, m.jsx)("textarea" === r ? "textarea" : "input", {
                        id: n,
                        type: r,
                        placeholder: o,
                        className: (0, iM.cn)(["flex w-full appearance-none rounded-[0.4rem] bg-transparent px-spacing-xs py-[0.9rem] font-roboto text-regular outline-none", "border border-text-primary-dark/20 text-text-primary-dark placeholder:text-text-primary-dark", "focus:border-text-primary-dark/80 focus:ring-2 focus:ring-text-primary-dark/30", {
                            "min-h-[15rem]": "textarea" === r,
                            "border-error focus:ring-error/50": c
                        }, {
                            "pointer-events-none opacity-40": h.disabled
                        }]),
                        ref: "consent" !== r && "select" !== r ? t : void 0,
                        ...h
                    }), u]
                })
            });
            iD.displayName = "FormControl";
            var iL = n(9469),
                iP = n(1438),
                iO = n(1916),
                iN = n.n(iO);
            let iU = Object.prototype.toString,
                iF = Error.prototype.toString,
                ik = RegExp.prototype.toString,
                iQ = "undefined" != typeof Symbol ? Symbol.prototype.toString : () => "",
                iG = /^Symbol\((.*)\)(.*)$/;

            function iz(e, t = !1) {
                if (null == e || !0 === e || !1 === e) return "" + e;
                let n = typeof e;
                if ("number" === n) return e != +e ? "NaN" : 0 === e && 1 / e < 0 ? "-0" : "" + e;
                if ("string" === n) return t ? `"${e}"` : e;
                if ("function" === n) return "[Function " + (e.name || "anonymous") + "]";
                if ("symbol" === n) return iQ.call(e).replace(iG, "Symbol($1)");
                let r = iU.call(e).slice(8, -1);
                return "Date" === r ? isNaN(e.getTime()) ? "" + e : e.toISOString(e) : "Error" === r || e instanceof Error ? "[" + iF.call(e) + "]" : "RegExp" === r ? ik.call(e) : null
            }

            function iH(e, t) {
                let n = iz(e, t);
                return null !== n ? n : JSON.stringify(e, function(e, n) {
                    let r = iz(this[e], t);
                    return null !== r ? r : n
                }, 2)
            }

            function iV(e) {
                return null == e ? [] : [].concat(e)
            }
            let ij = /\$\{\s*(\w+)\s*\}/g;
            r = Symbol.toStringTag;
            class iW {
                constructor(e, t, n, i) {
                    this.name = void 0, this.message = void 0, this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = void 0, this.inner = void 0, this[r] = "Error", this.name = "ValidationError", this.value = t, this.path = n, this.type = i, this.errors = [], this.inner = [], iV(e).forEach(e => {
                        if (iY.isError(e)) {
                            this.errors.push(...e.errors);
                            let t = e.inner.length ? e.inner : [e];
                            this.inner.push(...t)
                        } else this.errors.push(e)
                    }), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0]
                }
            }
            i = Symbol.hasInstance, s = Symbol.toStringTag;
            class iY extends Error {
                static formatError(e, t) {
                    let n = t.label || t.path || "this";
                    return (t = Object.assign({}, t, {
                        path: n,
                        originalPath: t.path
                    }), "string" == typeof e) ? e.replace(ij, (e, n) => iH(t[n])) : "function" == typeof e ? e(t) : e
                }
                static isError(e) {
                    return e && "ValidationError" === e.name
                }
                constructor(e, t, n, r, i) {
                    let a = new iW(e, t, n, r);
                    if (i) return a;
                    super(), this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = [], this.inner = [], this[s] = "Error", this.name = a.name, this.message = a.message, this.type = a.type, this.value = a.value, this.path = a.path, this.errors = a.errors, this.inner = a.inner, Error.captureStackTrace && Error.captureStackTrace(this, iY)
                }
                static[i](e) {
                    return iW[Symbol.hasInstance](e) || super[Symbol.hasInstance](e)
                }
            }
            let iX = {
                    default: "${path} is invalid",
                    required: "${path} is a required field",
                    defined: "${path} must be defined",
                    notNull: "${path} cannot be null",
                    oneOf: "${path} must be one of the following values: ${values}",
                    notOneOf: "${path} must not be one of the following values: ${values}",
                    notType: ({
                        path: e,
                        type: t,
                        value: n,
                        originalValue: r
                    }) => {
                        let i = null != r && r !== n ? ` (cast from the value \`${iH(r,!0)}\`).` : ".";
                        return "mixed" !== t ? `${e} must be a \`${t}\` type, but the final value was: \`${iH(n,!0)}\`` + i : `${e} must match the configured type. The validated value was: \`${iH(n,!0)}\`` + i
                    }
                },
                iq = {
                    length: "${path} must be exactly ${length} characters",
                    min: "${path} must be at least ${min} characters",
                    max: "${path} must be at most ${max} characters",
                    matches: '${path} must match the following: "${regex}"',
                    email: "${path} must be a valid email",
                    url: "${path} must be a valid URL",
                    uuid: "${path} must be a valid UUID",
                    datetime: "${path} must be a valid ISO date-time",
                    datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
                    datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
                    trim: "${path} must be a trimmed string",
                    lowercase: "${path} must be a lowercase string",
                    uppercase: "${path} must be a upper case string"
                },
                iK = {
                    min: "${path} must be greater than or equal to ${min}",
                    max: "${path} must be less than or equal to ${max}",
                    lessThan: "${path} must be less than ${less}",
                    moreThan: "${path} must be greater than ${more}",
                    positive: "${path} must be a positive number",
                    negative: "${path} must be a negative number",
                    integer: "${path} must be an integer"
                },
                iJ = {
                    min: "${path} field must be later than ${min}",
                    max: "${path} field must be at earlier than ${max}"
                },
                iZ = {
                    isValue: "${path} field must be ${value}"
                },
                i$ = {
                    noUnknown: "${path} field has unspecified keys: ${unknown}",
                    exact: "${path} object contains unknown properties: ${properties}"
                },
                i0 = {
                    min: "${path} field must have at least ${min} items",
                    max: "${path} field must have less than or equal to ${max} items",
                    length: "${path} must have ${length} items"
                },
                i1 = {
                    notType: e => {
                        let {
                            path: t,
                            value: n,
                            spec: r
                        } = e, i = r.types.length;
                        if (Array.isArray(n)) {
                            if (n.length < i) return `${t} tuple value has too few items, expected a length of ${i} but got ${n.length} for value: \`${iH(n,!0)}\``;
                            if (n.length > i) return `${t} tuple value has too many items, expected a length of ${i} but got ${n.length} for value: \`${iH(n,!0)}\``
                        }
                        return iY.formatError(iX.notType, e)
                    }
                };
            Object.assign(Object.create(null), {
                mixed: iX,
                string: iq,
                number: iK,
                date: iJ,
                object: i$,
                array: i0,
                boolean: iZ,
                tuple: i1
            });
            let i2 = e => e && e.__isYupSchema__;
            class i3 {
                static fromOptions(e, t) {
                    if (!t.then && !t.otherwise) throw TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
                    let {
                        is: n,
                        then: r,
                        otherwise: i
                    } = t, s = "function" == typeof n ? n : (...e) => e.every(e => e === n);
                    return new i3(e, (e, t) => {
                        var n;
                        let a = s(...e) ? r : i;
                        return null != (n = null == a ? void 0 : a(t)) ? n : t
                    })
                }
                constructor(e, t) {
                    this.fn = void 0, this.refs = e, this.refs = e, this.fn = t
                }
                resolve(e, t) {
                    let n = this.refs.map(e => e.getValue(null == t ? void 0 : t.value, null == t ? void 0 : t.parent, null == t ? void 0 : t.context)),
                        r = this.fn(n, e, t);
                    if (void 0 === r || r === e) return e;
                    if (!i2(r)) throw TypeError("conditions must return a schema object");
                    return r.resolve(t)
                }
            }
            let i4 = {
                context: "$",
                value: "."
            };
            class i5 {
                constructor(e, t = {}) {
                    if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, "string" != typeof e) throw TypeError("ref must be a string, got: " + e);
                    if (this.key = e.trim(), "" === e) throw TypeError("ref must be a non-empty string");
                    this.isContext = this.key[0] === i4.context, this.isValue = this.key[0] === i4.value, this.isSibling = !this.isContext && !this.isValue;
                    let n = this.isContext ? i4.context : this.isValue ? i4.value : "";
                    this.path = this.key.slice(n.length), this.getter = this.path && (0, iL.getter)(this.path, !0), this.map = t.map
                }
                getValue(e, t, n) {
                    let r = this.isContext ? n : this.isValue ? e : t;
                    return this.getter && (r = this.getter(r || {})), this.map && (r = this.map(r)), r
                }
                cast(e, t) {
                    return this.getValue(e, null == t ? void 0 : t.parent, null == t ? void 0 : t.context)
                }
                resolve() {
                    return this
                }
                describe() {
                    return {
                        type: "ref",
                        key: this.key
                    }
                }
                toString() {
                    return `Ref(${this.key})`
                }
                static isRef(e) {
                    return e && e.__isYupRef
                }
            }
            i5.prototype.__isYupRef = !0;
            let i6 = e => null == e;

            function i8(e) {
                function t({
                    value: t,
                    path: n = "",
                    options: r,
                    originalValue: i,
                    schema: s
                }, a, o) {
                    let l;
                    let {
                        name: u,
                        test: c,
                        params: h,
                        message: d,
                        skipAbsent: f
                    } = e, {
                        parent: p,
                        context: g,
                        abortEarly: A = s.spec.abortEarly,
                        disableStackTrace: m = s.spec.disableStackTrace
                    } = r;

                    function v(e) {
                        return i5.isRef(e) ? e.getValue(t, p, g) : e
                    }

                    function y(e = {}) {
                        let r = Object.assign({
                            value: t,
                            originalValue: i,
                            label: s.spec.label,
                            path: e.path || n,
                            spec: s.spec,
                            disableStackTrace: e.disableStackTrace || m
                        }, h, e.params);
                        for (let e of Object.keys(r)) r[e] = v(r[e]);
                        let a = new iY(iY.formatError(e.message || d, r), t, r.path, e.type || u, r.disableStackTrace);
                        return a.params = r, a
                    }
                    let x = A ? a : o,
                        E = {
                            path: n,
                            parent: p,
                            type: u,
                            from: r.from,
                            createError: y,
                            resolve: v,
                            options: r,
                            originalValue: i,
                            schema: s
                        },
                        _ = e => {
                            iY.isError(e) ? x(e) : e ? o(null) : x(y())
                        },
                        b = e => {
                            iY.isError(e) ? x(e) : a(e)
                        };
                    if (f && i6(t)) return _(!0);
                    try {
                        var w;
                        if (l = c.call(E, t, E), "function" == typeof(null == (w = l) ? void 0 : w.then)) {
                            if (r.sync) throw Error(`Validation test of type: "${E.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
                            return Promise.resolve(l).then(_, b)
                        }
                    } catch (e) {
                        b(e);
                        return
                    }
                    _(l)
                }
                return t.OPTIONS = e, t
            }
            class i9 extends Set {
                describe() {
                    let e = [];
                    for (let t of this.values()) e.push(i5.isRef(t) ? t.describe() : t);
                    return e
                }
                resolveAll(e) {
                    let t = [];
                    for (let n of this.values()) t.push(e(n));
                    return t
                }
                clone() {
                    return new i9(this.values())
                }
                merge(e, t) {
                    let n = this.clone();
                    return e.forEach(e => n.add(e)), t.forEach(e => n.delete(e)), n
                }
            }

            function i7(e, t = new Map) {
                let n;
                if (i2(e) || !e || "object" != typeof e) return e;
                if (t.has(e)) return t.get(e);
                if (e instanceof Date) n = new Date(e.getTime()), t.set(e, n);
                else if (e instanceof RegExp) n = new RegExp(e), t.set(e, n);
                else if (Array.isArray(e)) {
                    n = Array(e.length), t.set(e, n);
                    for (let r = 0; r < e.length; r++) n[r] = i7(e[r], t)
                } else if (e instanceof Map)
                    for (let [r, i] of (n = new Map, t.set(e, n), e.entries())) n.set(r, i7(i, t));
                else if (e instanceof Set)
                    for (let r of (n = new Set, t.set(e, n), e)) n.add(i7(r, t));
                else if (e instanceof Object)
                    for (let [r, i] of (n = {}, t.set(e, n), Object.entries(e))) n[r] = i7(i, t);
                else throw Error(`Unable to clone ${e}`);
                return n
            }
            class se {
                constructor(e) {
                    this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new i9, this._blacklist = new i9, this.exclusiveTests = Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(() => {
                        this.typeError(iX.notType)
                    }), this.type = e.type, this._typeCheck = e.check, this.spec = Object.assign({
                        strip: !1,
                        strict: !1,
                        abortEarly: !0,
                        recursive: !0,
                        disableStackTrace: !1,
                        nullable: !1,
                        optional: !0,
                        coerce: !0
                    }, null == e ? void 0 : e.spec), this.withMutation(e => {
                        e.nonNullable()
                    })
                }
                get _type() {
                    return this.type
                }
                clone(e) {
                    if (this._mutate) return e && Object.assign(this.spec, e), this;
                    let t = Object.create(Object.getPrototypeOf(this));
                    return t.type = this.type, t._typeCheck = this._typeCheck, t._whitelist = this._whitelist.clone(), t._blacklist = this._blacklist.clone(), t.internalTests = Object.assign({}, this.internalTests), t.exclusiveTests = Object.assign({}, this.exclusiveTests), t.deps = [...this.deps], t.conditions = [...this.conditions], t.tests = [...this.tests], t.transforms = [...this.transforms], t.spec = i7(Object.assign({}, this.spec, e)), t
                }
                label(e) {
                    let t = this.clone();
                    return t.spec.label = e, t
                }
                meta(...e) {
                    if (0 === e.length) return this.spec.meta;
                    let t = this.clone();
                    return t.spec.meta = Object.assign(t.spec.meta || {}, e[0]), t
                }
                withMutation(e) {
                    let t = this._mutate;
                    this._mutate = !0;
                    let n = e(this);
                    return this._mutate = t, n
                }
                concat(e) {
                    if (!e || e === this) return this;
                    if (e.type !== this.type && "mixed" !== this.type) throw TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`);
                    let t = e.clone(),
                        n = Object.assign({}, this.spec, t.spec);
                    return t.spec = n, t.internalTests = Object.assign({}, this.internalTests, t.internalTests), t._whitelist = this._whitelist.merge(e._whitelist, e._blacklist), t._blacklist = this._blacklist.merge(e._blacklist, e._whitelist), t.tests = this.tests, t.exclusiveTests = this.exclusiveTests, t.withMutation(t => {
                        e.tests.forEach(e => {
                            t.test(e.OPTIONS)
                        })
                    }), t.transforms = [...this.transforms, ...t.transforms], t
                }
                isType(e) {
                    return null == e ? !!this.spec.nullable && null === e || !!this.spec.optional && void 0 === e : this._typeCheck(e)
                }
                resolve(e) {
                    let t = this;
                    if (t.conditions.length) {
                        let n = t.conditions;
                        (t = t.clone()).conditions = [], t = (t = n.reduce((t, n) => n.resolve(t, e), t)).resolve(e)
                    }
                    return t
                }
                resolveOptions(e) {
                    var t, n, r, i;
                    return Object.assign({}, e, {
                        from: e.from || [],
                        strict: null != (t = e.strict) ? t : this.spec.strict,
                        abortEarly: null != (n = e.abortEarly) ? n : this.spec.abortEarly,
                        recursive: null != (r = e.recursive) ? r : this.spec.recursive,
                        disableStackTrace: null != (i = e.disableStackTrace) ? i : this.spec.disableStackTrace
                    })
                }
                cast(e, t = {}) {
                    let n = this.resolve(Object.assign({
                            value: e
                        }, t)),
                        r = "ignore-optionality" === t.assert,
                        i = n._cast(e, t);
                    if (!1 !== t.assert && !n.isType(i)) {
                        if (r && i6(i)) return i;
                        let s = iH(e),
                            a = iH(i);
                        throw TypeError(`The value of ${t.path||"field"} could not be cast to a value that satisfies the schema type: "${n.type}". 

attempted value: ${s} 
` + (a !== s ? `result of cast: ${a}` : ""))
                    }
                    return i
                }
                _cast(e, t) {
                    let n = void 0 === e ? e : this.transforms.reduce((t, n) => n.call(this, t, e, this), e);
                    return void 0 === n && (n = this.getDefault(t)), n
                }
                _validate(e, t = {}, n, r) {
                    let {
                        path: i,
                        originalValue: s = e,
                        strict: a = this.spec.strict
                    } = t, o = e;
                    a || (o = this._cast(o, Object.assign({
                        assert: !1
                    }, t)));
                    let l = [];
                    for (let e of Object.values(this.internalTests)) e && l.push(e);
                    this.runTests({
                        path: i,
                        value: o,
                        originalValue: s,
                        options: t,
                        tests: l
                    }, n, e => {
                        if (e.length) return r(e, o);
                        this.runTests({
                            path: i,
                            value: o,
                            originalValue: s,
                            options: t,
                            tests: this.tests
                        }, n, r)
                    })
                }
                runTests(e, t, n) {
                    let r = !1,
                        {
                            tests: i,
                            value: s,
                            originalValue: a,
                            path: o,
                            options: l
                        } = e,
                        u = e => {
                            r || (r = !0, t(e, s))
                        },
                        c = e => {
                            r || (r = !0, n(e, s))
                        },
                        h = i.length,
                        d = [];
                    if (!h) return c([]);
                    let f = {
                        value: s,
                        originalValue: a,
                        path: o,
                        options: l,
                        schema: this
                    };
                    for (let e = 0; e < i.length; e++)(0, i[e])(f, u, function(e) {
                        e && (Array.isArray(e) ? d.push(...e) : d.push(e)), --h <= 0 && c(d)
                    })
                }
                asNestedTest({
                    key: e,
                    index: t,
                    parent: n,
                    parentPath: r,
                    originalParent: i,
                    options: s
                }) {
                    let a = null != e ? e : t;
                    if (null == a) throw TypeError("Must include `key` or `index` for nested validations");
                    let o = "number" == typeof a,
                        l = n[a],
                        u = Object.assign({}, s, {
                            strict: !0,
                            parent: n,
                            value: l,
                            originalValue: i[a],
                            key: void 0,
                            [o ? "index" : "key"]: a,
                            path: o || a.includes(".") ? `${r||""}[${o?a:`"${a}"`}]` : (r ? `${r}.` : "") + e
                        });
                    return (e, t, n) => this.resolve(u)._validate(l, u, t, n)
                }
                validate(e, t) {
                    var n;
                    let r = this.resolve(Object.assign({}, t, {
                            value: e
                        })),
                        i = null != (n = null == t ? void 0 : t.disableStackTrace) ? n : r.spec.disableStackTrace;
                    return new Promise((n, s) => r._validate(e, t, (e, t) => {
                        iY.isError(e) && (e.value = t), s(e)
                    }, (e, t) => {
                        e.length ? s(new iY(e, t, void 0, void 0, i)) : n(t)
                    }))
                }
                validateSync(e, t) {
                    var n;
                    let r;
                    let i = this.resolve(Object.assign({}, t, {
                            value: e
                        })),
                        s = null != (n = null == t ? void 0 : t.disableStackTrace) ? n : i.spec.disableStackTrace;
                    return i._validate(e, Object.assign({}, t, {
                        sync: !0
                    }), (e, t) => {
                        throw iY.isError(e) && (e.value = t), e
                    }, (t, n) => {
                        if (t.length) throw new iY(t, e, void 0, void 0, s);
                        r = n
                    }), r
                }
                isValid(e, t) {
                    return this.validate(e, t).then(() => !0, e => {
                        if (iY.isError(e)) return !1;
                        throw e
                    })
                }
                isValidSync(e, t) {
                    try {
                        return this.validateSync(e, t), !0
                    } catch (e) {
                        if (iY.isError(e)) return !1;
                        throw e
                    }
                }
                _getDefault(e) {
                    let t = this.spec.default;
                    return null == t ? t : "function" == typeof t ? t.call(this, e) : i7(t)
                }
                getDefault(e) {
                    return this.resolve(e || {})._getDefault(e)
                }
                default (e) {
                    return 0 == arguments.length ? this._getDefault() : this.clone({
                        default: e
                    })
                }
                strict(e = !0) {
                    return this.clone({
                        strict: e
                    })
                }
                nullability(e, t) {
                    let n = this.clone({
                        nullable: e
                    });
                    return n.internalTests.nullable = i8({
                        message: t,
                        name: "nullable",
                        test(e) {
                            return null !== e || this.schema.spec.nullable
                        }
                    }), n
                }
                optionality(e, t) {
                    let n = this.clone({
                        optional: e
                    });
                    return n.internalTests.optionality = i8({
                        message: t,
                        name: "optionality",
                        test(e) {
                            return void 0 !== e || this.schema.spec.optional
                        }
                    }), n
                }
                optional() {
                    return this.optionality(!0)
                }
                defined(e = iX.defined) {
                    return this.optionality(!1, e)
                }
                nullable() {
                    return this.nullability(!0)
                }
                nonNullable(e = iX.notNull) {
                    return this.nullability(!1, e)
                }
                required(e = iX.required) {
                    return this.clone().withMutation(t => t.nonNullable(e).defined(e))
                }
                notRequired() {
                    return this.clone().withMutation(e => e.nullable().optional())
                }
                transform(e) {
                    let t = this.clone();
                    return t.transforms.push(e), t
                }
                test(...e) {
                    let t;
                    if (void 0 === (t = 1 === e.length ? "function" == typeof e[0] ? {
                            test: e[0]
                        } : e[0] : 2 === e.length ? {
                            name: e[0],
                            test: e[1]
                        } : {
                            name: e[0],
                            message: e[1],
                            test: e[2]
                        }).message && (t.message = iX.default), "function" != typeof t.test) throw TypeError("`test` is a required parameters");
                    let n = this.clone(),
                        r = i8(t),
                        i = t.exclusive || t.name && !0 === n.exclusiveTests[t.name];
                    if (t.exclusive && !t.name) throw TypeError("Exclusive tests must provide a unique `name` identifying the test");
                    return t.name && (n.exclusiveTests[t.name] = !!t.exclusive), n.tests = n.tests.filter(e => e.OPTIONS.name !== t.name || !i && e.OPTIONS.test !== r.OPTIONS.test), n.tests.push(r), n
                }
                when(e, t) {
                    Array.isArray(e) || "string" == typeof e || (t = e, e = ".");
                    let n = this.clone(),
                        r = iV(e).map(e => new i5(e));
                    return r.forEach(e => {
                        e.isSibling && n.deps.push(e.key)
                    }), n.conditions.push("function" == typeof t ? new i3(r, t) : i3.fromOptions(r, t)), n
                }
                typeError(e) {
                    let t = this.clone();
                    return t.internalTests.typeError = i8({
                        message: e,
                        name: "typeError",
                        skipAbsent: !0,
                        test(e) {
                            return !!this.schema._typeCheck(e) || this.createError({
                                params: {
                                    type: this.schema.type
                                }
                            })
                        }
                    }), t
                }
                oneOf(e, t = iX.oneOf) {
                    let n = this.clone();
                    return e.forEach(e => {
                        n._whitelist.add(e), n._blacklist.delete(e)
                    }), n.internalTests.whiteList = i8({
                        message: t,
                        name: "oneOf",
                        skipAbsent: !0,
                        test(e) {
                            let t = this.schema._whitelist,
                                n = t.resolveAll(this.resolve);
                            return !!n.includes(e) || this.createError({
                                params: {
                                    values: Array.from(t).join(", "),
                                    resolved: n
                                }
                            })
                        }
                    }), n
                }
                notOneOf(e, t = iX.notOneOf) {
                    let n = this.clone();
                    return e.forEach(e => {
                        n._blacklist.add(e), n._whitelist.delete(e)
                    }), n.internalTests.blacklist = i8({
                        message: t,
                        name: "notOneOf",
                        test(e) {
                            let t = this.schema._blacklist,
                                n = t.resolveAll(this.resolve);
                            return !n.includes(e) || this.createError({
                                params: {
                                    values: Array.from(t).join(", "),
                                    resolved: n
                                }
                            })
                        }
                    }), n
                }
                strip(e = !0) {
                    let t = this.clone();
                    return t.spec.strip = e, t
                }
                describe(e) {
                    let t = (e ? this.resolve(e) : this).clone(),
                        {
                            label: n,
                            meta: r,
                            optional: i,
                            nullable: s
                        } = t.spec;
                    return {
                        meta: r,
                        label: n,
                        optional: i,
                        nullable: s,
                        default: t.getDefault(e),
                        type: t.type,
                        oneOf: t._whitelist.describe(),
                        notOneOf: t._blacklist.describe(),
                        tests: t.tests.map(e => ({
                            name: e.OPTIONS.name,
                            params: e.OPTIONS.params
                        })).filter((e, t, n) => n.findIndex(t => t.name === e.name) === t)
                    }
                }
            }
            for (let e of (se.prototype.__isYupSchema__ = !0, ["validate", "validateSync"])) se.prototype[`${e}At`] = function(t, n, r = {}) {
                let {
                    parent: i,
                    parentPath: s,
                    schema: a
                } = function(e, t, n, r = n) {
                    let i, s, a;
                    return t ? ((0, iL.forEach)(t, (o, l, u) => {
                        let c = l ? o.slice(1, o.length - 1) : o,
                            h = "tuple" === (e = e.resolve({
                                context: r,
                                parent: i,
                                value: n
                            })).type,
                            d = u ? parseInt(c, 10) : 0;
                        if (e.innerType || h) {
                            if (h && !u) throw Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${a}" must contain an index to the tuple element, e.g. "${a}[0]"`);
                            if (n && d >= n.length) throw Error(`Yup.reach cannot resolve an array item at index: ${o}, in the path: ${t}. because there is no value at that index. `);
                            i = n, n = n && n[d], e = h ? e.spec.types[d] : e.innerType
                        }
                        if (!u) {
                            if (!e.fields || !e.fields[c]) throw Error(`The schema does not contain the path: ${t}. (failed at: ${a} which is a type: "${e.type}")`);
                            i = n, n = n && n[c], e = e.fields[c]
                        }
                        s = c, a = l ? "[" + o + "]" : "." + o
                    }), {
                        schema: e,
                        parent: i,
                        parentPath: s
                    }) : {
                        parent: i,
                        parentPath: t,
                        schema: e
                    }
                }(this, t, n, r.context);
                return a[e](i && i[s], Object.assign({}, r, {
                    parent: i,
                    path: t
                }))
            };
            for (let e of ["equals", "is"]) se.prototype[e] = se.prototype.oneOf;
            for (let e of ["not", "nope"]) se.prototype[e] = se.prototype.notOneOf;
            let st = () => !0;

            function sn(e) {
                return new sr(e)
            }
            class sr extends se {
                constructor(e) {
                    super("function" == typeof e ? {
                        type: "mixed",
                        check: e
                    } : Object.assign({
                        type: "mixed",
                        check: st
                    }, e))
                }
            }

            function si() {
                return new ss
            }
            sn.prototype = sr.prototype;
            class ss extends se {
                constructor() {
                    super({
                        type: "boolean",
                        check: e => (e instanceof Boolean && (e = e.valueOf()), "boolean" == typeof e)
                    }), this.withMutation(() => {
                        this.transform((e, t, n) => {
                            if (n.spec.coerce && !n.isType(e)) {
                                if (/^(true|1)$/i.test(String(e))) return !0;
                                if (/^(false|0)$/i.test(String(e))) return !1
                            }
                            return e
                        })
                    })
                }
                isTrue(e = iZ.isValue) {
                    return this.test({
                        message: e,
                        name: "is-value",
                        exclusive: !0,
                        params: {
                            value: "true"
                        },
                        test: e => i6(e) || !0 === e
                    })
                }
                isFalse(e = iZ.isValue) {
                    return this.test({
                        message: e,
                        name: "is-value",
                        exclusive: !0,
                        params: {
                            value: "false"
                        },
                        test: e => i6(e) || !1 === e
                    })
                }
                default (e) {
                    return super.default(e)
                }
                defined(e) {
                    return super.defined(e)
                }
                optional() {
                    return super.optional()
                }
                required(e) {
                    return super.required(e)
                }
                notRequired() {
                    return super.notRequired()
                }
                nullable() {
                    return super.nullable()
                }
                nonNullable(e) {
                    return super.nonNullable(e)
                }
                strip(e) {
                    return super.strip(e)
                }
            }
            si.prototype = ss.prototype;
            let sa = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;

            function so(e) {
                var t, n;
                let r = sa.exec(e);
                return r ? {
                    year: sl(r[1]),
                    month: sl(r[2], 1) - 1,
                    day: sl(r[3], 1),
                    hour: sl(r[4]),
                    minute: sl(r[5]),
                    second: sl(r[6]),
                    millisecond: r[7] ? sl(r[7].substring(0, 3)) : 0,
                    precision: null != (t = null == (n = r[7]) ? void 0 : n.length) ? t : void 0,
                    z: r[8] || void 0,
                    plusMinus: r[9] || void 0,
                    hourOffset: sl(r[10]),
                    minuteOffset: sl(r[11])
                } : null
            }

            function sl(e, t = 0) {
                return Number(e) || t
            }
            let su = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
                sc = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
                sh = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,
                sd = RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"),
                sf = e => i6(e) || e === e.trim(),
                sp = ({}).toString();

            function sg() {
                return new sA
            }
            class sA extends se {
                constructor() {
                    super({
                        type: "string",
                        check: e => (e instanceof String && (e = e.valueOf()), "string" == typeof e)
                    }), this.withMutation(() => {
                        this.transform((e, t, n) => {
                            if (!n.spec.coerce || n.isType(e) || Array.isArray(e)) return e;
                            let r = null != e && e.toString ? e.toString() : e;
                            return r === sp ? e : r
                        })
                    })
                }
                required(e) {
                    return super.required(e).withMutation(t => t.test({
                        message: e || iX.required,
                        name: "required",
                        skipAbsent: !0,
                        test: e => !!e.length
                    }))
                }
                notRequired() {
                    return super.notRequired().withMutation(e => (e.tests = e.tests.filter(e => "required" !== e.OPTIONS.name), e))
                }
                length(e, t = iq.length) {
                    return this.test({
                        message: t,
                        name: "length",
                        exclusive: !0,
                        params: {
                            length: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t.length === this.resolve(e)
                        }
                    })
                }
                min(e, t = iq.min) {
                    return this.test({
                        message: t,
                        name: "min",
                        exclusive: !0,
                        params: {
                            min: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t.length >= this.resolve(e)
                        }
                    })
                }
                max(e, t = iq.max) {
                    return this.test({
                        name: "max",
                        exclusive: !0,
                        message: t,
                        params: {
                            max: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t.length <= this.resolve(e)
                        }
                    })
                }
                matches(e, t) {
                    let n, r, i = !1;
                    return t && ("object" == typeof t ? {
                        excludeEmptyString: i = !1,
                        message: n,
                        name: r
                    } = t : n = t), this.test({
                        name: r || "matches",
                        message: n || iq.matches,
                        params: {
                            regex: e
                        },
                        skipAbsent: !0,
                        test: t => "" === t && i || -1 !== t.search(e)
                    })
                }
                email(e = iq.email) {
                    return this.matches(su, {
                        name: "email",
                        message: e,
                        excludeEmptyString: !0
                    })
                }
                url(e = iq.url) {
                    return this.matches(sc, {
                        name: "url",
                        message: e,
                        excludeEmptyString: !0
                    })
                }
                uuid(e = iq.uuid) {
                    return this.matches(sh, {
                        name: "uuid",
                        message: e,
                        excludeEmptyString: !1
                    })
                }
                datetime(e) {
                    let t, n, r = "";
                    return e && ("object" == typeof e ? {
                        message: r = "",
                        allowOffset: t = !1,
                        precision: n
                    } = e : r = e), this.matches(sd, {
                        name: "datetime",
                        message: r || iq.datetime,
                        excludeEmptyString: !0
                    }).test({
                        name: "datetime_offset",
                        message: r || iq.datetime_offset,
                        params: {
                            allowOffset: t
                        },
                        skipAbsent: !0,
                        test: e => {
                            if (!e || t) return !0;
                            let n = so(e);
                            return !!n && !!n.z
                        }
                    }).test({
                        name: "datetime_precision",
                        message: r || iq.datetime_precision,
                        params: {
                            precision: n
                        },
                        skipAbsent: !0,
                        test: e => {
                            if (!e || void 0 == n) return !0;
                            let t = so(e);
                            return !!t && t.precision === n
                        }
                    })
                }
                ensure() {
                    return this.default("").transform(e => null === e ? "" : e)
                }
                trim(e = iq.trim) {
                    return this.transform(e => null != e ? e.trim() : e).test({
                        message: e,
                        name: "trim",
                        test: sf
                    })
                }
                lowercase(e = iq.lowercase) {
                    return this.transform(e => i6(e) ? e : e.toLowerCase()).test({
                        message: e,
                        name: "string_case",
                        exclusive: !0,
                        skipAbsent: !0,
                        test: e => i6(e) || e === e.toLowerCase()
                    })
                }
                uppercase(e = iq.uppercase) {
                    return this.transform(e => i6(e) ? e : e.toUpperCase()).test({
                        message: e,
                        name: "string_case",
                        exclusive: !0,
                        skipAbsent: !0,
                        test: e => i6(e) || e === e.toUpperCase()
                    })
                }
            }
            sg.prototype = sA.prototype;
            let sm = e => e != +e;

            function sv() {
                return new sy
            }
            class sy extends se {
                constructor() {
                    super({
                        type: "number",
                        check: e => (e instanceof Number && (e = e.valueOf()), "number" == typeof e && !sm(e))
                    }), this.withMutation(() => {
                        this.transform((e, t, n) => {
                            if (!n.spec.coerce) return e;
                            let r = e;
                            if ("string" == typeof r) {
                                if ("" === (r = r.replace(/\s/g, ""))) return NaN;
                                r = +r
                            }
                            return n.isType(r) || null === r ? r : parseFloat(r)
                        })
                    })
                }
                min(e, t = iK.min) {
                    return this.test({
                        message: t,
                        name: "min",
                        exclusive: !0,
                        params: {
                            min: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t >= this.resolve(e)
                        }
                    })
                }
                max(e, t = iK.max) {
                    return this.test({
                        message: t,
                        name: "max",
                        exclusive: !0,
                        params: {
                            max: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t <= this.resolve(e)
                        }
                    })
                }
                lessThan(e, t = iK.lessThan) {
                    return this.test({
                        message: t,
                        name: "max",
                        exclusive: !0,
                        params: {
                            less: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t < this.resolve(e)
                        }
                    })
                }
                moreThan(e, t = iK.moreThan) {
                    return this.test({
                        message: t,
                        name: "min",
                        exclusive: !0,
                        params: {
                            more: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t > this.resolve(e)
                        }
                    })
                }
                positive(e = iK.positive) {
                    return this.moreThan(0, e)
                }
                negative(e = iK.negative) {
                    return this.lessThan(0, e)
                }
                integer(e = iK.integer) {
                    return this.test({
                        name: "integer",
                        message: e,
                        skipAbsent: !0,
                        test: e => Number.isInteger(e)
                    })
                }
                truncate() {
                    return this.transform(e => i6(e) ? e : 0 | e)
                }
                round(e) {
                    var t;
                    let n = ["ceil", "floor", "round", "trunc"];
                    if ("trunc" === (e = (null == (t = e) ? void 0 : t.toLowerCase()) || "round")) return this.truncate();
                    if (-1 === n.indexOf(e.toLowerCase())) throw TypeError("Only valid options for round() are: " + n.join(", "));
                    return this.transform(t => i6(t) ? t : Math[e](t))
                }
            }
            sv.prototype = sy.prototype;
            let sx = new Date(""),
                sE = e => "[object Date]" === Object.prototype.toString.call(e);

            function s_() {
                return new sb
            }
            class sb extends se {
                constructor() {
                    super({
                        type: "date",
                        check: e => sE(e) && !isNaN(e.getTime())
                    }), this.withMutation(() => {
                        this.transform((e, t, n) => !n.spec.coerce || n.isType(e) || null === e ? e : isNaN(e = function(e) {
                            let t = so(e);
                            if (!t) return Date.parse ? Date.parse(e) : Number.NaN;
                            if (void 0 === t.z && void 0 === t.plusMinus) return new Date(t.year, t.month, t.day, t.hour, t.minute, t.second, t.millisecond).valueOf();
                            let n = 0;
                            return "Z" !== t.z && void 0 !== t.plusMinus && (n = 60 * t.hourOffset + t.minuteOffset, "+" === t.plusMinus && (n = 0 - n)), Date.UTC(t.year, t.month, t.day, t.hour, t.minute + n, t.second, t.millisecond)
                        }(e)) ? sb.INVALID_DATE : new Date(e))
                    })
                }
                prepareParam(e, t) {
                    let n;
                    if (i5.isRef(e)) n = e;
                    else {
                        let r = this.cast(e);
                        if (!this._typeCheck(r)) throw TypeError(`\`${t}\` must be a Date or a value that can be \`cast()\` to a Date`);
                        n = r
                    }
                    return n
                }
                min(e, t = iJ.min) {
                    let n = this.prepareParam(e, "min");
                    return this.test({
                        message: t,
                        name: "min",
                        exclusive: !0,
                        params: {
                            min: e
                        },
                        skipAbsent: !0,
                        test(e) {
                            return e >= this.resolve(n)
                        }
                    })
                }
                max(e, t = iJ.max) {
                    let n = this.prepareParam(e, "max");
                    return this.test({
                        message: t,
                        name: "max",
                        exclusive: !0,
                        params: {
                            max: e
                        },
                        skipAbsent: !0,
                        test(e) {
                            return e <= this.resolve(n)
                        }
                    })
                }
            }

            function sw(e, t) {
                let n = 1 / 0;
                return e.some((e, r) => {
                    var i;
                    if (null != (i = t.path) && i.includes(e)) return n = r, !0
                }), n
            }

            function sC(e) {
                return (t, n) => sw(e, t) - sw(e, n)
            }
            sb.INVALID_DATE = sx, s_.prototype = sb.prototype, s_.INVALID_DATE = sx;
            let sS = (e, t, n) => {
                    if ("string" != typeof e) return e;
                    let r = e;
                    try {
                        r = JSON.parse(e)
                    } catch (e) {}
                    return n.isType(r) ? r : e
                },
                sI = (e, t) => {
                    let n = [...(0, iL.normalizePath)(t)];
                    if (1 === n.length) return n[0] in e;
                    let r = n.pop(),
                        i = (0, iL.getter)((0, iL.join)(n), !0)(e);
                    return !!(i && r in i)
                },
                sM = e => "[object Object]" === Object.prototype.toString.call(e);

            function sT(e, t) {
                let n = Object.keys(e.fields);
                return Object.keys(t).filter(e => -1 === n.indexOf(e))
            }
            let sB = sC([]);

            function sR(e) {
                return new sD(e)
            }
            class sD extends se {
                constructor(e) {
                    super({
                        type: "object",
                        check: e => sM(e) || "function" == typeof e
                    }), this.fields = Object.create(null), this._sortErrors = sB, this._nodes = [], this._excludedEdges = [], this.withMutation(() => {
                        e && this.shape(e)
                    })
                }
                _cast(e, t = {}) {
                    var n;
                    let r = super._cast(e, t);
                    if (void 0 === r) return this.getDefault(t);
                    if (!this._typeCheck(r)) return r;
                    let i = this.fields,
                        s = null != (n = t.stripUnknown) ? n : this.spec.noUnknown,
                        a = [].concat(this._nodes, Object.keys(r).filter(e => !this._nodes.includes(e))),
                        o = {},
                        l = Object.assign({}, t, {
                            parent: o,
                            __validating: t.__validating || !1
                        }),
                        u = !1;
                    for (let e of a) {
                        let n = i[e],
                            a = e in r;
                        if (n) {
                            let i;
                            let s = r[e];
                            l.path = (t.path ? `${t.path}.` : "") + e;
                            let a = (n = n.resolve({
                                    value: s,
                                    context: t.context,
                                    parent: o
                                })) instanceof se ? n.spec : void 0,
                                c = null == a ? void 0 : a.strict;
                            if (null != a && a.strip) {
                                u = u || e in r;
                                continue
                            }
                            void 0 !== (i = t.__validating && c ? r[e] : n.cast(r[e], l)) && (o[e] = i)
                        } else a && !s && (o[e] = r[e]);
                        (a !== e in o || o[e] !== r[e]) && (u = !0)
                    }
                    return u ? o : r
                }
                _validate(e, t = {}, n, r) {
                    let {
                        from: i = [],
                        originalValue: s = e,
                        recursive: a = this.spec.recursive
                    } = t;
                    t.from = [{
                        schema: this,
                        value: s
                    }, ...i], t.__validating = !0, t.originalValue = s, super._validate(e, t, n, (e, i) => {
                        if (!a || !sM(i)) {
                            r(e, i);
                            return
                        }
                        s = s || i;
                        let o = [];
                        for (let e of this._nodes) {
                            let n = this.fields[e];
                            !n || i5.isRef(n) || o.push(n.asNestedTest({
                                options: t,
                                key: e,
                                parent: i,
                                parentPath: t.path,
                                originalParent: s
                            }))
                        }
                        this.runTests({
                            tests: o,
                            value: i,
                            originalValue: s,
                            options: t
                        }, n, t => {
                            r(t.sort(this._sortErrors).concat(e), i)
                        })
                    })
                }
                clone(e) {
                    let t = super.clone(e);
                    return t.fields = Object.assign({}, this.fields), t._nodes = this._nodes, t._excludedEdges = this._excludedEdges, t._sortErrors = this._sortErrors, t
                }
                concat(e) {
                    let t = super.concat(e),
                        n = t.fields;
                    for (let [e, t] of Object.entries(this.fields)) {
                        let r = n[e];
                        n[e] = void 0 === r ? t : r
                    }
                    return t.withMutation(t => t.setFields(n, [...this._excludedEdges, ...e._excludedEdges]))
                }
                _getDefault(e) {
                    if ("default" in this.spec) return super._getDefault(e);
                    if (!this._nodes.length) return;
                    let t = {};
                    return this._nodes.forEach(n => {
                        var r;
                        let i = this.fields[n],
                            s = e;
                        null != (r = s) && r.value && (s = Object.assign({}, s, {
                            parent: s.value,
                            value: s.value[n]
                        })), t[n] = i && "getDefault" in i ? i.getDefault(s) : void 0
                    }), t
                }
                setFields(e, t) {
                    let n = this.clone();
                    return n.fields = e, n._nodes = function(e, t = []) {
                        let n = [],
                            r = new Set,
                            i = new Set(t.map(([e, t]) => `${e}-${t}`));

                        function s(e, t) {
                            let s = (0, iL.split)(e)[0];
                            r.add(s), i.has(`${t}-${s}`) || n.push([t, s])
                        }
                        for (let t of Object.keys(e)) {
                            let n = e[t];
                            r.add(t), i5.isRef(n) && n.isSibling ? s(n.path, t) : i2(n) && "deps" in n && n.deps.forEach(e => s(e, t))
                        }
                        return iN().array(Array.from(r), n).reverse()
                    }(e, t), n._sortErrors = sC(Object.keys(e)), t && (n._excludedEdges = t), n
                }
                shape(e, t = []) {
                    return this.clone().withMutation(n => {
                        let r = n._excludedEdges;
                        return t.length && (Array.isArray(t[0]) || (t = [t]), r = [...n._excludedEdges, ...t]), n.setFields(Object.assign(n.fields, e), r)
                    })
                }
                partial() {
                    let e = {};
                    for (let [t, n] of Object.entries(this.fields)) e[t] = "optional" in n && n.optional instanceof Function ? n.optional() : n;
                    return this.setFields(e)
                }
                deepPartial() {
                    return function e(t) {
                        if ("fields" in t) {
                            let n = {};
                            for (let [r, i] of Object.entries(t.fields)) n[r] = e(i);
                            return t.setFields(n)
                        }
                        if ("array" === t.type) {
                            let n = t.optional();
                            return n.innerType && (n.innerType = e(n.innerType)), n
                        }
                        return "tuple" === t.type ? t.optional().clone({
                            types: t.spec.types.map(e)
                        }) : "optional" in t ? t.optional() : t
                    }(this)
                }
                pick(e) {
                    let t = {};
                    for (let n of e) this.fields[n] && (t[n] = this.fields[n]);
                    return this.setFields(t, this._excludedEdges.filter(([t, n]) => e.includes(t) && e.includes(n)))
                }
                omit(e) {
                    let t = [];
                    for (let n of Object.keys(this.fields)) e.includes(n) || t.push(n);
                    return this.pick(t)
                }
                from(e, t, n) {
                    let r = (0, iL.getter)(e, !0);
                    return this.transform(i => {
                        if (!i) return i;
                        let s = i;
                        return sI(i, e) && (s = Object.assign({}, i), n || delete s[e], s[t] = r(i)), s
                    })
                }
                json() {
                    return this.transform(sS)
                }
                exact(e) {
                    return this.test({
                        name: "exact",
                        exclusive: !0,
                        message: e || i$.exact,
                        test(e) {
                            if (null == e) return !0;
                            let t = sT(this.schema, e);
                            return 0 === t.length || this.createError({
                                params: {
                                    properties: t.join(", ")
                                }
                            })
                        }
                    })
                }
                stripUnknown() {
                    return this.clone({
                        noUnknown: !0
                    })
                }
                noUnknown(e = !0, t = i$.noUnknown) {
                    "boolean" != typeof e && (t = e, e = !0);
                    let n = this.test({
                        name: "noUnknown",
                        exclusive: !0,
                        message: t,
                        test(t) {
                            if (null == t) return !0;
                            let n = sT(this.schema, t);
                            return !e || 0 === n.length || this.createError({
                                params: {
                                    unknown: n.join(", ")
                                }
                            })
                        }
                    });
                    return n.spec.noUnknown = e, n
                }
                unknown(e = !0, t = i$.noUnknown) {
                    return this.noUnknown(!e, t)
                }
                transformKeys(e) {
                    return this.transform(t => {
                        if (!t) return t;
                        let n = {};
                        for (let r of Object.keys(t)) n[e(r)] = t[r];
                        return n
                    })
                }
                camelCase() {
                    return this.transformKeys(iP.camelCase)
                }
                snakeCase() {
                    return this.transformKeys(iP.snakeCase)
                }
                constantCase() {
                    return this.transformKeys(e => (0, iP.snakeCase)(e).toUpperCase())
                }
                describe(e) {
                    let t = (e ? this.resolve(e) : this).clone(),
                        n = super.describe(e);
                    for (let [i, s] of (n.fields = {}, Object.entries(t.fields))) {
                        var r;
                        let t = e;
                        null != (r = t) && r.value && (t = Object.assign({}, t, {
                            parent: t.value,
                            value: t.value[i]
                        })), n.fields[i] = s.describe(t)
                    }
                    return n
                }
            }
            sR.prototype = sD.prototype;
            class sL extends se {
                constructor(e) {
                    super({
                        type: "array",
                        spec: {
                            types: e
                        },
                        check: e => Array.isArray(e)
                    }), this.innerType = void 0, this.innerType = e
                }
                _cast(e, t) {
                    let n = super._cast(e, t);
                    if (!this._typeCheck(n) || !this.innerType) return n;
                    let r = !1,
                        i = n.map((e, n) => {
                            let i = this.innerType.cast(e, Object.assign({}, t, {
                                path: `${t.path||""}[${n}]`
                            }));
                            return i !== e && (r = !0), i
                        });
                    return r ? i : n
                }
                _validate(e, t = {}, n, r) {
                    var i;
                    let s = this.innerType,
                        a = null != (i = t.recursive) ? i : this.spec.recursive;
                    null != t.originalValue && t.originalValue, super._validate(e, t, n, (i, o) => {
                        var l, u;
                        if (!a || !s || !this._typeCheck(o)) {
                            r(i, o);
                            return
                        }
                        let c = Array(o.length);
                        for (let n = 0; n < o.length; n++) c[n] = s.asNestedTest({
                            options: t,
                            index: n,
                            parent: o,
                            parentPath: t.path,
                            originalParent: null != (u = t.originalValue) ? u : e
                        });
                        this.runTests({
                            value: o,
                            tests: c,
                            originalValue: null != (l = t.originalValue) ? l : e,
                            options: t
                        }, n, e => r(e.concat(i), o))
                    })
                }
                clone(e) {
                    let t = super.clone(e);
                    return t.innerType = this.innerType, t
                }
                json() {
                    return this.transform(sS)
                }
                concat(e) {
                    let t = super.concat(e);
                    return t.innerType = this.innerType, e.innerType && (t.innerType = t.innerType ? t.innerType.concat(e.innerType) : e.innerType), t
                } of (e) {
                    let t = this.clone();
                    if (!i2(e)) throw TypeError("`array.of()` sub-schema must be a valid yup schema not: " + iH(e));
                    return t.innerType = e, t.spec = Object.assign({}, t.spec, {
                        types: e
                    }), t
                }
                length(e, t = i0.length) {
                    return this.test({
                        message: t,
                        name: "length",
                        exclusive: !0,
                        params: {
                            length: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t.length === this.resolve(e)
                        }
                    })
                }
                min(e, t) {
                    return t = t || i0.min, this.test({
                        message: t,
                        name: "min",
                        exclusive: !0,
                        params: {
                            min: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t.length >= this.resolve(e)
                        }
                    })
                }
                max(e, t) {
                    return t = t || i0.max, this.test({
                        message: t,
                        name: "max",
                        exclusive: !0,
                        params: {
                            max: e
                        },
                        skipAbsent: !0,
                        test(t) {
                            return t.length <= this.resolve(e)
                        }
                    })
                }
                ensure() {
                    return this.default(() => []).transform((e, t) => this._typeCheck(e) ? e : null == t ? [] : [].concat(t))
                }
                compact(e) {
                    let t = e ? (t, n, r) => !e(t, n, r) : e => !!e;
                    return this.transform(e => null != e ? e.filter(t) : e)
                }
                describe(e) {
                    let t = (e ? this.resolve(e) : this).clone(),
                        n = super.describe(e);
                    if (t.innerType) {
                        var r;
                        let i = e;
                        null != (r = i) && r.value && (i = Object.assign({}, i, {
                            parent: i.value,
                            value: i.value[0]
                        })), n.innerType = t.innerType.describe(i)
                    }
                    return n
                }
            }
            sL.prototype;
            class sP extends se {
                constructor(e) {
                    super({
                        type: "tuple",
                        spec: {
                            types: e
                        },
                        check(e) {
                            let t = this.spec.types;
                            return Array.isArray(e) && e.length === t.length
                        }
                    }), this.withMutation(() => {
                        this.typeError(i1.notType)
                    })
                }
                _cast(e, t) {
                    let {
                        types: n
                    } = this.spec, r = super._cast(e, t);
                    if (!this._typeCheck(r)) return r;
                    let i = !1,
                        s = n.map((e, n) => {
                            let s = e.cast(r[n], Object.assign({}, t, {
                                path: `${t.path||""}[${n}]`
                            }));
                            return s !== r[n] && (i = !0), s
                        });
                    return i ? s : r
                }
                _validate(e, t = {}, n, r) {
                    let i = this.spec.types;
                    super._validate(e, t, n, (s, a) => {
                        var o, l;
                        if (!this._typeCheck(a)) {
                            r(s, a);
                            return
                        }
                        let u = [];
                        for (let [n, r] of i.entries()) u[n] = r.asNestedTest({
                            options: t,
                            index: n,
                            parent: a,
                            parentPath: t.path,
                            originalParent: null != (l = t.originalValue) ? l : e
                        });
                        this.runTests({
                            value: a,
                            tests: u,
                            originalValue: null != (o = t.originalValue) ? o : e,
                            options: t
                        }, n, e => r(e.concat(s), a))
                    })
                }
                describe(e) {
                    let t = (e ? this.resolve(e) : this).clone(),
                        n = super.describe(e);
                    return n.innerType = t.spec.types.map((t, n) => {
                        var r;
                        let i = e;
                        return null != (r = i) && r.value && (i = Object.assign({}, i, {
                            parent: i.value,
                            value: i.value[n]
                        })), t.describe(i)
                    }), n
                }
            }
            sP.prototype;
            let sO = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en",
                        r = n(788)("./".concat(t, ".json")),
                        i = e.filter(e => "space" !== e.type && "title" !== e.type && "multiple_dates" !== e.type).reduce((e, t) => {
                            let n = sn();
                            return ("text" === t.type || "date" === t.type || "textarea" === t.type || "select" === t.type || "radio" === t.type || "address" === t.type || "website" === t.type || "hidden" === t.type) && (n = sg(), t.isRequired && (n = n.required(r.required))), "email" === t.type && (n = sg().email(r.email), t.isRequired && (n = n.required(r.required))), "password" === t.type && (n = sg(), t.isRequired && (n = n.min(8, r.password).required(r.required))), "confirm_password" === t.type && (n = sg(), t.isRequired) && (n = n.required(r.required).oneOf([new i5("user_pass", void 0), null], r.confirm_password)), ("tel" === t.type || "phone" === t.type) && (n = sv().typeError(r.tel), t.isRequired && (n = n.required(r.required))), ("checkbox" === t.type || "consent" === t.type) && (n = si(), t.isRequired && (n = n.oneOf([!0], r.checkbox).required(r.required))), ("file" === t.type || "fileupload" === t.type) && (n = sn(), t.isRequired && (n = n.required(r.required))), { ...e,
                                ["input_".concat(t.id)]: n
                            }
                        }, {});
                    return sR().shape(i)
                },
                sN = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    return Object.assign(e.reduce((e, t) => ({ ...e,
                        ["input_".concat(t.id)]: "consent" !== t.type && ""
                    }), {}), ...t)
                },
                sU = e => {
                    let t = new FormData;
                    for (let n in e) e.hasOwnProperty(n) && t.append(n, e[n]);
                    return t
                };
            var sF = n(8020),
                sk = n(5523),
                sQ = n(3142),
                sG = n(6592),
                sz = n(6947),
                sH = e => {
                    var t, n, r, i, s, a, o, l, u, c, h, d, f, p, g, A, y, x, E, _, b, C, S, I, M, T, B, R, D, L, P, O, N, U, F, k, Q, G, z, H, j, W, Y, X, q, K, J, Z, $, ee, et, en, er, ei, es, ea;
                    let {
                        form_id: eo,
                        fields: el = [],
                        submit: eu,
                        className: ec,
                        ...eh
                    } = e, [ed, ef] = (0, v.useState)("&nbsp;");
                    async function ep(e) {
                        return await sk.e.post("".concat(sF.bl.GRAVITY_FORM, "/").concat(eo, "/submissions"), sU(e), {
                            headers: {
                                "Content-Type": "multipart/form-data"
                            }
                        })
                    }
                    let eg = (r = void 0 === (n = (t = {
                        initialValues: sN(el) || {},
                        validationSchema: sO(el, "en"),
                        enableReinitialize: !0,
                        onSubmit: (e, t) => {
                            let {
                                setStatus: n,
                                setSubmitting: r,
                                resetForm: i
                            } = t;
                            ep({ ...e
                            }).then(e => {
                                ef(e.data.confirmation_message), n(e.data.is_valid ? "success" : "error")
                            }).then(() => {
                                setTimeout(() => {
                                    i(), ef("&nbsp;"), n(""), r(!1)
                                }, 3e3)
                            })
                        }
                    }).validateOnChange) || n, s = void 0 === (i = t.validateOnBlur) || i, o = void 0 !== (a = t.validateOnMount) && a, l = t.isInitialValid, c = void 0 !== (u = t.enableReinitialize) && u, h = t.onSubmit, d = nn(t, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]), f = nt({
                        validateOnChange: r,
                        validateOnBlur: s,
                        validateOnMount: o,
                        onSubmit: h
                    }, d), p = (0, v.useRef)(f.initialValues), g = (0, v.useRef)(f.initialErrors || nd), A = (0, v.useRef)(f.initialTouched || nf), y = (0, v.useRef)(f.initialStatus), x = (0, v.useRef)(!1), E = (0, v.useRef)({}), (0, v.useEffect)(function() {
                        return x.current = !0,
                            function() {
                                x.current = !1
                            }
                    }, []), _ = (0, v.useState)(0)[1], C = (b = (0, v.useRef)({
                        values: tY(f.initialValues),
                        errors: tY(f.initialErrors) || nd,
                        touched: tY(f.initialTouched) || nf,
                        status: tY(f.initialStatus),
                        isSubmitting: !1,
                        isValidating: !1,
                        submitCount: 0
                    })).current, S = (0, v.useCallback)(function(e) {
                        var t = b.current;
                        b.current = function(e, t) {
                            switch (t.type) {
                                case "SET_VALUES":
                                    return nt({}, e, {
                                        values: t.payload
                                    });
                                case "SET_TOUCHED":
                                    return nt({}, e, {
                                        touched: t.payload
                                    });
                                case "SET_ERRORS":
                                    if (tq()(e.errors, t.payload)) return e;
                                    return nt({}, e, {
                                        errors: t.payload
                                    });
                                case "SET_STATUS":
                                    return nt({}, e, {
                                        status: t.payload
                                    });
                                case "SET_ISSUBMITTING":
                                    return nt({}, e, {
                                        isSubmitting: t.payload
                                    });
                                case "SET_ISVALIDATING":
                                    return nt({}, e, {
                                        isValidating: t.payload
                                    });
                                case "SET_FIELD_VALUE":
                                    return nt({}, e, {
                                        values: nh(e.values, t.payload.field, t.payload.value)
                                    });
                                case "SET_FIELD_TOUCHED":
                                    return nt({}, e, {
                                        touched: nh(e.touched, t.payload.field, t.payload.value)
                                    });
                                case "SET_FIELD_ERROR":
                                    return nt({}, e, {
                                        errors: nh(e.errors, t.payload.field, t.payload.value)
                                    });
                                case "RESET_FORM":
                                    return nt({}, e, t.payload);
                                case "SET_FORMIK_STATE":
                                    return t.payload(e);
                                case "SUBMIT_ATTEMPT":
                                    return nt({}, e, {
                                        touched: function e(t, n, r, i) {
                                            void 0 === r && (r = new WeakMap), void 0 === i && (i = {});
                                            for (var s = 0, a = Object.keys(t); s < a.length; s++) {
                                                var o = a[s],
                                                    l = t[o];
                                                no(l) ? r.get(l) || (r.set(l, !0), i[o] = Array.isArray(l) ? [] : {}, e(l, n, r, i[o])) : i[o] = n
                                            }
                                            return i
                                        }(e.values, !0),
                                        isSubmitting: !0,
                                        submitCount: e.submitCount + 1
                                    });
                                case "SUBMIT_FAILURE":
                                case "SUBMIT_SUCCESS":
                                    return nt({}, e, {
                                        isSubmitting: !1
                                    });
                                default:
                                    return e
                            }
                        }(t, e), t !== b.current && _(function(e) {
                            return e + 1
                        })
                    }, []), I = (0, v.useCallback)(function(e, t) {
                        return new Promise(function(n, r) {
                            var i = f.validate(e, t);
                            null == i ? n(nd) : nu(i) ? i.then(function(e) {
                                n(e || nd)
                            }, function(e) {
                                r(e)
                            }) : n(i)
                        })
                    }, [f.validate]), M = (0, v.useCallback)(function(e, t) {
                        var n, r, i = f.validationSchema,
                            s = na(i) ? i(t) : i,
                            a = t && s.validateAt ? s.validateAt(t, e) : (void 0 === n && (n = !1), r = function e(t) {
                                var n = Array.isArray(t) ? [] : {};
                                for (var r in t)
                                    if (Object.prototype.hasOwnProperty.call(t, r)) {
                                        var i = String(r);
                                        !0 === Array.isArray(t[i]) ? n[i] = t[i].map(function(t) {
                                            return !0 === Array.isArray(t) || V(t) ? e(t) : "" !== t ? t : void 0
                                        }) : V(t[i]) ? n[i] = e(t[i]) : n[i] = "" !== t[i] ? t[i] : void 0
                                    }
                                return n
                            }(e), s[n ? "validateSync" : "validate"](r, {
                                abortEarly: !1,
                                context: r
                            }));
                        return new Promise(function(e, t) {
                            a.then(function() {
                                e(nd)
                            }, function(n) {
                                "ValidationError" === n.name ? e(function(e) {
                                    var t = {};
                                    if (e.inner) {
                                        if (0 === e.inner.length) return nh(t, e.path, e.message);
                                        for (var n = e.inner, r = Array.isArray(n), i = 0, n = r ? n : n[Symbol.iterator]();;) {
                                            if (r) {
                                                if (i >= n.length) break;
                                                s = n[i++]
                                            } else {
                                                if ((i = n.next()).done) break;
                                                s = i.value
                                            }
                                            var s, a = s;
                                            nc(t, a.path) || (t = nh(t, a.path, a.message))
                                        }
                                    }
                                    return t
                                }(n)) : t(n)
                            })
                        })
                    }, [f.validationSchema]), T = (0, v.useCallback)(function(e, t) {
                        return new Promise(function(n) {
                            return n(E.current[e].validate(t))
                        })
                    }, []), B = (0, v.useCallback)(function(e) {
                        var t = Object.keys(E.current).filter(function(e) {
                            return na(E.current[e].validate)
                        });
                        return Promise.all(t.length > 0 ? t.map(function(t) {
                            return T(t, nc(e, t))
                        }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")]).then(function(e) {
                            return e.reduce(function(e, n, r) {
                                return "DO_NOT_DELETE_YOU_WILL_BE_FIRED" === n || n && (e = nh(e, t[r], n)), e
                            }, {})
                        })
                    }, [T]), R = (0, v.useCallback)(function(e) {
                        return Promise.all([B(e), f.validationSchema ? M(e) : {}, f.validate ? I(e) : {}]).then(function(e) {
                            var t = e[0],
                                n = e[1],
                                r = e[2];
                            return w.all([t, n, r], {
                                arrayMerge: np
                            })
                        })
                    }, [f.validate, f.validationSchema, B, I, M]), D = nA(function(e) {
                        return void 0 === e && (e = C.values), S({
                            type: "SET_ISVALIDATING",
                            payload: !0
                        }), R(e).then(function(e) {
                            return x.current && (S({
                                type: "SET_ISVALIDATING",
                                payload: !1
                            }), S({
                                type: "SET_ERRORS",
                                payload: e
                            })), e
                        })
                    }), (0, v.useEffect)(function() {
                        o && !0 === x.current && tq()(p.current, f.initialValues) && D(p.current)
                    }, [o, D]), L = (0, v.useCallback)(function(e) {
                        var t = e && e.values ? e.values : p.current,
                            n = e && e.errors ? e.errors : g.current ? g.current : f.initialErrors || {},
                            r = e && e.touched ? e.touched : A.current ? A.current : f.initialTouched || {},
                            i = e && e.status ? e.status : y.current ? y.current : f.initialStatus;
                        p.current = t, g.current = n, A.current = r, y.current = i;
                        var s = function() {
                            S({
                                type: "RESET_FORM",
                                payload: {
                                    isSubmitting: !!e && !!e.isSubmitting,
                                    errors: n,
                                    touched: r,
                                    status: i,
                                    values: t,
                                    isValidating: !!e && !!e.isValidating,
                                    submitCount: e && e.submitCount && "number" == typeof e.submitCount ? e.submitCount : 0
                                }
                            })
                        };
                        if (f.onReset) {
                            var a = f.onReset(C.values, $);
                            nu(a) ? a.then(s) : s()
                        } else s()
                    }, [f.initialErrors, f.initialStatus, f.initialTouched, f.onReset]), (0, v.useEffect)(function() {
                        !0 === x.current && !tq()(p.current, f.initialValues) && c && (p.current = f.initialValues, L(), o && D(p.current))
                    }, [c, f.initialValues, L, o, D]), (0, v.useEffect)(function() {
                        c && !0 === x.current && !tq()(g.current, f.initialErrors) && (g.current = f.initialErrors || nd, S({
                            type: "SET_ERRORS",
                            payload: f.initialErrors || nd
                        }))
                    }, [c, f.initialErrors]), (0, v.useEffect)(function() {
                        c && !0 === x.current && !tq()(A.current, f.initialTouched) && (A.current = f.initialTouched || nf, S({
                            type: "SET_TOUCHED",
                            payload: f.initialTouched || nf
                        }))
                    }, [c, f.initialTouched]), (0, v.useEffect)(function() {
                        c && !0 === x.current && !tq()(y.current, f.initialStatus) && (y.current = f.initialStatus, S({
                            type: "SET_STATUS",
                            payload: f.initialStatus
                        }))
                    }, [c, f.initialStatus, f.initialTouched]), P = nA(function(e) {
                        if (E.current[e] && na(E.current[e].validate)) {
                            var t = nc(C.values, e),
                                n = E.current[e].validate(t);
                            return nu(n) ? (S({
                                type: "SET_ISVALIDATING",
                                payload: !0
                            }), n.then(function(e) {
                                return e
                            }).then(function(t) {
                                S({
                                    type: "SET_FIELD_ERROR",
                                    payload: {
                                        field: e,
                                        value: t
                                    }
                                }), S({
                                    type: "SET_ISVALIDATING",
                                    payload: !1
                                })
                            })) : (S({
                                type: "SET_FIELD_ERROR",
                                payload: {
                                    field: e,
                                    value: n
                                }
                            }), Promise.resolve(n))
                        }
                        return f.validationSchema ? (S({
                            type: "SET_ISVALIDATING",
                            payload: !0
                        }), M(C.values, e).then(function(e) {
                            return e
                        }).then(function(t) {
                            S({
                                type: "SET_FIELD_ERROR",
                                payload: {
                                    field: e,
                                    value: nc(t, e)
                                }
                            }), S({
                                type: "SET_ISVALIDATING",
                                payload: !1
                            })
                        })) : Promise.resolve()
                    }), O = (0, v.useCallback)(function(e, t) {
                        var n = t.validate;
                        E.current[e] = {
                            validate: n
                        }
                    }, []), N = (0, v.useCallback)(function(e) {
                        delete E.current[e]
                    }, []), U = nA(function(e, t) {
                        return S({
                            type: "SET_TOUCHED",
                            payload: e
                        }), (void 0 === t ? s : t) ? D(C.values) : Promise.resolve()
                    }), F = (0, v.useCallback)(function(e) {
                        S({
                            type: "SET_ERRORS",
                            payload: e
                        })
                    }, []), k = nA(function(e, t) {
                        var n = na(e) ? e(C.values) : e;
                        return S({
                            type: "SET_VALUES",
                            payload: n
                        }), (void 0 === t ? r : t) ? D(n) : Promise.resolve()
                    }), Q = (0, v.useCallback)(function(e, t) {
                        S({
                            type: "SET_FIELD_ERROR",
                            payload: {
                                field: e,
                                value: t
                            }
                        })
                    }, []), G = nA(function(e, t, n) {
                        return S({
                            type: "SET_FIELD_VALUE",
                            payload: {
                                field: e,
                                value: t
                            }
                        }), (void 0 === n ? r : n) ? D(nh(C.values, e, t)) : Promise.resolve()
                    }), z = (0, v.useCallback)(function(e, t) {
                        var n, r = t,
                            i = e;
                        if (!nl(e)) {
                            e.persist && e.persist();
                            var s = e.target ? e.target : e.currentTarget,
                                a = s.type,
                                o = s.name,
                                l = s.id,
                                u = s.value,
                                c = s.checked,
                                h = (s.outerHTML, s.options),
                                d = s.multiple;
                            r = t || o || l, i = /number|range/.test(a) ? isNaN(n = parseFloat(u)) ? "" : n : /checkbox/.test(a) ? function(e, t, n) {
                                if ("boolean" == typeof e) return !!t;
                                var r = [],
                                    i = !1,
                                    s = -1;
                                if (Array.isArray(e)) r = e, i = (s = e.indexOf(n)) >= 0;
                                else if (!n || "true" == n || "false" == n) return !!t;
                                return t && n && !i ? r.concat(n) : i ? r.slice(0, s).concat(r.slice(s + 1)) : r
                            }(nc(C.values, r), c, u) : h && d ? Array.from(h).filter(function(e) {
                                return e.selected
                            }).map(function(e) {
                                return e.value
                            }) : u
                        }
                        r && G(r, i)
                    }, [G, C.values]), H = nA(function(e) {
                        if (nl(e)) return function(t) {
                            return z(t, e)
                        };
                        z(e)
                    }), j = nA(function(e, t, n) {
                        return void 0 === t && (t = !0), S({
                            type: "SET_FIELD_TOUCHED",
                            payload: {
                                field: e,
                                value: t
                            }
                        }), (void 0 === n ? s : n) ? D(C.values) : Promise.resolve()
                    }), W = (0, v.useCallback)(function(e, t) {
                        e.persist && e.persist();
                        var n = e.target,
                            r = n.name,
                            i = n.id;
                        n.outerHTML, j(t || r || i, !0)
                    }, [j]), Y = nA(function(e) {
                        if (nl(e)) return function(t) {
                            return W(t, e)
                        };
                        W(e)
                    }), X = (0, v.useCallback)(function(e) {
                        na(e) ? S({
                            type: "SET_FORMIK_STATE",
                            payload: e
                        }) : S({
                            type: "SET_FORMIK_STATE",
                            payload: function() {
                                return e
                            }
                        })
                    }, []), q = (0, v.useCallback)(function(e) {
                        S({
                            type: "SET_STATUS",
                            payload: e
                        })
                    }, []), K = (0, v.useCallback)(function(e) {
                        S({
                            type: "SET_ISSUBMITTING",
                            payload: e
                        })
                    }, []), J = nA(function() {
                        return S({
                            type: "SUBMIT_ATTEMPT"
                        }), D().then(function(e) {
                            var t, n = e instanceof Error;
                            if (!n && 0 === Object.keys(e).length) {
                                try {
                                    if (t = ee(), void 0 === t) return
                                } catch (e) {
                                    throw e
                                }
                                return Promise.resolve(t).then(function(e) {
                                    return x.current && S({
                                        type: "SUBMIT_SUCCESS"
                                    }), e
                                }).catch(function(e) {
                                    if (x.current) throw S({
                                        type: "SUBMIT_FAILURE"
                                    }), e
                                })
                            }
                            if (x.current && (S({
                                    type: "SUBMIT_FAILURE"
                                }), n)) throw e
                        })
                    }), Z = nA(function(e) {
                        e && e.preventDefault && na(e.preventDefault) && e.preventDefault(), e && e.stopPropagation && na(e.stopPropagation) && e.stopPropagation(), J().catch(function(e) {
                            console.warn("Warning: An unhandled error was caught from submitForm()", e)
                        })
                    }), $ = {
                        resetForm: L,
                        validateForm: D,
                        validateField: P,
                        setErrors: F,
                        setFieldError: Q,
                        setFieldTouched: j,
                        setFieldValue: G,
                        setStatus: q,
                        setSubmitting: K,
                        setTouched: U,
                        setValues: k,
                        setFormikState: X,
                        submitForm: J
                    }, ee = nA(function() {
                        return h(C.values, $)
                    }), et = nA(function(e) {
                        e && e.preventDefault && na(e.preventDefault) && e.preventDefault(), e && e.stopPropagation && na(e.stopPropagation) && e.stopPropagation(), L()
                    }), en = (0, v.useCallback)(function(e) {
                        return {
                            value: nc(C.values, e),
                            error: nc(C.errors, e),
                            touched: !!nc(C.touched, e),
                            initialValue: nc(p.current, e),
                            initialTouched: !!nc(A.current, e),
                            initialError: nc(g.current, e)
                        }
                    }, [C.errors, C.touched, C.values]), er = (0, v.useCallback)(function(e) {
                        return {
                            setValue: function(t, n) {
                                return G(e, t, n)
                            },
                            setTouched: function(t, n) {
                                return j(e, t, n)
                            },
                            setError: function(t) {
                                return Q(e, t)
                            }
                        }
                    }, [G, j, Q]), ei = (0, v.useCallback)(function(e) {
                        var t = no(e),
                            n = t ? e.name : e,
                            r = nc(C.values, n),
                            i = {
                                name: n,
                                value: r,
                                onChange: H,
                                onBlur: Y
                            };
                        if (t) {
                            var s = e.type,
                                a = e.value,
                                o = e.as,
                                l = e.multiple;
                            "checkbox" === s ? void 0 === a ? i.checked = !!r : (i.checked = !!(Array.isArray(r) && ~r.indexOf(a)), i.value = a) : "radio" === s ? (i.checked = r === a, i.value = a) : "select" === o && l && (i.value = i.value || [], i.multiple = !0)
                        }
                        return i
                    }, [Y, H, C.values]), es = (0, v.useMemo)(function() {
                        return !tq()(p.current, C.values)
                    }, [p.current, C.values]), ea = (0, v.useMemo)(function() {
                        return void 0 !== l ? es ? C.errors && 0 === Object.keys(C.errors).length : !1 !== l && na(l) ? l(f) : l : C.errors && 0 === Object.keys(C.errors).length
                    }, [l, es, C.errors, f]), nt({}, C, {
                        initialValues: p.current,
                        initialErrors: g.current,
                        initialTouched: A.current,
                        initialStatus: y.current,
                        handleBlur: Y,
                        handleChange: H,
                        handleReset: et,
                        handleSubmit: Z,
                        resetForm: L,
                        setErrors: F,
                        setFormikState: X,
                        setFieldTouched: j,
                        setFieldValue: G,
                        setFieldError: Q,
                        setStatus: q,
                        setSubmitting: K,
                        setTouched: U,
                        setValues: k,
                        submitForm: J,
                        validateForm: D,
                        validateField: P,
                        isValid: ea,
                        dirty: es,
                        unregisterField: N,
                        registerField: O,
                        getFieldProps: ei,
                        getFieldMeta: en,
                        getFieldHelpers: er,
                        validateOnBlur: s,
                        validateOnChange: r,
                        validateOnMount: o
                    }));
                    return (0, m.jsxs)("form", {
                        noValidate: !0,
                        autoComplete: "off",
                        onSubmit: eg.handleSubmit,
                        className: (0, iM.cn)(["relative grid grid-cols-2 gap-spacing-xxs", ec]),
                        ...eh,
                        children: [null == el ? void 0 : el.map((e, t) => (0, m.jsx)(iD, {
                            id: "input_".concat(e.id),
                            name: "input_".concat(e.id),
                            type: e.type,
                            label: "consent" === e.type ? e.checkboxLabel : e.label,
                            required: e.isRequired,
                            choices: e.choices,
                            placeholder: "".concat(e.placeholder).concat(e.isRequired ? " *" : ""),
                            checked: eg.values["input_".concat(e.id)] || !1,
                            value: eg.values["input_".concat(e.id)],
                            disabled: eg.isSubmitting,
                            onChange: t => {
                                eg.handleChange(t), "consent" === e.type && eg.setFieldValue("input_".concat(e.id, "_1"), t.target.checked ? "1" : "0", !1)
                            },
                            onBlur: eg.handleBlur,
                            error: void 0 !== eg.errors["input_".concat(e.id)] && void 0 !== eg.touched["input_".concat(e.id)],
                            className: (0, iM.cn)(["col-span-2", {
                                "md:col-span-1": "half" === e.cssClass,
                                "mt-spacing-xs": "consent" === e.type
                            }])
                        }, t)), (0, m.jsx)("div", {
                            className: "col-span-2 mt-spacing-xs flex items-center gap-spacing-xs",
                            children: (0, m.jsxs)(sQ.Z, {
                                type: "submit",
                                className: (0, iM.cn)(["w-full justify-between rounded-radius-minimal py-spacing-xs", {
                                    "pointer-events-none opacity-40": eg.isSubmitting
                                }]),
                                endIcon: (0, m.jsx)(iR.Z, {
                                    symbol: "arrow-right",
                                    className: (0, iM.cn)("h-[0.8rem] w-[4rem] fill-surface-primay-invert-dark", {
                                        "opacity-0": eg.isSubmitting
                                    })
                                }),
                                disabled: eg.isSubmitting,
                                children: [(0, m.jsx)(sz.Z, {
                                    children: (0, m.jsx)(iB.Z, {
                                        variant: "regular",
                                        className: "text-text-primary-invert-dark",
                                        children: eu
                                    })
                                }), eg.isSubmitting ? (0, m.jsx)("div", {
                                    className: "spinner !absolute right-spacing-md top-1/2 -translate-y-[0.3rem]",
                                    children: (0, m.jsx)(sG.Z, {
                                        variant: "small"
                                    })
                                }) : null]
                            })
                        }), "" !== ed ? (0, m.jsx)("div", {
                            className: (0, iM.cn)(["status-message", "col-span-2 mt-spacing-xxs flex font-roboto text-small", {
                                "text-text-primary-dark": "error" !== eg.status,
                                "text-error": "error" === eg.status
                            }]),
                            children: (0, nb.ZP)(ed)
                        }) : null]
                    })
                }
        },
        774: function(e, t, n) {
            "use strict";
            var r = n(1527),
                i = n(6704),
                s = n.n(i),
                a = n(5026),
                o = n(9814),
                l = n(989);
            t.Z = e => {
                let {
                    className: t,
                    revealDelay: n = 0,
                    ...i
                } = e, {
                    menu: u
                } = (0, o.oR)();
                return (0, r.jsx)("ul", {
                    className: (0, l.cn)("flex space-x-spacing-xxs", t),
                    ...i,
                    children: null == u ? void 0 : u.legals_menu.menu.map((e, t) => {
                        let {
                            url: i,
                            target: o,
                            title: u
                        } = e;
                        return (0, r.jsx)("li", {
                            "data-motion-legal": !0,
                            children: (0, r.jsx)(s(), {
                                href: i,
                                target: o,
                                scroll: !1,
                                className: (0, l.cn)(["-my-2 flex overflow-hidden py-2 pointer:hover:opacity-50", "transition-opacity duration-300 ease-out-cubic", {
                                    "pointer-events-none": "#" === i
                                }]),
                                children: (0, r.jsx)("span", {
                                    className: "label inline-flex",
                                    style: n > 0 ? {
                                        transitionDelay: "".concat(300 + 30 * (n + t), "ms")
                                    } : void 0,
                                    children: (0, r.jsx)(a.Z, {
                                        variant: "small",
                                        children: u
                                    })
                                })
                            })
                        }, t)
                    })
                })
            }
        },
        6351: function(e, t, n) {
            "use strict";
            var r = n(1527),
                i = n(989);
            t.Z = e => {
                let {
                    className: t,
                    ...n
                } = e;
                return (0, r.jsx)("svg", {
                    width: "69",
                    height: "17",
                    viewBox: "0 0 69 17",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    className: (0, i.cn)(t),
                    ...n,
                    children: (0, r.jsx)("path", {
                        d: "M20.1841 0.935C20.1841 0.4182 19.7659 0 19.2491 0C18.7323 0 18.3141 0.4182 18.3141 0.935V15.9715C18.3141 16.4883 18.7323 16.9065 19.2491 16.9065C19.7659 16.9065 20.1841 16.4883 20.1841 15.9715V15.8223C20.9953 16.4625 22.0193 16.8453 23.1336 16.8453H27.4703C27.6072 16.8453 27.7333 16.8283 27.8603 16.8112L27.8604 16.8112L27.8605 16.8112C27.9086 16.8047 27.9568 16.7982 28.0058 16.7926C28.0629 16.784 28.1221 16.7809 28.1817 16.7777H28.1817C28.264 16.7733 28.3468 16.7688 28.4257 16.7501C29.0445 16.6243 29.6225 16.3727 30.1274 16.0361C30.2138 15.9799 30.2895 15.913 30.3654 15.8459C30.4179 15.7994 30.4706 15.7528 30.5269 15.7097C30.5515 15.6903 30.5762 15.6713 30.6006 15.6524C30.6809 15.5904 30.7596 15.5298 30.8312 15.4581C30.8414 15.4479 30.852 15.4347 30.8627 15.4216C30.8733 15.4084 30.8839 15.3952 30.8941 15.385C31.7135 14.5231 32.2286 13.3688 32.2286 12.087C32.2286 9.46221 30.0968 7.18931 27.4601 7.18931H23.1234C22.7987 7.18931 22.4723 7.22161 22.168 7.28451C21.6529 7.38991 21.1803 7.59901 20.74 7.85231C20.7 7.87447 20.6602 7.89483 20.6213 7.91478C20.5677 7.94226 20.5156 7.96896 20.4663 7.99851C20.43 8.02307 20.4004 8.05104 20.3718 8.07815C20.3509 8.09795 20.3305 8.11729 20.3082 8.13451C20.2663 8.16582 20.225 8.19795 20.1841 8.23088V0.935ZM4.7362 2.0621C3.2555 2.0621 2.0485 3.2691 2.0485 4.7498C2.0485 6.2305 3.2555 7.4375 4.7362 7.4375C5.304 7.4375 5.7545 7.8999 5.7545 8.4558C5.7545 9.0117 5.2921 9.4741 4.7362 9.4741C3.2555 9.4741 2.0485 10.6811 2.0485 12.1618C2.0485 13.6425 3.2555 14.8495 4.7362 14.8495H9.0729C10.5536 14.8495 11.7606 13.6425 11.7606 12.1618C11.7606 10.6811 10.5536 9.4741 9.0729 9.4741C8.5051 9.4741 8.0546 9.0117 8.0546 8.4558C8.0546 7.8999 8.517 7.4375 9.0729 7.4375C10.5536 7.4375 11.7606 6.2305 11.7606 4.7498C11.7606 3.2691 10.5536 2.0621 9.0729 2.0621H4.7362ZM4.7362 16.9116C2.1216 16.9116 0 14.79 0 12.1754C0 10.7474 0.6613 9.4027 1.8071 8.4898L1.8394 8.4694L1.8071 8.449C0.6613 7.5344 0 6.1897 0 4.7617C0 2.1471 2.1216 0.0152942 4.7362 0.0152942H9.0729C11.6875 0.0152942 13.8091 2.1471 13.8091 4.7515C13.8091 6.1795 13.1478 7.5242 12.002 8.4371L11.9697 8.4575L12.002 8.4779C13.1461 9.3908 13.8091 10.7355 13.8091 12.1635C13.8091 14.7781 11.6875 16.8997 9.0729 16.8997H4.7362V16.9099V16.9116ZM48.5214 14.926C48.28 14.8206 47.9961 14.8206 47.7547 14.926C47.6289 14.9787 47.5235 15.0416 47.4181 15.147C47.2396 15.3255 47.124 15.5873 47.124 15.861C47.124 16.1347 47.2294 16.3863 47.4181 16.5648C47.5235 16.66 47.617 16.7331 47.7547 16.7858C47.8703 16.8385 48.0063 16.8589 48.1321 16.8589C48.2579 16.8589 48.3956 16.8385 48.5095 16.7858C48.6353 16.7331 48.7407 16.66 48.8461 16.5648C49.0246 16.3863 49.1402 16.1245 49.1402 15.861C49.1402 15.5975 49.0246 15.3255 48.8461 15.147C48.7407 15.0416 48.6472 14.9787 48.5095 14.926H48.5197H48.5214ZM28.4784 14.5435H28.5107C28.7317 14.45 28.9204 14.3225 29.1091 14.1763C29.7279 13.6833 30.1376 12.937 30.1376 12.087C30.1376 10.6165 28.9408 9.28881 27.4703 9.28881H23.1336C22.9551 9.28881 22.7664 9.30921 22.5981 9.34151C22.4519 9.37211 22.304 9.42481 22.168 9.47751C22.1476 9.48771 22.1153 9.49791 22.0949 9.49791C21.9793 9.55061 21.8637 9.61351 21.7481 9.68661C21.7324 9.69653 21.7143 9.70444 21.6963 9.71229C21.6773 9.72059 21.6584 9.72883 21.6427 9.73931C21.6312 9.7446 21.623 9.7531 21.6148 9.76147C21.6073 9.76924 21.5998 9.7769 21.59 9.78181C20.9185 10.2646 20.4663 11.1826 20.4663 12.0751C20.4663 13.5456 21.6631 14.7424 23.1336 14.7424H27.4703C27.8273 14.7424 28.1639 14.6693 28.4784 14.5435ZM60.3092 14.5588H60.3398H60.3415C60.5625 14.4653 60.7512 14.3378 60.9399 14.1916C61.5587 13.6986 61.9684 12.9523 61.9684 12.1023C61.9684 10.6318 60.7716 9.3041 59.3011 9.3041H54.9644C54.7859 9.3041 54.5972 9.3245 54.4289 9.3568C54.2827 9.3874 54.1348 9.4401 53.9988 9.4928C53.9784 9.503 53.9461 9.5132 53.9257 9.5132C53.8101 9.5659 53.6945 9.6288 53.5789 9.7019C53.5628 9.7121 53.5445 9.72018 53.5262 9.72825C53.508 9.73633 53.4897 9.7444 53.4735 9.7546C53.4633 9.7597 53.4552 9.76778 53.4472 9.77585C53.4391 9.78393 53.431 9.792 53.4208 9.7971C52.7493 10.2799 52.2971 11.1979 52.2971 12.0904C52.2971 13.5609 53.4939 14.7577 54.9644 14.7577H59.3011C59.6581 14.7577 59.9947 14.6846 60.3092 14.5588ZM62.203 15.8595L62.2183 15.8459V15.9341C62.2183 16.4509 62.6365 16.8691 63.1533 16.8691C63.6701 16.8691 64.0883 16.4509 64.0883 15.9341V8.14811C64.0883 7.63131 63.6701 7.21311 63.1533 7.21311C62.6365 7.21311 62.2183 7.63131 62.2183 8.14811V8.25209C61.4118 7.59926 60.3988 7.2029 59.2977 7.2029H54.961C54.6363 7.2029 54.3099 7.2352 54.0056 7.2981C53.4905 7.4035 53.0179 7.6126 52.5776 7.8659C52.5376 7.88805 52.4979 7.9084 52.459 7.92833L52.4589 7.92837C52.4053 7.95585 52.3532 7.98255 52.3039 8.0121C52.2676 8.03666 52.238 8.06463 52.2094 8.09174C52.1885 8.11154 52.1681 8.13088 52.1458 8.1481C50.9796 9.0202 50.2027 10.5264 50.2027 12.0904C50.2027 14.7152 52.3345 16.8589 54.9712 16.8589H59.3079C59.4448 16.8589 59.5709 16.8419 59.698 16.8248L59.6982 16.8248C59.7462 16.8183 59.7945 16.8118 59.8434 16.8062C59.9005 16.7976 59.9597 16.7945 60.0193 16.7913H60.0193C60.1016 16.7869 60.1844 16.7824 60.2633 16.7637C60.8821 16.6379 61.4601 16.3863 61.965 16.0497C62.0514 15.9935 62.1271 15.9265 62.203 15.8595ZM66.8202 3.9049C67.0616 3.7995 67.3455 3.7995 67.5869 3.9049H67.5852H67.575C67.7127 3.9576 67.8062 4.0205 67.9116 4.1259C68.0901 4.3044 68.2057 4.5764 68.2057 4.8399C68.2057 5.1034 68.0901 5.3652 67.9116 5.5437C67.8062 5.6389 67.7008 5.712 67.575 5.7647C67.4594 5.8174 67.3234 5.8378 67.1976 5.8378C67.0718 5.8378 66.9358 5.8174 66.8202 5.7647C66.6825 5.712 66.589 5.6389 66.4836 5.5437C66.2949 5.3652 66.1895 5.1136 66.1895 4.8399C66.1895 4.5662 66.3051 4.3044 66.4836 4.1259C66.589 4.0205 66.6944 3.9576 66.8202 3.9049ZM68.1343 8.279C68.1343 7.7622 67.7161 7.344 67.1993 7.344C66.6825 7.344 66.2643 7.7622 66.2643 8.279V15.9341C66.2643 16.4509 66.6825 16.8691 67.1993 16.8691C67.7161 16.8691 68.1343 16.4509 68.1343 15.9341V8.279ZM34.8313 3.9049C35.0727 3.7995 35.3566 3.7995 35.598 3.9049H35.5963H35.5861C35.7238 3.9576 35.8173 4.0205 35.9227 4.1259C36.1012 4.3044 36.2168 4.5764 36.2168 4.8399C36.2168 5.1034 36.1012 5.3652 35.9227 5.5437C35.8173 5.6389 35.7119 5.712 35.5861 5.7647C35.4705 5.8174 35.3345 5.8378 35.2087 5.8378C35.0829 5.8378 34.9469 5.8174 34.8313 5.7647C34.6936 5.712 34.6001 5.6389 34.4947 5.5437C34.306 5.3652 34.2006 5.1136 34.2006 4.8399C34.2006 4.5662 34.3162 4.3044 34.4947 4.1259C34.6001 4.0205 34.7055 3.9576 34.8313 3.9049ZM36.1556 8.279C36.1556 7.7622 35.7374 7.344 35.2206 7.344C34.7038 7.344 34.2856 7.7622 34.2856 8.279V16.065C34.2856 16.5818 34.7038 17 35.2206 17C35.7374 17 36.1556 16.5818 36.1556 16.065V8.279ZM42.3929 9.35681V14.3361C42.3929 14.535 42.5612 14.7033 42.7601 14.7033H43.8515C44.3666 14.7033 44.7865 15.1249 44.7865 15.6383C44.7865 16.1517 44.3666 16.8334 43.8515 16.8334H42.1294C41.2471 16.8334 40.5229 15.8576 40.5229 14.9651V9.35681H39.4094C38.8943 9.35681 38.4744 8.9369 38.4744 8.42181C38.4744 7.9067 38.8943 7.3559 39.4094 7.3559H40.5229V4.8246C40.5229 4.3095 40.9428 3.8896 41.4579 3.8896C41.973 3.8896 42.3929 4.3095 42.3929 4.8246V7.3559H43.8532C44.3683 7.3559 44.7882 7.9067 44.7882 8.42181C44.7882 8.9369 44.3683 9.35681 43.8532 9.35681H42.3929Z",
                        fillRule: "evenodd",
                        clipRule: "evenodd",
                        fill: "currentColor"
                    })
                })
            }
        },
        7146: function(e, t, n) {
            "use strict";
            var r = n(1527);
            let i = (0, n(959).forwardRef)((e, t) => {
                let {
                    symbol: n,
                    ...i
                } = e;
                return (0, r.jsx)("svg", {
                    ref: t,
                    ...i,
                    children: (0, r.jsx)("use", {
                        xlinkHref: "#".concat(n)
                    })
                })
            });
            t.Z = i
        },
        2153: function(e, t, n) {
            "use strict";
            var r = n(1527),
                i = n(7146),
                s = n(9814),
                a = n(989);
            t.Z = e => {
                let {
                    className: t,
                    revealDelay: n = 0,
                    ...o
                } = e, {
                    menu: l
                } = (0, s.oR)();
                return (0, r.jsx)("ul", {
                    className: (0, a.cn)("flex items-center space-x-spacing-xxs", t),
                    ...o,
                    children: null == l ? void 0 : l.social_menu.menu.map((e, t) => {
                        let {
                            url: s,
                            target: o,
                            title: l,
                            classes: u
                        } = e;
                        return (0, r.jsx)("li", {
                            className: "flex",
                            "data-motion-social": !0,
                            children: (0, r.jsx)("a", {
                                href: s,
                                target: o,
                                className: (0, a.cn)(["-m-spacing-xxs flex overflow-hidden p-spacing-xxs", "pointer:hover:opacity-50", "transition-opacity duration-300 ease-out-cubic"]),
                                children: (0, r.jsxs)("span", {
                                    className: "icon inline-flex",
                                    style: n > 0 ? {
                                        transitionDelay: "".concat(300 + 30 * (n + t), "ms")
                                    } : void 0,
                                    children: [(0, r.jsx)("span", {
                                        className: "sr-only",
                                        children: l
                                    }), (0, r.jsx)(i.Z, {
                                        symbol: "".concat(u, "-icon"),
                                        className: "h-[1.6rem] w-[1.6rem] fill-text-primary-dark"
                                    })]
                                })
                            })
                        }, t)
                    })
                })
            }
        },
        6592: function(e, t, n) {
            "use strict";
            var r = n(1527),
                i = n(989);
            t.Z = e => {
                let {
                    className: t,
                    variant: n = "medium",
                    ...s
                } = e;
                return (0, r.jsx)("span", {
                    className: (0, i.cn)("block animate-rotate", {
                        "h-[1.6rem] w-[1.6rem]": "small" === n,
                        "h-[3.0rem] w-[3.0rem]": "medium" === n,
                        "h-[23.0rem] w-[23.0rem]": "large" === n
                    }, t),
                    ...s,
                    children: (0, r.jsx)("svg", {
                        viewBox: "25 25 50 50",
                        className: "animate-spin",
                        children: (0, r.jsx)("circle", {
                            cx: "50",
                            cy: "50",
                            r: "20",
                            fill: "none",
                            strokeWidth: "small" === n ? 4 : "medium" === n ? 3 : .2,
                            strokeMiterlimit: "10",
                            className: "stroke-current"
                        })
                    })
                })
            }
        },
        5026: function(e, t, n) {
            "use strict";
            n.d(t, {
                Z: function() {
                    return p
                }
            });
            var r = n(1527),
                i = n(959),
                s = n(9310),
                a = n(2808),
                o = n(8349);
            let l = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                    return e.replace(/<p[^>]*>/g, "").replace(/<\/p>/g, "")
                },
                u = e => e.replace(/(\r\n|\n\r|\r|\n)/g, "<br />");
            var c = n(989);
            let h = (0, a.j)("", {
                    variants: {
                        variant: {
                            h1: "font-helvetica text-s-h1 md:text-d-h1 -mt-[0.12em] -mb-[0.16em] md:-mt-[0.22em] md:-mb-[0.26em]",
                            h2: "font-helvetica text-s-h2 md:text-d-h2 -mt-[0.22em] -mb-[0.26em]",
                            h3: "font-helvetica text-s-h3 md:text-d-h3 -mt-[0.22em] -mb-[0.26em]",
                            h4: "font-helvetica text-s-h4 md:text-d-h4 -mt-[0.22em] -mb-[0.22em]",
                            h5: "font-helvetica text-s-h5 md:text-d-h5 -mt-[0.22em] -mb-[0.26em]",
                            h6: "font-helvetica text-s-h6 md:text-d-h6 -mt-[0.52em] -mb-[0.56em] md:-mt-[0.22em] md:-mb-[0.22em]",
                            large: "font-roboto text-large -my-[0.32em]",
                            regular: "font-roboto text-regular -my-[0.36em]",
                            small: "font-roboto text-small -my-[0.36em]",
                            caption: "font-roboto text-caption -my-[0.46em]",
                            overline: "font-roboto text-overline uppercase -my-[0.38em]"
                        }
                    },
                    defaultVariants: {
                        variant: "regular"
                    }
                }),
                d = (0, c.cn)(["[&_b]:font-medium", "[&_sup]:text-[0.6425em]", "[&_ul]:list-disc [&_ul]:pl-[1.45rem] [&_ul]:my-[2rem]", "[&_a]:underline [&_a:hover]:text-text-accent-light [&_a]:transition-colors [&_a]:duration-300 [&_a]:ease-out-cubic"]),
                f = {
                    replace: e => {
                        if ("tag" === e.type && ["i", "b", "strong"].includes(e.name)) {
                            let t = e.name;
                            return (0, r.jsx)(r.Fragment, {
                                children: e.children.map((e, n) => "text" === e.type ? e.data.split(" ").map((i, s) => (0, r.jsxs)(t, {
                                    children: [i, s < e.data.split(" ").length - 1 ? " " : ""]
                                }, "".concat(n, "-").concat(s))) : (0, o.du)(e, f))
                            })
                        }
                    }
                };
            var p = (0, i.forwardRef)((e, t) => {
                let {
                    variant: n,
                    className: i,
                    children: a,
                    component: p = !1,
                    paragraph: g = !1,
                    asChild: A = !1,
                    ...m
                } = e, v = A ? s.g7 : p || (g ? "p" : "span");
                return (0, r.jsx)(v, {
                    className: (0, c.cn)(h({
                        variant: n,
                        className: i
                    }), d),
                    ref: t,
                    ...m,
                    children: (0, o.ZP)(a ? l(u(a)) : "", f)
                })
            })
        },
        6947: function(e, t, n) {
            "use strict";
            var r = n(1527),
                i = n(959),
                s = n(989);
            let a = (0, i.forwardRef)((e, t) => {
                var n;
                let {
                    className: i,
                    children: a,
                    ...o
                } = e;
                return (0, r.jsx)("span", {
                    ref: t,
                    "data-label": null == a ? void 0 : null === (n = a.props) || void 0 === n ? void 0 : n.children,
                    className: (0, s.cn)("relative inline-flex overflow-hidden", "after:font-roboto after:text-regular after:content-[attr(data-label)]", "after:absolute after:left-0 after:top-0 after:h-full after:w-full after:translate-y-[87%]", "after:transition-transform after:duration-300 after:ease-out-cubic", "[&>span]:my-0 [&>span]:inline-flex [&>span]:grow", "[&>span]:transition-transform [&>span]:duration-300 [&>span]:ease-out-cubic", "group-hover:after:translate-y-0 [&>span]:group-hover:-translate-y-[87%]", i),
                    ...o,
                    children: a
                })
            });
            t.Z = a
        },
        8020: function(e, t, n) {
            "use strict";
            n.d(t, {
                CT: function() {
                    return r
                },
                Fn: function() {
                    return l
                },
                GW: function() {
                    return a
                },
                I6: function() {
                    return i
                },
                bl: function() {
                    return u
                },
                lL: function() {
                    return c
                },
                o7: function() {
                    return o
                },
                q2: function() {
                    return s
                }
            });
            let r = "https://eightbitai.wpenginepowered.com",
                i = "https://8bit.ai";
            JSON.parse("[]");
            let s = !1,
                a = "",
                o = "https://www.gstatic.com/draco/v1/decoders/",
                l = {
                    GF_CONSUMER_KEY: "ck_5a4f579b7a061aa48c238e59ae0d6ab9d6410d20",
                    GF_CONSUMER_SECRET: "cs_ed2675157114d0cee5779b79a083629a13704cfe"
                },
                u = {
                    BASE: "/wp-json/wp/v2",
                    ROUTES: "/wp-json/gusto/routes",
                    STRINGS: "/wp-json/gusto/options",
                    MENU_LOCATIONS: "/wp-json/gusto/nav/menu-locations",
                    GRAVITY_FORM: "/wp-json/gf/v2/forms"
                },
                c = {
                    MD: 768,
                    LG: 1024,
                    XL: 1280
                }
        },
        410: function(e, t, n) {
            "use strict";
            n.d(t, {
                UU: function() {
                    return L
                },
                Sh: function() {
                    return P
                },
                v4: function() {
                    return B
                }
            });
            var r = n(1527),
                i = n(959),
                s = n(1519),
                a = n(4970),
                o = n(7489),
                l = n.n(o),
                u = n(9892),
                c = n(4576),
                h = n(217),
                d = n(6912),
                f = n(4937),
                p = n(8020),
                g = n(2378),
                A = n(7835),
                m = n.n(A),
                v = n(6636),
                y = n(5026),
                x = n(9814),
                E = n(989);
            let _ = (0, i.forwardRef)((e, t) => {
                let {
                    state: n,
                    ...s
                } = e, {
                    strings: o
                } = (0, x.oR)(), l = (0, i.useRef)(null), u = (0, v.Z)(l, t);
                return (0, i.useEffect)(() => {
                    let e = a.ZP.quickTo(l.current, "x", {
                            duration: .6,
                            ease: "power3.out"
                        }),
                        t = a.ZP.quickTo(l.current, "y", {
                            duration: .6,
                            ease: "power3.out"
                        }),
                        n = n => {
                            let r = n.clientX - .5 * window.innerWidth,
                                i = n.clientY - .5 * window.innerHeight;
                            e(r), t(i)
                        };
                    return window.addEventListener("pointermove", n), () => {
                        window.removeEventListener("pointermove", n)
                    }
                }, []), (0, r.jsx)("button", {
                    ref: u,
                    className: (0, E.cn)("z-audio pointer-events-none fixed left-1/2 top-1/2", "transition-opacity duration-300 ease-out-cubic", {
                        "opacity-0 duration-0": "entering" === n,
                        "opacity-100": "entered" === n,
                        "opacity-0": "exiting" === n
                    }),
                    ...s,
                    children: (0, r.jsx)("span", {
                        className: (0, E.cn)("absolute left-0 top-0 flex -translate-x-1/2 -translate-y-1/2 px-[2rem] py-[1.4rem]", "rounded-full bg-white-light/10 backdrop-blur-sm"),
                        children: (0, r.jsx)(y.Z, {
                            variant: "caption",
                            className: "whitespace-nowrap uppercase",
                            children: null == o ? void 0 : o.sound
                        })
                    })
                })
            });
            var b = () => {
                    let e = (0, d.U2)(e => e.compiled),
                        t = (0, h.E)(e => e.needsAudioTrigger),
                        n = (0, h.E)(e => e.setState),
                        s = (0, i.useRef)(null),
                        a = (0, i.useRef)(!1);
                    return (0, i.useEffect)(() => {
                        if (!e || m().isTouch > 0) return;
                        let t = () => {
                            a.current || (a.current = !0, n({
                                needsAudioTrigger: !0
                            }))
                        };
                        return window.addEventListener("pointermove", t), () => {
                            window.removeEventListener("pointermove", t)
                        }
                    }, [e, n]), (0, r.jsx)(g.ZP, {
                        nodeRef: s,
                        in: t,
                        timeout: {
                            enter: 0,
                            exit: 500
                        },
                        unmountOnExit: !0,
                        children: e => (0, r.jsx)(_, {
                            ref: s,
                            state: e
                        })
                    })
                },
                w = n(7929),
                C = n.n(w),
                S = n(9749),
                I = n(2125),
                M = n(4753);
            let T = {
                    muted: !0,
                    played: !1,
                    progress: !1,
                    detune: 0
                },
                B = (0, S.Ue)((0, I.XR)((0, M.n)(e => ({ ...T,
                    setState: t => e(e => C()(e, t))
                })))),
                R = (0, i.createContext)(void 0),
                D = [{
                    name: "ambient",
                    src: "".concat(p.GW, "/sounds/music.mp3")
                }, {
                    name: "fx",
                    src: "".concat(p.GW, "/sounds/fx.mp3")
                }];
            var L = e => {
                let {
                    children: t
                } = e, [n] = (0, i.useState)(() => new u.AudioLoader), [o] = (0, i.useState)(() => new Map), p = (0, h.E)(e => e.setState), g = (0, c.d9)(), A = (0, i.useCallback)(() => {
                    let e = new u.AudioListener;
                    l()(D, t => {
                        n.load(t.src, n => {
                            let r = new u.Audio(e),
                                i = t.name;
                            r.setVolume(1), r.setBuffer(n), r.setLoop("ambient" === i), r.userData = {
                                volume: 1
                            }, o.set(i, r)
                        })
                    })
                }, [n, o]), m = (0, i.useCallback)(function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    o.forEach(t => {
                        e ? (t.userData.volume = 0, t.setVolume(0), t.stop()) : a.ZP.to(t.userData, {
                            volume: 0,
                            duration: .8,
                            ease: "none",
                            onUpdate: () => {
                                t.setVolume(t.userData.volume)
                            }
                        })
                    })
                }, [o]), v = (0, i.useCallback)(function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    o.forEach(t => {
                        e ? (t.userData.volume = 1, t.setVolume(1), t.play()) : a.ZP.to(t.userData, {
                            volume: 1,
                            duration: .8,
                            ease: "none",
                            onUpdate: () => {
                                t.setVolume(t.userData.volume)
                            }
                        })
                    })
                }, [o]), y = (0, i.useCallback)((e, t) => {
                    let n = o.get(e),
                        r = 1 - Math.abs(-1 + 2 * t);
                    null == n || n.setDetune(-1200 * r)
                }, [o]), x = (0, i.useCallback)(function(e) {
                    let t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1],
                        n = o.get(e);
                    if (n) return t && n.stop(), n.play()
                }, [o]), E = (0, i.useCallback)(() => {
                    document.removeEventListener("click", E), p({
                        needsAudioTrigger: !1
                    });
                    let e = B.getState();
                    if (e.muted ? v() : m(), e.setState({
                            muted: !e.muted,
                            played: !0
                        }), !e.played) {
                        let e = o.get("ambient");
                        null == e || e.play()
                    }
                }, [o, m, v]), _ = (0, i.useCallback)(() => {
                    document.addEventListener("click", E)
                }, [E]), w = (0, i.useCallback)(() => {
                    document.removeEventListener("click", E)
                }, [E]);
                (0, s.Z)(() => {
                    let e = B.getState();
                    g ? m(!0) : e.muted || v(!0)
                }, [g, m, v]), (0, s.Z)(() => {
                    let e = B.subscribe(e => e.progress, e => e && x("fx"));
                    return () => {
                        e()
                    }
                }, []), (0, s.Z)(() => {
                    let e = B.subscribe(e => e.detune, e => y("ambient", e));
                    return () => {
                        e()
                    }
                }, []), (0, s.Z)(() => {
                    let e = d.U2.subscribe(e => e.compiled, t => {
                        (0, f.G)() && t && (e(), _(), A())
                    });
                    return () => {
                        w(), e()
                    }
                }, [A]);
                let C = (0, i.useMemo)(() => ({
                    detune: y,
                    toggleSound: E
                }), [y, E]);
                return (0, r.jsxs)(R.Provider, {
                    value: C,
                    children: [t, (0, r.jsx)(b, {})]
                })
            };
            let P = () => {
                let e = (0, i.useContext)(R);
                if (void 0 === e) throw Error("useMixer must be used within a MixerProvider");
                return e
            }
        },
        9814: function(e, t, n) {
            "use strict";
            n.d(t, {
                g3: function() {
                    return u
                },
                oR: function() {
                    return h
                }
            });
            var r = n(1527),
                i = n(959),
                s = n(9795),
                a = n(2125);
            let o = (0, i.createContext)(void 0),
                l = e => (0, s.M)((0, a.mW)(() => ({ ...e
                })));
            var u = e => {
                    let {
                        children: t,
                        ...n
                    } = e, s = (0, i.useRef)(void 0);
                    return s.current || (s.current = l(n)), (0, r.jsx)(o.Provider, {
                        value: s.current,
                        children: t
                    })
                },
                c = n(9749);
            let h = e => {
                let t = (0, i.useContext)(o);
                if (!t) throw Error("useStore must be used within a StoreProvider");
                return (0, c.oR)(t, e)
            }
        },
        5950: function(e, t, n) {
            "use strict";
            n.d(t, {
                f: function() {
                    return g
                },
                F: function() {
                    return A
                }
            });
            var r = n(1527),
                i = n(959),
                s = n(5429),
                a = n.n(s),
                o = n(2710),
                l = n.n(o),
                u = n(6630),
                c = n.n(u),
                h = n(1519),
                d = n(3759),
                f = e => {
                    let {
                        fluid: t = !0
                    } = e, n = (0, i.useRef)(0), s = (0, i.useCallback)(() => {
                        let e = window.innerWidth,
                            t = window.innerHeight;
                        n.current !== e && (n.current = e, document.documentElement.style.setProperty("--vh", "".concat(.01 * t, "px")))
                    }, []);
                    return (0, h.Z)(() => s(), [s]), (0, d.Z)("resize", s), (0, r.jsx)(c(), {
                        id: "d25e33c455f3aed6",
                        dynamic: [l().style.fontFamily, a().style.fontFamily, t ? "clamp(10px, ".concat(10 / 1440 * 100, "vw, 11.5px)") : "10px"],
                        children: ":root{--font-family-helvetica:".concat(l().style.fontFamily, ";--font-family-roboto:").concat(a().style.fontFamily, ";--font-size:").concat(t ? "clamp(10px, ".concat(10 / 1440 * 100, "vw, 11.5px)") : "10px", "}")
                    })
                };
            let p = (0, i.createContext)(void 0);
            var g = e => {
                let {
                    children: t,
                    fluid: n = !1
                } = e, s = (0, i.useMemo)(() => ({
                    fluid: n
                }), [n]);
                return (0, r.jsxs)(p.Provider, {
                    value: s,
                    children: [(0, r.jsx)(f, {
                        fluid: n
                    }), t]
                })
            };
            let A = () => {
                let e = (0, i.useContext)(p);
                if (void 0 === e) throw Error("useTheme must be used within a ThemeProvider");
                return e
            }
        },
        4485: function(e, t, n) {
            "use strict";
            n.d(t, {
                Gt: function() {
                    return c
                },
                ws: function() {
                    return h
                },
                mU: function() {
                    return l
                }
            });
            var r = n(1527),
                i = n(959),
                s = n(1519),
                a = n(4970),
                o = n(6912);
            let l = () => {
                    let e = (0, i.useContext)(u);
                    if (void 0 === e) throw Error("useTimeline must be used within a TimelineProvider");
                    return e
                },
                u = (0, i.createContext)(void 0),
                c = () => {
                    let e = l(),
                        t = (0, o.U2)(e => e.complete);
                    return (0, s.Z)(() => {
                        let n = o.U2.subscribe(e => e.compiled, async r => {
                            r && (n(), await e.play(), t())
                        });
                        return () => {
                            n()
                        }
                    }, []), null
                };
            var h = e => {
                let {
                    children: t
                } = e, [n] = (0, i.useState)(() => a.ZP.timeline({
                    paused: !0
                })), s = (0, i.useMemo)(() => n, [n]);
                return (0, r.jsx)(u.Provider, {
                    value: s,
                    children: t
                })
            }
        },
        4576: function(e, t, n) {
            "use strict";
            n.d(t, {
                VD: function() {
                    return a
                },
                d9: function() {
                    return l
                },
                sI: function() {
                    return d
                }
            });
            var r = n(959),
                i = n(4358),
                s = n(4543),
                a = () => {
                    let e = (0, i.useRouter)(),
                        t = (0, s.U)(e => e.setCurrentRoute);
                    (0, r.useEffect)(() => {
                        t(e.asPath)
                    }, [e.asPath, e.locale, t])
                };
            let o = () => {
                let e = window.document;
                return {
                    hidden: void 0 !== e.hidden ? "hidden" : void 0 !== e.msHidden ? "msHidden" : "webkitHidden",
                    visibilityChange: void 0 !== e.hidden ? "visibilitychange" : void 0 !== e.msHidden ? "msvisibilitychange" : "webkitvisibilitychange"
                }
            };
            var l = () => {
                    let [e, t] = (0, r.useState)(!1);
                    return (0, r.useEffect)(() => {
                        let {
                            hidden: e,
                            visibilityChange: n
                        } = o();

                        function r() {
                            t(document[e])
                        }
                        return document.addEventListener(n, r), () => {
                            document.removeEventListener(n, r)
                        }
                    }, []), e
                },
                u = n(3771),
                c = n(9892),
                h = n(217);

            function d() {
                let e = (0, r.useMemo)(() => new c.Vector2, []),
                    t = (0, r.useMemo)(() => new c.Vector2, []),
                    n = (0, r.useMemo)(() => new c.Vector2, []),
                    i = (0, r.useMemo)(() => new c.Vector2, []),
                    s = (0, r.useMemo)(() => new c.Vector2, []),
                    a = (0, r.useMemo)(() => new c.Vector2, []),
                    o = (0, r.useMemo)(() => new c.Vector2, []),
                    l = (0, r.useRef)(!1),
                    d = e => {
                        let t = e.clientX,
                            r = e.clientY;
                        n.set(t, r), i.set(t / window.innerWidth, 1 - r / window.innerHeight), s.copy(i).multiplyScalar(2).subScalar(1)
                    },
                    f = () => {
                        e.copy(n).sub(a), t.copy(i).sub(o)
                    },
                    p = () => {
                        a.copy(n), o.copy(i)
                    },
                    g = () => {
                        if (!l.current) return;
                        let t = h.E.getState();
                        if (!t.scrollDirLocked) {
                            let n = Math.abs(e.x),
                                r = Math.abs(e.y);
                            n > r ? t.setState({
                                scrollDirLocked: "x"
                            }) : r > n ? t.setState({
                                scrollDirLocked: "y"
                            }) : t.setState({
                                scrollDirLocked: null
                            })
                        }
                    };
                return (0, u.useGesture)({
                    onPointerDown: e => {
                        let {
                            event: t
                        } = e;
                        l.current = !0, d(t), p(), f()
                    },
                    onPointerMove: e => {
                        let {
                            event: t
                        } = e;
                        d(t), f(), p(), g()
                    },
                    onPointerUp: e => {
                        let {
                            event: t
                        } = e;
                        d(t), f(), p(), l.current = !1, h.E.getState().setState({
                            scrollDirLocked: null
                        })
                    }
                }, {
                    target: document.body,
                    eventOptions: {
                        passive: !1
                    }
                }), {
                    delta11: t,
                    touching: l
                }
            }
        },
        989: function(e, t, n) {
            "use strict";
            n.d(t, {
                cn: function() {
                    return en
                }
            });
            let r = e => {
                    let t = o(e),
                        {
                            conflictingClassGroups: n,
                            conflictingClassGroupModifiers: r
                        } = e;
                    return {
                        getClassGroupId: e => {
                            let n = e.split("-");
                            return "" === n[0] && 1 !== n.length && n.shift(), i(n, t) || a(e)
                        },
                        getConflictingClassGroupIds: (e, t) => {
                            let i = n[e] || [];
                            return t && r[e] ? [...i, ...r[e]] : i
                        }
                    }
                },
                i = (e, t) => {
                    if (0 === e.length) return t.classGroupId;
                    let n = e[0],
                        r = t.nextPart.get(n),
                        s = r ? i(e.slice(1), r) : void 0;
                    if (s) return s;
                    if (0 === t.validators.length) return;
                    let a = e.join("-");
                    return t.validators.find(({
                        validator: e
                    }) => e(a)) ? .classGroupId
                },
                s = /^\[(.+)\]$/,
                a = e => {
                    if (s.test(e)) {
                        let t = s.exec(e)[1],
                            n = t ? .substring(0, t.indexOf(":"));
                        if (n) return "arbitrary.." + n
                    }
                },
                o = e => {
                    let {
                        theme: t,
                        prefix: n
                    } = e, r = {
                        nextPart: new Map,
                        validators: []
                    };
                    return h(Object.entries(e.classGroups), n).forEach(([e, n]) => {
                        l(n, r, e, t)
                    }), r
                },
                l = (e, t, n, r) => {
                    e.forEach(e => {
                        if ("string" == typeof e) {
                            ("" === e ? t : u(t, e)).classGroupId = n;
                            return
                        }
                        if ("function" == typeof e) {
                            if (c(e)) {
                                l(e(r), t, n, r);
                                return
                            }
                            t.validators.push({
                                validator: e,
                                classGroupId: n
                            });
                            return
                        }
                        Object.entries(e).forEach(([e, i]) => {
                            l(i, u(t, e), n, r)
                        })
                    })
                },
                u = (e, t) => {
                    let n = e;
                    return t.split("-").forEach(e => {
                        n.nextPart.has(e) || n.nextPart.set(e, {
                            nextPart: new Map,
                            validators: []
                        }), n = n.nextPart.get(e)
                    }), n
                },
                c = e => e.isThemeGetter,
                h = (e, t) => t ? e.map(([e, n]) => [e, n.map(e => "string" == typeof e ? t + e : "object" == typeof e ? Object.fromEntries(Object.entries(e).map(([e, n]) => [t + e, n])) : e)]) : e,
                d = e => {
                    if (e < 1) return {
                        get: () => void 0,
                        set: () => {}
                    };
                    let t = 0,
                        n = new Map,
                        r = new Map,
                        i = (i, s) => {
                            n.set(i, s), ++t > e && (t = 0, r = n, n = new Map)
                        };
                    return {
                        get(e) {
                            let t = n.get(e);
                            return void 0 !== t ? t : void 0 !== (t = r.get(e)) ? (i(e, t), t) : void 0
                        },
                        set(e, t) {
                            n.has(e) ? n.set(e, t) : i(e, t)
                        }
                    }
                },
                f = e => {
                    let {
                        separator: t,
                        experimentalParseClassName: n
                    } = e, r = 1 === t.length, i = t[0], s = t.length, a = e => {
                        let n;
                        let a = [],
                            o = 0,
                            l = 0;
                        for (let u = 0; u < e.length; u++) {
                            let c = e[u];
                            if (0 === o) {
                                if (c === i && (r || e.slice(u, u + s) === t)) {
                                    a.push(e.slice(l, u)), l = u + s;
                                    continue
                                }
                                if ("/" === c) {
                                    n = u;
                                    continue
                                }
                            }
                            "[" === c ? o++ : "]" === c && o--
                        }
                        let u = 0 === a.length ? e : e.substring(l),
                            c = u.startsWith("!"),
                            h = c ? u.substring(1) : u;
                        return {
                            modifiers: a,
                            hasImportantModifier: c,
                            baseClassName: h,
                            maybePostfixModifierPosition: n && n > l ? n - l : void 0
                        }
                    };
                    return n ? e => n({
                        className: e,
                        parseClassName: a
                    }) : a
                },
                p = e => {
                    if (e.length <= 1) return e;
                    let t = [],
                        n = [];
                    return e.forEach(e => {
                        "[" === e[0] ? (t.push(...n.sort(), e), n = []) : n.push(e)
                    }), t.push(...n.sort()), t
                },
                g = e => ({
                    cache: d(e.cacheSize),
                    parseClassName: f(e),
                    ...r(e)
                }),
                A = /\s+/,
                m = (e, t) => {
                    let {
                        parseClassName: n,
                        getClassGroupId: r,
                        getConflictingClassGroupIds: i
                    } = t, s = [], a = e.trim().split(A), o = "";
                    for (let e = a.length - 1; e >= 0; e -= 1) {
                        let t = a[e],
                            {
                                modifiers: l,
                                hasImportantModifier: u,
                                baseClassName: c,
                                maybePostfixModifierPosition: h
                            } = n(t),
                            d = !!h,
                            f = r(d ? c.substring(0, h) : c);
                        if (!f) {
                            if (!d || !(f = r(c))) {
                                o = t + (o.length > 0 ? " " + o : o);
                                continue
                            }
                            d = !1
                        }
                        let g = p(l).join(":"),
                            A = u ? g + "!" : g,
                            m = A + f;
                        if (s.includes(m)) continue;
                        s.push(m);
                        let v = i(f, d);
                        for (let e = 0; e < v.length; ++e) {
                            let t = v[e];
                            s.push(A + t)
                        }
                        o = t + (o.length > 0 ? " " + o : o)
                    }
                    return o
                };

            function v() {
                let e, t, n = 0,
                    r = "";
                for (; n < arguments.length;)(e = arguments[n++]) && (t = y(e)) && (r && (r += " "), r += t);
                return r
            }
            let y = e => {
                let t;
                if ("string" == typeof e) return e;
                let n = "";
                for (let r = 0; r < e.length; r++) e[r] && (t = y(e[r])) && (n && (n += " "), n += t);
                return n
            };

            function x(e, ...t) {
                let n, r, i;
                let s = function(o) {
                    return r = (n = g(t.reduce((e, t) => t(e), e()))).cache.get, i = n.cache.set, s = a, a(o)
                };

                function a(e) {
                    let t = r(e);
                    if (t) return t;
                    let s = m(e, n);
                    return i(e, s), s
                }
                return function() {
                    return s(v.apply(null, arguments))
                }
            }
            let E = e => {
                    let t = t => t[e] || [];
                    return t.isThemeGetter = !0, t
                },
                _ = /^\[(?:([a-z-]+):)?(.+)\]$/i,
                b = /^\d+\/\d+$/,
                w = new Set(["px", "full", "screen"]),
                C = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
                S = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
                I = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
                M = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
                T = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
                B = e => D(e) || w.has(e) || b.test(e),
                R = e => j(e, "length", W),
                D = e => !!e && !Number.isNaN(Number(e)),
                L = e => j(e, "number", D),
                P = e => !!e && Number.isInteger(Number(e)),
                O = e => e.endsWith("%") && D(e.slice(0, -1)),
                N = e => _.test(e),
                U = e => C.test(e),
                F = new Set(["length", "size", "percentage"]),
                k = e => j(e, F, Y),
                Q = e => j(e, "position", Y),
                G = new Set(["image", "url"]),
                z = e => j(e, G, q),
                H = e => j(e, "", X),
                V = () => !0,
                j = (e, t, n) => {
                    let r = _.exec(e);
                    return !!r && (r[1] ? "string" == typeof t ? r[1] === t : t.has(r[1]) : n(r[2]))
                },
                W = e => S.test(e) && !I.test(e),
                Y = () => !1,
                X = e => M.test(e),
                q = e => T.test(e),
                K = () => {
                    let e = E("colors"),
                        t = E("spacing"),
                        n = E("blur"),
                        r = E("brightness"),
                        i = E("borderColor"),
                        s = E("borderRadius"),
                        a = E("borderSpacing"),
                        o = E("borderWidth"),
                        l = E("contrast"),
                        u = E("grayscale"),
                        c = E("hueRotate"),
                        h = E("invert"),
                        d = E("gap"),
                        f = E("gradientColorStops"),
                        p = E("gradientColorStopPositions"),
                        g = E("inset"),
                        A = E("margin"),
                        m = E("opacity"),
                        v = E("padding"),
                        y = E("saturate"),
                        x = E("scale"),
                        _ = E("sepia"),
                        b = E("skew"),
                        w = E("space"),
                        C = E("translate"),
                        S = () => ["auto", "contain", "none"],
                        I = () => ["auto", "hidden", "clip", "visible", "scroll"],
                        M = () => ["auto", N, t],
                        T = () => [N, t],
                        F = () => ["", B, R],
                        G = () => ["auto", D, N],
                        j = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"],
                        W = () => ["solid", "dashed", "dotted", "double", "none"],
                        Y = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"],
                        X = () => ["start", "end", "center", "between", "around", "evenly", "stretch"],
                        q = () => ["", "0", N],
                        K = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"],
                        J = () => [D, N];
                    return {
                        cacheSize: 500,
                        separator: ":",
                        theme: {
                            colors: [V],
                            spacing: [B, R],
                            blur: ["none", "", U, N],
                            brightness: J(),
                            borderColor: [e],
                            borderRadius: ["none", "", "full", U, N],
                            borderSpacing: T(),
                            borderWidth: F(),
                            contrast: J(),
                            grayscale: q(),
                            hueRotate: J(),
                            invert: q(),
                            gap: T(),
                            gradientColorStops: [e],
                            gradientColorStopPositions: [O, R],
                            inset: M(),
                            margin: M(),
                            opacity: J(),
                            padding: T(),
                            saturate: J(),
                            scale: J(),
                            sepia: q(),
                            skew: J(),
                            space: T(),
                            translate: T()
                        },
                        classGroups: {
                            aspect: [{
                                aspect: ["auto", "square", "video", N]
                            }],
                            container: ["container"],
                            columns: [{
                                columns: [U]
                            }],
                            "break-after": [{
                                "break-after": K()
                            }],
                            "break-before": [{
                                "break-before": K()
                            }],
                            "break-inside": [{
                                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
                            }],
                            "box-decoration": [{
                                "box-decoration": ["slice", "clone"]
                            }],
                            box: [{
                                box: ["border", "content"]
                            }],
                            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
                            float: [{
                                float: ["right", "left", "none", "start", "end"]
                            }],
                            clear: [{
                                clear: ["left", "right", "both", "none", "start", "end"]
                            }],
                            isolation: ["isolate", "isolation-auto"],
                            "object-fit": [{
                                object: ["contain", "cover", "fill", "none", "scale-down"]
                            }],
                            "object-position": [{
                                object: [...j(), N]
                            }],
                            overflow: [{
                                overflow: I()
                            }],
                            "overflow-x": [{
                                "overflow-x": I()
                            }],
                            "overflow-y": [{
                                "overflow-y": I()
                            }],
                            overscroll: [{
                                overscroll: S()
                            }],
                            "overscroll-x": [{
                                "overscroll-x": S()
                            }],
                            "overscroll-y": [{
                                "overscroll-y": S()
                            }],
                            position: ["static", "fixed", "absolute", "relative", "sticky"],
                            inset: [{
                                inset: [g]
                            }],
                            "inset-x": [{
                                "inset-x": [g]
                            }],
                            "inset-y": [{
                                "inset-y": [g]
                            }],
                            start: [{
                                start: [g]
                            }],
                            end: [{
                                end: [g]
                            }],
                            top: [{
                                top: [g]
                            }],
                            right: [{
                                right: [g]
                            }],
                            bottom: [{
                                bottom: [g]
                            }],
                            left: [{
                                left: [g]
                            }],
                            visibility: ["visible", "invisible", "collapse"],
                            z: [{
                                z: ["auto", P, N]
                            }],
                            basis: [{
                                basis: M()
                            }],
                            "flex-direction": [{
                                flex: ["row", "row-reverse", "col", "col-reverse"]
                            }],
                            "flex-wrap": [{
                                flex: ["wrap", "wrap-reverse", "nowrap"]
                            }],
                            flex: [{
                                flex: ["1", "auto", "initial", "none", N]
                            }],
                            grow: [{
                                grow: q()
                            }],
                            shrink: [{
                                shrink: q()
                            }],
                            order: [{
                                order: ["first", "last", "none", P, N]
                            }],
                            "grid-cols": [{
                                "grid-cols": [V]
                            }],
                            "col-start-end": [{
                                col: ["auto", {
                                    span: ["full", P, N]
                                }, N]
                            }],
                            "col-start": [{
                                "col-start": G()
                            }],
                            "col-end": [{
                                "col-end": G()
                            }],
                            "grid-rows": [{
                                "grid-rows": [V]
                            }],
                            "row-start-end": [{
                                row: ["auto", {
                                    span: [P, N]
                                }, N]
                            }],
                            "row-start": [{
                                "row-start": G()
                            }],
                            "row-end": [{
                                "row-end": G()
                            }],
                            "grid-flow": [{
                                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
                            }],
                            "auto-cols": [{
                                "auto-cols": ["auto", "min", "max", "fr", N]
                            }],
                            "auto-rows": [{
                                "auto-rows": ["auto", "min", "max", "fr", N]
                            }],
                            gap: [{
                                gap: [d]
                            }],
                            "gap-x": [{
                                "gap-x": [d]
                            }],
                            "gap-y": [{
                                "gap-y": [d]
                            }],
                            "justify-content": [{
                                justify: ["normal", ...X()]
                            }],
                            "justify-items": [{
                                "justify-items": ["start", "end", "center", "stretch"]
                            }],
                            "justify-self": [{
                                "justify-self": ["auto", "start", "end", "center", "stretch"]
                            }],
                            "align-content": [{
                                content: ["normal", ...X(), "baseline"]
                            }],
                            "align-items": [{
                                items: ["start", "end", "center", "baseline", "stretch"]
                            }],
                            "align-self": [{
                                self: ["auto", "start", "end", "center", "stretch", "baseline"]
                            }],
                            "place-content": [{
                                "place-content": [...X(), "baseline"]
                            }],
                            "place-items": [{
                                "place-items": ["start", "end", "center", "baseline", "stretch"]
                            }],
                            "place-self": [{
                                "place-self": ["auto", "start", "end", "center", "stretch"]
                            }],
                            p: [{
                                p: [v]
                            }],
                            px: [{
                                px: [v]
                            }],
                            py: [{
                                py: [v]
                            }],
                            ps: [{
                                ps: [v]
                            }],
                            pe: [{
                                pe: [v]
                            }],
                            pt: [{
                                pt: [v]
                            }],
                            pr: [{
                                pr: [v]
                            }],
                            pb: [{
                                pb: [v]
                            }],
                            pl: [{
                                pl: [v]
                            }],
                            m: [{
                                m: [A]
                            }],
                            mx: [{
                                mx: [A]
                            }],
                            my: [{
                                my: [A]
                            }],
                            ms: [{
                                ms: [A]
                            }],
                            me: [{
                                me: [A]
                            }],
                            mt: [{
                                mt: [A]
                            }],
                            mr: [{
                                mr: [A]
                            }],
                            mb: [{
                                mb: [A]
                            }],
                            ml: [{
                                ml: [A]
                            }],
                            "space-x": [{
                                "space-x": [w]
                            }],
                            "space-x-reverse": ["space-x-reverse"],
                            "space-y": [{
                                "space-y": [w]
                            }],
                            "space-y-reverse": ["space-y-reverse"],
                            w: [{
                                w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", N, t]
                            }],
                            "min-w": [{
                                "min-w": [N, t, "min", "max", "fit"]
                            }],
                            "max-w": [{
                                "max-w": [N, t, "none", "full", "min", "max", "fit", "prose", {
                                    screen: [U]
                                }, U]
                            }],
                            h: [{
                                h: [N, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
                            }],
                            "min-h": [{
                                "min-h": [N, t, "min", "max", "fit", "svh", "lvh", "dvh"]
                            }],
                            "max-h": [{
                                "max-h": [N, t, "min", "max", "fit", "svh", "lvh", "dvh"]
                            }],
                            size: [{
                                size: [N, t, "auto", "min", "max", "fit"]
                            }],
                            "font-size": [{
                                text: ["base", U, R]
                            }],
                            "font-smoothing": ["antialiased", "subpixel-antialiased"],
                            "font-style": ["italic", "not-italic"],
                            "font-weight": [{
                                font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", L]
                            }],
                            "font-family": [{
                                font: [V]
                            }],
                            "fvn-normal": ["normal-nums"],
                            "fvn-ordinal": ["ordinal"],
                            "fvn-slashed-zero": ["slashed-zero"],
                            "fvn-figure": ["lining-nums", "oldstyle-nums"],
                            "fvn-spacing": ["proportional-nums", "tabular-nums"],
                            "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
                            tracking: [{
                                tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", N]
                            }],
                            "line-clamp": [{
                                "line-clamp": ["none", D, L]
                            }],
                            leading: [{
                                leading: ["none", "tight", "snug", "normal", "relaxed", "loose", B, N]
                            }],
                            "list-image": [{
                                "list-image": ["none", N]
                            }],
                            "list-style-type": [{
                                list: ["none", "disc", "decimal", N]
                            }],
                            "list-style-position": [{
                                list: ["inside", "outside"]
                            }],
                            "placeholder-color": [{
                                placeholder: [e]
                            }],
                            "placeholder-opacity": [{
                                "placeholder-opacity": [m]
                            }],
                            "text-alignment": [{
                                text: ["left", "center", "right", "justify", "start", "end"]
                            }],
                            "text-color": [{
                                text: [e]
                            }],
                            "text-opacity": [{
                                "text-opacity": [m]
                            }],
                            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
                            "text-decoration-style": [{
                                decoration: [...W(), "wavy"]
                            }],
                            "text-decoration-thickness": [{
                                decoration: ["auto", "from-font", B, R]
                            }],
                            "underline-offset": [{
                                "underline-offset": ["auto", B, N]
                            }],
                            "text-decoration-color": [{
                                decoration: [e]
                            }],
                            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
                            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
                            "text-wrap": [{
                                text: ["wrap", "nowrap", "balance", "pretty"]
                            }],
                            indent: [{
                                indent: T()
                            }],
                            "vertical-align": [{
                                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", N]
                            }],
                            whitespace: [{
                                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
                            }],
                            break: [{
                                break: ["normal", "words", "all", "keep"]
                            }],
                            hyphens: [{
                                hyphens: ["none", "manual", "auto"]
                            }],
                            content: [{
                                content: ["none", N]
                            }],
                            "bg-attachment": [{
                                bg: ["fixed", "local", "scroll"]
                            }],
                            "bg-clip": [{
                                "bg-clip": ["border", "padding", "content", "text"]
                            }],
                            "bg-opacity": [{
                                "bg-opacity": [m]
                            }],
                            "bg-origin": [{
                                "bg-origin": ["border", "padding", "content"]
                            }],
                            "bg-position": [{
                                bg: [...j(), Q]
                            }],
                            "bg-repeat": [{
                                bg: ["no-repeat", {
                                    repeat: ["", "x", "y", "round", "space"]
                                }]
                            }],
                            "bg-size": [{
                                bg: ["auto", "cover", "contain", k]
                            }],
                            "bg-image": [{
                                bg: ["none", {
                                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                                }, z]
                            }],
                            "bg-color": [{
                                bg: [e]
                            }],
                            "gradient-from-pos": [{
                                from: [p]
                            }],
                            "gradient-via-pos": [{
                                via: [p]
                            }],
                            "gradient-to-pos": [{
                                to: [p]
                            }],
                            "gradient-from": [{
                                from: [f]
                            }],
                            "gradient-via": [{
                                via: [f]
                            }],
                            "gradient-to": [{
                                to: [f]
                            }],
                            rounded: [{
                                rounded: [s]
                            }],
                            "rounded-s": [{
                                "rounded-s": [s]
                            }],
                            "rounded-e": [{
                                "rounded-e": [s]
                            }],
                            "rounded-t": [{
                                "rounded-t": [s]
                            }],
                            "rounded-r": [{
                                "rounded-r": [s]
                            }],
                            "rounded-b": [{
                                "rounded-b": [s]
                            }],
                            "rounded-l": [{
                                "rounded-l": [s]
                            }],
                            "rounded-ss": [{
                                "rounded-ss": [s]
                            }],
                            "rounded-se": [{
                                "rounded-se": [s]
                            }],
                            "rounded-ee": [{
                                "rounded-ee": [s]
                            }],
                            "rounded-es": [{
                                "rounded-es": [s]
                            }],
                            "rounded-tl": [{
                                "rounded-tl": [s]
                            }],
                            "rounded-tr": [{
                                "rounded-tr": [s]
                            }],
                            "rounded-br": [{
                                "rounded-br": [s]
                            }],
                            "rounded-bl": [{
                                "rounded-bl": [s]
                            }],
                            "border-w": [{
                                border: [o]
                            }],
                            "border-w-x": [{
                                "border-x": [o]
                            }],
                            "border-w-y": [{
                                "border-y": [o]
                            }],
                            "border-w-s": [{
                                "border-s": [o]
                            }],
                            "border-w-e": [{
                                "border-e": [o]
                            }],
                            "border-w-t": [{
                                "border-t": [o]
                            }],
                            "border-w-r": [{
                                "border-r": [o]
                            }],
                            "border-w-b": [{
                                "border-b": [o]
                            }],
                            "border-w-l": [{
                                "border-l": [o]
                            }],
                            "border-opacity": [{
                                "border-opacity": [m]
                            }],
                            "border-style": [{
                                border: [...W(), "hidden"]
                            }],
                            "divide-x": [{
                                "divide-x": [o]
                            }],
                            "divide-x-reverse": ["divide-x-reverse"],
                            "divide-y": [{
                                "divide-y": [o]
                            }],
                            "divide-y-reverse": ["divide-y-reverse"],
                            "divide-opacity": [{
                                "divide-opacity": [m]
                            }],
                            "divide-style": [{
                                divide: W()
                            }],
                            "border-color": [{
                                border: [i]
                            }],
                            "border-color-x": [{
                                "border-x": [i]
                            }],
                            "border-color-y": [{
                                "border-y": [i]
                            }],
                            "border-color-s": [{
                                "border-s": [i]
                            }],
                            "border-color-e": [{
                                "border-e": [i]
                            }],
                            "border-color-t": [{
                                "border-t": [i]
                            }],
                            "border-color-r": [{
                                "border-r": [i]
                            }],
                            "border-color-b": [{
                                "border-b": [i]
                            }],
                            "border-color-l": [{
                                "border-l": [i]
                            }],
                            "divide-color": [{
                                divide: [i]
                            }],
                            "outline-style": [{
                                outline: ["", ...W()]
                            }],
                            "outline-offset": [{
                                "outline-offset": [B, N]
                            }],
                            "outline-w": [{
                                outline: [B, R]
                            }],
                            "outline-color": [{
                                outline: [e]
                            }],
                            "ring-w": [{
                                ring: F()
                            }],
                            "ring-w-inset": ["ring-inset"],
                            "ring-color": [{
                                ring: [e]
                            }],
                            "ring-opacity": [{
                                "ring-opacity": [m]
                            }],
                            "ring-offset-w": [{
                                "ring-offset": [B, R]
                            }],
                            "ring-offset-color": [{
                                "ring-offset": [e]
                            }],
                            shadow: [{
                                shadow: ["", "inner", "none", U, H]
                            }],
                            "shadow-color": [{
                                shadow: [V]
                            }],
                            opacity: [{
                                opacity: [m]
                            }],
                            "mix-blend": [{
                                "mix-blend": [...Y(), "plus-lighter", "plus-darker"]
                            }],
                            "bg-blend": [{
                                "bg-blend": Y()
                            }],
                            filter: [{
                                filter: ["", "none"]
                            }],
                            blur: [{
                                blur: [n]
                            }],
                            brightness: [{
                                brightness: [r]
                            }],
                            contrast: [{
                                contrast: [l]
                            }],
                            "drop-shadow": [{
                                "drop-shadow": ["", "none", U, N]
                            }],
                            grayscale: [{
                                grayscale: [u]
                            }],
                            "hue-rotate": [{
                                "hue-rotate": [c]
                            }],
                            invert: [{
                                invert: [h]
                            }],
                            saturate: [{
                                saturate: [y]
                            }],
                            sepia: [{
                                sepia: [_]
                            }],
                            "backdrop-filter": [{
                                "backdrop-filter": ["", "none"]
                            }],
                            "backdrop-blur": [{
                                "backdrop-blur": [n]
                            }],
                            "backdrop-brightness": [{
                                "backdrop-brightness": [r]
                            }],
                            "backdrop-contrast": [{
                                "backdrop-contrast": [l]
                            }],
                            "backdrop-grayscale": [{
                                "backdrop-grayscale": [u]
                            }],
                            "backdrop-hue-rotate": [{
                                "backdrop-hue-rotate": [c]
                            }],
                            "backdrop-invert": [{
                                "backdrop-invert": [h]
                            }],
                            "backdrop-opacity": [{
                                "backdrop-opacity": [m]
                            }],
                            "backdrop-saturate": [{
                                "backdrop-saturate": [y]
                            }],
                            "backdrop-sepia": [{
                                "backdrop-sepia": [_]
                            }],
                            "border-collapse": [{
                                border: ["collapse", "separate"]
                            }],
                            "border-spacing": [{
                                "border-spacing": [a]
                            }],
                            "border-spacing-x": [{
                                "border-spacing-x": [a]
                            }],
                            "border-spacing-y": [{
                                "border-spacing-y": [a]
                            }],
                            "table-layout": [{
                                table: ["auto", "fixed"]
                            }],
                            caption: [{
                                caption: ["top", "bottom"]
                            }],
                            transition: [{
                                transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", N]
                            }],
                            duration: [{
                                duration: J()
                            }],
                            ease: [{
                                ease: ["linear", "in", "out", "in-out", N]
                            }],
                            delay: [{
                                delay: J()
                            }],
                            animate: [{
                                animate: ["none", "spin", "ping", "pulse", "bounce", N]
                            }],
                            transform: [{
                                transform: ["", "gpu", "none"]
                            }],
                            scale: [{
                                scale: [x]
                            }],
                            "scale-x": [{
                                "scale-x": [x]
                            }],
                            "scale-y": [{
                                "scale-y": [x]
                            }],
                            rotate: [{
                                rotate: [P, N]
                            }],
                            "translate-x": [{
                                "translate-x": [C]
                            }],
                            "translate-y": [{
                                "translate-y": [C]
                            }],
                            "skew-x": [{
                                "skew-x": [b]
                            }],
                            "skew-y": [{
                                "skew-y": [b]
                            }],
                            "transform-origin": [{
                                origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", N]
                            }],
                            accent: [{
                                accent: ["auto", e]
                            }],
                            appearance: [{
                                appearance: ["none", "auto"]
                            }],
                            cursor: [{
                                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", N]
                            }],
                            "caret-color": [{
                                caret: [e]
                            }],
                            "pointer-events": [{
                                "pointer-events": ["none", "auto"]
                            }],
                            resize: [{
                                resize: ["none", "y", "x", ""]
                            }],
                            "scroll-behavior": [{
                                scroll: ["auto", "smooth"]
                            }],
                            "scroll-m": [{
                                "scroll-m": T()
                            }],
                            "scroll-mx": [{
                                "scroll-mx": T()
                            }],
                            "scroll-my": [{
                                "scroll-my": T()
                            }],
                            "scroll-ms": [{
                                "scroll-ms": T()
                            }],
                            "scroll-me": [{
                                "scroll-me": T()
                            }],
                            "scroll-mt": [{
                                "scroll-mt": T()
                            }],
                            "scroll-mr": [{
                                "scroll-mr": T()
                            }],
                            "scroll-mb": [{
                                "scroll-mb": T()
                            }],
                            "scroll-ml": [{
                                "scroll-ml": T()
                            }],
                            "scroll-p": [{
                                "scroll-p": T()
                            }],
                            "scroll-px": [{
                                "scroll-px": T()
                            }],
                            "scroll-py": [{
                                "scroll-py": T()
                            }],
                            "scroll-ps": [{
                                "scroll-ps": T()
                            }],
                            "scroll-pe": [{
                                "scroll-pe": T()
                            }],
                            "scroll-pt": [{
                                "scroll-pt": T()
                            }],
                            "scroll-pr": [{
                                "scroll-pr": T()
                            }],
                            "scroll-pb": [{
                                "scroll-pb": T()
                            }],
                            "scroll-pl": [{
                                "scroll-pl": T()
                            }],
                            "snap-align": [{
                                snap: ["start", "end", "center", "align-none"]
                            }],
                            "snap-stop": [{
                                snap: ["normal", "always"]
                            }],
                            "snap-type": [{
                                snap: ["none", "x", "y", "both"]
                            }],
                            "snap-strictness": [{
                                snap: ["mandatory", "proximity"]
                            }],
                            touch: [{
                                touch: ["auto", "none", "manipulation"]
                            }],
                            "touch-x": [{
                                "touch-pan": ["x", "left", "right"]
                            }],
                            "touch-y": [{
                                "touch-pan": ["y", "up", "down"]
                            }],
                            "touch-pz": ["touch-pinch-zoom"],
                            select: [{
                                select: ["none", "text", "all", "auto"]
                            }],
                            "will-change": [{
                                "will-change": ["auto", "scroll", "contents", "transform", N]
                            }],
                            fill: [{
                                fill: [e, "none"]
                            }],
                            "stroke-w": [{
                                stroke: [B, R, L]
                            }],
                            stroke: [{
                                stroke: [e, "none"]
                            }],
                            sr: ["sr-only", "not-sr-only"],
                            "forced-color-adjust": [{
                                "forced-color-adjust": ["auto", "none"]
                            }]
                        },
                        conflictingClassGroups: {
                            overflow: ["overflow-x", "overflow-y"],
                            overscroll: ["overscroll-x", "overscroll-y"],
                            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
                            "inset-x": ["right", "left"],
                            "inset-y": ["top", "bottom"],
                            flex: ["basis", "grow", "shrink"],
                            gap: ["gap-x", "gap-y"],
                            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
                            px: ["pr", "pl"],
                            py: ["pt", "pb"],
                            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
                            mx: ["mr", "ml"],
                            my: ["mt", "mb"],
                            size: ["w", "h"],
                            "font-size": ["leading"],
                            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
                            "fvn-ordinal": ["fvn-normal"],
                            "fvn-slashed-zero": ["fvn-normal"],
                            "fvn-figure": ["fvn-normal"],
                            "fvn-spacing": ["fvn-normal"],
                            "fvn-fraction": ["fvn-normal"],
                            "line-clamp": ["display", "overflow"],
                            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
                            "rounded-s": ["rounded-ss", "rounded-es"],
                            "rounded-e": ["rounded-se", "rounded-ee"],
                            "rounded-t": ["rounded-tl", "rounded-tr"],
                            "rounded-r": ["rounded-tr", "rounded-br"],
                            "rounded-b": ["rounded-br", "rounded-bl"],
                            "rounded-l": ["rounded-tl", "rounded-bl"],
                            "border-spacing": ["border-spacing-x", "border-spacing-y"],
                            "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
                            "border-w-x": ["border-w-r", "border-w-l"],
                            "border-w-y": ["border-w-t", "border-w-b"],
                            "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
                            "border-color-x": ["border-color-r", "border-color-l"],
                            "border-color-y": ["border-color-t", "border-color-b"],
                            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
                            "scroll-mx": ["scroll-mr", "scroll-ml"],
                            "scroll-my": ["scroll-mt", "scroll-mb"],
                            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
                            "scroll-px": ["scroll-pr", "scroll-pl"],
                            "scroll-py": ["scroll-pt", "scroll-pb"],
                            touch: ["touch-x", "touch-y", "touch-pz"],
                            "touch-x": ["touch"],
                            "touch-y": ["touch"],
                            "touch-pz": ["touch"]
                        },
                        conflictingClassGroupModifiers: {
                            "font-size": ["leading"]
                        }
                    }
                },
                J = (e, {
                    cacheSize: t,
                    prefix: n,
                    separator: r,
                    experimentalParseClassName: i,
                    extend: s = {},
                    override: a = {}
                }) => {
                    for (let s in Z(e, "cacheSize", t), Z(e, "prefix", n), Z(e, "separator", r), Z(e, "experimentalParseClassName", i), a) $(e[s], a[s]);
                    for (let t in s) ee(e[t], s[t]);
                    return e
                },
                Z = (e, t, n) => {
                    void 0 !== n && (e[t] = n)
                },
                $ = (e, t) => {
                    if (t)
                        for (let n in t) Z(e, n, t[n])
                },
                ee = (e, t) => {
                    if (t)
                        for (let n in t) {
                            let r = t[n];
                            void 0 !== r && (e[n] = (e[n] || []).concat(r))
                        }
                },
                et = ((e, ...t) => "function" == typeof e ? x(K, e, ...t) : x(() => J(K(), e), ...t))({
                    extend: {
                        classGroups: {
                            "font-size": ["text-s-h1", "text-s-h2", "text-s-h3", "text-s-h4", "text-s-h5", "text-s-h6", "text-d-h1", "text-d-h2", "text-d-h3", "text-d-h4", "text-d-h5", "text-d-h6", "text-large", "text-regular", "text-small", "text-caption", "text-overline"]
                        }
                    }
                });

            function en() {
                for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return et(function() {
                    for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = function e(t) {
                        var n, r, i = "";
                        if ("string" == typeof t || "number" == typeof t) i += t;
                        else if ("object" == typeof t) {
                            if (Array.isArray(t)) {
                                var s = t.length;
                                for (n = 0; n < s; n++) t[n] && (r = e(t[n])) && (i && (i += " "), i += r)
                            } else
                                for (r in t) t[r] && (i && (i += " "), i += r)
                        }
                        return i
                    }(e)) && (r && (r += " "), r += t);
                    return r
                }(t))
            }
        },
        1139: function(e, t) {
            "use strict";
            var n, r, i, s;
            Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                function(e, t) {
                    for (var n in t) Object.defineProperty(e, n, {
                        enumerable: !0,
                        get: t[n]
                    })
                }(t, {
                    ACTION_FAST_REFRESH: function() {
                        return h
                    },
                    ACTION_NAVIGATE: function() {
                        return o
                    },
                    ACTION_PREFETCH: function() {
                        return c
                    },
                    ACTION_REFRESH: function() {
                        return a
                    },
                    ACTION_RESTORE: function() {
                        return l
                    },
                    ACTION_SERVER_ACTION: function() {
                        return d
                    },
                    ACTION_SERVER_PATCH: function() {
                        return u
                    },
                    PrefetchCacheEntryStatus: function() {
                        return r
                    },
                    PrefetchKind: function() {
                        return n
                    },
                    isThenable: function() {
                        return f
                    }
                });
            let a = "refresh",
                o = "navigate",
                l = "restore",
                u = "server-patch",
                c = "prefetch",
                h = "fast-refresh",
                d = "server-action";

            function f(e) {
                return e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then
            }(i = n || (n = {})).AUTO = "auto", i.FULL = "full", i.TEMPORARY = "temporary", (s = r || (r = {})).fresh = "fresh", s.reusable = "reusable", s.expired = "expired", s.stale = "stale", ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", {
                value: !0
            }), Object.assign(t.default, t), e.exports = t.default)
        },
        9227: function(e, t, n) {
            "use strict";

            function r(e, t, n, r) {
                return !1
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), Object.defineProperty(t, "getDomainLocale", {
                enumerable: !0,
                get: function() {
                    return r
                }
            }), n(3616), ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", {
                value: !0
            }), Object.assign(t.default, t), e.exports = t.default)
        },
        7150: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), Object.defineProperty(t, "default", {
                enumerable: !0,
                get: function() {
                    return x
                }
            });
            let r = n(2430),
                i = n(1527),
                s = r._(n(959)),
                a = n(8121),
                o = n(5584),
                l = n(583),
                u = n(5419),
                c = n(6578),
                h = n(1878),
                d = n(3612),
                f = n(3410),
                p = n(9227),
                g = n(1697),
                A = n(1139),
                m = new Set;

            function v(e, t, n, r, i, s) {
                if (s || (0, o.isLocalURL)(t)) {
                    if (!r.bypassPrefetchedCheck) {
                        let i = t + "%" + n + "%" + (void 0 !== r.locale ? r.locale : "locale" in e ? e.locale : void 0);
                        if (m.has(i)) return;
                        m.add(i)
                    }(async () => s ? e.prefetch(t, i) : e.prefetch(t, n, r))().catch(e => {})
                }
            }

            function y(e) {
                return "string" == typeof e ? e : (0, l.formatUrl)(e)
            }
            let x = s.default.forwardRef(function(e, t) {
                let n, r;
                let {
                    href: l,
                    as: m,
                    children: x,
                    prefetch: E = null,
                    passHref: _,
                    replace: b,
                    shallow: w,
                    scroll: C,
                    locale: S,
                    onClick: I,
                    onMouseEnter: M,
                    onTouchStart: T,
                    legacyBehavior: B = !1,
                    ...R
                } = e;
                n = x, B && ("string" == typeof n || "number" == typeof n) && (n = (0, i.jsx)("a", {
                    children: n
                }));
                let D = s.default.useContext(h.RouterContext),
                    L = s.default.useContext(d.AppRouterContext),
                    P = null != D ? D : L,
                    O = !D,
                    N = !1 !== E,
                    U = null === E ? A.PrefetchKind.AUTO : A.PrefetchKind.FULL,
                    {
                        href: F,
                        as: k
                    } = s.default.useMemo(() => {
                        if (!D) {
                            let e = y(l);
                            return {
                                href: e,
                                as: m ? y(m) : e
                            }
                        }
                        let [e, t] = (0, a.resolveHref)(D, l, !0);
                        return {
                            href: e,
                            as: m ? (0, a.resolveHref)(D, m) : t || e
                        }
                    }, [D, l, m]),
                    Q = s.default.useRef(F),
                    G = s.default.useRef(k);
                B && (r = s.default.Children.only(n));
                let z = B ? r && "object" == typeof r && r.ref : t,
                    [H, V, j] = (0, f.useIntersection)({
                        rootMargin: "200px"
                    }),
                    W = s.default.useCallback(e => {
                        (G.current !== k || Q.current !== F) && (j(), G.current = k, Q.current = F), H(e), z && ("function" == typeof z ? z(e) : "object" == typeof z && (z.current = e))
                    }, [k, z, F, j, H]);
                s.default.useEffect(() => {
                    P && V && N && v(P, F, k, {
                        locale: S
                    }, {
                        kind: U
                    }, O)
                }, [k, F, V, S, N, null == D ? void 0 : D.locale, P, O, U]);
                let Y = {
                    ref: W,
                    onClick(e) {
                        B || "function" != typeof I || I(e), B && r.props && "function" == typeof r.props.onClick && r.props.onClick(e), P && !e.defaultPrevented && function(e, t, n, r, i, a, l, u, c) {
                            let {
                                nodeName: h
                            } = e.currentTarget;
                            if ("A" === h.toUpperCase() && (function(e) {
                                    let t = e.currentTarget.getAttribute("target");
                                    return t && "_self" !== t || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey || e.nativeEvent && 2 === e.nativeEvent.which
                                }(e) || !c && !(0, o.isLocalURL)(n))) return;
                            e.preventDefault();
                            let d = () => {
                                let e = null == l || l;
                                "beforePopState" in t ? t[i ? "replace" : "push"](n, r, {
                                    shallow: a,
                                    locale: u,
                                    scroll: e
                                }) : t[i ? "replace" : "push"](r || n, {
                                    scroll: e
                                })
                            };
                            c ? s.default.startTransition(d) : d()
                        }(e, P, F, k, b, w, C, S, O)
                    },
                    onMouseEnter(e) {
                        B || "function" != typeof M || M(e), B && r.props && "function" == typeof r.props.onMouseEnter && r.props.onMouseEnter(e), P && (N || !O) && v(P, F, k, {
                            locale: S,
                            priority: !0,
                            bypassPrefetchedCheck: !0
                        }, {
                            kind: U
                        }, O)
                    },
                    onTouchStart: function(e) {
                        B || "function" != typeof T || T(e), B && r.props && "function" == typeof r.props.onTouchStart && r.props.onTouchStart(e), P && (N || !O) && v(P, F, k, {
                            locale: S,
                            priority: !0,
                            bypassPrefetchedCheck: !0
                        }, {
                            kind: U
                        }, O)
                    }
                };
                if ((0, u.isAbsoluteUrl)(k)) Y.href = k;
                else if (!B || _ || "a" === r.type && !("href" in r.props)) {
                    let e = void 0 !== S ? S : null == D ? void 0 : D.locale,
                        t = (null == D ? void 0 : D.isLocaleDomain) && (0, p.getDomainLocale)(k, e, null == D ? void 0 : D.locales, null == D ? void 0 : D.domainLocales);
                    Y.href = t || (0, g.addBasePath)((0, c.addLocale)(k, e, null == D ? void 0 : D.defaultLocale))
                }
                return B ? s.default.cloneElement(r, Y) : (0, i.jsx)("a", { ...R,
                    ...Y,
                    children: n
                })
            });
            ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", {
                value: !0
            }), Object.assign(t.default, t), e.exports = t.default)
        },
        3410: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), Object.defineProperty(t, "useIntersection", {
                enumerable: !0,
                get: function() {
                    return l
                }
            });
            let r = n(959),
                i = n(5226),
                s = "function" == typeof IntersectionObserver,
                a = new Map,
                o = [];

            function l(e) {
                let {
                    rootRef: t,
                    rootMargin: n,
                    disabled: l
                } = e, u = l || !s, [c, h] = (0, r.useState)(!1), d = (0, r.useRef)(null), f = (0, r.useCallback)(e => {
                    d.current = e
                }, []);
                return (0, r.useEffect)(() => {
                    if (s) {
                        if (u || c) return;
                        let e = d.current;
                        if (e && e.tagName) return function(e, t, n) {
                            let {
                                id: r,
                                observer: i,
                                elements: s
                            } = function(e) {
                                let t;
                                let n = {
                                        root: e.root || null,
                                        margin: e.rootMargin || ""
                                    },
                                    r = o.find(e => e.root === n.root && e.margin === n.margin);
                                if (r && (t = a.get(r))) return t;
                                let i = new Map;
                                return t = {
                                    id: n,
                                    observer: new IntersectionObserver(e => {
                                        e.forEach(e => {
                                            let t = i.get(e.target),
                                                n = e.isIntersecting || e.intersectionRatio > 0;
                                            t && n && t(n)
                                        })
                                    }, e),
                                    elements: i
                                }, o.push(n), a.set(n, t), t
                            }(n);
                            return s.set(e, t), i.observe(e),
                                function() {
                                    if (s.delete(e), i.unobserve(e), 0 === s.size) {
                                        i.disconnect(), a.delete(r);
                                        let e = o.findIndex(e => e.root === r.root && e.margin === r.margin);
                                        e > -1 && o.splice(e, 1)
                                    }
                                }
                        }(e, e => e && h(e), {
                            root: null == t ? void 0 : t.current,
                            rootMargin: n
                        })
                    } else if (!c) {
                        let e = (0, i.requestIdleCallback)(() => h(!0));
                        return () => (0, i.cancelIdleCallback)(e)
                    }
                }, [u, n, t, c, d.current]), [f, c, (0, r.useCallback)(() => {
                    h(!1)
                }, [])]
            }("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", {
                value: !0
            }), Object.assign(t.default, t), e.exports = t.default)
        },
        6543: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                function(e, t) {
                    for (var n in t) Object.defineProperty(e, n, {
                        enumerable: !0,
                        get: t[n]
                    })
                }(t, {
                    default: function() {
                        return o
                    },
                    noSSR: function() {
                        return a
                    }
                });
            let r = n(2430);
            n(1527), n(959);
            let i = r._(n(385));

            function s(e) {
                return {
                    default: (null == e ? void 0 : e.default) || e
                }
            }

            function a(e, t) {
                return delete t.webpack, delete t.modules, e(t)
            }

            function o(e, t) {
                let n = i.default,
                    r = {
                        loading: e => {
                            let {
                                error: t,
                                isLoading: n,
                                pastDelay: r
                            } = e;
                            return null
                        }
                    };
                e instanceof Promise ? r.loader = () => e : "function" == typeof e ? r.loader = e : "object" == typeof e && (r = { ...r,
                    ...e
                });
                let o = (r = { ...r,
                    ...t
                }).loader;
                return (r.loadableGenerated && (r = { ...r,
                    ...r.loadableGenerated
                }, delete r.loadableGenerated), "boolean" != typeof r.ssr || r.ssr) ? n({ ...r,
                    loader: () => null != o ? o().then(s) : Promise.resolve(s(() => null))
                }) : (delete r.webpack, delete r.modules, a(n, r))
            }("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", {
                value: !0
            }), Object.assign(t.default, t), e.exports = t.default)
        },
        8203: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), Object.defineProperty(t, "LoadableContext", {
                enumerable: !0,
                get: function() {
                    return r
                }
            });
            let r = n(2430)._(n(959)).default.createContext(null)
        },
        385: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), Object.defineProperty(t, "default", {
                enumerable: !0,
                get: function() {
                    return d
                }
            });
            let r = n(2430)._(n(959)),
                i = n(8203),
                s = [],
                a = [],
                o = !1;

            function l(e) {
                let t = e(),
                    n = {
                        loading: !0,
                        loaded: null,
                        error: null
                    };
                return n.promise = t.then(e => (n.loading = !1, n.loaded = e, e)).catch(e => {
                    throw n.loading = !1, n.error = e, e
                }), n
            }
            class u {
                promise() {
                    return this._res.promise
                }
                retry() {
                    this._clearTimeouts(), this._res = this._loadFn(this._opts.loader), this._state = {
                        pastDelay: !1,
                        timedOut: !1
                    };
                    let {
                        _res: e,
                        _opts: t
                    } = this;
                    e.loading && ("number" == typeof t.delay && (0 === t.delay ? this._state.pastDelay = !0 : this._delay = setTimeout(() => {
                        this._update({
                            pastDelay: !0
                        })
                    }, t.delay)), "number" == typeof t.timeout && (this._timeout = setTimeout(() => {
                        this._update({
                            timedOut: !0
                        })
                    }, t.timeout))), this._res.promise.then(() => {
                        this._update({}), this._clearTimeouts()
                    }).catch(e => {
                        this._update({}), this._clearTimeouts()
                    }), this._update({})
                }
                _update(e) {
                    this._state = { ...this._state,
                        error: this._res.error,
                        loaded: this._res.loaded,
                        loading: this._res.loading,
                        ...e
                    }, this._callbacks.forEach(e => e())
                }
                _clearTimeouts() {
                    clearTimeout(this._delay), clearTimeout(this._timeout)
                }
                getCurrentValue() {
                    return this._state
                }
                subscribe(e) {
                    return this._callbacks.add(e), () => {
                        this._callbacks.delete(e)
                    }
                }
                constructor(e, t) {
                    this._loadFn = e, this._opts = t, this._callbacks = new Set, this._delay = null, this._timeout = null, this.retry()
                }
            }

            function c(e) {
                return function(e, t) {
                    let n = Object.assign({
                            loader: null,
                            loading: null,
                            delay: 200,
                            timeout: null,
                            webpack: null,
                            modules: null
                        }, t),
                        s = null;

                    function l() {
                        if (!s) {
                            let t = new u(e, n);
                            s = {
                                getCurrentValue: t.getCurrentValue.bind(t),
                                subscribe: t.subscribe.bind(t),
                                retry: t.retry.bind(t),
                                promise: t.promise.bind(t)
                            }
                        }
                        return s.promise()
                    }
                    if (!o) {
                        let e = n.webpack ? n.webpack() : n.modules;
                        e && a.push(t => {
                            for (let n of e)
                                if (t.includes(n)) return l()
                        })
                    }

                    function c(e, t) {
                        ! function() {
                            l();
                            let e = r.default.useContext(i.LoadableContext);
                            e && Array.isArray(n.modules) && n.modules.forEach(t => {
                                e(t)
                            })
                        }();
                        let a = r.default.useSyncExternalStore(s.subscribe, s.getCurrentValue, s.getCurrentValue);
                        return r.default.useImperativeHandle(t, () => ({
                            retry: s.retry
                        }), []), r.default.useMemo(() => {
                            var t;
                            return a.loading || a.error ? r.default.createElement(n.loading, {
                                isLoading: a.loading,
                                pastDelay: a.pastDelay,
                                timedOut: a.timedOut,
                                error: a.error,
                                retry: s.retry
                            }) : a.loaded ? r.default.createElement((t = a.loaded) && t.default ? t.default : t, e) : null
                        }, [e, a])
                    }
                    return c.preload = () => l(), c.displayName = "LoadableComponent", r.default.forwardRef(c)
                }(l, e)
            }

            function h(e, t) {
                let n = [];
                for (; e.length;) {
                    let r = e.pop();
                    n.push(r(t))
                }
                return Promise.all(n).then(() => {
                    if (e.length) return h(e, t)
                })
            }
            c.preloadAll = () => new Promise((e, t) => {
                h(s).then(e, t)
            }), c.preloadReady = e => (void 0 === e && (e = []), new Promise(t => {
                let n = () => (o = !0, t());
                h(a, e).then(n, n)
            })), window.__NEXT_PRELOADREADY = c.preloadReady;
            let d = c
        },
        5700: function(e, t, n) {
            "use strict";
            n.d(t, {
                S1: function() {
                    return s
                },
                ZT: function() {
                    return r
                },
                jU: function() {
                    return a
                },
                on: function() {
                    return i
                }
            });
            var r = function() {};

            function i(e) {
                for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
                e && e.addEventListener && e.addEventListener.apply(e, t)
            }

            function s(e) {
                for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
                e && e.removeEventListener && e.removeEventListener.apply(e, t)
            }
            var a = !0
        },
        3759: function(e, t, n) {
            "use strict";
            var r = n(959),
                i = n(5700),
                s = i.jU ? window : null,
                a = function(e) {
                    return !!e.addEventListener
                },
                o = function(e) {
                    return !!e.on
                };
            t.Z = function(e, t, n, l) {
                void 0 === n && (n = s), (0, r.useEffect)(function() {
                    if (t && n) return a(n) ? (0, i.on)(n, e, t, l) : o(n) && n.on(e, t, l),
                        function() {
                            a(n) ? (0, i.S1)(n, e, t, l) : o(n) && n.off(e, t, l)
                        }
                }, [e, t, n, JSON.stringify(l)])
            }
        },
        1519: function(e, t, n) {
            "use strict";
            var r = n(959),
                i = n(5700).jU ? r.useLayoutEffect : r.useEffect;
            t.Z = i
        },
        5868: function(e, t, n) {
            "use strict";
            var r = n(4507);
            n(2071);
            var i = n(959),
                s = i && "object" == typeof i && "default" in i ? i : {
                    default: i
                },
                a = void 0 !== r && r.env && !0,
                o = function(e) {
                    return "[object String]" === Object.prototype.toString.call(e)
                },
                l = function() {
                    function e(e) {
                        var t = void 0 === e ? {} : e,
                            n = t.name,
                            r = void 0 === n ? "stylesheet" : n,
                            i = t.optimizeForSpeed,
                            s = void 0 === i ? a : i;
                        u(o(r), "`name` must be a string"), this._name = r, this._deletedRulePlaceholder = "#" + r + "-deleted-rule____{}", u("boolean" == typeof s, "`optimizeForSpeed` must be a boolean"), this._optimizeForSpeed = s, this._serverSheet = void 0, this._tags = [], this._injected = !1, this._rulesCount = 0;
                        var l = document.querySelector('meta[property="csp-nonce"]');
                        this._nonce = l ? l.getAttribute("content") : null
                    }
                    var t = e.prototype;
                    return t.setOptimizeForSpeed = function(e) {
                            u("boolean" == typeof e, "`setOptimizeForSpeed` accepts a boolean"), u(0 === this._rulesCount, "optimizeForSpeed cannot be when rules have already been inserted"), this.flush(), this._optimizeForSpeed = e, this.inject()
                        }, t.isOptimizeForSpeed = function() {
                            return this._optimizeForSpeed
                        }, t.inject = function() {
                            var e = this;
                            if (u(!this._injected, "sheet already injected"), this._injected = !0, this._optimizeForSpeed) {
                                this._tags[0] = this.makeStyleTag(this._name), this._optimizeForSpeed = "insertRule" in this.getSheet(), this._optimizeForSpeed || (this.flush(), this._injected = !0);
                                return
                            }
                            this._serverSheet = {
                                cssRules: [],
                                insertRule: function(t, n) {
                                    return "number" == typeof n ? e._serverSheet.cssRules[n] = {
                                        cssText: t
                                    } : e._serverSheet.cssRules.push({
                                        cssText: t
                                    }), n
                                },
                                deleteRule: function(t) {
                                    e._serverSheet.cssRules[t] = null
                                }
                            }
                        }, t.getSheetForTag = function(e) {
                            if (e.sheet) return e.sheet;
                            for (var t = 0; t < document.styleSheets.length; t++)
                                if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t]
                        }, t.getSheet = function() {
                            return this.getSheetForTag(this._tags[this._tags.length - 1])
                        }, t.insertRule = function(e, t) {
                            if (u(o(e), "`insertRule` accepts only strings"), this._optimizeForSpeed) {
                                var n = this.getSheet();
                                "number" != typeof t && (t = n.cssRules.length);
                                try {
                                    n.insertRule(e, t)
                                } catch (e) {
                                    return -1
                                }
                            } else {
                                var r = this._tags[t];
                                this._tags.push(this.makeStyleTag(this._name, e, r))
                            }
                            return this._rulesCount++
                        }, t.replaceRule = function(e, t) {
                            if (this._optimizeForSpeed) {
                                var n = this.getSheet();
                                if (t.trim() || (t = this._deletedRulePlaceholder), !n.cssRules[e]) return e;
                                n.deleteRule(e);
                                try {
                                    n.insertRule(t, e)
                                } catch (t) {
                                    n.insertRule(this._deletedRulePlaceholder, e)
                                }
                            } else {
                                var r = this._tags[e];
                                u(r, "old rule at index `" + e + "` not found"), r.textContent = t
                            }
                            return e
                        }, t.deleteRule = function(e) {
                            if (this._optimizeForSpeed) this.replaceRule(e, "");
                            else {
                                var t = this._tags[e];
                                u(t, "rule at index `" + e + "` not found"), t.parentNode.removeChild(t), this._tags[e] = null
                            }
                        }, t.flush = function() {
                            this._injected = !1, this._rulesCount = 0, this._tags.forEach(function(e) {
                                return e && e.parentNode.removeChild(e)
                            }), this._tags = []
                        }, t.cssRules = function() {
                            var e = this;
                            return this._tags.reduce(function(t, n) {
                                return n ? t = t.concat(Array.prototype.map.call(e.getSheetForTag(n).cssRules, function(t) {
                                    return t.cssText === e._deletedRulePlaceholder ? null : t
                                })) : t.push(null), t
                            }, [])
                        }, t.makeStyleTag = function(e, t, n) {
                            t && u(o(t), "makeStyleTag accepts only strings as second parameter");
                            var r = document.createElement("style");
                            this._nonce && r.setAttribute("nonce", this._nonce), r.type = "text/css", r.setAttribute("data-" + e, ""), t && r.appendChild(document.createTextNode(t));
                            var i = document.head || document.getElementsByTagName("head")[0];
                            return n ? i.insertBefore(r, n) : i.appendChild(r), r
                        },
                        function(e, t) {
                            for (var n = 0; n < t.length; n++) {
                                var r = t[n];
                                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                            }
                        }(e.prototype, [{
                            key: "length",
                            get: function() {
                                return this._rulesCount
                            }
                        }]), e
                }();

            function u(e, t) {
                if (!e) throw Error("StyleSheet: " + t + ".")
            }
            var c = function(e) {
                    for (var t = 5381, n = e.length; n;) t = 33 * t ^ e.charCodeAt(--n);
                    return t >>> 0
                },
                h = {};

            function d(e, t) {
                if (!t) return "jsx-" + e;
                var n = String(t),
                    r = e + n;
                return h[r] || (h[r] = "jsx-" + c(e + "-" + n)), h[r]
            }

            function f(e, t) {
                var n = e + t;
                return h[n] || (h[n] = t.replace(/__jsx-style-dynamic-selector/g, e)), h[n]
            }
            var p = function() {
                    function e(e) {
                        var t = void 0 === e ? {} : e,
                            n = t.styleSheet,
                            r = void 0 === n ? null : n,
                            i = t.optimizeForSpeed,
                            s = void 0 !== i && i;
                        this._sheet = r || new l({
                            name: "styled-jsx",
                            optimizeForSpeed: s
                        }), this._sheet.inject(), r && "boolean" == typeof s && (this._sheet.setOptimizeForSpeed(s), this._optimizeForSpeed = this._sheet.isOptimizeForSpeed()), this._fromServer = void 0, this._indices = {}, this._instancesCounts = {}
                    }
                    var t = e.prototype;
                    return t.add = function(e) {
                        var t = this;
                        void 0 === this._optimizeForSpeed && (this._optimizeForSpeed = Array.isArray(e.children), this._sheet.setOptimizeForSpeed(this._optimizeForSpeed), this._optimizeForSpeed = this._sheet.isOptimizeForSpeed()), this._fromServer || (this._fromServer = this.selectFromServer(), this._instancesCounts = Object.keys(this._fromServer).reduce(function(e, t) {
                            return e[t] = 0, e
                        }, {}));
                        var n = this.getIdAndRules(e),
                            r = n.styleId,
                            i = n.rules;
                        if (r in this._instancesCounts) {
                            this._instancesCounts[r] += 1;
                            return
                        }
                        var s = i.map(function(e) {
                            return t._sheet.insertRule(e)
                        }).filter(function(e) {
                            return -1 !== e
                        });
                        this._indices[r] = s, this._instancesCounts[r] = 1
                    }, t.remove = function(e) {
                        var t = this,
                            n = this.getIdAndRules(e).styleId;
                        if (function(e, t) {
                                if (!e) throw Error("StyleSheetRegistry: " + t + ".")
                            }(n in this._instancesCounts, "styleId: `" + n + "` not found"), this._instancesCounts[n] -= 1, this._instancesCounts[n] < 1) {
                            var r = this._fromServer && this._fromServer[n];
                            r ? (r.parentNode.removeChild(r), delete this._fromServer[n]) : (this._indices[n].forEach(function(e) {
                                return t._sheet.deleteRule(e)
                            }), delete this._indices[n]), delete this._instancesCounts[n]
                        }
                    }, t.update = function(e, t) {
                        this.add(t), this.remove(e)
                    }, t.flush = function() {
                        this._sheet.flush(), this._sheet.inject(), this._fromServer = void 0, this._indices = {}, this._instancesCounts = {}
                    }, t.cssRules = function() {
                        var e = this,
                            t = this._fromServer ? Object.keys(this._fromServer).map(function(t) {
                                return [t, e._fromServer[t]]
                            }) : [],
                            n = this._sheet.cssRules();
                        return t.concat(Object.keys(this._indices).map(function(t) {
                            return [t, e._indices[t].map(function(e) {
                                return n[e].cssText
                            }).join(e._optimizeForSpeed ? "" : "\n")]
                        }).filter(function(e) {
                            return !!e[1]
                        }))
                    }, t.styles = function(e) {
                        var t, n;
                        return t = this.cssRules(), void 0 === (n = e) && (n = {}), t.map(function(e) {
                            var t = e[0],
                                r = e[1];
                            return s.default.createElement("style", {
                                id: "__" + t,
                                key: "__" + t,
                                nonce: n.nonce ? n.nonce : void 0,
                                dangerouslySetInnerHTML: {
                                    __html: r
                                }
                            })
                        })
                    }, t.getIdAndRules = function(e) {
                        var t = e.children,
                            n = e.dynamic,
                            r = e.id;
                        if (n) {
                            var i = d(r, n);
                            return {
                                styleId: i,
                                rules: Array.isArray(t) ? t.map(function(e) {
                                    return f(i, e)
                                }) : [f(i, t)]
                            }
                        }
                        return {
                            styleId: d(r),
                            rules: Array.isArray(t) ? t : [t]
                        }
                    }, t.selectFromServer = function() {
                        return Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]')).reduce(function(e, t) {
                            return e[t.id.slice(2)] = t, e
                        }, {})
                    }, e
                }(),
                g = i.createContext(null);
            g.displayName = "StyleSheetContext";
            var A = s.default.useInsertionEffect || s.default.useLayoutEffect,
                m = new p;

            function v(e) {
                var t = m || i.useContext(g);
                return t && A(function() {
                    return t.add(e),
                        function() {
                            t.remove(e)
                        }
                }, [e.id, String(e.dynamic)]), null
            }
            v.dynamic = function(e) {
                return e.map(function(e) {
                    return d(e[0], e[1])
                }).join(" ")
            }, t.style = v
        },
        6630: function(e, t, n) {
            "use strict";
            e.exports = n(5868).style
        },
        6495: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return ex
                }
            });
            var r, i, s = n(1527),
                a = n(7899),
                o = n.n(a),
                l = n(4063),
                u = n.n(l),
                c = n(959),
                h = n(2378),
                d = n(6351),
                f = n(6592),
                p = n(6912),
                g = n(989),
                A = () => {
                    let e = (0, c.useRef)(null),
                        t = (0, p.U2)(e => e.compiled);
                    return (0, s.jsx)(h.ZP, {
                        nodeRef: e,
                        in: !t,
                        timeout: {
                            enter: 0,
                            exit: 1e3
                        },
                        unmountOnExit: !0,
                        children: t => (0, s.jsxs)("div", {
                            ref: e,
                            className: (0, g.cn)(["fixed left-0 top-0 z-loader h-full w-full bg-black-light", "flex items-center justify-center"], {
                                "opacity-0": "entering" === t,
                                "opacity-100 transition-opacity duration-1000 ease-in-out-cubic": "entered" === t,
                                "opacity-0 transition-opacity duration-1000 ease-in-out-cubic": "exiting" === t
                            }),
                            children: [(0, s.jsx)("div", {
                                className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2",
                                children: (0, s.jsx)(d.Z, {})
                            }), (0, s.jsx)("div", {
                                className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2",
                                children: (0, s.jsx)(f.Z, {
                                    variant: "large"
                                })
                            })]
                        })
                    })
                },
                m = () => (0, s.jsxs)("svg", {
                    className: "hidden",
                    children: [(0, s.jsx)("symbol", {
                        id: "8bit-logo",
                        viewBox: "0 0 69 17",
                        children: (0, s.jsx)("path", {
                            d: "M20.1841 0.935C20.1841 0.4182 19.7659 0 19.2491 0C18.7323 0 18.3141 0.4182 18.3141 0.935V15.9715C18.3141 16.4883 18.7323 16.9065 19.2491 16.9065C19.7659 16.9065 20.1841 16.4883 20.1841 15.9715V15.8223C20.9953 16.4625 22.0193 16.8453 23.1336 16.8453H27.4703C27.6072 16.8453 27.7333 16.8283 27.8603 16.8112L27.8604 16.8112L27.8605 16.8112C27.9086 16.8047 27.9568 16.7982 28.0058 16.7926C28.0629 16.784 28.1221 16.7809 28.1817 16.7777H28.1817C28.264 16.7733 28.3468 16.7688 28.4257 16.7501C29.0445 16.6243 29.6225 16.3727 30.1274 16.0361C30.2138 15.9799 30.2895 15.913 30.3654 15.8459C30.4179 15.7994 30.4706 15.7528 30.5269 15.7097C30.5515 15.6903 30.5762 15.6713 30.6006 15.6524C30.6809 15.5904 30.7596 15.5298 30.8312 15.4581C30.8414 15.4479 30.852 15.4347 30.8627 15.4216C30.8733 15.4084 30.8839 15.3952 30.8941 15.385C31.7135 14.5231 32.2286 13.3688 32.2286 12.087C32.2286 9.46221 30.0968 7.18931 27.4601 7.18931H23.1234C22.7987 7.18931 22.4723 7.22161 22.168 7.28451C21.6529 7.38991 21.1803 7.59901 20.74 7.85231C20.7 7.87447 20.6602 7.89483 20.6213 7.91478C20.5677 7.94226 20.5156 7.96896 20.4663 7.99851C20.43 8.02307 20.4004 8.05104 20.3718 8.07815C20.3509 8.09795 20.3305 8.11729 20.3082 8.13451C20.2663 8.16582 20.225 8.19795 20.1841 8.23088V0.935ZM4.7362 2.0621C3.2555 2.0621 2.0485 3.2691 2.0485 4.7498C2.0485 6.2305 3.2555 7.4375 4.7362 7.4375C5.304 7.4375 5.7545 7.8999 5.7545 8.4558C5.7545 9.0117 5.2921 9.4741 4.7362 9.4741C3.2555 9.4741 2.0485 10.6811 2.0485 12.1618C2.0485 13.6425 3.2555 14.8495 4.7362 14.8495H9.0729C10.5536 14.8495 11.7606 13.6425 11.7606 12.1618C11.7606 10.6811 10.5536 9.4741 9.0729 9.4741C8.5051 9.4741 8.0546 9.0117 8.0546 8.4558C8.0546 7.8999 8.517 7.4375 9.0729 7.4375C10.5536 7.4375 11.7606 6.2305 11.7606 4.7498C11.7606 3.2691 10.5536 2.0621 9.0729 2.0621H4.7362ZM4.7362 16.9116C2.1216 16.9116 0 14.79 0 12.1754C0 10.7474 0.6613 9.4027 1.8071 8.4898L1.8394 8.4694L1.8071 8.449C0.6613 7.5344 0 6.1897 0 4.7617C0 2.1471 2.1216 0.0152942 4.7362 0.0152942H9.0729C11.6875 0.0152942 13.8091 2.1471 13.8091 4.7515C13.8091 6.1795 13.1478 7.5242 12.002 8.4371L11.9697 8.4575L12.002 8.4779C13.1461 9.3908 13.8091 10.7355 13.8091 12.1635C13.8091 14.7781 11.6875 16.8997 9.0729 16.8997H4.7362V16.9099V16.9116ZM48.5214 14.926C48.28 14.8206 47.9961 14.8206 47.7547 14.926C47.6289 14.9787 47.5235 15.0416 47.4181 15.147C47.2396 15.3255 47.124 15.5873 47.124 15.861C47.124 16.1347 47.2294 16.3863 47.4181 16.5648C47.5235 16.66 47.617 16.7331 47.7547 16.7858C47.8703 16.8385 48.0063 16.8589 48.1321 16.8589C48.2579 16.8589 48.3956 16.8385 48.5095 16.7858C48.6353 16.7331 48.7407 16.66 48.8461 16.5648C49.0246 16.3863 49.1402 16.1245 49.1402 15.861C49.1402 15.5975 49.0246 15.3255 48.8461 15.147C48.7407 15.0416 48.6472 14.9787 48.5095 14.926H48.5197H48.5214ZM28.4784 14.5435H28.5107C28.7317 14.45 28.9204 14.3225 29.1091 14.1763C29.7279 13.6833 30.1376 12.937 30.1376 12.087C30.1376 10.6165 28.9408 9.28881 27.4703 9.28881H23.1336C22.9551 9.28881 22.7664 9.30921 22.5981 9.34151C22.4519 9.37211 22.304 9.42481 22.168 9.47751C22.1476 9.48771 22.1153 9.49791 22.0949 9.49791C21.9793 9.55061 21.8637 9.61351 21.7481 9.68661C21.7324 9.69653 21.7143 9.70444 21.6963 9.71229C21.6773 9.72059 21.6584 9.72883 21.6427 9.73931C21.6312 9.7446 21.623 9.7531 21.6148 9.76147C21.6073 9.76924 21.5998 9.7769 21.59 9.78181C20.9185 10.2646 20.4663 11.1826 20.4663 12.0751C20.4663 13.5456 21.6631 14.7424 23.1336 14.7424H27.4703C27.8273 14.7424 28.1639 14.6693 28.4784 14.5435ZM60.3092 14.5588H60.3398H60.3415C60.5625 14.4653 60.7512 14.3378 60.9399 14.1916C61.5587 13.6986 61.9684 12.9523 61.9684 12.1023C61.9684 10.6318 60.7716 9.3041 59.3011 9.3041H54.9644C54.7859 9.3041 54.5972 9.3245 54.4289 9.3568C54.2827 9.3874 54.1348 9.4401 53.9988 9.4928C53.9784 9.503 53.9461 9.5132 53.9257 9.5132C53.8101 9.5659 53.6945 9.6288 53.5789 9.7019C53.5628 9.7121 53.5445 9.72018 53.5262 9.72825C53.508 9.73633 53.4897 9.7444 53.4735 9.7546C53.4633 9.7597 53.4552 9.76778 53.4472 9.77585C53.4391 9.78393 53.431 9.792 53.4208 9.7971C52.7493 10.2799 52.2971 11.1979 52.2971 12.0904C52.2971 13.5609 53.4939 14.7577 54.9644 14.7577H59.3011C59.6581 14.7577 59.9947 14.6846 60.3092 14.5588ZM62.203 15.8595L62.2183 15.8459V15.9341C62.2183 16.4509 62.6365 16.8691 63.1533 16.8691C63.6701 16.8691 64.0883 16.4509 64.0883 15.9341V8.14811C64.0883 7.63131 63.6701 7.21311 63.1533 7.21311C62.6365 7.21311 62.2183 7.63131 62.2183 8.14811V8.25209C61.4118 7.59926 60.3988 7.2029 59.2977 7.2029H54.961C54.6363 7.2029 54.3099 7.2352 54.0056 7.2981C53.4905 7.4035 53.0179 7.6126 52.5776 7.8659C52.5376 7.88805 52.4979 7.9084 52.459 7.92833L52.4589 7.92837C52.4053 7.95585 52.3532 7.98255 52.3039 8.0121C52.2676 8.03666 52.238 8.06463 52.2094 8.09174C52.1885 8.11154 52.1681 8.13088 52.1458 8.1481C50.9796 9.0202 50.2027 10.5264 50.2027 12.0904C50.2027 14.7152 52.3345 16.8589 54.9712 16.8589H59.3079C59.4448 16.8589 59.5709 16.8419 59.698 16.8248L59.6982 16.8248C59.7462 16.8183 59.7945 16.8118 59.8434 16.8062C59.9005 16.7976 59.9597 16.7945 60.0193 16.7913H60.0193C60.1016 16.7869 60.1844 16.7824 60.2633 16.7637C60.8821 16.6379 61.4601 16.3863 61.965 16.0497C62.0514 15.9935 62.1271 15.9265 62.203 15.8595ZM66.8202 3.9049C67.0616 3.7995 67.3455 3.7995 67.5869 3.9049H67.5852H67.575C67.7127 3.9576 67.8062 4.0205 67.9116 4.1259C68.0901 4.3044 68.2057 4.5764 68.2057 4.8399C68.2057 5.1034 68.0901 5.3652 67.9116 5.5437C67.8062 5.6389 67.7008 5.712 67.575 5.7647C67.4594 5.8174 67.3234 5.8378 67.1976 5.8378C67.0718 5.8378 66.9358 5.8174 66.8202 5.7647C66.6825 5.712 66.589 5.6389 66.4836 5.5437C66.2949 5.3652 66.1895 5.1136 66.1895 4.8399C66.1895 4.5662 66.3051 4.3044 66.4836 4.1259C66.589 4.0205 66.6944 3.9576 66.8202 3.9049ZM68.1343 8.279C68.1343 7.7622 67.7161 7.344 67.1993 7.344C66.6825 7.344 66.2643 7.7622 66.2643 8.279V15.9341C66.2643 16.4509 66.6825 16.8691 67.1993 16.8691C67.7161 16.8691 68.1343 16.4509 68.1343 15.9341V8.279ZM34.8313 3.9049C35.0727 3.7995 35.3566 3.7995 35.598 3.9049H35.5963H35.5861C35.7238 3.9576 35.8173 4.0205 35.9227 4.1259C36.1012 4.3044 36.2168 4.5764 36.2168 4.8399C36.2168 5.1034 36.1012 5.3652 35.9227 5.5437C35.8173 5.6389 35.7119 5.712 35.5861 5.7647C35.4705 5.8174 35.3345 5.8378 35.2087 5.8378C35.0829 5.8378 34.9469 5.8174 34.8313 5.7647C34.6936 5.712 34.6001 5.6389 34.4947 5.5437C34.306 5.3652 34.2006 5.1136 34.2006 4.8399C34.2006 4.5662 34.3162 4.3044 34.4947 4.1259C34.6001 4.0205 34.7055 3.9576 34.8313 3.9049ZM36.1556 8.279C36.1556 7.7622 35.7374 7.344 35.2206 7.344C34.7038 7.344 34.2856 7.7622 34.2856 8.279V16.065C34.2856 16.5818 34.7038 17 35.2206 17C35.7374 17 36.1556 16.5818 36.1556 16.065V8.279ZM42.3929 9.35681V14.3361C42.3929 14.535 42.5612 14.7033 42.7601 14.7033H43.8515C44.3666 14.7033 44.7865 15.1249 44.7865 15.6383C44.7865 16.1517 44.3666 16.8334 43.8515 16.8334H42.1294C41.2471 16.8334 40.5229 15.8576 40.5229 14.9651V9.35681H39.4094C38.8943 9.35681 38.4744 8.9369 38.4744 8.42181C38.4744 7.9067 38.8943 7.3559 39.4094 7.3559H40.5229V4.8246C40.5229 4.3095 40.9428 3.8896 41.4579 3.8896C41.973 3.8896 42.3929 4.3095 42.3929 4.8246V7.3559H43.8532C44.3683 7.3559 44.7882 7.9067 44.7882 8.42181C44.7882 8.9369 44.3683 9.35681 43.8532 9.35681H42.3929Z",
                            fill: "currentColor",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "shape-outline",
                        viewBox: "0 0 182 206",
                        children: (0, s.jsx)("path", {
                            d: "M87.25 1.74242C89.5705 0.40267 92.4295 0.402668 94.75 1.74241L176.817 49.1236C179.137 50.4634 180.567 52.9393 180.567 55.6188V150.381C180.567 153.061 179.137 155.537 176.817 156.876L94.75 204.258C92.4295 205.597 89.5705 205.597 87.25 204.258L5.18336 156.876C2.86285 155.537 1.43336 153.061 1.43336 150.381V55.6188C1.43336 52.9393 2.86285 50.4634 5.18336 49.1236L87.25 1.74242Z"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "arrow-left",
                        viewBox: "0 0 41 8",
                        children: (0, s.jsx)("path", {
                            d: "M0.646447 3.64645C0.451184 3.84171 0.451184 4.15829 0.646447 4.35355L3.82843 7.53553C4.02369 7.7308 4.34027 7.7308 4.53553 7.53553C4.7308 7.34027 4.7308 7.02369 4.53553 6.82843L1.70711 4L4.53553 1.17157C4.7308 0.976311 4.7308 0.659728 4.53553 0.464466C4.34027 0.269204 4.02369 0.269204 3.82843 0.464466L0.646447 3.64645ZM1 4.5H41V3.5H1V4.5Z"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "arrow-right",
                        viewBox: "0 0 41 8",
                        children: (0, s.jsx)("path", {
                            d: "M40.3536 4.20609C40.5488 4.01083 40.5488 3.69425 40.3536 3.49899L37.1716 0.317005C36.9763 0.121743 36.6597 0.121743 36.4645 0.317005C36.2692 0.512267 36.2692 0.82885 36.4645 1.02411L39.2929 3.85254L36.4645 6.68097C36.2692 6.87623 36.2692 7.19281 36.4645 7.38807C36.6597 7.58334 36.9763 7.58334 37.1716 7.38807L40.3536 4.20609ZM0 4.35254H40V3.35254H0V4.35254Z"
                        })
                    }), (0, s.jsxs)("symbol", {
                        id: "arrow-prev",
                        viewBox: "0 0 19 18",
                        children: [(0, s.jsx)("path", {
                            d: "M13.094 14.7322C12.6477 15.1785 11.924 15.1785 11.4777 14.7322L6.9063 10.1607C6.45999 9.71442 6.45999 8.9908 6.9063 8.54449C7.35262 8.09817 8.07623 8.09817 8.52255 8.54449L13.094 13.1159C13.5403 13.5622 13.5403 14.2858 13.094 14.7322Z",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        }), (0, s.jsx)("path", {
                            d: "M13.094 3.97306C12.6477 3.52675 11.924 3.52675 11.4777 3.97306L6.9063 8.54449C6.45999 8.9908 6.45999 9.71442 6.9063 10.1607C7.35262 10.607 8.07623 10.607 8.52255 10.1607L13.094 5.5893C13.5403 5.14299 13.5403 4.41937 13.094 3.97306Z",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        })]
                    }), (0, s.jsxs)("symbol", {
                        id: "arrow-next",
                        viewBox: "0 0 16 17",
                        children: [(0, s.jsx)("path", {
                            d: "M4.90627 2.97292C5.35258 2.52661 6.0762 2.52661 6.52251 2.97292L11.0939 7.54435C11.5403 7.99066 11.5403 8.71428 11.0939 9.16059C10.6476 9.6069 9.92401 9.6069 9.4777 9.16059L4.90627 4.58916C4.45995 4.14285 4.45995 3.41923 4.90627 2.97292Z",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        }), (0, s.jsx)("path", {
                            d: "M4.90627 13.732C5.35258 14.1783 6.0762 14.1783 6.52251 13.732L11.0939 9.16059C11.5403 8.71428 11.5403 7.99066 11.0939 7.54435C10.6476 7.09803 9.92401 7.09803 9.4777 7.54435L4.90627 12.1158C4.45995 12.5621 4.45995 13.2857 4.90627 13.732Z",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        })]
                    }), (0, s.jsx)("symbol", {
                        id: "check-icon",
                        viewBox: "0 0 16 16",
                        children: (0, s.jsx)("path", {
                            d: "M7.09835 13.0015C6.97778 13.122 6.815 13.1884 6.64318 13.1884C6.47136 13.1884 6.30859 13.122 6.18801 13.0015L2.56775 9.37519C2.19096 8.99839 2.19096 8.38949 2.56775 8.01269L3.02292 7.55752C3.39972 7.18073 4.00862 7.18073 4.38542 7.55752L6.64921 9.82131L12.7563 3.71119C13.1331 3.33439 13.742 3.33439 14.1188 3.71119L14.574 4.16636C14.9508 4.54315 14.9508 5.15205 14.574 5.52885L7.09835 13.0015Z"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "linkedin-icon",
                        viewBox: "0 0 16 16",
                        children: (0, s.jsx)("path", {
                            d: "M4.87605 3.52395C4.87605 3.86793 4.75331 4.16031 4.50781 4.40109C4.26231 4.64187 3.94909 4.76226 3.56815 4.76226C3.18721 4.76226 2.87822 4.64187 2.64119 4.40109C2.40416 4.16031 2.28564 3.86363 2.28564 3.51106C2.28564 3.15848 2.40416 2.8661 2.64119 2.63392C2.87822 2.40173 3.19144 2.28564 3.58085 2.28564C3.97026 2.28564 4.27924 2.40173 4.50781 2.63392C4.73638 2.8661 4.85912 3.16278 4.87605 3.52395ZM2.36145 13.7142V5.74261H4.79949V13.7142H2.36145ZM6.19695 5.7426C6.23081 6.70573 6.24774 7.55706 6.24774 8.29661V13.7142H8.71117V9.12215C8.71117 8.81257 8.73657 8.60619 8.78736 8.503C9.02439 7.88384 9.43919 7.57427 10.0318 7.57427C10.8614 7.57427 11.2762 8.15042 11.2762 9.30274V13.7142H13.7142V8.99316C13.7142 7.85804 13.456 7.00241 12.9396 6.42625C12.4232 5.85009 11.7418 5.56201 10.8952 5.56201C9.79474 5.56201 8.99053 5.99198 8.48261 6.85192H8.43181L8.30483 5.7426H6.19695Z",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "twitter-icon",
                        viewBox: "0 0 16 16",
                        children: (0, s.jsx)("path", {
                            d: "M3.42854 2C2.16617 2 1.14282 2.89543 1.14282 4V12C1.14282 13.1046 2.16617 14 3.42854 14H12.5714C13.8338 14 14.8571 13.1046 14.8571 12V4C14.8571 2.89543 13.8338 2 12.5714 2H3.42854ZM4.10966 4.57143H6.7015L8.54206 6.85993L10.7755 4.57143H11.5918L8.91068 7.31808L12.2168 11.4286H9.6256L7.48976 8.77344L4.89792 11.4286H4.0816L7.12114 8.31529L4.10966 4.57143ZM5.35966 5.14286L9.96616 10.8571H10.9668L6.3603 5.14286H5.35966Z"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "instagram-icon",
                        viewBox: "0 0 16 16",
                        children: (0, s.jsx)("path", {
                            d: "M14.8091 10.8291C14.8411 10.307 14.8571 9.36394 14.8571 7.99996C14.8571 6.63599 14.8411 5.69294 14.8091 5.17079C14.7451 3.92403 14.377 2.965 13.7049 2.29367C13.0328 1.62234 12.078 1.25471 10.8404 1.19077C10.3177 1.15881 9.37353 1.14282 8.00797 1.14282C6.6424 1.14282 5.69825 1.15881 5.17549 1.19077C3.93795 1.24405 2.9778 1.61168 2.29501 2.29367C1.61223 2.97566 1.24417 3.93469 1.19083 5.17079C1.15882 5.69294 1.14282 6.63599 1.14282 7.99996C1.14282 9.36394 1.15882 10.307 1.19083 10.8291C1.24417 12.0759 1.61223 13.0349 2.29501 13.7063C2.9778 14.3776 3.93795 14.7452 5.17549 14.8092C5.70892 14.8411 6.65307 14.8571 8.00797 14.8571C9.36286 14.8571 10.307 14.8411 10.8404 14.8092C12.0673 14.7559 13.0221 14.3882 13.7049 13.7063C14.3877 13.0243 14.7558 12.0652 14.8091 10.8291ZM8.00841 2.37358H6.37613C6.16276 2.37358 5.87472 2.38424 5.51199 2.40555C5.14926 2.42686 4.84521 2.4535 4.59984 2.48547C4.35446 2.51744 4.1411 2.57605 3.95973 2.6613C3.66101 2.77851 3.39964 2.94901 3.1756 3.17278C2.95156 3.39656 2.77554 3.65763 2.64751 3.956C2.5835 4.1265 2.53016 4.33962 2.48749 4.59536C2.44481 4.85111 2.41281 5.16013 2.39147 5.52244C2.37013 5.88474 2.3648 6.16712 2.37547 6.36959C2.38614 6.57205 2.38614 6.8864 2.37547 7.31264C2.3648 7.73889 2.3648 7.96799 2.37547 7.99996C2.38614 8.03193 2.38614 8.26103 2.37547 8.68727C2.3648 9.11351 2.3648 9.42786 2.37547 9.63033C2.38614 9.83279 2.39147 10.1152 2.39147 10.4775C2.39147 10.8398 2.42348 11.1488 2.48749 11.4046L2.64751 12.0439C2.77554 12.3423 2.95156 12.6034 3.1756 12.8271C3.39964 13.0509 3.66101 13.2214 3.95973 13.3386C4.13043 13.4026 4.34379 13.4612 4.59984 13.5144C4.85588 13.5677 5.15993 13.5944 5.51199 13.5944C5.86405 13.5944 6.1521 13.605 6.37613 13.6263C6.60017 13.6476 6.91489 13.6476 7.32029 13.6263C7.7257 13.605 7.95506 13.605 8.00841 13.6263C8.06175 13.6476 8.28578 13.6476 8.68052 13.6263C9.07525 13.605 9.38997 13.605 9.62468 13.6263C9.85938 13.6476 10.1474 13.637 10.4888 13.5944C10.8302 13.5517 11.1396 13.5251 11.417 13.5144C11.6944 13.5038 11.9024 13.4452 12.0411 13.3386C12.3398 13.2214 12.6065 13.0509 12.8412 12.8271C13.0759 12.6034 13.2466 12.3423 13.3533 12.0439C13.4173 11.8734 13.4707 11.6603 13.5133 11.4046C13.556 11.1488 13.588 10.8398 13.6093 10.4775C13.6307 10.1152 13.636 9.83279 13.6253 9.63033C13.6147 9.42786 13.6147 9.11351 13.6253 8.68727C13.636 8.26103 13.636 8.03193 13.6253 7.99996C13.6147 7.96799 13.6147 7.73889 13.6253 7.31264C13.636 6.8864 13.636 6.57205 13.6253 6.36959C13.6147 6.16712 13.6093 5.88474 13.6093 5.52244C13.6093 5.16013 13.5773 4.85111 13.5133 4.59536L13.3533 3.956C13.2359 3.65763 13.0652 3.39656 12.8412 3.17278C12.6172 2.94901 12.3505 2.77851 12.0411 2.6613C11.8704 2.59736 11.6624 2.53875 11.417 2.48547C11.1716 2.43219 10.8622 2.40555 10.4888 2.40555C10.1154 2.40555 9.82738 2.3949 9.62468 2.37358C9.42197 2.35227 9.10726 2.35227 8.68052 2.37358C8.25378 2.3949 8.02974 2.3949 8.00841 2.37358ZM12.2487 4.91505C12.4087 4.75521 12.4887 4.5634 12.4887 4.33963C12.51 4.11585 12.43 3.92404 12.2487 3.7642C12.0673 3.60436 11.8699 3.52444 11.6566 3.52444C11.4432 3.52444 11.2512 3.60436 11.0805 3.7642C10.9098 3.92404 10.8298 4.11585 10.8404 4.33963C10.8511 4.5634 10.9311 4.75521 11.0805 4.91505C11.2298 5.07489 11.4219 5.15481 11.6566 5.15481C11.8913 5.15481 12.0886 5.07489 12.2487 4.91505ZM11.5125 7.99997C11.5125 8.96967 11.1712 9.80083 10.4884 10.4935C9.80559 11.1861 8.97879 11.5271 8.00796 11.5165C7.03713 11.5058 6.205 11.1648 5.51154 10.4935C4.81809 9.82214 4.4767 8.99098 4.48737 7.99997C4.49804 7.00895 4.83943 6.17779 5.51154 5.50646C6.18366 4.83513 7.01579 4.49414 8.00796 4.48348C9.00013 4.47283 9.82693 4.81382 10.4884 5.50646C11.1498 6.1991 11.4912 7.03027 11.5125 7.99997ZM10.2807 7.99997C10.2807 7.37126 10.062 6.83314 9.6246 6.38558C9.18719 5.93803 8.64844 5.71425 8.00833 5.71425C7.36822 5.71425 6.82947 5.93803 6.39206 6.38558C5.95465 6.83314 5.73062 7.37126 5.71995 7.99997C5.70928 8.62867 5.93332 9.1668 6.39206 9.61435C6.85081 10.0619 7.38956 10.2857 8.00833 10.2857C8.62711 10.2857 9.16586 10.0619 9.6246 9.61435C10.0833 9.1668 10.302 8.62867 10.2807 7.99997Z",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "youtube-icon",
                        viewBox: "0 0 16 16",
                        children: (0, s.jsx)("path", {
                            d: "M14.5705 2.3116C14.4128 1.7956 13.9479 1.3888 13.3581 1.2508C12.2884 1 7.99996 1 7.99996 1C7.99996 1 3.71151 1 2.64179 1.2508C2.05208 1.3888 1.58717 1.7956 1.42945 2.3116C1.14282 3.2476 1.14282 7.8 1.14282 7.8C1.14282 7.8 1.14282 12.3524 1.42945 13.2884C1.58717 13.8044 2.05208 14.2112 2.64179 14.3492C3.71151 14.6 7.99996 14.6 7.99996 14.6C7.99996 14.6 12.2884 14.6 13.3581 14.3492C13.9485 14.2112 14.4128 13.8044 14.5705 13.2884C14.8571 12.3524 14.8571 7.8 14.8571 7.8C14.8571 7.8 14.8571 3.2476 14.5705 2.3116ZM6.62854 9.3588V6.2412C6.62854 6.0102 6.91448 5.8662 7.14282 5.9814L10.2285 7.5402C10.4569 7.6554 10.4569 7.9446 10.2285 8.0598L7.14282 9.6186C6.91448 9.7344 6.62854 9.5898 6.62854 9.3588Z"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "arrow-right-2",
                        viewBox: "0 0 16 18",
                        children: (0, s.jsx)("path", {
                            fillRule: "evenodd",
                            clipRule: "evenodd",
                            d: "M2.40039 8.85274C2.40039 8.52137 2.66902 8.25274 3.00039 8.25274H11.5107L8.18453 5.08524C7.94566 4.85556 7.93821 4.47574 8.16789 4.23687C8.39757 3.99801 8.77739 3.99056 9.01626 4.22024L13.4163 8.42024C13.5339 8.53336 13.6004 8.68953 13.6004 8.85274C13.6004 9.01595 13.5339 9.17212 13.4163 9.28524L9.01626 13.4852C8.77739 13.7149 8.39757 13.7075 8.16789 13.4686C7.93822 13.2298 7.94566 12.8499 8.18453 12.6202L11.5107 9.45274H3.00039C2.66902 9.45274 2.40039 9.18411 2.40039 8.85274Z",
                            fill: "currentColor"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "plus",
                        width: "16",
                        height: "17",
                        viewBox: "0 0 16 17",
                        fill: "none",
                        children: (0, s.jsx)("path", {
                            fillRule: "evenodd",
                            clipRule: "evenodd",
                            d: "M8.00042 2.42773C8.6316 2.42773 9.14328 2.93941 9.14328 3.57059V6.99916H12.5718C13.203 6.99916 13.7147 7.51084 13.7147 8.14202C13.7147 8.7732 13.203 9.28488 12.5718 9.28488H9.14328V12.7134C9.14328 13.3446 8.6316 13.8563 8.00042 13.8563C7.36924 13.8563 6.85756 13.3446 6.85756 12.7134V9.28488H3.42899C2.79781 9.28488 2.28613 8.7732 2.28613 8.14202C2.28613 7.51084 2.79781 6.99916 3.42899 6.99916H6.85756V3.57059C6.85756 2.93941 7.36924 2.42773 8.00042 2.42773Z",
                            fill: "currentColor"
                        })
                    }), (0, s.jsx)("symbol", {
                        id: "minus",
                        width: "16",
                        height: "17",
                        viewBox: "0 0 16 17",
                        fill: "none",
                        children: (0, s.jsx)("path", {
                            fillRule: "evenodd",
                            clipRule: "evenodd",
                            d: "M2.28613 8.14286C2.28613 7.51167 2.79781 7 3.42899 7H12.5718C13.203 7 13.7147 7.51167 13.7147 8.14286C13.7147 8.77404 13.203 9.28571 12.5718 9.28571H3.42899C2.79781 9.28571 2.28613 8.77404 2.28613 8.14286Z",
                            fill: "currentColor"
                        })
                    })]
                }),
                v = n(1519),
                y = n(169),
                x = n(4970),
                E = n(6704),
                _ = n.n(E),
                b = n(4358),
                w = n(3759),
                C = n(5700),
                S = function(e, t, n, r) {
                    void 0 === t && (t = C.ZT), void 0 === n && (n = {}), void 0 === r && (r = [e]);
                    var i = n.event,
                        s = n.target,
                        a = n.options,
                        o = (0, c.useMemo)(function() {
                            var n = "function" == typeof e ? e : "string" == typeof e ? function(t) {
                                return t.key === e
                            } : e ? function() {
                                return !0
                            } : function() {
                                return !1
                            };
                            return function(e) {
                                if (n(e)) return t(e)
                            }
                        }, r);
                    (0, w.Z)(void 0 === i ? "keydown" : i, o, s, a)
                },
                I = ["mousedown", "touchstart"],
                M = function(e, t, n) {
                    void 0 === n && (n = I);
                    var r = (0, c.useRef)(t);
                    (0, c.useEffect)(function() {
                        r.current = t
                    }, [t]), (0, c.useEffect)(function() {
                        for (var t = function(t) {
                                var n = e.current;
                                n && !n.contains(t.target) && r.current(t)
                            }, i = 0, s = n; i < s.length; i++) {
                            var a = s[i];
                            (0, C.on)(document, a, t)
                        }
                        return function() {
                            for (var e = 0, r = n; e < r.length; e++) {
                                var i = r[e];
                                (0, C.S1)(document, i, t)
                            }
                        }
                    }, [n, e])
                },
                T = n(9793),
                B = n(6636),
                R = n(5478),
                D = n(774),
                L = n(2153),
                P = n(7146),
                O = n(5026),
                N = n(9814);
            let U = e => e.replace(/^\/|\/$/g, ""),
                F = (0, c.forwardRef)((e, t) => {
                    let {
                        state: n,
                        className: r,
                        onClose: i,
                        ...a
                    } = e, {
                        strings: o
                    } = (0, N.oR)(), l = (0, c.useRef)(null), u = (0, c.useRef)(null);
                    return S("Backspace", () => null == i ? void 0 : i()), (0, s.jsx)("div", {
                        ref: (0, B.Z)(t, l),
                        className: (0, g.cn)("relative flex h-full w-full shrink-0 grow overflow-auto px-margin pointer:scrollbar-hide", "transition-transform duration-500 ease-in-out-cubic will-change-transform", "translate-x-full", {
                            "absolute left-0 top-0 translate-x-full": "exiting" === n,
                            "translate-x-0": "entering" === n || "entered" === n
                        }, r),
                        ...a,
                        children: (0, s.jsx)("div", {
                            ref: u,
                            className: "my-auto grow p-margin md:p-0",
                            children: (0, s.jsxs)("div", {
                                className: "-mt-[var(--header-height)] grid gap-y-spacing-xl md:mt-0",
                                children: [(0, s.jsx)("div", {
                                    className: "relative md:absolute md:left-margin md:top-[3.65rem]",
                                    children: (0, s.jsxs)("button", {
                                        className: "-m-[1rem] inline-flex p-[1rem]",
                                        onClick: i,
                                        children: [(0, s.jsx)("span", {
                                            className: "sr-only",
                                            children: "Back"
                                        }), (0, s.jsx)(P.Z, {
                                            symbol: "arrow-left",
                                            className: "h-[.8rem] w-[4.1rem] fill-white-light"
                                        })]
                                    })
                                }), (0, s.jsxs)("div", {
                                    className: "grid gap-y-spacing-md",
                                    children: [(0, s.jsxs)("div", {
                                        className: "grid gap-y-spacing-sm",
                                        children: [(0, s.jsx)(O.Z, {
                                            component: "h4",
                                            variant: "h4",
                                            className: "",
                                            onClick: i,
                                            children: null == o ? void 0 : o.newsletter.title
                                        }), (0, s.jsx)(O.Z, {
                                            variant: "regular",
                                            paragraph: !0,
                                            className: "",
                                            children: null == o ? void 0 : o.newsletter.description
                                        })]
                                    }), (0, s.jsx)("hr", {
                                        className: "opacity-30"
                                    }), (0, s.jsx)("div", {
                                        children: (0, s.jsx)(R.Z, {
                                            form_id: null == o ? void 0 : o.newsletter.form_id,
                                            fields: null == o ? void 0 : o.newsletter.fields,
                                            submit: null == o ? void 0 : o.newsletter.submit,
                                            className: "[&_.status-message]:absolute [&_.status-message]:left-0 [&_.status-message]:top-full [&_.status-message]:mt-spacing-xs"
                                        })
                                    })]
                                })]
                            })
                        })
                    })
                }),
                k = (0, c.forwardRef)((e, t) => {
                    let {
                        state: n,
                        menuState: r,
                        className: i,
                        onNewsletterClick: a,
                        ...o
                    } = e, {
                        asPath: l
                    } = (0, b.useRouter)(), {
                        strings: u,
                        menu: h
                    } = (0, N.oR)(), d = (0, c.useRef)(null), f = (0, c.useRef)(null), p = (0, c.useMemo)(() => (null == h ? void 0 : h.main_menu_01.menu) || [], [h]), A = (0, c.useMemo)(() => (null == h ? void 0 : h.main_menu_02.menu) || [], [h]), m = (0, c.useMemo)(() => (null == h ? void 0 : h.main_menu_03.menu) || [], [h]), y = (0, c.useCallback)(e => U(e) === U(l), [l]);
                    return (0, v.Z)(() => {
                        let e = new T.Z({
                                smoothWheel: !0,
                                wrapper: d.current,
                                content: f.current
                            }),
                            t = t => {
                                e.raf(1e3 * t)
                            };
                        return x.ZP.ticker.add(t), () => {
                            x.ZP.ticker.remove(t), e.destroy()
                        }
                    }, []), (0, s.jsx)("div", {
                        ref: (0, B.Z)(t, d),
                        className: (0, g.cn)("relative flex h-full w-full shrink-0 grow overflow-auto px-margin pointer:scrollbar-hide", "transition-transform duration-500 ease-in-out-cubic will-change-transform", "translate-x-0", {
                            "absolute left-0 top-0 -translate-x-full": "exiting" === n,
                            "translate-x-0": "entering" === n,
                            "-translate-x-full": "exited" === n
                        }, i),
                        ...o,
                        children: (0, s.jsxs)("div", {
                            ref: f,
                            className: "my-auto grid grow gap-y-spacing-md p-margin md:gap-y-spacing-lg md:p-0",
                            children: [(0, s.jsx)("nav", {
                                children: (0, s.jsx)("ul", {
                                    children: (0, s.jsx)("li", {
                                        className: (0, g.cn)("flex", "transition-transform duration-500 ease-out-cubic", {
                                            "translate-x-[2rem]": "exiting" === r || "exited" === r,
                                            "translate-x-0": "entering" === r || "entered" === r
                                        }),
                                        style: {
                                            transitionDelay: "".concat(300, "ms")
                                        },
                                        children: (0, s.jsx)(_(), {
                                            href: "/",
                                            scroll: !1,
                                            className: (0, g.cn)("-my-2 inline-flex overflow-hidden py-2", "transition-opacity duration-300 ease-out-cubic", "hover:opacity-50", {
                                                "pointer-events-none opacity-20": y("/")
                                            }),
                                            children: (0, s.jsx)("span", {
                                                className: (0, g.cn)("inline-flex", "transition-transform duration-500 ease-out-cubic", {
                                                    "translate-y-[150%] md:translate-y-[130%]": "exiting" === r || "exited" === r,
                                                    "translate-y-0": "entering" === r || "entered" === r
                                                }),
                                                style: {
                                                    transitionDelay: "".concat(300, "ms")
                                                },
                                                children: (0, s.jsx)(O.Z, {
                                                    variant: "h4",
                                                    children: null == u ? void 0 : u.home
                                                })
                                            })
                                        })
                                    })
                                })
                            }), (0, s.jsx)("nav", {
                                children: (0, s.jsxs)("ul", {
                                    className: "grid",
                                    children: [(0, s.jsx)("li", {
                                        className: (0, g.cn)("flex overflow-hidden py-2", "transition-transform duration-500 ease-out-cubic", {
                                            "translate-x-[2rem]": "exiting" === r || "exited" === r,
                                            "translate-x-0": "entering" === r || "entered" === r
                                        }),
                                        style: {
                                            transitionDelay: "".concat(300, "ms")
                                        },
                                        children: (0, s.jsx)("span", {
                                            className: (0, g.cn)("inline-flex", "transition-transform duration-500 ease-out-cubic", {
                                                "translate-y-[150%] md:translate-y-[130%]": "exiting" === r || "exited" === r,
                                                "translate-y-0": "entering" === r || "entered" === r
                                            }),
                                            style: {
                                                transitionDelay: "".concat(300, "ms")
                                            },
                                            children: (0, s.jsx)(O.Z, {
                                                variant: "regular",
                                                className: "text-text-secondary-dark",
                                                children: null == u ? void 0 : u.services
                                            })
                                        })
                                    }), p.map((e, t) => {
                                        let {
                                            title: n,
                                            url: i
                                        } = e;
                                        return (0, s.jsxs)("li", {
                                            className: (0, g.cn)("relative flex py-spacing-xs", "transition-transform duration-500 ease-out-cubic", {
                                                "translate-x-[2rem]": "exiting" === r || "exited" === r,
                                                "translate-x-0": "entering" === r || "entered" === r
                                            }),
                                            style: {
                                                transitionDelay: "".concat(300 + 50 * t, "ms")
                                            },
                                            children: [(0, s.jsx)(_(), {
                                                href: i,
                                                scroll: !1,
                                                className: (0, g.cn)("-my-2 inline-flex overflow-hidden py-2", "transition-all duration-300 ease-out-cubic", "hover:text-text-accent-dark", {
                                                    "pointer-events-none opacity-20": y(i)
                                                }),
                                                children: (0, s.jsx)("span", {
                                                    className: (0, g.cn)("inline-flex", "transition-transform duration-500 ease-out-cubic", {
                                                        "translate-y-[150%] md:translate-y-[130%]": "exiting" === r || "exited" === r,
                                                        "translate-y-0": "entering" === r || "entered" === r
                                                    }),
                                                    style: {
                                                        transitionDelay: "".concat(300 + 50 * t, "ms")
                                                    },
                                                    children: (0, s.jsx)(O.Z, {
                                                        variant: "h4",
                                                        children: n
                                                    })
                                                })
                                            }), (0, s.jsx)("hr", {
                                                className: (0, g.cn)("absolute bottom-0 left-0 w-full origin-left opacity-30", "transition-transform duration-500 ease-out-cubic", {
                                                    "scale-x-0": "exiting" === r || "exited" === r,
                                                    "scale-x-100": "entering" === r || "entered" === r
                                                }),
                                                style: {
                                                    transitionDelay: "".concat(300 + 100 * t, "ms")
                                                }
                                            })]
                                        }, "menu-item-".concat(t))
                                    })]
                                })
                            }), (0, s.jsx)("nav", {
                                children: (0, s.jsx)("ul", {
                                    className: "grid gap-y-spacing-xs",
                                    children: A.map((e, t) => {
                                        let {
                                            title: n,
                                            url: i
                                        } = e;
                                        return (0, s.jsx)("li", {
                                            className: (0, g.cn)("flex", "transition-transform duration-500 ease-out-cubic", {
                                                "translate-x-[2rem]": "exiting" === r || "exited" === r,
                                                "translate-x-0": "entering" === r || "entered" === r
                                            }),
                                            style: {
                                                transitionDelay: "".concat(300 + 50 * (p.length + t), "ms")
                                            },
                                            children: (0, s.jsx)(_(), {
                                                href: i,
                                                scroll: !1,
                                                className: (0, g.cn)("-my-2 inline-flex overflow-hidden py-2", "transition-all duration-300 ease-out-cubic", "hover:text-text-accent-dark", {
                                                    "pointer-events-none opacity-20": y(i)
                                                }),
                                                children: (0, s.jsx)("span", {
                                                    className: (0, g.cn)("inline-flex", "transition-transform duration-500 ease-out-cubic", {
                                                        "translate-y-[150%] md:translate-y-[130%]": "exiting" === r || "exited" === r,
                                                        "translate-x-0": "entering" === r || "entered" === r
                                                    }),
                                                    style: {
                                                        transitionDelay: "".concat(300 + 50 * (p.length + t), "ms")
                                                    },
                                                    children: (0, s.jsx)(O.Z, {
                                                        variant: "h4",
                                                        children: n
                                                    })
                                                })
                                            })
                                        }, "menu-item-".concat(t))
                                    })
                                })
                            }), (0, s.jsx)("nav", {
                                children: (0, s.jsx)("ul", {
                                    className: "grid gap-y-spacing-xs",
                                    children: m.map((e, t) => {
                                        let {
                                            title: n,
                                            url: i
                                        } = e;
                                        return (0, s.jsx)("li", {
                                            className: (0, g.cn)("flex", "transition-transform duration-500 ease-out-cubic", {
                                                "translate-x-[2rem]": "exiting" === r || "exited" === r,
                                                "translate-x-0": "entering" === r || "entered" === r
                                            }),
                                            style: {
                                                transitionDelay: "".concat(300 + 50 * (p.length + A.length + t), "ms")
                                            },
                                            children: (0, s.jsx)(_(), {
                                                href: i,
                                                scroll: !1,
                                                className: (0, g.cn)("group -my-2 inline-flex overflow-hidden py-2", "transition-all duration-300 ease-out-cubic", "text-text-secondary-dark", "hover:text-text-accent-dark", {
                                                    "pointer-events-none opacity-40": y(i)
                                                }),
                                                onClick: e => {
                                                    "#newsletter" === i && (e.preventDefault(), null == a || a())
                                                },
                                                children: (0, s.jsx)("span", {
                                                    className: (0, g.cn)("inline-flex", "transition-transform duration-500 ease-out-cubic", {
                                                        "translate-y-[150%] md:translate-y-[130%]": "exiting" === r || "exited" === r,
                                                        "translate-y-0": "entering" === r || "entered" === r
                                                    }),
                                                    style: {
                                                        transitionDelay: "".concat(300 + 50 * (p.length + A.length + t), "ms")
                                                    },
                                                    children: (0, s.jsx)(O.Z, {
                                                        variant: "h6",
                                                        className: "",
                                                        children: n
                                                    })
                                                })
                                            })
                                        }, "menu-item-".concat(t))
                                    })
                                })
                            }), (0, s.jsx)(D.Z, {
                                className: (0, g.cn)("[&_.label]:transition-transform [&_.label]:duration-500 [&_.label]:ease-out-cubic", {
                                    "[&_.label]:translate-x-[2rem] [&_.label]:translate-y-[180%]": "exiting" === r || "exited" === r,
                                    "[&_.label]:translate-x-0 [&_.label]:translate-y-0": "entering" === r || "entered" === r
                                }),
                                revealDelay: p.length + A.length + m.length
                            }), (0, s.jsx)(L.Z, {
                                className: (0, g.cn)("[&_.icon]:transition-transform [&_.icon]:duration-500 [&_.icon]:ease-out-cubic", {
                                    "[&_.icon]:translate-x-[2rem] [&_.icon]:translate-y-[150%]": "exiting" === r || "exited" === r,
                                    "[&_.icon]:translate-x-0 [&_.icon]:translate-y-0": "entering" === r || "entered" === r
                                }),
                                revealDelay: p.length + A.length + m.length
                            })]
                        })
                    })
                }),
                Q = (0, c.forwardRef)((e, t) => {
                    let {
                        state: n,
                        className: r,
                        onClose: i,
                        ...a
                    } = e, [o, l] = (0, c.useState)(!1), u = (0, c.useRef)(null), d = (0, c.useRef)(null), f = (0, c.useRef)(null);
                    return M(u, () => null == i ? void 0 : i()), S("Escape", () => null == i ? void 0 : i()), (0, s.jsx)("div", {
                        ref: t,
                        className: (0, g.cn)("static", "before:fixed before:left-0 before:top-0 before:z-menu before:h-full before:w-full before:bg-black-dark/0", r),
                        ...a,
                        children: (0, s.jsxs)("div", {
                            ref: u,
                            className: (0, g.cn)("fixed bottom-0 right-0 top-[var(--header-height)] z-menu bg-black-dark md:top-0", "flex w-full overflow-hidden md:w-auto md:max-w-[calc(46rem_+_var(--margin)_*_2)]", "transition-transform duration-500 ease-in-out-cubic will-change-transform", {
                                "translate-x-full duration-0": "entering" === n,
                                "translate-x-0": "entered" === n,
                                "translate-x-full": "exiting" === n
                            }),
                            children: [(0, s.jsx)(h.ZP, {
                                nodeRef: d,
                                in: !o,
                                timeout: 500,
                                unmountOnExit: !0,
                                children: e => (0, s.jsx)(k, {
                                    ref: d,
                                    state: e,
                                    menuState: n,
                                    onNewsletterClick: () => l(!0)
                                })
                            }), (0, s.jsx)(h.ZP, {
                                nodeRef: f,
                                in: o,
                                timeout: 500,
                                unmountOnExit: !0,
                                children: e => (0, s.jsx)(F, {
                                    ref: f,
                                    state: e,
                                    onClose: () => l(!1)
                                })
                            })]
                        })
                    })
                });
            var G = n(4485),
                z = n(217),
                H = n(4543),
                V = n(4937);
            let j = (0, c.forwardRef)((e, t) => {
                    let {
                        state: n,
                        className: r,
                        ...i
                    } = e;
                    return (0, s.jsxs)("button", {
                        ref: t,
                        className: (0, g.cn)("fixed right-[4rem] top-spacing-sm z-hamb h-[4.4rem] w-[4.4rem] -translate-y-[1.5rem] translate-x-[0.8rem] md:right-margin md:top-spacing-lg md:-translate-y-[1.1rem]", r),
                        ...i,
                        children: [(0, s.jsx)("span", {
                            className: "sr-only",
                            children: "Close"
                        }), (0, s.jsx)("span", {
                            className: "absolute left-1/2 top-1/2 h-[.2rem] w-[1.6rem] -translate-x-1/2 -translate-y-1/2 rotate-45",
                            children: (0, s.jsx)("span", {
                                className: (0, g.cn)("absolute left-0 top-0 h-full w-full origin-left bg-text-primary-dark", "transition-transform duration-300 ease-out-cubic", {
                                    "-translate-x-[1rem] scale-x-0 duration-0": "entering" === n,
                                    "translate-x-0 scale-x-100": "entered" === n,
                                    "-translate-x-[1rem] scale-x-0": "exiting" === n
                                })
                            })
                        }), (0, s.jsx)("span", {
                            className: "absolute left-1/2 top-1/2 h-[.2rem] w-[1.6rem] -translate-x-1/2 -translate-y-1/2 -rotate-45",
                            children: (0, s.jsx)("span", {
                                className: (0, g.cn)("absolute left-0 top-0 h-full w-full origin-left bg-text-primary-dark", "transition-transform duration-300 ease-out-cubic", {
                                    "-translate-x-[1rem] scale-x-0 duration-0": "entering" === n,
                                    "translate-x-0 scale-x-100 delay-75": "entered" === n,
                                    "-translate-x-[1rem] scale-x-0 delay-75": "exiting" === n
                                })
                            })
                        })]
                    })
                }),
                W = (0, c.forwardRef)((e, t) => {
                    let {
                        state: n,
                        className: r,
                        ...i
                    } = e;
                    return (0, s.jsxs)("button", {
                        ref: t,
                        className: (0, g.cn)("fixed right-[4rem] top-spacing-sm z-hamb h-[4.4rem] w-[4.4rem] -translate-y-[1.5rem] translate-x-[0.8rem] md:right-margin md:top-spacing-lg md:-translate-y-[1.1rem]", r),
                        "data-motion-hamb": !0,
                        ...i,
                        children: [(0, s.jsx)("span", {
                            className: "sr-only",
                            children: "Menu"
                        }), (0, s.jsx)("span", {
                            className: "absolute left-1/2 top-1/2 h-[.2rem] w-[2.8rem] origin-right -translate-x-1/2 -translate-y-[.5rem]",
                            "data-motion-hamb-line-top": !0,
                            children: (0, s.jsx)("span", {
                                className: (0, g.cn)("absolute left-0 top-0 h-full w-full origin-right bg-text-primary-dark", "transition-transform duration-300 ease-out-cubic", {
                                    "translate-x-[1.5rem] scale-x-0 duration-0": "entering" === n,
                                    "translate-x-0 scale-x-100": "entered" === n,
                                    "translate-x-[1.5rem] scale-x-0": "exiting" === n
                                })
                            })
                        }), (0, s.jsx)("span", {
                            className: "absolute left-1/2 top-1/2 h-[.2rem] w-[2.8rem] origin-right -translate-x-1/2 translate-y-[.3rem]",
                            "data-motion-hamb-line-bot": !0,
                            children: (0, s.jsx)("span", {
                                className: (0, g.cn)("absolute left-0 top-0 h-full w-full origin-right bg-text-primary-dark", "transition-transform duration-300 ease-out-cubic", {
                                    "translate-x-[1.5rem] scale-x-0 duration-0": "entering" === n,
                                    "translate-x-0 scale-x-100 delay-75": "entered" === n,
                                    "translate-x-[1.5rem] scale-x-0 delay-75": "exiting" === n
                                })
                            })
                        })]
                    })
                });
            var Y = e => {
                let {
                    className: t,
                    ...n
                } = e, {
                    strings: r
                } = (0, N.oR)(), i = (0, c.useRef)(null), a = (0, c.useRef)(null), o = (0, c.useRef)(null), l = (0, c.useRef)(null), {
                    context: u,
                    contextSafe: f
                } = (0, y.V)({
                    scope: i
                }), A = (0, z.E)(e => e.menuOpen), m = (0, z.E)(e => e.setState), E = (0, G.mU)(), w = (0, b.useRouter)(), C = () => {
                    m({
                        menuOpen: !0,
                        scrollLocked: !0
                    })
                }, S = () => {
                    m({
                        menuOpen: !1,
                        scrollLocked: !1
                    })
                }, I = f(() => {
                    var e, t, n, r;
                    let i = null === (e = u.selector) || void 0 === e ? void 0 : e.call(u, "[data-motion-logo]"),
                        s = null === (t = u.selector) || void 0 === t ? void 0 : t.call(u, "[data-motion-panel]"),
                        a = null === (n = u.selector) || void 0 === n ? void 0 : n.call(u, "[data-motion-hamb-line-top]"),
                        o = null === (r = u.selector) || void 0 === r ? void 0 : r.call(u, "[data-motion-hamb-line-bot]"),
                        l = x.ZP.timeline();
                    return (0, V.G)() || l.fromTo(s, {
                        yPercent: -100
                    }, {
                        yPercent: 0,
                        duration: 1.2,
                        ease: "power3.inOut"
                    }, 0), l.fromTo(i, {
                        yPercent: 110,
                        autoAlpha: 0
                    }, {
                        yPercent: 0,
                        autoAlpha: 1,
                        duration: 1,
                        ease: "power3.inOut"
                    }, (0, V.G)() ? 0 : .2).fromTo([a, o], {
                        scaleX: 0,
                        x: 15
                    }, {
                        scaleX: 1,
                        x: 0,
                        duration: 1,
                        ease: "power3.inOut",
                        stagger: .1
                    }, (0, V.G)() ? .2 : .3), l
                });
                return (0, v.Z)(() => {
                    let e = p.U2.subscribe(e => e.compiled, t => {
                        t && (e(), "/" === w.asPath && E.add(I(), 2.8))
                    });
                    return () => {
                        e()
                    }
                }, []), (0, v.Z)(() => {
                    let e = H.U.subscribe(e => e.currentRoute, S);
                    return () => {
                        e()
                    }
                }, [m]), (0, s.jsxs)("header", {
                    ref: i,
                    className: (0, g.cn)(["static", t]),
                    ...n,
                    children: [(0, s.jsx)("span", {
                        className: "fixed left-0 top-0 z-header h-[var(--header-height)] w-full bg-black-dark md:hidden",
                        "data-motion-panel": !0
                    }), (0, s.jsx)("div", {
                        className: "fixed left-[4rem] top-spacing-sm z-logo overflow-hidden md:left-margin md:top-spacing-lg",
                        children: (0, s.jsxs)(_(), {
                            href: "/",
                            scroll: !1,
                            className: (0, g.cn)("relative -m-spacing-xxs flex p-spacing-xxs", "/" === w.pathname ? "pointer-events-none" : "pointer-events-all"),
                            children: [(0, s.jsx)("span", {
                                className: "sr-only",
                                children: null == r ? void 0 : r.brand
                            }), (0, s.jsx)(d.Z, {
                                className: "h-[1.3rem] w-[5.3rem] md:h-[1.7rem] md:w-[6.9rem]",
                                "data-motion-logo": !0
                            })]
                        })
                    }), (0, s.jsx)(h.ZP, {
                        nodeRef: o,
                        in: !A,
                        timeout: {
                            enter: 0,
                            exit: 575
                        },
                        unmountOnExit: !0,
                        children: e => (0, s.jsx)(W, {
                            ref: o,
                            state: e,
                            onClick: C
                        })
                    }), (0, s.jsx)(h.ZP, {
                        nodeRef: l,
                        in: A,
                        timeout: {
                            enter: 0,
                            exit: 375
                        },
                        unmountOnExit: !0,
                        children: e => (0, s.jsx)(j, {
                            ref: l,
                            state: e,
                            onClick: S
                        })
                    }), (0, s.jsx)(h.ZP, {
                        nodeRef: a,
                        in: A,
                        timeout: {
                            enter: 0,
                            exit: 500
                        },
                        unmountOnExit: !0,
                        children: e => (0, s.jsx)(Q, {
                            ref: a,
                            state: e,
                            onClose: S
                        })
                    })]
                })
            };
            let X = (0, c.forwardRef)((e, t) => {
                let {
                    id: n,
                    ...r
                } = e;
                return (0, s.jsx)("svg", {
                    ref: t,
                    width: "0",
                    height: "0",
                    ...r,
                    children: (0, s.jsx)("defs", {
                        children: (0, s.jsx)("clipPath", {
                            id: n,
                            clipPathUnits: "objectBoundingBox",
                            children: (0, s.jsx)("path", {
                                d: "M 0 0 L 1 0 L 1 1 L 0 1z"
                            })
                        })
                    })
                })
            });
            var q = n(8061),
                K = e => {
                    let {
                        className: t,
                        ...n
                    } = e, r = (0, c.useRef)(null), i = (0, c.useRef)(null);
                    return (0, v.Z)(() => {
                        let e = H.U.subscribe(e => [e.currentRoute, e.previousRoute], e => {
                            let [t, n] = e;
                            if (t === n) return;
                            let r = x.ZP.utils.selector(i.current)("path");
                            "/" === t ? (document.body.classList.add("home"), x.ZP.timeline().to(r, {
                                keyframes: [{
                                    attr: {
                                        d: "M 0 0 L 1 0 L 1 0 L 0 1z"
                                    },
                                    duration: 1
                                }, {
                                    attr: {
                                        d: "M 0 0 L 1 0 L 1 1 L 0 1z"
                                    },
                                    duration: 1,
                                    delay: -.5
                                }],
                                duration: 1.3,
                                ease: "power2.inOut"
                            })) : n && "/" !== n || (document.body.classList.remove("home"), x.ZP.timeline().to(r, {
                                keyframes: [{
                                    attr: {
                                        d: "M 0 0 L 1 0 L 1 0 L 0 1z"
                                    },
                                    duration: 1
                                }, {
                                    attr: {
                                        d: "M 0 0 L 1 0 L 1 0 L 0 0z"
                                    },
                                    duration: 1,
                                    delay: -.5
                                }],
                                duration: 1.3,
                                ease: "power2.inOut"
                            }))
                        }, {
                            fireImmediately: !0
                        });
                        return () => {
                            e()
                        }
                    }, []), (0, s.jsxs)("div", {
                        ref: r,
                        className: (0, g.cn)("fixed left-0 top-0 z-20 h-full w-full touch-none overflow-hidden", "[clip-path:url(#landing-mask)]", t),
                        ...n,
                        children: [(0, s.jsx)(q.C.Out, {}), (0, s.jsx)(X, {
                            ref: i,
                            id: "landing-mask"
                        })]
                    })
                },
                J = n(410),
                Z = n(5950),
                $ = n(5142),
                ee = n(6222),
                et = {
                    out: "out-in",
                    in: "in-out"
                },
                en = function(e, t, n) {
                    return function() {
                        var r;
                        e.props[t] && (r = e.props)[t].apply(r, arguments), n()
                    }
                },
                er = ((r = {})[et.out] = function(e) {
                    var t = e.current,
                        n = e.changeState;
                    return c.cloneElement(t, { in: !1,
                        onExited: en(t, "onExited", function() {
                            n(h.d0, null)
                        })
                    })
                }, r[et.in] = function(e) {
                    var t = e.current,
                        n = e.changeState,
                        r = e.children;
                    return [t, c.cloneElement(r, { in: !0,
                        onEntered: en(r, "onEntered", function() {
                            n(h.d0)
                        })
                    })]
                }, r),
                ei = ((i = {})[et.out] = function(e) {
                    var t = e.children,
                        n = e.changeState;
                    return c.cloneElement(t, { in: !0,
                        onEntered: en(t, "onEntered", function() {
                            n(h.cn, c.cloneElement(t, { in: !0
                            }))
                        })
                    })
                }, i[et.in] = function(e) {
                    var t = e.current,
                        n = e.children,
                        r = e.changeState;
                    return [c.cloneElement(t, { in: !1,
                        onExited: en(t, "onExited", function() {
                            r(h.cn, c.cloneElement(n, { in: !0
                            }))
                        })
                    }), c.cloneElement(n, { in: !0
                    })]
                }, i),
                es = function(e) {
                    function t() {
                        for (var t, n = arguments.length, r = Array(n), i = 0; i < n; i++) r[i] = arguments[i];
                        return (t = e.call.apply(e, [this].concat(r)) || this).state = {
                            status: h.cn,
                            current: null
                        }, t.appeared = !1, t.changeState = function(e, n) {
                            void 0 === n && (n = t.state.current), t.setState({
                                status: e,
                                current: n
                            })
                        }, t
                    }(0, $.Z)(t, e);
                    var n = t.prototype;
                    return n.componentDidMount = function() {
                        this.appeared = !0
                    }, t.getDerivedStateFromProps = function(e, t) {
                        var n, r;
                        return null == e.children ? {
                            current: null
                        } : t.status === h.d0 && e.mode === et.in ? {
                            status: h.d0
                        } : t.current && !((n = t.current) === (r = e.children) || c.isValidElement(n) && c.isValidElement(r) && null != n.key && n.key === r.key) ? {
                            status: h.Ix
                        } : {
                            current: c.cloneElement(e.children, { in: !0
                            })
                        }
                    }, n.render = function() {
                        var e, t = this.props,
                            n = t.children,
                            r = t.mode,
                            i = this.state,
                            s = i.status,
                            a = i.current,
                            o = {
                                children: n,
                                current: a,
                                changeState: this.changeState,
                                status: s
                            };
                        switch (s) {
                            case h.d0:
                                e = ei[r](o);
                                break;
                            case h.Ix:
                                e = er[r](o);
                                break;
                            case h.cn:
                                e = a
                        }
                        return c.createElement(ee.Z.Provider, {
                            value: {
                                isMounting: !this.appeared
                            }
                        }, e)
                    }, t
                }(c.Component);
            es.propTypes = {}, es.defaultProps = {
                mode: et.out
            };
            var ea = n(7835),
                eo = n.n(ea);
            let el = (0, c.createContext)(void 0);
            var eu = e => {
                let {
                    children: t
                } = e, n = (0, b.useRouter)(), r = (0, c.useRef)(null), i = (0, c.useRef)(null), a = (0, c.useMemo)(() => void 0, []);
                return (0, c.useEffect)(() => {
                    eo().clearScrollMemory("manual"), n.beforePopState(e => (e.options.scroll = !1, !0))
                }, [n]), (0, s.jsx)(el.Provider, {
                    value: a,
                    children: (0, s.jsxs)("main", {
                        className: (0, g.cn)("static"),
                        children: [(0, s.jsx)(es, {
                            mode: "out-in",
                            children: (0, s.jsx)(h.ZP, {
                                appear: !0,
                                nodeRef: r,
                                timeout: {
                                    enter: 0,
                                    exit: 800
                                },
                                unmountOnExit: !0,
                                children: e => (0, s.jsx)("div", {
                                    ref: r,
                                    className: (0, g.cn)("fixed left-0 top-0 z-10 h-screen w-full", "[background:linear-gradient(45deg,rgba(0,0,0,0)_10%,_rgba(0,0,0,0.75)_25%,_rgba(0,0,0,1)_50%,_rgba(0,0,0,1)_65%,_rgba(0,0,0,0)_100%)]", "transition-opacity duration-1000 ease-in-out-cubic", "opacity-0", {
                                        "opacity-0": "exiting" === e,
                                        "opacity-100": ("entering" === e || "entered" === e) && "/" !== n.asPath
                                    })
                                })
                            }, n.asPath)
                        }), (0, s.jsx)(es, {
                            mode: "out-in",
                            children: (0, s.jsx)(h.ZP, {
                                nodeRef: i,
                                timeout: {
                                    enter: 0,
                                    exit: 1400
                                },
                                unmountOnExit: !0,
                                children: e => (0, s.jsx)("div", {
                                    ref: i,
                                    className: (0, g.cn)("relative z-20 h-auto w-full", "transition-opacity duration-1000 ease-in-out-cubic", "opacity-0", {
                                        "opacity-0": "exiting" === e,
                                        "opacity-100": "entering" === e || "entered" === e
                                    }),
                                    children: t
                                })
                            }, n.asPath)
                        })]
                    })
                })
            };
            n(3194);
            var ec = n(8020),
                eh = n(5523);
            let ed = async e => {
                    let {
                        form_id: t
                    } = e.newsletter, {
                        data: {
                            fields: r,
                            button: i
                        }
                    } = ec.q2 ? {
                        data: n(7035)("./".concat(t, ".json"))
                    } : await eh.e.get("".concat(ec.bl.GRAVITY_FORM, "/").concat(t, "/"));
                    return { ...e,
                        newsletter: { ...e.newsletter,
                            submit: i.text,
                            fields: r
                        }
                    }
                },
                ef = e => {
                    let {
                        params: t = {},
                        config: n = {},
                        method: r = "get",
                        url: i = ""
                    } = e;
                    return new Promise(e => eh.e[r](i, t, n).then(e).catch(t => e(t.response)))
                };
            n(7432);
            var ep = n(7650),
                eg = n(6934),
                eA = n(5215),
                em = n(547),
                ev = n(630);
            x.ZP.registerPlugin(eg.MotionPathPlugin, em.ScrollSmoother, ea.ScrollTrigger, ev.SplitText, ep.CustomEase, eA.Observer), ep.CustomEase.create("inOut1", "M0,0 C0.5,0 0.1,1 1,1", {
                precision: 2
            }), ep.CustomEase.create("inOut2", "M0,0 C0.56,0 0,1 1,1", {
                precision: 2
            }), ep.CustomEase.create("inOut3", "M0,0 C0.6,0 0,1 1,1", {
                precision: 2
            }), ep.CustomEase.create("inOut4", "M0,0 C0.4,0 -0.06,1 1,1", {
                precision: 2
            }), u()(() => n.e(830).then(n.bind(n, 8830)), {
                loadableGenerated: {
                    webpack: () => [8830]
                },
                ssr: !1
            });
            let ey = u()(() => Promise.all([n.e(268), n.e(906), n.e(333), n.e(504)]).then(n.bind(n, 5504)), {
                loadableGenerated: {
                    webpack: () => [5504]
                },
                ssr: !1
            });

            function ex(e) {
                var t;
                let {
                    Component: n,
                    pageProps: r,
                    menu: i,
                    strings: a
                } = e, o = null !== (t = n.getLayout) && void 0 !== t ? t : e => e;
                return (0, s.jsx)(N.g3, {
                    home: r.homeProps || r,
                    menu: i,
                    strings: a,
                    children: (0, s.jsx)(Z.f, {
                        fluid: !0,
                        children: (0, s.jsx)(J.UU, {
                            children: (0, s.jsxs)(G.ws, {
                                children: [null, (0, s.jsx)(ey, {}), (0, s.jsx)(A, {}), (0, s.jsx)(Y, {}), (0, s.jsx)(K, {}), (0, s.jsx)(eu, {
                                    children: o((0, s.jsx)(n, { ...r
                                    }), r)
                                }), (0, s.jsx)(m, {})]
                            })
                        })
                    })
                })
            }
            ex.getInitialProps = async e => {
                let t = await o().getInitialProps(e),
                    r = e.router.locale,
                    {
                        data: i
                    } = ec.q2 ? {
                        data: n(4749)
                    } : await ef({
                        method: "get",
                        url: "".concat(ec.bl.MENU_LOCATIONS, "?lang=").concat(r)
                    }),
                    {
                        data: s
                    } = ec.q2 ? {
                        data: n(1625)
                    } : await ef({
                        method: "get",
                        url: "".concat(ec.bl.STRINGS, "?lang=").concat(r)
                    });
                return { ...t,
                    strings: await ed(s),
                    menu: Object.keys(i).length > 0 ? i : {}
                }
            }
        },
        217: function(e, t, n) {
            "use strict";
            n.d(t, {
                E: function() {
                    return u
                }
            });
            var r = n(7929),
                i = n.n(r),
                s = n(9749),
                a = n(2125),
                o = n(4753);
            let l = {
                    menuOpen: !1,
                    scrollLocked: !1,
                    swiperActive: !1,
                    newsletterOpen: !1,
                    scrollDirLocked: null,
                    needsAudioTrigger: !1
                },
                u = (0, s.Ue)((0, a.XR)((0, o.n)(e => ({ ...l,
                    setState: t => e(e => i()(e, t))
                }))))
        },
        6912: function(e, t, n) {
            "use strict";
            let r, i, s, a, o;
            n.d(t, {
                iW: function() {
                    return eW
                },
                G: function() {
                    return eY
                },
                U2: function() {
                    return ej
                }
            });
            var l = n(4970),
                u = n(7489),
                c = n.n(u),
                h = n(7691),
                d = n(9892);
            let f = new WeakMap;
            class p extends d.Loader {
                constructor(e) {
                    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                        position: "POSITION",
                        normal: "NORMAL",
                        color: "COLOR",
                        uv: "TEX_COORD"
                    }, this.defaultAttributeTypes = {
                        position: "Float32Array",
                        normal: "Float32Array",
                        color: "Float32Array",
                        uv: "Float32Array"
                    }
                }
                setDecoderPath(e) {
                    return this.decoderPath = e, this
                }
                setDecoderConfig(e) {
                    return this.decoderConfig = e, this
                }
                setWorkerLimit(e) {
                    return this.workerLimit = e, this
                }
                load(e, t, n, r) {
                    let i = new d.FileLoader(this.manager);
                    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, e => {
                        let n = {
                            attributeIDs: this.defaultAttributeIDs,
                            attributeTypes: this.defaultAttributeTypes,
                            useUniqueIDs: !1
                        };
                        this.decodeGeometry(e, n).then(t).catch(r)
                    }, n, r)
                }
                decodeDracoFile(e, t, n, r) {
                    let i = {
                        attributeIDs: n || this.defaultAttributeIDs,
                        attributeTypes: r || this.defaultAttributeTypes,
                        useUniqueIDs: !!n
                    };
                    this.decodeGeometry(e, i).then(t)
                }
                decodeGeometry(e, t) {
                    let n;
                    for (let e in t.attributeTypes) {
                        let n = t.attributeTypes[e];
                        void 0 !== n.BYTES_PER_ELEMENT && (t.attributeTypes[e] = n.name)
                    }
                    let r = JSON.stringify(t);
                    if (f.has(e)) {
                        let t = f.get(e);
                        if (t.key === r) return t.promise;
                        if (0 === e.byteLength) throw Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                    }
                    let i = this.workerNextTaskID++,
                        s = e.byteLength,
                        a = this._getWorker(i, s).then(r => (n = r, new Promise((r, s) => {
                            n._callbacks[i] = {
                                resolve: r,
                                reject: s
                            }, n.postMessage({
                                type: "decode",
                                id: i,
                                taskConfig: t,
                                buffer: e
                            }, [e])
                        }))).then(e => this._createGeometry(e.geometry));
                    return a.catch(() => !0).then(() => {
                        n && i && this._releaseTask(n, i)
                    }), f.set(e, {
                        key: r,
                        promise: a
                    }), a
                }
                _createGeometry(e) {
                    let t = new d.BufferGeometry;
                    e.index && t.setIndex(new d.BufferAttribute(e.index.array, 1));
                    for (let n = 0; n < e.attributes.length; n++) {
                        let r = e.attributes[n],
                            i = r.name,
                            s = r.array,
                            a = r.itemSize;
                        t.setAttribute(i, new d.BufferAttribute(s, a))
                    }
                    return t
                }
                _loadLibrary(e, t) {
                    let n = new d.FileLoader(this.manager);
                    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((t, r) => {
                        n.load(e, t, void 0, r)
                    })
                }
                preload() {
                    return this._initDecoder(), this
                }
                _initDecoder() {
                    if (this.decoderPending) return this.decoderPending;
                    let e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                        t = [];
                    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(t => {
                        let n = t[0];
                        e || (this.decoderConfig.wasmBinary = t[1]);
                        let r = g.toString(),
                            i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([i]))
                    }), this.decoderPending
                }
                _getWorker(e, t) {
                    return this._initDecoder().then(() => {
                        if (this.workerPool.length < this.workerLimit) {
                            let e = new Worker(this.workerSourceURL);
                            e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                                type: "init",
                                decoderConfig: this.decoderConfig
                            }), e.onmessage = function(t) {
                                let n = t.data;
                                switch (n.type) {
                                    case "decode":
                                        e._callbacks[n.id].resolve(n);
                                        break;
                                    case "error":
                                        e._callbacks[n.id].reject(n);
                                        break;
                                    default:
                                        console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                                }
                            }, this.workerPool.push(e)
                        } else this.workerPool.sort(function(e, t) {
                            return e._taskLoad > t._taskLoad ? -1 : 1
                        });
                        let n = this.workerPool[this.workerPool.length - 1];
                        return n._taskCosts[e] = t, n._taskLoad += t, n
                    })
                }
                _releaseTask(e, t) {
                    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
                }
                debug() {
                    console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
                }
                dispose() {
                    for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                    return this.workerPool.length = 0, this
                }
            }

            function g() {
                let e, t;
                onmessage = function(n) {
                    let r = n.data;
                    switch (r.type) {
                        case "init":
                            e = r.decoderConfig, t = new Promise(function(t) {
                                e.onModuleLoaded = function(e) {
                                    t({
                                        draco: e
                                    })
                                }, DracoDecoderModule(e)
                            });
                            break;
                        case "decode":
                            let i = r.buffer,
                                s = r.taskConfig;
                            t.then(e => {
                                let t = e.draco,
                                    n = new t.Decoder,
                                    a = new t.DecoderBuffer;
                                a.Init(new Int8Array(i), i.byteLength);
                                try {
                                    let e = function(e, t, n, r) {
                                            let i, s;
                                            let a = r.attributeIDs,
                                                o = r.attributeTypes,
                                                l = t.GetEncodedGeometryType(n);
                                            if (l === e.TRIANGULAR_MESH) i = new e.Mesh, s = t.DecodeBufferToMesh(n, i);
                                            else if (l === e.POINT_CLOUD) i = new e.PointCloud, s = t.DecodeBufferToPointCloud(n, i);
                                            else throw Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            if (!s.ok() || 0 === i.ptr) throw Error("THREE.DRACOLoader: Decoding failed: " + s.error_msg());
                                            let u = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (let n in a) {
                                                let s, l;
                                                let c = self[o[n]];
                                                if (r.useUniqueIDs) l = a[n], s = t.GetAttributeByUniqueId(i, l);
                                                else {
                                                    if (-1 === (l = t.GetAttributeId(i, e[a[n]]))) continue;
                                                    s = t.GetAttribute(i, l)
                                                }
                                                u.attributes.push(function(e, t, n, r, i, s) {
                                                    let a = s.num_components(),
                                                        o = n.num_points() * a,
                                                        l = o * i.BYTES_PER_ELEMENT,
                                                        u = function(e, t) {
                                                            switch (t) {
                                                                case Float32Array:
                                                                    return e.DT_FLOAT32;
                                                                case Int8Array:
                                                                    return e.DT_INT8;
                                                                case Int16Array:
                                                                    return e.DT_INT16;
                                                                case Int32Array:
                                                                    return e.DT_INT32;
                                                                case Uint8Array:
                                                                    return e.DT_UINT8;
                                                                case Uint16Array:
                                                                    return e.DT_UINT16;
                                                                case Uint32Array:
                                                                    return e.DT_UINT32
                                                            }
                                                        }(e, i),
                                                        c = e._malloc(l);
                                                    t.GetAttributeDataArrayForAllPoints(n, s, u, l, c);
                                                    let h = new i(e.HEAPF32.buffer, c, o).slice();
                                                    return e._free(c), {
                                                        name: r,
                                                        array: h,
                                                        itemSize: a
                                                    }
                                                }(e, t, i, n, c, s))
                                            }
                                            return l === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                                let r = 3 * n.num_faces(),
                                                    i = 4 * r,
                                                    s = e._malloc(i);
                                                t.GetTrianglesUInt32Array(n, i, s);
                                                let a = new Uint32Array(e.HEAPF32.buffer, s, r).slice();
                                                return e._free(s), {
                                                    array: a,
                                                    itemSize: 1
                                                }
                                            }(e, t, i)), e.destroy(i), u
                                        }(t, n, a, s),
                                        i = e.attributes.map(e => e.array.buffer);
                                    e.index && i.push(e.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: r.id,
                                        geometry: e
                                    }, i)
                                } catch (e) {
                                    console.error(e), self.postMessage({
                                        type: "error",
                                        id: r.id,
                                        error: e.message
                                    })
                                } finally {
                                    t.destroy(a), t.destroy(n)
                                }
                            })
                    }
                }
            }

            function A(e, t) {
                if (t === d.TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
                if (t !== d.TriangleFanDrawMode && t !== d.TriangleStripDrawMode) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e; {
                    let n = e.getIndex();
                    if (null === n) {
                        let t = [],
                            r = e.getAttribute("position");
                        if (void 0 === r) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                        for (let e = 0; e < r.count; e++) t.push(e);
                        e.setIndex(t), n = e.getIndex()
                    }
                    let r = n.count - 2,
                        i = [];
                    if (n) {
                        if (t === d.TriangleFanDrawMode)
                            for (let e = 1; e <= r; e++) i.push(n.getX(0)), i.push(n.getX(e)), i.push(n.getX(e + 1));
                        else
                            for (let e = 0; e < r; e++) e % 2 == 0 ? (i.push(n.getX(e)), i.push(n.getX(e + 1)), i.push(n.getX(e + 2))) : (i.push(n.getX(e + 2)), i.push(n.getX(e + 1)), i.push(n.getX(e)))
                    }
                    i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    let s = e.clone();
                    return s.setIndex(i), s.clearGroups(), s
                }
            }
            let m = parseInt(d.REVISION.replace(/\D+/g, ""));

            function v(e) {
                if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
                let t = "";
                for (let n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (e) {
                    return t
                }
            }
            let y = "srgb",
                x = "srgb-linear";
            class E extends d.Loader {
                constructor(e) {
                    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
                        return new I(e)
                    }), this.register(function(e) {
                        return new M(e)
                    }), this.register(function(e) {
                        return new U(e)
                    }), this.register(function(e) {
                        return new F(e)
                    }), this.register(function(e) {
                        return new k(e)
                    }), this.register(function(e) {
                        return new B(e)
                    }), this.register(function(e) {
                        return new R(e)
                    }), this.register(function(e) {
                        return new D(e)
                    }), this.register(function(e) {
                        return new L(e)
                    }), this.register(function(e) {
                        return new S(e)
                    }), this.register(function(e) {
                        return new P(e)
                    }), this.register(function(e) {
                        return new T(e)
                    }), this.register(function(e) {
                        return new N(e)
                    }), this.register(function(e) {
                        return new O(e)
                    }), this.register(function(e) {
                        return new w(e)
                    }), this.register(function(e) {
                        return new Q(e)
                    }), this.register(function(e) {
                        return new G(e)
                    })
                }
                load(e, t, n, r) {
                    let i;
                    let s = this;
                    if ("" !== this.resourcePath) i = this.resourcePath;
                    else if ("" !== this.path) {
                        let t = d.LoaderUtils.extractUrlBase(e);
                        i = d.LoaderUtils.resolveURL(t, this.path)
                    } else i = d.LoaderUtils.extractUrlBase(e);
                    this.manager.itemStart(e);
                    let a = function(t) {
                            r ? r(t) : console.error(t), s.manager.itemError(e), s.manager.itemEnd(e)
                        },
                        o = new d.FileLoader(this.manager);
                    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(n) {
                        try {
                            s.parse(n, i, function(n) {
                                t(n), s.manager.itemEnd(e)
                            }, a)
                        } catch (e) {
                            a(e)
                        }
                    }, n, a)
                }
                setDRACOLoader(e) {
                    return this.dracoLoader = e, this
                }
                setDDSLoader() {
                    throw Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                }
                setKTX2Loader(e) {
                    return this.ktx2Loader = e, this
                }
                setMeshoptDecoder(e) {
                    return this.meshoptDecoder = e, this
                }
                register(e) {
                    return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
                }
                unregister(e) {
                    return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
                }
                parse(e, t, n, r) {
                    let i;
                    let s = {},
                        a = {};
                    if ("string" == typeof e) i = JSON.parse(e);
                    else if (e instanceof ArrayBuffer) {
                        if (v(new Uint8Array(e.slice(0, 4))) === z) {
                            try {
                                s[b.KHR_BINARY_GLTF] = new V(e)
                            } catch (e) {
                                r && r(e);
                                return
                            }
                            i = JSON.parse(s[b.KHR_BINARY_GLTF].content)
                        } else i = JSON.parse(v(new Uint8Array(e)))
                    } else i = e;
                    if (void 0 === i.asset || i.asset.version[0] < 2) {
                        r && r(Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                        return
                    }
                    let o = new eh(i, {
                        path: t || this.resourcePath || "",
                        crossOrigin: this.crossOrigin,
                        requestHeader: this.requestHeader,
                        manager: this.manager,
                        ktx2Loader: this.ktx2Loader,
                        meshoptDecoder: this.meshoptDecoder
                    });
                    o.fileLoader.setRequestHeader(this.requestHeader);
                    for (let e = 0; e < this.pluginCallbacks.length; e++) {
                        let t = this.pluginCallbacks[e](o);
                        t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[t.name] = t, s[t.name] = !0
                    }
                    if (i.extensionsUsed)
                        for (let e = 0; e < i.extensionsUsed.length; ++e) {
                            let t = i.extensionsUsed[e],
                                n = i.extensionsRequired || [];
                            switch (t) {
                                case b.KHR_MATERIALS_UNLIT:
                                    s[t] = new C;
                                    break;
                                case b.KHR_DRACO_MESH_COMPRESSION:
                                    s[t] = new j(i, this.dracoLoader);
                                    break;
                                case b.KHR_TEXTURE_TRANSFORM:
                                    s[t] = new W;
                                    break;
                                case b.KHR_MESH_QUANTIZATION:
                                    s[t] = new Y;
                                    break;
                                default:
                                    n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                            }
                        }
                    o.setExtensions(s), o.setPlugins(a), o.parse(n, r)
                }
                parseAsync(e, t) {
                    let n = this;
                    return new Promise(function(r, i) {
                        n.parse(e, t, r, i)
                    })
                }
            }

            function _() {
                let e = {};
                return {
                    get: function(t) {
                        return e[t]
                    },
                    add: function(t, n) {
                        e[t] = n
                    },
                    remove: function(t) {
                        delete e[t]
                    },
                    removeAll: function() {
                        e = {}
                    }
                }
            }
            let b = {
                KHR_BINARY_GLTF: "KHR_binary_glTF",
                KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
                KHR_MATERIALS_IOR: "KHR_materials_ior",
                KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
                KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
                EXT_MATERIALS_BUMP: "EXT_materials_bump",
                EXT_TEXTURE_WEBP: "EXT_texture_webp",
                EXT_TEXTURE_AVIF: "EXT_texture_avif",
                EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
            };
            class w {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_LIGHTS_PUNCTUAL, this.cache = {
                        refs: {},
                        uses: {}
                    }
                }
                _markDefs() {
                    let e = this.parser,
                        t = this.parser.json.nodes || [];
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n];
                        r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
                    }
                }
                _loadLight(e) {
                    let t;
                    let n = this.parser,
                        r = "light:" + e,
                        i = n.cache.get(r);
                    if (i) return i;
                    let s = n.json,
                        a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e],
                        o = new d.Color(16777215);
                    void 0 !== a.color && o.setRGB(a.color[0], a.color[1], a.color[2], x);
                    let l = void 0 !== a.range ? a.range : 0;
                    switch (a.type) {
                        case "directional":
                            (t = new d.DirectionalLight(o)).target.position.set(0, 0, -1), t.add(t.target);
                            break;
                        case "point":
                            (t = new d.PointLight(o)).distance = l;
                            break;
                        case "spot":
                            (t = new d.SpotLight(o)).distance = l, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, t.angle = a.spot.outerConeAngle, t.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, t.target.position.set(0, 0, -1), t.add(t.target);
                            break;
                        default:
                            throw Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                    }
                    return t.position.set(0, 0, 0), t.decay = 2, eo(t, a), void 0 !== a.intensity && (t.intensity = a.intensity), t.name = n.createUniqueName(a.name || "light_" + e), i = Promise.resolve(t), n.cache.add(r, i), i
                }
                getDependency(e, t) {
                    if ("light" === e) return this._loadLight(t)
                }
                createNodeAttachment(e) {
                    let t = this,
                        n = this.parser,
                        r = n.json.nodes[e],
                        i = (r.extensions && r.extensions[this.name] || {}).light;
                    return void 0 === i ? null : this._loadLight(i).then(function(e) {
                        return n._getNodeRef(t.cache, i, e)
                    })
                }
            }
            class C {
                constructor() {
                    this.name = b.KHR_MATERIALS_UNLIT
                }
                getMaterialType() {
                    return d.MeshBasicMaterial
                }
                extendParams(e, t, n) {
                    let r = [];
                    e.color = new d.Color(1, 1, 1), e.opacity = 1;
                    let i = t.pbrMetallicRoughness;
                    if (i) {
                        if (Array.isArray(i.baseColorFactor)) {
                            let t = i.baseColorFactor;
                            e.color.setRGB(t[0], t[1], t[2], x), e.opacity = t[3]
                        }
                        void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture, y))
                    }
                    return Promise.all(r)
                }
            }
            class S {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_EMISSIVE_STRENGTH
                }
                extendMaterialParams(e, t) {
                    let n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    let r = n.extensions[this.name].emissiveStrength;
                    return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve()
                }
            }
            class I {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_CLEARCOAT
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [],
                        s = r.extensions[this.name];
                    if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                        let e = s.clearcoatNormalTexture.scale;
                        t.clearcoatNormalScale = new d.Vector2(e, e)
                    }
                    return Promise.all(i)
                }
            }
            class M {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_DISPERSION
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    let r = n.extensions[this.name];
                    return t.dispersion = void 0 !== r.dispersion ? r.dispersion : 0, Promise.resolve()
                }
            }
            class T {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_IRIDESCENCE
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [],
                        s = r.extensions[this.name];
                    return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(i)
                }
            }
            class B {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_SHEEN
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [];
                    t.sheenColor = new d.Color(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                    let s = r.extensions[this.name];
                    if (void 0 !== s.sheenColorFactor) {
                        let e = s.sheenColorFactor;
                        t.sheenColor.setRGB(e[0], e[1], e[2], x)
                    }
                    return void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, y)), void 0 !== s.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(i)
                }
            }
            class R {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_TRANSMISSION
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [],
                        s = r.extensions[this.name];
                    return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(i)
                }
            }
            class D {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_VOLUME
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [],
                        s = r.extensions[this.name];
                    t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 1 / 0;
                    let a = s.attenuationColor || [1, 1, 1];
                    return t.attenuationColor = new d.Color().setRGB(a[0], a[1], a[2], x), Promise.all(i)
                }
            }
            class L {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_IOR
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    let r = n.extensions[this.name];
                    return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
                }
            }
            class P {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_SPECULAR
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [],
                        s = r.extensions[this.name];
                    t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
                    let a = s.specularColorFactor || [1, 1, 1];
                    return t.specularColor = new d.Color().setRGB(a[0], a[1], a[2], x), void 0 !== s.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture, y)), Promise.all(i)
                }
            }
            class O {
                constructor(e) {
                    this.parser = e, this.name = b.EXT_MATERIALS_BUMP
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [],
                        s = r.extensions[this.name];
                    return t.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1, void 0 !== s.bumpTexture && i.push(n.assignTexture(t, "bumpMap", s.bumpTexture)), Promise.all(i)
                }
            }
            class N {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_MATERIALS_ANISOTROPY
                }
                getMaterialType(e) {
                    let t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? d.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    let n = this.parser,
                        r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    let i = [],
                        s = r.extensions[this.name];
                    return void 0 !== s.anisotropyStrength && (t.anisotropy = s.anisotropyStrength), void 0 !== s.anisotropyRotation && (t.anisotropyRotation = s.anisotropyRotation), void 0 !== s.anisotropyTexture && i.push(n.assignTexture(t, "anisotropyMap", s.anisotropyTexture)), Promise.all(i)
                }
            }
            class U {
                constructor(e) {
                    this.parser = e, this.name = b.KHR_TEXTURE_BASISU
                }
                loadTexture(e) {
                    let t = this.parser,
                        n = t.json,
                        r = n.textures[e];
                    if (!r.extensions || !r.extensions[this.name]) return null;
                    let i = r.extensions[this.name],
                        s = t.options.ktx2Loader;
                    if (!s) {
                        if (!(n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)) return null;
                        throw Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures")
                    }
                    return t.loadTextureImage(e, i.source, s)
                }
            }
            class F {
                constructor(e) {
                    this.parser = e, this.name = b.EXT_TEXTURE_WEBP, this.isSupported = null
                }
                loadTexture(e) {
                    let t = this.name,
                        n = this.parser,
                        r = n.json,
                        i = r.textures[e];
                    if (!i.extensions || !i.extensions[t]) return null;
                    let s = i.extensions[t],
                        a = r.images[s.source],
                        o = n.textureLoader;
                    if (a.uri) {
                        let e = n.options.manager.getHandler(a.uri);
                        null !== e && (o = e)
                    }
                    return this.detectSupport().then(function(i) {
                        if (i) return n.loadTextureImage(e, s.source, o);
                        if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                        return n.loadTexture(e)
                    })
                }
                detectSupport() {
                    return this.isSupported || (this.isSupported = new Promise(function(e) {
                        let t = new Image;
                        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                            e(1 === t.height)
                        }
                    })), this.isSupported
                }
            }
            class k {
                constructor(e) {
                    this.parser = e, this.name = b.EXT_TEXTURE_AVIF, this.isSupported = null
                }
                loadTexture(e) {
                    let t = this.name,
                        n = this.parser,
                        r = n.json,
                        i = r.textures[e];
                    if (!i.extensions || !i.extensions[t]) return null;
                    let s = i.extensions[t],
                        a = r.images[s.source],
                        o = n.textureLoader;
                    if (a.uri) {
                        let e = n.options.manager.getHandler(a.uri);
                        null !== e && (o = e)
                    }
                    return this.detectSupport().then(function(i) {
                        if (i) return n.loadTextureImage(e, s.source, o);
                        if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                        return n.loadTexture(e)
                    })
                }
                detectSupport() {
                    return this.isSupported || (this.isSupported = new Promise(function(e) {
                        let t = new Image;
                        t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                            e(1 === t.height)
                        }
                    })), this.isSupported
                }
            }
            class Q {
                constructor(e) {
                    this.name = b.EXT_MESHOPT_COMPRESSION, this.parser = e
                }
                loadBufferView(e) {
                    let t = this.parser.json,
                        n = t.bufferViews[e];
                    if (!n.extensions || !n.extensions[this.name]) return null; {
                        let e = n.extensions[this.name],
                            r = this.parser.getDependency("buffer", e.buffer),
                            i = this.parser.options.meshoptDecoder;
                        if (!i || !i.supported) {
                            if (!(t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)) return null;
                            throw Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files")
                        }
                        return r.then(function(t) {
                            let n = e.byteOffset || 0,
                                r = e.byteLength || 0,
                                s = e.count,
                                a = e.byteStride,
                                o = new Uint8Array(t, n, r);
                            return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(s, a, o, e.mode, e.filter).then(function(e) {
                                return e.buffer
                            }) : i.ready.then(function() {
                                let t = new ArrayBuffer(s * a);
                                return i.decodeGltfBuffer(new Uint8Array(t), s, a, o, e.mode, e.filter), t
                            })
                        })
                    }
                }
            }
            class G {
                constructor(e) {
                    this.name = b.EXT_MESH_GPU_INSTANCING, this.parser = e
                }
                createNodeMesh(e) {
                    let t = this.parser.json,
                        n = t.nodes[e];
                    if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                    for (let e of t.meshes[n.mesh].primitives)
                        if (e.mode !== J.TRIANGLES && e.mode !== J.TRIANGLE_STRIP && e.mode !== J.TRIANGLE_FAN && void 0 !== e.mode) return null;
                    let r = n.extensions[this.name].attributes,
                        i = [],
                        s = {};
                    for (let e in r) i.push(this.parser.getDependency("accessor", r[e]).then(t => (s[e] = t, s[e])));
                    return i.length < 1 ? null : (i.push(this.parser.createNodeMesh(e)), Promise.all(i).then(e => {
                        let t = e.pop(),
                            n = t.isGroup ? t.children : [t],
                            r = e[0].count,
                            i = [];
                        for (let e of n) {
                            let t = new d.Matrix4,
                                n = new d.Vector3,
                                a = new d.Quaternion,
                                o = new d.Vector3(1, 1, 1),
                                l = new d.InstancedMesh(e.geometry, e.material, r);
                            for (let e = 0; e < r; e++) s.TRANSLATION && n.fromBufferAttribute(s.TRANSLATION, e), s.ROTATION && a.fromBufferAttribute(s.ROTATION, e), s.SCALE && o.fromBufferAttribute(s.SCALE, e), l.setMatrixAt(e, t.compose(n, a, o));
                            for (let t in s)
                                if ("_COLOR_0" === t) {
                                    let e = s[t];
                                    l.instanceColor = new d.InstancedBufferAttribute(e.array, e.itemSize, e.normalized)
                                } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, s[t]);
                            d.Object3D.prototype.copy.call(l, e), this.parser.assignFinalMaterial(l), i.push(l)
                        }
                        return t.isGroup ? (t.clear(), t.add(...i), t) : i[0]
                    }))
                }
            }
            let z = "glTF",
                H = {
                    JSON: 1313821514,
                    BIN: 5130562
                };
            class V {
                constructor(e) {
                    this.name = b.KHR_BINARY_GLTF, this.content = null, this.body = null;
                    let t = new DataView(e, 0, 12);
                    if (this.header = {
                            magic: v(new Uint8Array(e.slice(0, 4))),
                            version: t.getUint32(4, !0),
                            length: t.getUint32(8, !0)
                        }, this.header.magic !== z) throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw Error("THREE.GLTFLoader: Legacy binary file detected.");
                    let n = this.header.length - 12,
                        r = new DataView(e, 12),
                        i = 0;
                    for (; i < n;) {
                        let t = r.getUint32(i, !0);
                        i += 4;
                        let n = r.getUint32(i, !0);
                        if (i += 4, n === H.JSON) {
                            let n = new Uint8Array(e, 12 + i, t);
                            this.content = v(n)
                        } else if (n === H.BIN) {
                            let n = 12 + i;
                            this.body = e.slice(n, n + t)
                        }
                        i += t
                    }
                    if (null === this.content) throw Error("THREE.GLTFLoader: JSON content not found.")
                }
            }
            class j {
                constructor(e, t) {
                    if (!t) throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    this.name = b.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
                }
                decodePrimitive(e, t) {
                    let n = this.json,
                        r = this.dracoLoader,
                        i = e.extensions[this.name].bufferView,
                        s = e.extensions[this.name].attributes,
                        a = {},
                        o = {},
                        l = {};
                    for (let e in s) a[en[e] || e.toLowerCase()] = s[e];
                    for (let t in e.attributes) {
                        let r = en[t] || t.toLowerCase();
                        if (void 0 !== s[t]) {
                            let i = n.accessors[e.attributes[t]],
                                s = Z[i.componentType];
                            l[r] = s.name, o[r] = !0 === i.normalized
                        }
                    }
                    return t.getDependency("bufferView", i).then(function(e) {
                        return new Promise(function(t, n) {
                            r.decodeDracoFile(e, function(e) {
                                for (let t in e.attributes) {
                                    let n = e.attributes[t],
                                        r = o[t];
                                    void 0 !== r && (n.normalized = r)
                                }
                                t(e)
                            }, a, l, x, n)
                        })
                    })
                }
            }
            class W {
                constructor() {
                    this.name = b.KHR_TEXTURE_TRANSFORM
                }
                extendTexture(e, t) {
                    return (void 0 === t.texCoord || t.texCoord === e.channel) && void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
                }
            }
            class Y {
                constructor() {
                    this.name = b.KHR_MESH_QUANTIZATION
                }
            }
            class X extends d.Interpolant {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                copySampleValue_(e) {
                    let t = this.resultBuffer,
                        n = this.sampleValues,
                        r = this.valueSize,
                        i = e * r * 3 + r;
                    for (let e = 0; e !== r; e++) t[e] = n[i + e];
                    return t
                }
                interpolate_(e, t, n, r) {
                    let i = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = 2 * a,
                        l = 3 * a,
                        u = r - t,
                        c = (n - t) / u,
                        h = c * c,
                        d = h * c,
                        f = e * l,
                        p = f - l,
                        g = -2 * d + 3 * h,
                        A = d - h,
                        m = 1 - g,
                        v = A - h + c;
                    for (let e = 0; e !== a; e++) {
                        let t = s[p + e + a],
                            n = s[p + e + o] * u,
                            r = s[f + e + a],
                            l = s[f + e] * u;
                        i[e] = m * t + v * n + g * r + A * l
                    }
                    return i
                }
            }
            let q = new d.Quaternion;
            class K extends X {
                interpolate_(e, t, n, r) {
                    let i = super.interpolate_(e, t, n, r);
                    return q.fromArray(i).normalize().toArray(i), i
                }
            }
            let J = {
                    POINTS: 0,
                    LINES: 1,
                    LINE_LOOP: 2,
                    LINE_STRIP: 3,
                    TRIANGLES: 4,
                    TRIANGLE_STRIP: 5,
                    TRIANGLE_FAN: 6
                },
                Z = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                },
                $ = {
                    9728: d.NearestFilter,
                    9729: d.LinearFilter,
                    9984: d.NearestMipmapNearestFilter,
                    9985: d.LinearMipmapNearestFilter,
                    9986: d.NearestMipmapLinearFilter,
                    9987: d.LinearMipmapLinearFilter
                },
                ee = {
                    33071: d.ClampToEdgeWrapping,
                    33648: d.MirroredRepeatWrapping,
                    10497: d.RepeatWrapping
                },
                et = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                },
                en = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    ...m >= 152 ? {
                        TEXCOORD_0: "uv",
                        TEXCOORD_1: "uv1",
                        TEXCOORD_2: "uv2",
                        TEXCOORD_3: "uv3"
                    } : {
                        TEXCOORD_0: "uv",
                        TEXCOORD_1: "uv2"
                    },
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                },
                er = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                },
                ei = {
                    CUBICSPLINE: void 0,
                    LINEAR: d.InterpolateLinear,
                    STEP: d.InterpolateDiscrete
                },
                es = {
                    OPAQUE: "OPAQUE",
                    MASK: "MASK",
                    BLEND: "BLEND"
                };

            function ea(e, t, n) {
                for (let r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
            }

            function eo(e, t) {
                void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
            }

            function el(e) {
                let t = "",
                    n = Object.keys(e).sort();
                for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
                return t
            }

            function eu(e) {
                switch (e) {
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        throw Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                }
            }
            let ec = new d.Matrix4;
            class eh {
                constructor(e = {}, t = {}) {
                    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new _, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                        refs: {},
                        uses: {}
                    }, this.cameraCache = {
                        refs: {},
                        uses: {}
                    }, this.lightCache = {
                        refs: {},
                        uses: {}
                    }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                    let n = !1,
                        r = !1,
                        i = -1;
                    "undefined" != typeof navigator && void 0 !== navigator.userAgent && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = (r = navigator.userAgent.indexOf("Firefox") > -1) ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || r && i < 98 ? this.textureLoader = new d.TextureLoader(this.options.manager) : this.textureLoader = new d.ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new d.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                }
                setExtensions(e) {
                    this.extensions = e
                }
                setPlugins(e) {
                    this.plugins = e
                }
                parse(e, t) {
                    let n = this,
                        r = this.json,
                        i = this.extensions;
                    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(e) {
                        return e._markDefs && e._markDefs()
                    }), Promise.all(this._invokeAll(function(e) {
                        return e.beforeRoot && e.beforeRoot()
                    })).then(function() {
                        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                    }).then(function(t) {
                        let s = {
                            scene: t[0][r.scene || 0],
                            scenes: t[0],
                            animations: t[1],
                            cameras: t[2],
                            asset: r.asset,
                            parser: n,
                            userData: {}
                        };
                        return ea(i, s, r), eo(s, r), Promise.all(n._invokeAll(function(e) {
                            return e.afterRoot && e.afterRoot(s)
                        })).then(function() {
                            for (let e of s.scenes) e.updateMatrixWorld();
                            e(s)
                        })
                    }).catch(t)
                }
                _markDefs() {
                    let e = this.json.nodes || [],
                        t = this.json.skins || [],
                        n = this.json.meshes || [];
                    for (let n = 0, r = t.length; n < r; n++) {
                        let r = t[n].joints;
                        for (let t = 0, n = r.length; t < n; t++) e[r[t]].isBone = !0
                    }
                    for (let t = 0, r = e.length; t < r; t++) {
                        let r = e[t];
                        void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera)
                    }
                }
                _addNodeRef(e, t) {
                    void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
                }
                _getNodeRef(e, t, n) {
                    if (e.refs[t] <= 1) return n;
                    let r = n.clone(),
                        i = (e, t) => {
                            let n = this.associations.get(e);
                            for (let [r, s] of (null != n && this.associations.set(t, n), e.children.entries())) i(s, t.children[r])
                        };
                    return i(n, r), r.name += "_instance_" + e.uses[t]++, r
                }
                _invokeOne(e) {
                    let t = Object.values(this.plugins);
                    t.push(this);
                    for (let n = 0; n < t.length; n++) {
                        let r = e(t[n]);
                        if (r) return r
                    }
                    return null
                }
                _invokeAll(e) {
                    let t = Object.values(this.plugins);
                    t.unshift(this);
                    let n = [];
                    for (let r = 0; r < t.length; r++) {
                        let i = e(t[r]);
                        i && n.push(i)
                    }
                    return n
                }
                getDependency(e, t) {
                    let n = e + ":" + t,
                        r = this.cache.get(n);
                    if (!r) {
                        switch (e) {
                            case "scene":
                                r = this.loadScene(t);
                                break;
                            case "node":
                                r = this._invokeOne(function(e) {
                                    return e.loadNode && e.loadNode(t)
                                });
                                break;
                            case "mesh":
                                r = this._invokeOne(function(e) {
                                    return e.loadMesh && e.loadMesh(t)
                                });
                                break;
                            case "accessor":
                                r = this.loadAccessor(t);
                                break;
                            case "bufferView":
                                r = this._invokeOne(function(e) {
                                    return e.loadBufferView && e.loadBufferView(t)
                                });
                                break;
                            case "buffer":
                                r = this.loadBuffer(t);
                                break;
                            case "material":
                                r = this._invokeOne(function(e) {
                                    return e.loadMaterial && e.loadMaterial(t)
                                });
                                break;
                            case "texture":
                                r = this._invokeOne(function(e) {
                                    return e.loadTexture && e.loadTexture(t)
                                });
                                break;
                            case "skin":
                                r = this.loadSkin(t);
                                break;
                            case "animation":
                                r = this._invokeOne(function(e) {
                                    return e.loadAnimation && e.loadAnimation(t)
                                });
                                break;
                            case "camera":
                                r = this.loadCamera(t);
                                break;
                            default:
                                if (!(r = this._invokeOne(function(n) {
                                        return n != this && n.getDependency && n.getDependency(e, t)
                                    }))) throw Error("Unknown type: " + e)
                        }
                        this.cache.add(n, r)
                    }
                    return r
                }
                getDependencies(e) {
                    let t = this.cache.get(e);
                    if (!t) {
                        let n = this;
                        t = Promise.all((this.json[e + ("mesh" === e ? "es" : "s")] || []).map(function(t, r) {
                            return n.getDependency(e, r)
                        })), this.cache.add(e, t)
                    }
                    return t
                }
                loadBuffer(e) {
                    let t = this.json.buffers[e],
                        n = this.fileLoader;
                    if (t.type && "arraybuffer" !== t.type) throw Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                    if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[b.KHR_BINARY_GLTF].body);
                    let r = this.options;
                    return new Promise(function(e, i) {
                        n.load(d.LoaderUtils.resolveURL(t.uri, r.path), e, void 0, function() {
                            i(Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                        })
                    })
                }
                loadBufferView(e) {
                    let t = this.json.bufferViews[e];
                    return this.getDependency("buffer", t.buffer).then(function(e) {
                        let n = t.byteLength || 0,
                            r = t.byteOffset || 0;
                        return e.slice(r, r + n)
                    })
                }
                loadAccessor(e) {
                    let t = this,
                        n = this.json,
                        r = this.json.accessors[e];
                    if (void 0 === r.bufferView && void 0 === r.sparse) {
                        let e = et[r.type],
                            t = Z[r.componentType],
                            n = !0 === r.normalized,
                            i = new t(r.count * e);
                        return Promise.resolve(new d.BufferAttribute(i, e, n))
                    }
                    let i = [];
                    return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then(function(e) {
                        let i, s;
                        let a = e[0],
                            o = et[r.type],
                            l = Z[r.componentType],
                            u = l.BYTES_PER_ELEMENT,
                            c = u * o,
                            h = r.byteOffset || 0,
                            f = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                            p = !0 === r.normalized;
                        if (f && f !== c) {
                            let e = Math.floor(h / f),
                                n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count,
                                c = t.cache.get(n);
                            c || (i = new l(a, e * f, r.count * f / u), c = new d.InterleavedBuffer(i, f / u), t.cache.add(n, c)), s = new d.InterleavedBufferAttribute(c, o, h % f / u, p)
                        } else i = null === a ? new l(r.count * o) : new l(a, h, r.count * o), s = new d.BufferAttribute(i, o, p);
                        if (void 0 !== r.sparse) {
                            let t = et.SCALAR,
                                n = Z[r.sparse.indices.componentType],
                                i = r.sparse.indices.byteOffset || 0,
                                u = r.sparse.values.byteOffset || 0,
                                c = new n(e[1], i, r.sparse.count * t),
                                h = new l(e[2], u, r.sparse.count * o);
                            null !== a && (s = new d.BufferAttribute(s.array.slice(), s.itemSize, s.normalized));
                            for (let e = 0, t = c.length; e < t; e++) {
                                let t = c[e];
                                if (s.setX(t, h[e * o]), o >= 2 && s.setY(t, h[e * o + 1]), o >= 3 && s.setZ(t, h[e * o + 2]), o >= 4 && s.setW(t, h[e * o + 3]), o >= 5) throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                            }
                        }
                        return s
                    })
                }
                loadTexture(e) {
                    let t = this.json,
                        n = this.options,
                        r = t.textures[e].source,
                        i = t.images[r],
                        s = this.textureLoader;
                    if (i.uri) {
                        let e = n.manager.getHandler(i.uri);
                        null !== e && (s = e)
                    }
                    return this.loadTextureImage(e, r, s)
                }
                loadTextureImage(e, t, n) {
                    let r = this,
                        i = this.json,
                        s = i.textures[e],
                        a = i.images[t],
                        o = (a.uri || a.bufferView) + ":" + s.sampler;
                    if (this.textureCache[o]) return this.textureCache[o];
                    let l = this.loadImageSource(t, n).then(function(t) {
                        t.flipY = !1, t.name = s.name || a.name || "", "" === t.name && "string" == typeof a.uri && !1 === a.uri.startsWith("data:image/") && (t.name = a.uri);
                        let n = (i.samplers || {})[s.sampler] || {};
                        return t.magFilter = $[n.magFilter] || d.LinearFilter, t.minFilter = $[n.minFilter] || d.LinearMipmapLinearFilter, t.wrapS = ee[n.wrapS] || d.RepeatWrapping, t.wrapT = ee[n.wrapT] || d.RepeatWrapping, r.associations.set(t, {
                            textures: e
                        }), t
                    }).catch(function() {
                        return null
                    });
                    return this.textureCache[o] = l, l
                }
                loadImageSource(e, t) {
                    let n = this.json,
                        r = this.options;
                    if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then(e => e.clone());
                    let i = n.images[e],
                        s = self.URL || self.webkitURL,
                        a = i.uri || "",
                        o = !1;
                    if (void 0 !== i.bufferView) a = this.getDependency("bufferView", i.bufferView).then(function(e) {
                        o = !0;
                        let t = new Blob([e], {
                            type: i.mimeType
                        });
                        return a = s.createObjectURL(t)
                    });
                    else if (void 0 === i.uri) throw Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                    let l = Promise.resolve(a).then(function(e) {
                        return new Promise(function(n, i) {
                            let s = n;
                            !0 === t.isImageBitmapLoader && (s = function(e) {
                                let t = new d.Texture(e);
                                t.needsUpdate = !0, n(t)
                            }), t.load(d.LoaderUtils.resolveURL(e, r.path), s, void 0, i)
                        })
                    }).then(function(e) {
                        var t;
                        return !0 === o && s.revokeObjectURL(a), eo(e, i), e.userData.mimeType = i.mimeType || ((t = i.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
                    }).catch(function(e) {
                        throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e
                    });
                    return this.sourceCache[e] = l, l
                }
                assignTexture(e, t, n, r) {
                    let i = this;
                    return this.getDependency("texture", n.index).then(function(s) {
                        if (!s) return null;
                        if (void 0 !== n.texCoord && n.texCoord > 0 && ((s = s.clone()).channel = n.texCoord), i.extensions[b.KHR_TEXTURE_TRANSFORM]) {
                            let e = void 0 !== n.extensions ? n.extensions[b.KHR_TEXTURE_TRANSFORM] : void 0;
                            if (e) {
                                let t = i.associations.get(s);
                                s = i.extensions[b.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), i.associations.set(s, t)
                            }
                        }
                        return void 0 !== r && ("number" == typeof r && (r = 3001 === r ? y : x), "colorSpace" in s ? s.colorSpace = r : s.encoding = r === y ? 3001 : 3e3), e[t] = s, s
                    })
                }
                assignFinalMaterial(e) {
                    let t = e.geometry,
                        n = e.material,
                        r = void 0 === t.attributes.tangent,
                        i = void 0 !== t.attributes.color,
                        s = void 0 === t.attributes.normal;
                    if (e.isPoints) {
                        let e = "PointsMaterial:" + n.uuid,
                            t = this.cache.get(e);
                        t || (t = new d.PointsMaterial, d.Material.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
                    } else if (e.isLine) {
                        let e = "LineBasicMaterial:" + n.uuid,
                            t = this.cache.get(e);
                        t || (t = new d.LineBasicMaterial, d.Material.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t
                    }
                    if (r || i || s) {
                        let e = "ClonedMaterial:" + n.uuid + ":";
                        r && (e += "derivative-tangents:"), i && (e += "vertex-colors:"), s && (e += "flat-shading:");
                        let t = this.cache.get(e);
                        t || (t = n.clone(), i && (t.vertexColors = !0), s && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
                    }
                    e.material = n
                }
                getMaterialType() {
                    return d.MeshStandardMaterial
                }
                loadMaterial(e) {
                    let t;
                    let n = this,
                        r = this.json,
                        i = this.extensions,
                        s = r.materials[e],
                        a = {},
                        o = s.extensions || {},
                        l = [];
                    if (o[b.KHR_MATERIALS_UNLIT]) {
                        let e = i[b.KHR_MATERIALS_UNLIT];
                        t = e.getMaterialType(), l.push(e.extendParams(a, s, n))
                    } else {
                        let r = s.pbrMetallicRoughness || {};
                        if (a.color = new d.Color(1, 1, 1), a.opacity = 1, Array.isArray(r.baseColorFactor)) {
                            let e = r.baseColorFactor;
                            a.color.setRGB(e[0], e[1], e[2], x), a.opacity = e[3]
                        }
                        void 0 !== r.baseColorTexture && l.push(n.assignTexture(a, "map", r.baseColorTexture, y)), a.metalness = void 0 !== r.metallicFactor ? r.metallicFactor : 1, a.roughness = void 0 !== r.roughnessFactor ? r.roughnessFactor : 1, void 0 !== r.metallicRoughnessTexture && (l.push(n.assignTexture(a, "metalnessMap", r.metallicRoughnessTexture)), l.push(n.assignTexture(a, "roughnessMap", r.metallicRoughnessTexture))), t = this._invokeOne(function(t) {
                            return t.getMaterialType && t.getMaterialType(e)
                        }), l.push(Promise.all(this._invokeAll(function(t) {
                            return t.extendMaterialParams && t.extendMaterialParams(e, a)
                        })))
                    }!0 === s.doubleSided && (a.side = d.DoubleSide);
                    let u = s.alphaMode || es.OPAQUE;
                    if (u === es.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === es.MASK && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && t !== d.MeshBasicMaterial && (l.push(n.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new d.Vector2(1, 1), void 0 !== s.normalTexture.scale)) {
                        let e = s.normalTexture.scale;
                        a.normalScale.set(e, e)
                    }
                    if (void 0 !== s.occlusionTexture && t !== d.MeshBasicMaterial && (l.push(n.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && t !== d.MeshBasicMaterial) {
                        let e = s.emissiveFactor;
                        a.emissive = new d.Color().setRGB(e[0], e[1], e[2], x)
                    }
                    return void 0 !== s.emissiveTexture && t !== d.MeshBasicMaterial && l.push(n.assignTexture(a, "emissiveMap", s.emissiveTexture, y)), Promise.all(l).then(function() {
                        let r = new t(a);
                        return s.name && (r.name = s.name), eo(r, s), n.associations.set(r, {
                            materials: e
                        }), s.extensions && ea(i, r, s), r
                    })
                }
                createUniqueName(e) {
                    let t = d.PropertyBinding.sanitizeNodeName(e || "");
                    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
                }
                loadGeometries(e) {
                    let t = this,
                        n = this.extensions,
                        r = this.primitiveCache,
                        i = [];
                    for (let s = 0, a = e.length; s < a; s++) {
                        let a = e[s],
                            o = function(e) {
                                let t;
                                let n = e.extensions && e.extensions[b.KHR_DRACO_MESH_COMPRESSION];
                                if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + el(n.attributes) : e.indices + ":" + el(e.attributes) + ":" + e.mode, void 0 !== e.targets)
                                    for (let n = 0, r = e.targets.length; n < r; n++) t += ":" + el(e.targets[n]);
                                return t
                            }(a),
                            l = r[o];
                        if (l) i.push(l.promise);
                        else {
                            let e;
                            e = a.extensions && a.extensions[b.KHR_DRACO_MESH_COMPRESSION] ? function(e) {
                                return n[b.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function(n) {
                                    return ed(n, e, t)
                                })
                            }(a) : ed(new d.BufferGeometry, a, t), r[o] = {
                                primitive: a,
                                promise: e
                            }, i.push(e)
                        }
                    }
                    return Promise.all(i)
                }
                loadMesh(e) {
                    let t = this,
                        n = this.json,
                        r = this.extensions,
                        i = n.meshes[e],
                        s = i.primitives,
                        a = [];
                    for (let e = 0, t = s.length; e < t; e++) {
                        var o;
                        let t = void 0 === s[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new d.MeshStandardMaterial({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: d.FrontSide
                        })), o.DefaultMaterial) : this.getDependency("material", s[e].material);
                        a.push(t)
                    }
                    return a.push(t.loadGeometries(s)), Promise.all(a).then(function(n) {
                        let a = n.slice(0, n.length - 1),
                            o = n[n.length - 1],
                            l = [];
                        for (let n = 0, u = o.length; n < u; n++) {
                            let u;
                            let c = o[n],
                                h = s[n],
                                f = a[n];
                            if (h.mode === J.TRIANGLES || h.mode === J.TRIANGLE_STRIP || h.mode === J.TRIANGLE_FAN || void 0 === h.mode) !0 === (u = !0 === i.isSkinnedMesh ? new d.SkinnedMesh(c, f) : new d.Mesh(c, f)).isSkinnedMesh && u.normalizeSkinWeights(), h.mode === J.TRIANGLE_STRIP ? u.geometry = A(u.geometry, d.TriangleStripDrawMode) : h.mode === J.TRIANGLE_FAN && (u.geometry = A(u.geometry, d.TriangleFanDrawMode));
                            else if (h.mode === J.LINES) u = new d.LineSegments(c, f);
                            else if (h.mode === J.LINE_STRIP) u = new d.Line(c, f);
                            else if (h.mode === J.LINE_LOOP) u = new d.LineLoop(c, f);
                            else if (h.mode === J.POINTS) u = new d.Points(c, f);
                            else throw Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                            Object.keys(u.geometry.morphAttributes).length > 0 && function(e, t) {
                                if (e.updateMorphTargets(), void 0 !== t.weights)
                                    for (let n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
                                if (t.extras && Array.isArray(t.extras.targetNames)) {
                                    let n = t.extras.targetNames;
                                    if (e.morphTargetInfluences.length === n.length) {
                                        e.morphTargetDictionary = {};
                                        for (let t = 0, r = n.length; t < r; t++) e.morphTargetDictionary[n[t]] = t
                                    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                                }
                            }(u, i), u.name = t.createUniqueName(i.name || "mesh_" + e), eo(u, i), h.extensions && ea(r, u, h), t.assignFinalMaterial(u), l.push(u)
                        }
                        for (let n = 0, r = l.length; n < r; n++) t.associations.set(l[n], {
                            meshes: e,
                            primitives: n
                        });
                        if (1 === l.length) return i.extensions && ea(r, l[0], i), l[0];
                        let u = new d.Group;
                        i.extensions && ea(r, u, i), t.associations.set(u, {
                            meshes: e
                        });
                        for (let e = 0, t = l.length; e < t; e++) u.add(l[e]);
                        return u
                    })
                }
                loadCamera(e) {
                    let t;
                    let n = this.json.cameras[e],
                        r = n[n.type];
                    if (!r) {
                        console.warn("THREE.GLTFLoader: Missing camera parameters.");
                        return
                    }
                    return "perspective" === n.type ? t = new d.PerspectiveCamera(d.MathUtils.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new d.OrthographicCamera(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), eo(t, n), Promise.resolve(t)
                }
                loadSkin(e) {
                    let t = this.json.skins[e],
                        n = [];
                    for (let e = 0, r = t.joints.length; e < r; e++) n.push(this._loadNodeShallow(t.joints[e]));
                    return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(e) {
                        let n = e.pop(),
                            r = [],
                            i = [];
                        for (let s = 0, a = e.length; s < a; s++) {
                            let a = e[s];
                            if (a) {
                                r.push(a);
                                let e = new d.Matrix4;
                                null !== n && e.fromArray(n.array, 16 * s), i.push(e)
                            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[s])
                        }
                        return new d.Skeleton(r, i)
                    })
                }
                loadAnimation(e) {
                    let t = this.json,
                        n = this,
                        r = t.animations[e],
                        i = r.name ? r.name : "animation_" + e,
                        s = [],
                        a = [],
                        o = [],
                        l = [],
                        u = [];
                    for (let e = 0, t = r.channels.length; e < t; e++) {
                        let t = r.channels[e],
                            n = r.samplers[t.sampler],
                            i = t.target,
                            c = i.node,
                            h = void 0 !== r.parameters ? r.parameters[n.input] : n.input,
                            d = void 0 !== r.parameters ? r.parameters[n.output] : n.output;
                        void 0 !== i.node && (s.push(this.getDependency("node", c)), a.push(this.getDependency("accessor", h)), o.push(this.getDependency("accessor", d)), l.push(n), u.push(i))
                    }
                    return Promise.all([Promise.all(s), Promise.all(a), Promise.all(o), Promise.all(l), Promise.all(u)]).then(function(e) {
                        let t = e[0],
                            r = e[1],
                            s = e[2],
                            a = e[3],
                            o = e[4],
                            l = [];
                        for (let e = 0, i = t.length; e < i; e++) {
                            let i = t[e],
                                u = r[e],
                                c = s[e],
                                h = a[e],
                                d = o[e];
                            if (void 0 === i) continue;
                            i.updateMatrix && i.updateMatrix();
                            let f = n._createAnimationTracks(i, u, c, h, d);
                            if (f)
                                for (let e = 0; e < f.length; e++) l.push(f[e])
                        }
                        return new d.AnimationClip(i, void 0, l)
                    })
                }
                createNodeMesh(e) {
                    let t = this.json,
                        n = this,
                        r = t.nodes[e];
                    return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then(function(e) {
                        let t = n._getNodeRef(n.meshCache, r.mesh, e);
                        return void 0 !== r.weights && t.traverse(function(e) {
                            if (e.isMesh)
                                for (let t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t]
                        }), t
                    })
                }
                loadNode(e) {
                    let t = this.json.nodes[e],
                        n = this._loadNodeShallow(e),
                        r = [],
                        i = t.children || [];
                    for (let e = 0, t = i.length; e < t; e++) r.push(this.getDependency("node", i[e]));
                    let s = void 0 === t.skin ? Promise.resolve(null) : this.getDependency("skin", t.skin);
                    return Promise.all([n, Promise.all(r), s]).then(function(e) {
                        let t = e[0],
                            n = e[1],
                            r = e[2];
                        null !== r && t.traverse(function(e) {
                            e.isSkinnedMesh && e.bind(r, ec)
                        });
                        for (let e = 0, r = n.length; e < r; e++) t.add(n[e]);
                        return t
                    })
                }
                _loadNodeShallow(e) {
                    let t = this.json,
                        n = this.extensions,
                        r = this;
                    if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
                    let i = t.nodes[e],
                        s = i.name ? r.createUniqueName(i.name) : "",
                        a = [],
                        o = r._invokeOne(function(t) {
                            return t.createNodeMesh && t.createNodeMesh(e)
                        });
                    return o && a.push(o), void 0 !== i.camera && a.push(r.getDependency("camera", i.camera).then(function(e) {
                        return r._getNodeRef(r.cameraCache, i.camera, e)
                    })), r._invokeAll(function(t) {
                        return t.createNodeAttachment && t.createNodeAttachment(e)
                    }).forEach(function(e) {
                        a.push(e)
                    }), this.nodeCache[e] = Promise.all(a).then(function(t) {
                        let a;
                        if ((a = !0 === i.isBone ? new d.Bone : t.length > 1 ? new d.Group : 1 === t.length ? t[0] : new d.Object3D) !== t[0])
                            for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
                        if (i.name && (a.userData.name = i.name, a.name = s), eo(a, i), i.extensions && ea(n, a, i), void 0 !== i.matrix) {
                            let e = new d.Matrix4;
                            e.fromArray(i.matrix), a.applyMatrix4(e)
                        } else void 0 !== i.translation && a.position.fromArray(i.translation), void 0 !== i.rotation && a.quaternion.fromArray(i.rotation), void 0 !== i.scale && a.scale.fromArray(i.scale);
                        return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = e, a
                    }), this.nodeCache[e]
                }
                loadScene(e) {
                    let t = this.extensions,
                        n = this.json.scenes[e],
                        r = this,
                        i = new d.Group;
                    n.name && (i.name = r.createUniqueName(n.name)), eo(i, n), n.extensions && ea(t, i, n);
                    let s = n.nodes || [],
                        a = [];
                    for (let e = 0, t = s.length; e < t; e++) a.push(r.getDependency("node", s[e]));
                    return Promise.all(a).then(function(e) {
                        for (let t = 0, n = e.length; t < n; t++) i.add(e[t]);
                        return r.associations = (e => {
                            let t = new Map;
                            for (let [e, n] of r.associations)(e instanceof d.Material || e instanceof d.Texture) && t.set(e, n);
                            return e.traverse(e => {
                                let n = r.associations.get(e);
                                null != n && t.set(e, n)
                            }), t
                        })(i), i
                    })
                }
                _createAnimationTracks(e, t, n, r, i) {
                    let s;
                    let a = [],
                        o = e.name ? e.name : e.uuid,
                        l = [];
                    switch (er[i.path] === er.weights ? e.traverse(function(e) {
                        e.morphTargetInfluences && l.push(e.name ? e.name : e.uuid)
                    }) : l.push(o), er[i.path]) {
                        case er.weights:
                            s = d.NumberKeyframeTrack;
                            break;
                        case er.rotation:
                            s = d.QuaternionKeyframeTrack;
                            break;
                        case er.position:
                        case er.scale:
                            s = d.VectorKeyframeTrack;
                            break;
                        default:
                            s = 1 === n.itemSize ? d.NumberKeyframeTrack : d.VectorKeyframeTrack
                    }
                    let u = void 0 !== r.interpolation ? ei[r.interpolation] : d.InterpolateLinear,
                        c = this._getArrayFromAccessor(n);
                    for (let e = 0, n = l.length; e < n; e++) {
                        let n = new s(l[e] + "." + er[i.path], t.array, c, u);
                        "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(n), a.push(n)
                    }
                    return a
                }
                _getArrayFromAccessor(e) {
                    let t = e.array;
                    if (e.normalized) {
                        let e = eu(t.constructor),
                            n = new Float32Array(t.length);
                        for (let r = 0, i = t.length; r < i; r++) n[r] = t[r] * e;
                        t = n
                    }
                    return t
                }
                _createCubicSplineTrackInterpolant(e) {
                    e.createInterpolant = function(e) {
                        return new(this instanceof d.QuaternionKeyframeTrack ? K : X)(this.times, this.values, this.getValueSize() / 3, e)
                    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
                }
            }

            function ed(e, t, n) {
                let r = t.attributes,
                    i = [];
                for (let t in r) {
                    let s = en[t] || t.toLowerCase();
                    s in e.attributes || i.push(function(t, r) {
                        return n.getDependency("accessor", t).then(function(t) {
                            e.setAttribute(r, t)
                        })
                    }(r[t], s))
                }
                if (void 0 !== t.indices && !e.index) {
                    let r = n.getDependency("accessor", t.indices).then(function(t) {
                        e.setIndex(t)
                    });
                    i.push(r)
                }
                return eo(e, t), ! function(e, t, n) {
                    let r = t.attributes,
                        i = new d.Box3;
                    if (void 0 === r.POSITION) return; {
                        let e = n.json.accessors[r.POSITION],
                            t = e.min,
                            s = e.max;
                        if (void 0 !== t && void 0 !== s) {
                            if (i.set(new d.Vector3(t[0], t[1], t[2]), new d.Vector3(s[0], s[1], s[2])), e.normalized) {
                                let t = eu(Z[e.componentType]);
                                i.min.multiplyScalar(t), i.max.multiplyScalar(t)
                            }
                        } else {
                            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                            return
                        }
                    }
                    let s = t.targets;
                    if (void 0 !== s) {
                        let e = new d.Vector3,
                            t = new d.Vector3;
                        for (let r = 0, i = s.length; r < i; r++) {
                            let i = s[r];
                            if (void 0 !== i.POSITION) {
                                let r = n.json.accessors[i.POSITION],
                                    s = r.min,
                                    a = r.max;
                                if (void 0 !== s && void 0 !== a) {
                                    if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), r.normalized) {
                                        let e = eu(Z[r.componentType]);
                                        t.multiplyScalar(e)
                                    }
                                    e.max(t)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        i.expandByVector(e)
                    }
                    e.boundingBox = i;
                    let a = new d.Sphere;
                    i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = a
                }(e, t, n), Promise.all(i).then(function() {
                    return void 0 !== t.targets ? function(e, t, n) {
                        let r = !1,
                            i = !1,
                            s = !1;
                        for (let e = 0, n = t.length; e < n; e++) {
                            let n = t[e];
                            if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), void 0 !== n.COLOR_0 && (s = !0), r && i && s) break
                        }
                        if (!r && !i && !s) return Promise.resolve(e);
                        let a = [],
                            o = [],
                            l = [];
                        for (let u = 0, c = t.length; u < c; u++) {
                            let c = t[u];
                            if (r) {
                                let t = void 0 !== c.POSITION ? n.getDependency("accessor", c.POSITION) : e.attributes.position;
                                a.push(t)
                            }
                            if (i) {
                                let t = void 0 !== c.NORMAL ? n.getDependency("accessor", c.NORMAL) : e.attributes.normal;
                                o.push(t)
                            }
                            if (s) {
                                let t = void 0 !== c.COLOR_0 ? n.getDependency("accessor", c.COLOR_0) : e.attributes.color;
                                l.push(t)
                            }
                        }
                        return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(function(t) {
                            let n = t[0],
                                a = t[1],
                                o = t[2];
                            return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = a), s && (e.morphAttributes.color = o), e.morphTargetsRelative = !0, e
                        })
                    }(e, t.targets, n) : e
                })
            }
            class ef {
                constructor(e = 4) {
                    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
                }
                _initWorker(e) {
                    if (!this.workers[e]) {
                        let t = this.workerCreator();
                        t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t
                    }
                }
                _getIdleWorker() {
                    for (let e = 0; e < this.pool; e++)
                        if (!(this.workerStatus & 1 << e)) return e;
                    return -1
                }
                _onMessage(e, t) {
                    let n = this.workersResolve[e];
                    if (n && n(t), this.queue.length) {
                        let {
                            resolve: t,
                            msg: n,
                            transfer: r
                        } = this.queue.shift();
                        this.workersResolve[e] = t, this.workers[e].postMessage(n, r)
                    } else this.workerStatus ^= 1 << e
                }
                setWorkerCreator(e) {
                    this.workerCreator = e
                }
                setWorkerLimit(e) {
                    this.pool = e
                }
                postMessage(e, t) {
                    return new Promise(n => {
                        let r = this._getIdleWorker(); - 1 !== r ? (this._initWorker(r), this.workerStatus |= 1 << r, this.workersResolve[r] = n, this.workers[r].postMessage(e, t)) : this.queue.push({
                            resolve: n,
                            msg: e,
                            transfer: t
                        })
                    })
                }
                dispose() {
                    this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
                }
            }
            var ep = n(5872).lW;
            class eg {
                constructor() {
                    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                        vendorId: 0,
                        descriptorType: 0,
                        descriptorBlockSize: 0,
                        versionNumber: 2,
                        colorModel: 0,
                        colorPrimaries: 1,
                        transferFunction: 2,
                        flags: 0,
                        texelBlockDimension: [0, 0, 0, 0],
                        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                        samples: []
                    }], this.keyValue = {}, this.globalData = null
                }
            }
            class eA {
                constructor(e, t, n, r) {
                    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = r, this._offset = 0
                }
                _nextUint8() {
                    let e = this._dataView.getUint8(this._offset);
                    return this._offset += 1, e
                }
                _nextUint16() {
                    let e = this._dataView.getUint16(this._offset, this._littleEndian);
                    return this._offset += 2, e
                }
                _nextUint32() {
                    let e = this._dataView.getUint32(this._offset, this._littleEndian);
                    return this._offset += 4, e
                }
                _nextUint64() {
                    let e = this._dataView.getUint32(this._offset, this._littleEndian),
                        t = this._dataView.getUint32(this._offset + 4, this._littleEndian);
                    return this._offset += 8, e + 4294967296 * t
                }
                _nextInt32() {
                    let e = this._dataView.getInt32(this._offset, this._littleEndian);
                    return this._offset += 4, e
                }
                _nextUint8Array(e) {
                    let t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
                    return this._offset += e, t
                }
                _skip(e) {
                    return this._offset += e, this
                }
                _scan(e, t) {
                    void 0 === t && (t = 0);
                    let n = this._offset,
                        r = 0;
                    for (; this._dataView.getUint8(this._offset) !== t && r < e;) r++, this._offset++;
                    return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r)
                }
            }
            let em = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

            function ev(e) {
                return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : ep.from(e).toString("utf8")
            }
            var ey = n(5872).lW;
            let ex = {
                env: {
                    emscripten_notify_memory_growth: function(e) {
                        s = new Uint8Array(i.exports.memory.buffer)
                    }
                }
            };
            class eE {
                init() {
                    return r || ("undefined" != typeof fetch ? r = fetch("data:application/wasm;base64," + e_).then(e => e.arrayBuffer()).then(e => WebAssembly.instantiate(e, ex)).then(this._init) : r = WebAssembly.instantiate(ey.from(e_, "base64"), ex).then(this._init)), r
                }
                _init(e) {
                    i = e.instance, ex.env.emscripten_notify_memory_growth(0)
                }
                decode(e, t = 0) {
                    if (!i) throw Error("ZSTDDecoder: Await .init() before decoding.");
                    let n = e.byteLength,
                        r = i.exports.malloc(n);
                    s.set(e, r), t = t || Number(i.exports.ZSTD_findDecompressedSize(r, n));
                    let a = i.exports.malloc(t),
                        o = i.exports.ZSTD_decompress(a, t, r, n),
                        l = s.slice(a, a + o);
                    return i.exports.free(r), i.exports.free(a), l
                }
            }
            let e_ = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
            class eb extends d.CompressedTexture {
                constructor(e, t, n) {
                    super(void 0, e[0].width, e[0].height, t, n, d.CubeReflectionMapping), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
                }
            }
            class ew extends d.CompressedTexture {
                constructor(e, t, n, r, i, s) {
                    super(e, t, n, i, s), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = d.ClampToEdgeWrapping
                }
            }
            class eC extends d.Texture {
                constructor(e = null, t = 1, n = 1, r = 1) {
                    super(null), this.isData3DTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    }, this.magFilter = d.NearestFilter, this.minFilter = d.NearestFilter, this.wrapR = d.ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            var eS = Object.defineProperty,
                eI = (e, t, n) => t in e ? eS(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : e[t] = n,
                eM = (e, t, n) => (eI(e, "symbol" != typeof t ? t + "" : t, n), n);
            let eT = "srgb",
                eB = new WeakMap,
                eR = 0,
                eD = class extends d.Loader {
                    constructor(e) {
                        super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new ef, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
                    }
                    setTranscoderPath(e) {
                        return this.transcoderPath = e, this
                    }
                    setWorkerLimit(e) {
                        return this.workerPool.setWorkerLimit(e), this
                    }
                    detectSupport(e) {
                        return this.workerConfig = {
                            astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
                            etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
                            etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                            dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                            bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                            pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                        }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this
                    }
                    init() {
                        if (!this.transcoderPending) {
                            let e = new d.FileLoader(this.manager);
                            e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
                            let t = e.loadAsync("basis_transcoder.js"),
                                n = new d.FileLoader(this.manager);
                            n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
                            let r = n.loadAsync("basis_transcoder.wasm");
                            this.transcoderPending = Promise.all([t, r]).then(([e, t]) => {
                                let n = eD.BasisWorker.toString(),
                                    r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(eD.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(eD.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(eD.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                                this.workerSourceURL = URL.createObjectURL(new Blob([r])), this.transcoderBinary = t, this.workerPool.setWorkerCreator(() => {
                                    let e = new Worker(this.workerSourceURL),
                                        t = this.transcoderBinary.slice(0);
                                    return e.postMessage({
                                        type: "init",
                                        config: this.workerConfig,
                                        transcoderBinary: t
                                    }, [t]), e
                                })
                            }), eR > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), eR++
                        }
                        return this.transcoderPending
                    }
                    load(e, t, n, r) {
                        if (null === this.workerConfig) throw Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                        let i = new d.FileLoader(this.manager);
                        i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials), i.load(e, e => {
                            if (eB.has(e)) return eB.get(e).promise.then(t).catch(r);
                            this._createTexture(e).then(e => t ? t(e) : null).catch(r)
                        }, n, r)
                    }
                    _createTextureFrom(e, t) {
                        let n;
                        let {
                            faces: r,
                            width: i,
                            height: s,
                            format: a,
                            type: o,
                            error: l,
                            dfdFlags: u
                        } = e;
                        if ("error" === o) return Promise.reject(l);
                        if (6 === t.faceCount) n = new eb(r, a, d.UnsignedByteType);
                        else {
                            let e = r[0].mipmaps;
                            n = t.layerCount > 1 ? new ew(e, i, s, t.layerCount, a, d.UnsignedByteType) : new d.CompressedTexture(e, i, s, a, d.UnsignedByteType)
                        }
                        n.minFilter = 1 === r[0].mipmaps.length ? d.LinearFilter : d.LinearMipmapLinearFilter, n.magFilter = d.LinearFilter, n.generateMipmaps = !1, n.needsUpdate = !0;
                        let c = eU(t);
                        return "colorSpace" in n ? n.colorSpace = c : n.encoding = c === eT ? 3001 : 3e3, n.premultiplyAlpha = !!(1 & u), n
                    }
                    async _createTexture(e, t = {}) {
                        let n = function(e) {
                            let t = new Uint8Array(e.buffer, e.byteOffset, em.length);
                            if (t[0] !== em[0] || t[1] !== em[1] || t[2] !== em[2] || t[3] !== em[3] || t[4] !== em[4] || t[5] !== em[5] || t[6] !== em[6] || t[7] !== em[7] || t[8] !== em[8] || t[9] !== em[9] || t[10] !== em[10] || t[11] !== em[11]) throw Error("Missing KTX 2.0 identifier.");
                            let n = new eg,
                                r = 17 * Uint32Array.BYTES_PER_ELEMENT,
                                i = new eA(e, em.length, r, !0);
                            n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();
                            let s = i._nextUint32();
                            n.supercompressionScheme = i._nextUint32();
                            let a = i._nextUint32(),
                                o = i._nextUint32(),
                                l = i._nextUint32(),
                                u = i._nextUint32(),
                                c = i._nextUint64(),
                                h = i._nextUint64(),
                                d = new eA(e, em.length + r, 24 * s, !0);
                            for (let t = 0; t < s; t++) n.levels.push({
                                levelData: new Uint8Array(e.buffer, e.byteOffset + d._nextUint64(), d._nextUint64()),
                                uncompressedByteLength: d._nextUint64()
                            });
                            let f = new eA(e, a, o, !0),
                                p = {
                                    vendorId: f._skip(4)._nextUint16(),
                                    descriptorType: f._nextUint16(),
                                    versionNumber: f._nextUint16(),
                                    descriptorBlockSize: f._nextUint16(),
                                    colorModel: f._nextUint8(),
                                    colorPrimaries: f._nextUint8(),
                                    transferFunction: f._nextUint8(),
                                    flags: f._nextUint8(),
                                    texelBlockDimension: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
                                    bytesPlane: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
                                    samples: []
                                },
                                g = (p.descriptorBlockSize / 4 - 6) / 4;
                            for (let e = 0; e < g; e++) {
                                let t = {
                                    bitOffset: f._nextUint16(),
                                    bitLength: f._nextUint8(),
                                    channelType: f._nextUint8(),
                                    samplePosition: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
                                    sampleLower: -1 / 0,
                                    sampleUpper: 1 / 0
                                };
                                64 & t.channelType ? (t.sampleLower = f._nextInt32(), t.sampleUpper = f._nextInt32()) : (t.sampleLower = f._nextUint32(), t.sampleUpper = f._nextUint32()), p.samples[e] = t
                            }
                            n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(p);
                            let A = new eA(e, l, u, !0);
                            for (; A._offset < u;) {
                                let e = A._nextUint32(),
                                    t = A._scan(e),
                                    r = ev(t);
                                if (n.keyValue[r] = A._nextUint8Array(e - t.byteLength - 1), r.match(/^ktx/i)) {
                                    let e = ev(n.keyValue[r]);
                                    n.keyValue[r] = e.substring(0, e.lastIndexOf("\0"))
                                }
                                let i = e % 4 ? 4 - e % 4 : 0;
                                A._skip(i)
                            }
                            if (h <= 0) return n;
                            let m = new eA(e, c, h, !0),
                                v = m._nextUint16(),
                                y = m._nextUint16(),
                                x = m._nextUint32(),
                                E = m._nextUint32(),
                                _ = m._nextUint32(),
                                b = m._nextUint32(),
                                w = [];
                            for (let e = 0; e < s; e++) w.push({
                                imageFlags: m._nextUint32(),
                                rgbSliceByteOffset: m._nextUint32(),
                                rgbSliceByteLength: m._nextUint32(),
                                alphaSliceByteOffset: m._nextUint32(),
                                alphaSliceByteLength: m._nextUint32()
                            });
                            let C = c + m._offset,
                                S = C + x,
                                I = S + E,
                                M = I + _,
                                T = new Uint8Array(e.buffer, e.byteOffset + C, x),
                                B = new Uint8Array(e.buffer, e.byteOffset + S, E),
                                R = new Uint8Array(e.buffer, e.byteOffset + I, _),
                                D = new Uint8Array(e.buffer, e.byteOffset + M, b);
                            return n.globalData = {
                                endpointCount: v,
                                selectorCount: y,
                                imageDescs: w,
                                endpointsData: T,
                                selectorsData: B,
                                tablesData: R,
                                extendedData: D
                            }, n
                        }(new Uint8Array(e));
                        if (0 !== n.vkFormat) return eN(n);
                        let r = this.init().then(() => this.workerPool.postMessage({
                            type: "transcode",
                            buffer: e,
                            taskConfig: t
                        }, [e])).then(e => this._createTextureFrom(e.data, n));
                        return eB.set(e, {
                            promise: r
                        }), r
                    }
                    dispose() {
                        return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), eR--, this
                    }
                };
            eM(eD, "BasisFormat", {
                ETC1S: 0,
                UASTC_4x4: 1
            }), eM(eD, "TranscoderFormat", {
                ETC1: 0,
                ETC2: 1,
                BC1: 2,
                BC3: 3,
                BC4: 4,
                BC5: 5,
                BC7_M6_OPAQUE_ONLY: 6,
                BC7_M5: 7,
                PVRTC1_4_RGB: 8,
                PVRTC1_4_RGBA: 9,
                ASTC_4x4: 10,
                ATC_RGB: 11,
                ATC_RGBA_INTERPOLATED_ALPHA: 12,
                RGBA32: 13,
                RGB565: 14,
                BGR565: 15,
                RGBA4444: 16
            }), eM(eD, "EngineFormat", {
                RGBAFormat: d.RGBAFormat,
                RGBA_ASTC_4x4_Format: d.RGBA_ASTC_4x4_Format,
                RGBA_BPTC_Format: d.RGBA_BPTC_Format,
                RGBA_ETC2_EAC_Format: d.RGBA_ETC2_EAC_Format,
                RGBA_PVRTC_4BPPV1_Format: d.RGBA_PVRTC_4BPPV1_Format,
                RGBA_S3TC_DXT5_Format: d.RGBA_S3TC_DXT5_Format,
                RGB_ETC1_Format: d.RGB_ETC1_Format,
                RGB_ETC2_Format: d.RGB_ETC2_Format,
                RGB_PVRTC_4BPPV1_Format: d.RGB_PVRTC_4BPPV1_Format,
                RGB_S3TC_DXT1_Format: d.RGB_S3TC_DXT1_Format
            }), eM(eD, "BasisWorker", function() {
                let e, t, n;
                let r = _EngineFormat,
                    i = _TranscoderFormat,
                    s = _BasisFormat;
                self.addEventListener("message", function(a) {
                    let c = a.data;
                    switch (c.type) {
                        case "init":
                            var h;
                            e = c.config, h = c.transcoderBinary, t = new Promise(e => {
                                BASIS(n = {
                                    wasmBinary: h,
                                    onRuntimeInitialized: e
                                })
                            }).then(() => {
                                n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                            });
                            break;
                        case "transcode":
                            t.then(() => {
                                try {
                                    let {
                                        faces: t,
                                        buffers: a,
                                        width: h,
                                        height: d,
                                        hasAlpha: f,
                                        format: p,
                                        dfdFlags: g
                                    } = function(t) {
                                        let a = new n.KTX2File(new Uint8Array(t));

                                        function c() {
                                            a.close(), a.delete()
                                        }
                                        if (!a.isValid()) throw c(), Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
                                        let h = a.isUASTC() ? s.UASTC_4x4 : s.ETC1S,
                                            d = a.getWidth(),
                                            f = a.getHeight(),
                                            p = a.getLayers() || 1,
                                            g = a.getLevels(),
                                            A = a.getFaces(),
                                            m = a.getHasAlpha(),
                                            v = a.getDFDFlags(),
                                            {
                                                transcoderFormat: y,
                                                engineFormat: x
                                            } = function(t, n, a, c) {
                                                let h;
                                                let d = t === s.ETC1S ? o : l;
                                                for (let r = 0; r < d.length; r++) {
                                                    let i = d[r];
                                                    if (e[i.if] && i.basisFormat.includes(t) && (!c || !(i.transcoderFormat.length < 2)) && (!i.needsPowerOfTwo || u(n) && u(a))) return {
                                                        transcoderFormat: i.transcoderFormat[c ? 1 : 0],
                                                        engineFormat: i.engineFormat[c ? 1 : 0]
                                                    }
                                                }
                                                return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), {
                                                    transcoderFormat: i.RGBA32,
                                                    engineFormat: r.RGBAFormat
                                                }
                                            }(h, d, f, m);
                                        if (!d || !f || !g) throw c(), Error("THREE.KTX2Loader:	Invalid texture");
                                        if (!a.startTranscoding()) throw c(), Error("THREE.KTX2Loader: .startTranscoding failed");
                                        let E = [],
                                            _ = [];
                                        for (let e = 0; e < A; e++) {
                                            let t = [];
                                            for (let n = 0; n < g; n++) {
                                                let r, i;
                                                let s = [];
                                                for (let t = 0; t < p; t++) {
                                                    let o = a.getImageLevelInfo(n, t, e);
                                                    0 === e && 0 === n && 0 === t && (o.origWidth % 4 != 0 || o.origHeight % 4 != 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), g > 1 ? (r = o.origWidth, i = o.origHeight) : (r = o.width, i = o.height);
                                                    let l = new Uint8Array(a.getImageTranscodedSizeInBytes(n, t, 0, y));
                                                    if (!a.transcodeImage(l, n, t, e, y, 0, -1, -1)) throw c(), Error("THREE.KTX2Loader: .transcodeImage failed.");
                                                    s.push(l)
                                                }
                                                let o = function(e) {
                                                    if (1 === e.length) return e[0];
                                                    let t = 0;
                                                    for (let n = 0; n < e.length; n++) t += e[n].byteLength;
                                                    let n = new Uint8Array(t),
                                                        r = 0;
                                                    for (let t = 0; t < e.length; t++) {
                                                        let i = e[t];
                                                        n.set(i, r), r += i.byteLength
                                                    }
                                                    return n
                                                }(s);
                                                t.push({
                                                    data: o,
                                                    width: r,
                                                    height: i
                                                }), _.push(o.buffer)
                                            }
                                            E.push({
                                                mipmaps: t,
                                                width: d,
                                                height: f,
                                                format: x
                                            })
                                        }
                                        return c(), {
                                            faces: E,
                                            buffers: _,
                                            width: d,
                                            height: f,
                                            hasAlpha: m,
                                            format: x,
                                            dfdFlags: v
                                        }
                                    }(c.buffer);
                                    self.postMessage({
                                        type: "transcode",
                                        id: c.id,
                                        faces: t,
                                        width: h,
                                        height: d,
                                        hasAlpha: f,
                                        format: p,
                                        dfdFlags: g
                                    }, a)
                                } catch (e) {
                                    console.error(e), self.postMessage({
                                        type: "error",
                                        id: c.id,
                                        error: e.message
                                    })
                                }
                            })
                    }
                });
                let a = [{
                        if: "astcSupported",
                        basisFormat: [s.UASTC_4x4],
                        transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
                        engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
                        priorityETC1S: 1 / 0,
                        priorityUASTC: 1,
                        needsPowerOfTwo: !1
                    }, {
                        if: "bptcSupported",
                        basisFormat: [s.ETC1S, s.UASTC_4x4],
                        transcoderFormat: [i.BC7_M5, i.BC7_M5],
                        engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
                        priorityETC1S: 3,
                        priorityUASTC: 2,
                        needsPowerOfTwo: !1
                    }, {
                        if: "dxtSupported",
                        basisFormat: [s.ETC1S, s.UASTC_4x4],
                        transcoderFormat: [i.BC1, i.BC3],
                        engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
                        priorityETC1S: 4,
                        priorityUASTC: 5,
                        needsPowerOfTwo: !1
                    }, {
                        if: "etc2Supported",
                        basisFormat: [s.ETC1S, s.UASTC_4x4],
                        transcoderFormat: [i.ETC1, i.ETC2],
                        engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
                        priorityETC1S: 1,
                        priorityUASTC: 3,
                        needsPowerOfTwo: !1
                    }, {
                        if: "etc1Supported",
                        basisFormat: [s.ETC1S, s.UASTC_4x4],
                        transcoderFormat: [i.ETC1],
                        engineFormat: [r.RGB_ETC1_Format],
                        priorityETC1S: 2,
                        priorityUASTC: 4,
                        needsPowerOfTwo: !1
                    }, {
                        if: "pvrtcSupported",
                        basisFormat: [s.ETC1S, s.UASTC_4x4],
                        transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
                        engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
                        priorityETC1S: 5,
                        priorityUASTC: 6,
                        needsPowerOfTwo: !0
                    }],
                    o = a.sort(function(e, t) {
                        return e.priorityETC1S - t.priorityETC1S
                    }),
                    l = a.sort(function(e, t) {
                        return e.priorityUASTC - t.priorityUASTC
                    });

                function u(e) {
                    return e <= 2 || (e & e - 1) == 0 && 0 !== e
                }
            });
            let eL = new Set([d.RGBAFormat, d.RGFormat, d.RedFormat]),
                eP = {
                    109: d.RGBAFormat,
                    97: d.RGBAFormat,
                    37: d.RGBAFormat,
                    43: d.RGBAFormat,
                    103: d.RGFormat,
                    83: d.RGFormat,
                    16: d.RGFormat,
                    22: d.RGFormat,
                    100: d.RedFormat,
                    76: d.RedFormat,
                    15: d.RedFormat,
                    9: d.RedFormat,
                    166: d.RGBA_ASTC_6x6_Format,
                    165: d.RGBA_ASTC_6x6_Format
                },
                eO = {
                    109: d.FloatType,
                    97: d.HalfFloatType,
                    37: d.UnsignedByteType,
                    43: d.UnsignedByteType,
                    103: d.FloatType,
                    83: d.HalfFloatType,
                    16: d.UnsignedByteType,
                    22: d.UnsignedByteType,
                    100: d.FloatType,
                    76: d.HalfFloatType,
                    15: d.UnsignedByteType,
                    9: d.UnsignedByteType,
                    166: d.UnsignedByteType,
                    165: d.UnsignedByteType
                };
            async function eN(e) {
                let t, n;
                let {
                    vkFormat: r
                } = e;
                if (void 0 === eP[r]) throw Error("THREE.KTX2Loader: Unsupported vkFormat.");
                2 === e.supercompressionScheme && (a || (a = new Promise(async e => {
                    let t = new eE;
                    await t.init(), e(t)
                })), t = await a);
                let i = [];
                for (let n = 0; n < e.levels.length; n++) {
                    let s, a;
                    let o = Math.max(1, e.pixelWidth >> n),
                        l = Math.max(1, e.pixelHeight >> n),
                        u = e.pixelDepth ? Math.max(1, e.pixelDepth >> n) : 0,
                        c = e.levels[n];
                    if (0 === e.supercompressionScheme) s = c.levelData;
                    else if (2 === e.supercompressionScheme) s = t.decode(c.levelData, c.uncompressedByteLength);
                    else throw Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                    a = eO[r] === d.FloatType ? new Float32Array(s.buffer, s.byteOffset, s.byteLength / Float32Array.BYTES_PER_ELEMENT) : eO[r] === d.HalfFloatType ? new Uint16Array(s.buffer, s.byteOffset, s.byteLength / Uint16Array.BYTES_PER_ELEMENT) : s, i.push({
                        data: a,
                        width: o,
                        height: l,
                        depth: u
                    })
                }
                if (eL.has(eP[r])) n = 0 === e.pixelDepth ? new d.DataTexture(i[0].data, e.pixelWidth, e.pixelHeight) : new eC(i[0].data, e.pixelWidth, e.pixelHeight, e.pixelDepth);
                else {
                    if (e.pixelDepth > 0) throw Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                    n = new d.CompressedTexture(i, e.pixelWidth, e.pixelHeight)
                }
                n.mipmaps = i, n.type = eO[r], n.format = eP[r], n.needsUpdate = !0;
                let s = eU(e);
                return "colorSpace" in n ? n.colorSpace = s : n.encoding = s === eT ? 3001 : 3e3, Promise.resolve(n)
            }

            function eU(e) {
                let t = e.dataFormatDescriptor[0];
                return 1 === t.colorPrimaries ? 2 === t.transferFunction ? eT : "srgb-linear" : 10 === t.colorPrimaries ? 2 === t.transferFunction ? "display-p3" : "display-p3-linear" : (0 === t.colorPrimaries || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`), "")
            }
            var eF = n(9749),
                ek = n(2125),
                eQ = n(8020);
            let eG = {
                    TEXTURE: "texture",
                    GLTF: "gltf",
                    KTX2: "ktx2",
                    LUT: "lut"
                },
                ez = () => [{
                    name: "hero-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/hero.glb")
                }, {
                    name: "chip-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/chip.glb")
                }, {
                    name: "neutrino-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/neutrino.glb")
                }, {
                    name: "tunnel-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/tunnel.glb")
                }, {
                    name: "section-1-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/sections.glb")
                }, {
                    name: "section-2-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/sections.glb")
                }, {
                    name: "section-3-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/sections.glb")
                }, {
                    name: "section-4-scene",
                    type: "gltf",
                    src: "".concat(eQ.GW, "/models/sections.glb")
                }, {
                    name: "lines-medium",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/hero-lines-medium-min.jpg")
                }, {
                    name: "lines-bold",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/hero-lines-bold-min.jpg")
                }, {
                    name: "lines-thin",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/hero-lines-thin-min.jpg")
                }, {
                    name: "tunnel-circles",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/tunnel-circles-min.jpg")
                }, {
                    name: "tunnel-circuits",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/tunnel-circuits-min.jpg")
                }, {
                    name: "tunnel-lines",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/tunnel-lines-min.jpg")
                }, {
                    name: "perlin-noise",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/perlin-datatexture.png")
                }, {
                    name: "simplex-noise",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/noise.png")
                }, {
                    name: "advect-noise",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/advect.png")
                }, {
                    name: "tech-noise",
                    type: "ktx2",
                    src: "".concat(eQ.GW, "/textures/tech-datatexture.ktx2")
                }, {
                    name: "lut-cube",
                    type: "lut",
                    src: "".concat(eQ.GW, "/textures/lut-R04.cube")
                }, {
                    name: "lut",
                    type: "texture",
                    src: "".concat(eQ.GW, "/textures/lut.png")
                }],
                eH = new p;
            eH.setDecoderPath(eQ.o7);
            let eV = (e, t) => {
                    let n;
                    switch (e.type) {
                        case eG.TEXTURE:
                            n = new d.TextureLoader(t);
                            break;
                        case eG.LUT:
                            n = new h.Xs(t);
                            break;
                        case eG.GLTF:
                            (n = new E(t)).setDRACOLoader(eH);
                            break;
                        case eG.KTX2:
                            o || (o = new eD(t).setTranscoderPath("".concat(eQ.GW, "/basis/")).detectSupport(new d.WebGLRenderer)), n = o
                    }
                    return n
                },
                ej = (0, eF.Ue)((0, ek.XR)((e, t) => ({
                    cache: new Map,
                    ready: !1,
                    loaded: !1,
                    loading: !1,
                    compiled: !1,
                    progress: 0,
                    load: () => {
                        new Promise(n => {
                            let r = new d.LoadingManager;
                            r.onStart = () => e({
                                loading: !0
                            }), r.onProgress = (t, n, r) => e({
                                progress: n / r * .9
                            }), r.onLoad = () => {
                                e({
                                    loading: !1,
                                    loaded: !0
                                }), n(t().cache)
                            }, c()(ez(), e => {
                                let n = eV(e, r);
                                null == n || n.load(e.src, n => {
                                    t().cache.set(e.name, n)
                                })
                            })
                        })
                    },
                    compile: async function() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        e({
                            compiled: !1
                        }), await Promise.all(t), l.ZP.delayedCall(0, () => {
                            e({
                                compiled: !0
                            })
                        })
                    },
                    complete: () => {
                        e({
                            ready: !0
                        })
                    }
                }))),
                eW = e => ej.getState().cache.get(e),
                eY = (e, t) => t.getObjectByName(e)
        },
        4543: function(e, t, n) {
            "use strict";
            n.d(t, {
                U: function() {
                    return o
                }
            });
            var r = n(9749),
                i = n(2125),
                s = n(4753);
            let a = {
                    currentRoute: void 0,
                    previousRoute: void 0
                },
                o = (0, r.Ue)((0, i.XR)((0, s.n)(e => ({ ...a,
                    setCurrentRoute: t => e(e => ({
                        previousRoute: e.currentRoute,
                        currentRoute: t
                    }))
                }))))
        },
        4937: function(e, t, n) {
            "use strict";
            n.d(t, {
                G: function() {
                    return i
                }
            });
            var r = n(8020);
            let i = () => window.innerWidth >= r.lL.LG
        },
        8061: function(e, t, n) {
            "use strict";
            n.d(t, {
                C: function() {
                    return l
                }
            });
            var r, i, s = n(959),
                a = n(9749);
            let o = "undefined" != typeof window && (null != (r = window.document) && r.createElement || (null == (i = window.navigator) ? void 0 : i.product) === "ReactNative") ? s.useLayoutEffect : s.useEffect,
                l = function() {
                    let e = (0, a.Ue)(e => ({
                        current: [],
                        version: 0,
                        set: e
                    }));
                    return {
                        In: ({
                            children: t
                        }) => {
                            let n = e(e => e.set),
                                r = e(e => e.version);
                            return o(() => {
                                n(e => ({
                                    version: e.version + 1
                                }))
                            }, []), o(() => (n(({
                                current: e
                            }) => ({
                                current: [...e, t]
                            })), () => n(({
                                current: e
                            }) => ({
                                current: e.filter(e => e !== t)
                            }))), [t, r]), null
                        },
                        Out: () => {
                            let t = e(e => e.current);
                            return s.createElement(s.Fragment, null, t)
                        }
                    }
                }()
        },
        2071: function() {},
        7432: function() {},
        5429: function(e) {
            e.exports = {
                style: {
                    fontFamily: "'__Roboto_Condensed_338de4', '__Roboto_Condensed_Fallback_338de4'",
                    fontStyle: "normal"
                },
                className: "__className_338de4"
            }
        },
        2710: function(e) {
            e.exports = {
                style: {
                    fontFamily: "'__helvetica_827732', '__helvetica_Fallback_827732'"
                },
                className: "__className_827732"
            }
        },
        9775: function(e) {
            ! function() {
                var t = {
                        229: function(e) {
                            var t, n, r, i = e.exports = {};

                            function s() {
                                throw Error("setTimeout has not been defined")
                            }

                            function a() {
                                throw Error("clearTimeout has not been defined")
                            }

                            function o(e) {
                                if (t === setTimeout) return setTimeout(e, 0);
                                if ((t === s || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);
                                try {
                                    return t(e, 0)
                                } catch (n) {
                                    try {
                                        return t.call(null, e, 0)
                                    } catch (n) {
                                        return t.call(this, e, 0)
                                    }
                                }
                            }! function() {
                                try {
                                    t = "function" == typeof setTimeout ? setTimeout : s
                                } catch (e) {
                                    t = s
                                }
                                try {
                                    n = "function" == typeof clearTimeout ? clearTimeout : a
                                } catch (e) {
                                    n = a
                                }
                            }();
                            var l = [],
                                u = !1,
                                c = -1;

                            function h() {
                                u && r && (u = !1, r.length ? l = r.concat(l) : c = -1, l.length && d())
                            }

                            function d() {
                                if (!u) {
                                    var e = o(h);
                                    u = !0;
                                    for (var t = l.length; t;) {
                                        for (r = l, l = []; ++c < t;) r && r[c].run();
                                        c = -1, t = l.length
                                    }
                                    r = null, u = !1,
                                        function(e) {
                                            if (n === clearTimeout) return clearTimeout(e);
                                            if ((n === a || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e);
                                            try {
                                                n(e)
                                            } catch (t) {
                                                try {
                                                    return n.call(null, e)
                                                } catch (t) {
                                                    return n.call(this, e)
                                                }
                                            }
                                        }(e)
                                }
                            }

                            function f(e, t) {
                                this.fun = e, this.array = t
                            }

                            function p() {}
                            i.nextTick = function(e) {
                                var t = Array(arguments.length - 1);
                                if (arguments.length > 1)
                                    for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
                                l.push(new f(e, t)), 1 !== l.length || u || o(d)
                            }, f.prototype.run = function() {
                                this.fun.apply(null, this.array)
                            }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = p, i.addListener = p, i.once = p, i.off = p, i.removeListener = p, i.removeAllListeners = p, i.emit = p, i.prependListener = p, i.prependOnceListener = p, i.listeners = function(e) {
                                return []
                            }, i.binding = function(e) {
                                throw Error("process.binding is not supported")
                            }, i.cwd = function() {
                                return "/"
                            }, i.chdir = function(e) {
                                throw Error("process.chdir is not supported")
                            }, i.umask = function() {
                                return 0
                            }
                        }
                    },
                    n = {};

                function r(e) {
                    var i = n[e];
                    if (void 0 !== i) return i.exports;
                    var s = n[e] = {
                            exports: {}
                        },
                        a = !0;
                    try {
                        t[e](s, s.exports, r), a = !1
                    } finally {
                        a && delete n[e]
                    }
                    return s.exports
                }
                r.ab = "//";
                var i = r(229);
                e.exports = i
            }()
        },
        4063: function(e, t, n) {
            e.exports = n(6543)
        },
        6704: function(e, t, n) {
            e.exports = n(7150)
        },
        4358: function(e, t, n) {
            e.exports = n(9153)
        },
        9469: function(e) {
            "use strict";

            function t(e) {
                this._maxSize = e, this.clear()
            }
            t.prototype.clear = function() {
                this._size = 0, this._values = Object.create(null)
            }, t.prototype.get = function(e) {
                return this._values[e]
            }, t.prototype.set = function(e, t) {
                return this._size >= this._maxSize && this.clear(), !(e in this._values) && this._size++, this._values[e] = t
            };
            var n = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
                r = /^\d+$/,
                i = /^\d/,
                s = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
                a = /^\s*(['"]?)(.*?)(\1)\s*$/,
                o = new t(512),
                l = new t(512),
                u = new t(512);

            function c(e) {
                return o.get(e) || o.set(e, h(e).map(function(e) {
                    return e.replace(a, "$2")
                }))
            }

            function h(e) {
                return e.match(n) || [""]
            }

            function d(e) {
                return "string" == typeof e && e && -1 !== ["'", '"'].indexOf(e.charAt(0))
            }
            e.exports = {
                Cache: t,
                split: h,
                normalizePath: c,
                setter: function(e) {
                    var t = c(e);
                    return l.get(e) || l.set(e, function(e, n) {
                        for (var r = 0, i = t.length, s = e; r < i - 1;) {
                            var a = t[r];
                            if ("__proto__" === a || "constructor" === a || "prototype" === a) return e;
                            s = s[t[r++]]
                        }
                        s[t[r]] = n
                    })
                },
                getter: function(e, t) {
                    var n = c(e);
                    return u.get(e) || u.set(e, function(e) {
                        for (var r = 0, i = n.length; r < i;) {
                            if (null == e && t) return;
                            e = e[n[r++]]
                        }
                        return e
                    })
                },
                join: function(e) {
                    return e.reduce(function(e, t) {
                        return e + (d(t) || r.test(t) ? "[" + t + "]" : (e ? "." : "") + t)
                    }, "")
                },
                forEach: function(e, t, n) {
                    ! function(e, t, n) {
                        var a, o, l, u, c, h = e.length;
                        for (l = 0; l < h; l++) {
                            (o = e[l]) && (!d(a = o) && (a.match(i) && !a.match(r) || s.test(a)) && (o = '"' + o + '"'), u = !(c = d(o)) && /^\d+$/.test(o), t.call(n, o, c, u, l, e))
                        }
                    }(Array.isArray(e) ? e : h(e), t, n)
                }
            }
        },
        1456: function(e) {
            "use strict";
            var t = Array.isArray,
                n = Object.keys,
                r = Object.prototype.hasOwnProperty,
                i = "undefined" != typeof Element;
            e.exports = function(e, s) {
                try {
                    return function e(s, a) {
                        if (s === a) return !0;
                        if (s && a && "object" == typeof s && "object" == typeof a) {
                            var o, l, u, c = t(s),
                                h = t(a);
                            if (c && h) {
                                if ((l = s.length) != a.length) return !1;
                                for (o = l; 0 != o--;)
                                    if (!e(s[o], a[o])) return !1;
                                return !0
                            }
                            if (c != h) return !1;
                            var d = s instanceof Date,
                                f = a instanceof Date;
                            if (d != f) return !1;
                            if (d && f) return s.getTime() == a.getTime();
                            var p = s instanceof RegExp,
                                g = a instanceof RegExp;
                            if (p != g) return !1;
                            if (p && g) return s.toString() == a.toString();
                            var A = n(s);
                            if ((l = A.length) !== n(a).length) return !1;
                            for (o = l; 0 != o--;)
                                if (!r.call(a, A[o])) return !1;
                            if (i && s instanceof Element && a instanceof Element) return s === a;
                            for (o = l; 0 != o--;)
                                if (("_owner" !== (u = A[o]) || !s.$$typeof) && !e(s[u], a[u])) return !1;
                            return !0
                        }
                        return s != s && a != a
                    }(e, s)
                } catch (e) {
                    if (e.message && e.message.match(/stack|recursion/i) || -2146828260 === e.number) return console.warn("Warning: react-fast-compare does not handle circular references.", e.name, e.message), !1;
                    throw e
                }
            }
        },
        198: function(e, t) {
            "use strict";
            var n = "function" == typeof Symbol && Symbol.for,
                r = n ? Symbol.for("react.element") : 60103,
                i = n ? Symbol.for("react.portal") : 60106,
                s = n ? Symbol.for("react.fragment") : 60107,
                a = n ? Symbol.for("react.strict_mode") : 60108,
                o = n ? Symbol.for("react.profiler") : 60114,
                l = n ? Symbol.for("react.provider") : 60109,
                u = n ? Symbol.for("react.context") : 60110,
                c = n ? Symbol.for("react.async_mode") : 60111,
                h = n ? Symbol.for("react.concurrent_mode") : 60111,
                d = n ? Symbol.for("react.forward_ref") : 60112,
                f = n ? Symbol.for("react.suspense") : 60113,
                p = n ? Symbol.for("react.suspense_list") : 60120,
                g = n ? Symbol.for("react.memo") : 60115,
                A = n ? Symbol.for("react.lazy") : 60116,
                m = n ? Symbol.for("react.block") : 60121,
                v = n ? Symbol.for("react.fundamental") : 60117,
                y = n ? Symbol.for("react.responder") : 60118,
                x = n ? Symbol.for("react.scope") : 60119;

            function E(e) {
                if ("object" == typeof e && null !== e) {
                    var t = e.$$typeof;
                    switch (t) {
                        case r:
                            switch (e = e.type) {
                                case c:
                                case h:
                                case s:
                                case o:
                                case a:
                                case f:
                                    return e;
                                default:
                                    switch (e = e && e.$$typeof) {
                                        case u:
                                        case d:
                                        case A:
                                        case g:
                                        case l:
                                            return e;
                                        default:
                                            return t
                                    }
                            }
                        case i:
                            return t
                    }
                }
            }

            function _(e) {
                return E(e) === h
            }
            t.AsyncMode = c, t.ConcurrentMode = h, t.ContextConsumer = u, t.ContextProvider = l, t.Element = r, t.ForwardRef = d, t.Fragment = s, t.Lazy = A, t.Memo = g, t.Portal = i, t.Profiler = o, t.StrictMode = a, t.Suspense = f, t.isAsyncMode = function(e) {
                return _(e) || E(e) === c
            }, t.isConcurrentMode = _, t.isContextConsumer = function(e) {
                return E(e) === u
            }, t.isContextProvider = function(e) {
                return E(e) === l
            }, t.isElement = function(e) {
                return "object" == typeof e && null !== e && e.$$typeof === r
            }, t.isForwardRef = function(e) {
                return E(e) === d
            }, t.isFragment = function(e) {
                return E(e) === s
            }, t.isLazy = function(e) {
                return E(e) === A
            }, t.isMemo = function(e) {
                return E(e) === g
            }, t.isPortal = function(e) {
                return E(e) === i
            }, t.isProfiler = function(e) {
                return E(e) === o
            }, t.isStrictMode = function(e) {
                return E(e) === a
            }, t.isSuspense = function(e) {
                return E(e) === f
            }, t.isValidElementType = function(e) {
                return "string" == typeof e || "function" == typeof e || e === s || e === h || e === o || e === a || e === f || e === p || "object" == typeof e && null !== e && (e.$$typeof === A || e.$$typeof === g || e.$$typeof === l || e.$$typeof === u || e.$$typeof === d || e.$$typeof === v || e.$$typeof === y || e.$$typeof === x || e.$$typeof === m)
            }, t.typeOf = E
        },
        6237: function(e, t, n) {
            "use strict";
            e.exports = n(198)
        },
        7068: function(e, t, n) {
            "use strict";

            function r(e, t, n, r, i, s, a) {
                this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = a
            }
            let i = {};
            ["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"].forEach(e => {
                i[e] = new r(e, 0, !1, e, null, !1, !1)
            }), [
                ["acceptCharset", "accept-charset"],
                ["className", "class"],
                ["htmlFor", "for"],
                ["httpEquiv", "http-equiv"]
            ].forEach(([e, t]) => {
                i[e] = new r(e, 1, !1, t, null, !1, !1)
            }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(e => {
                i[e] = new r(e, 2, !1, e.toLowerCase(), null, !1, !1)
            }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(e => {
                i[e] = new r(e, 2, !1, e, null, !1, !1)
            }), ["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "disablePictureInPicture", "disableRemotePlayback", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(e => {
                i[e] = new r(e, 3, !1, e.toLowerCase(), null, !1, !1)
            }), ["checked", "multiple", "muted", "selected"].forEach(e => {
                i[e] = new r(e, 3, !0, e, null, !1, !1)
            }), ["capture", "download"].forEach(e => {
                i[e] = new r(e, 4, !1, e, null, !1, !1)
            }), ["cols", "rows", "size", "span"].forEach(e => {
                i[e] = new r(e, 6, !1, e, null, !1, !1)
            }), ["rowSpan", "start"].forEach(e => {
                i[e] = new r(e, 5, !1, e.toLowerCase(), null, !1, !1)
            });
            let s = /[\-\:]([a-z])/g,
                a = e => e[1].toUpperCase();
            ["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(e => {
                let t = e.replace(s, a);
                i[t] = new r(t, 1, !1, e, null, !1, !1)
            }), ["xlink:actuate", "xlink:arcrole", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(e => {
                let t = e.replace(s, a);
                i[t] = new r(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
            }), ["xml:base", "xml:lang", "xml:space"].forEach(e => {
                let t = e.replace(s, a);
                i[t] = new r(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
            }), ["tabIndex", "crossOrigin"].forEach(e => {
                i[e] = new r(e, 1, !1, e.toLowerCase(), null, !1, !1)
            }), i.xlinkHref = new r("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(e => {
                i[e] = new r(e, 1, !1, e.toLowerCase(), null, !0, !0)
            });
            let {
                CAMELCASE: o,
                SAME: l,
                possibleStandardNames: u
            } = n(4090), c = RegExp.prototype.test.bind(RegExp("^(data|aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")), h = Object.keys(u).reduce((e, t) => {
                let n = u[t];
                return n === l ? e[t] = t : n === o ? e[t.toLowerCase()] = t : e[t] = n, e
            }, {});
            t.BOOLEAN = 3, t.BOOLEANISH_STRING = 2, t.NUMERIC = 5, t.OVERLOADED_BOOLEAN = 4, t.POSITIVE_NUMERIC = 6, t.RESERVED = 0, t.STRING = 1, t.getPropertyInfo = function(e) {
                return i.hasOwnProperty(e) ? i[e] : null
            }, t.isCustomAttribute = c, t.possibleStandardNames = h
        },
        4090: function(e, t) {
            t.SAME = 0, t.CAMELCASE = 1, t.possibleStandardNames = {
                accept: 0,
                acceptCharset: 1,
                "accept-charset": "acceptCharset",
                accessKey: 1,
                action: 0,
                allowFullScreen: 1,
                alt: 0,
                as: 0,
                async: 0,
                autoCapitalize: 1,
                autoComplete: 1,
                autoCorrect: 1,
                autoFocus: 1,
                autoPlay: 1,
                autoSave: 1,
                capture: 0,
                cellPadding: 1,
                cellSpacing: 1,
                challenge: 0,
                charSet: 1,
                checked: 0,
                children: 0,
                cite: 0,
                class: "className",
                classID: 1,
                className: 1,
                cols: 0,
                colSpan: 1,
                content: 0,
                contentEditable: 1,
                contextMenu: 1,
                controls: 0,
                controlsList: 1,
                coords: 0,
                crossOrigin: 1,
                dangerouslySetInnerHTML: 1,
                data: 0,
                dateTime: 1,
                default: 0,
                defaultChecked: 1,
                defaultValue: 1,
                defer: 0,
                dir: 0,
                disabled: 0,
                disablePictureInPicture: 1,
                disableRemotePlayback: 1,
                download: 0,
                draggable: 0,
                encType: 1,
                enterKeyHint: 1,
                for: "htmlFor",
                form: 0,
                formMethod: 1,
                formAction: 1,
                formEncType: 1,
                formNoValidate: 1,
                formTarget: 1,
                frameBorder: 1,
                headers: 0,
                height: 0,
                hidden: 0,
                high: 0,
                href: 0,
                hrefLang: 1,
                htmlFor: 1,
                httpEquiv: 1,
                "http-equiv": "httpEquiv",
                icon: 0,
                id: 0,
                innerHTML: 1,
                inputMode: 1,
                integrity: 0,
                is: 0,
                itemID: 1,
                itemProp: 1,
                itemRef: 1,
                itemScope: 1,
                itemType: 1,
                keyParams: 1,
                keyType: 1,
                kind: 0,
                label: 0,
                lang: 0,
                list: 0,
                loop: 0,
                low: 0,
                manifest: 0,
                marginWidth: 1,
                marginHeight: 1,
                max: 0,
                maxLength: 1,
                media: 0,
                mediaGroup: 1,
                method: 0,
                min: 0,
                minLength: 1,
                multiple: 0,
                muted: 0,
                name: 0,
                noModule: 1,
                nonce: 0,
                noValidate: 1,
                open: 0,
                optimum: 0,
                pattern: 0,
                placeholder: 0,
                playsInline: 1,
                poster: 0,
                preload: 0,
                profile: 0,
                radioGroup: 1,
                readOnly: 1,
                referrerPolicy: 1,
                rel: 0,
                required: 0,
                reversed: 0,
                role: 0,
                rows: 0,
                rowSpan: 1,
                sandbox: 0,
                scope: 0,
                scoped: 0,
                scrolling: 0,
                seamless: 0,
                selected: 0,
                shape: 0,
                size: 0,
                sizes: 0,
                span: 0,
                spellCheck: 1,
                src: 0,
                srcDoc: 1,
                srcLang: 1,
                srcSet: 1,
                start: 0,
                step: 0,
                style: 0,
                summary: 0,
                tabIndex: 1,
                target: 0,
                title: 0,
                type: 0,
                useMap: 1,
                value: 0,
                width: 0,
                wmode: 0,
                wrap: 0,
                about: 0,
                accentHeight: 1,
                "accent-height": "accentHeight",
                accumulate: 0,
                additive: 0,
                alignmentBaseline: 1,
                "alignment-baseline": "alignmentBaseline",
                allowReorder: 1,
                alphabetic: 0,
                amplitude: 0,
                arabicForm: 1,
                "arabic-form": "arabicForm",
                ascent: 0,
                attributeName: 1,
                attributeType: 1,
                autoReverse: 1,
                azimuth: 0,
                baseFrequency: 1,
                baselineShift: 1,
                "baseline-shift": "baselineShift",
                baseProfile: 1,
                bbox: 0,
                begin: 0,
                bias: 0,
                by: 0,
                calcMode: 1,
                capHeight: 1,
                "cap-height": "capHeight",
                clip: 0,
                clipPath: 1,
                "clip-path": "clipPath",
                clipPathUnits: 1,
                clipRule: 1,
                "clip-rule": "clipRule",
                color: 0,
                colorInterpolation: 1,
                "color-interpolation": "colorInterpolation",
                colorInterpolationFilters: 1,
                "color-interpolation-filters": "colorInterpolationFilters",
                colorProfile: 1,
                "color-profile": "colorProfile",
                colorRendering: 1,
                "color-rendering": "colorRendering",
                contentScriptType: 1,
                contentStyleType: 1,
                cursor: 0,
                cx: 0,
                cy: 0,
                d: 0,
                datatype: 0,
                decelerate: 0,
                descent: 0,
                diffuseConstant: 1,
                direction: 0,
                display: 0,
                divisor: 0,
                dominantBaseline: 1,
                "dominant-baseline": "dominantBaseline",
                dur: 0,
                dx: 0,
                dy: 0,
                edgeMode: 1,
                elevation: 0,
                enableBackground: 1,
                "enable-background": "enableBackground",
                end: 0,
                exponent: 0,
                externalResourcesRequired: 1,
                fill: 0,
                fillOpacity: 1,
                "fill-opacity": "fillOpacity",
                fillRule: 1,
                "fill-rule": "fillRule",
                filter: 0,
                filterRes: 1,
                filterUnits: 1,
                floodOpacity: 1,
                "flood-opacity": "floodOpacity",
                floodColor: 1,
                "flood-color": "floodColor",
                focusable: 0,
                fontFamily: 1,
                "font-family": "fontFamily",
                fontSize: 1,
                "font-size": "fontSize",
                fontSizeAdjust: 1,
                "font-size-adjust": "fontSizeAdjust",
                fontStretch: 1,
                "font-stretch": "fontStretch",
                fontStyle: 1,
                "font-style": "fontStyle",
                fontVariant: 1,
                "font-variant": "fontVariant",
                fontWeight: 1,
                "font-weight": "fontWeight",
                format: 0,
                from: 0,
                fx: 0,
                fy: 0,
                g1: 0,
                g2: 0,
                glyphName: 1,
                "glyph-name": "glyphName",
                glyphOrientationHorizontal: 1,
                "glyph-orientation-horizontal": "glyphOrientationHorizontal",
                glyphOrientationVertical: 1,
                "glyph-orientation-vertical": "glyphOrientationVertical",
                glyphRef: 1,
                gradientTransform: 1,
                gradientUnits: 1,
                hanging: 0,
                horizAdvX: 1,
                "horiz-adv-x": "horizAdvX",
                horizOriginX: 1,
                "horiz-origin-x": "horizOriginX",
                ideographic: 0,
                imageRendering: 1,
                "image-rendering": "imageRendering",
                in2: 0,
                in: 0,
                inlist: 0,
                intercept: 0,
                k1: 0,
                k2: 0,
                k3: 0,
                k4: 0,
                k: 0,
                kernelMatrix: 1,
                kernelUnitLength: 1,
                kerning: 0,
                keyPoints: 1,
                keySplines: 1,
                keyTimes: 1,
                lengthAdjust: 1,
                letterSpacing: 1,
                "letter-spacing": "letterSpacing",
                lightingColor: 1,
                "lighting-color": "lightingColor",
                limitingConeAngle: 1,
                local: 0,
                markerEnd: 1,
                "marker-end": "markerEnd",
                markerHeight: 1,
                markerMid: 1,
                "marker-mid": "markerMid",
                markerStart: 1,
                "marker-start": "markerStart",
                markerUnits: 1,
                markerWidth: 1,
                mask: 0,
                maskContentUnits: 1,
                maskUnits: 1,
                mathematical: 0,
                mode: 0,
                numOctaves: 1,
                offset: 0,
                opacity: 0,
                operator: 0,
                order: 0,
                orient: 0,
                orientation: 0,
                origin: 0,
                overflow: 0,
                overlinePosition: 1,
                "overline-position": "overlinePosition",
                overlineThickness: 1,
                "overline-thickness": "overlineThickness",
                paintOrder: 1,
                "paint-order": "paintOrder",
                panose1: 0,
                "panose-1": "panose1",
                pathLength: 1,
                patternContentUnits: 1,
                patternTransform: 1,
                patternUnits: 1,
                pointerEvents: 1,
                "pointer-events": "pointerEvents",
                points: 0,
                pointsAtX: 1,
                pointsAtY: 1,
                pointsAtZ: 1,
                prefix: 0,
                preserveAlpha: 1,
                preserveAspectRatio: 1,
                primitiveUnits: 1,
                property: 0,
                r: 0,
                radius: 0,
                refX: 1,
                refY: 1,
                renderingIntent: 1,
                "rendering-intent": "renderingIntent",
                repeatCount: 1,
                repeatDur: 1,
                requiredExtensions: 1,
                requiredFeatures: 1,
                resource: 0,
                restart: 0,
                result: 0,
                results: 0,
                rotate: 0,
                rx: 0,
                ry: 0,
                scale: 0,
                security: 0,
                seed: 0,
                shapeRendering: 1,
                "shape-rendering": "shapeRendering",
                slope: 0,
                spacing: 0,
                specularConstant: 1,
                specularExponent: 1,
                speed: 0,
                spreadMethod: 1,
                startOffset: 1,
                stdDeviation: 1,
                stemh: 0,
                stemv: 0,
                stitchTiles: 1,
                stopColor: 1,
                "stop-color": "stopColor",
                stopOpacity: 1,
                "stop-opacity": "stopOpacity",
                strikethroughPosition: 1,
                "strikethrough-position": "strikethroughPosition",
                strikethroughThickness: 1,
                "strikethrough-thickness": "strikethroughThickness",
                string: 0,
                stroke: 0,
                strokeDasharray: 1,
                "stroke-dasharray": "strokeDasharray",
                strokeDashoffset: 1,
                "stroke-dashoffset": "strokeDashoffset",
                strokeLinecap: 1,
                "stroke-linecap": "strokeLinecap",
                strokeLinejoin: 1,
                "stroke-linejoin": "strokeLinejoin",
                strokeMiterlimit: 1,
                "stroke-miterlimit": "strokeMiterlimit",
                strokeWidth: 1,
                "stroke-width": "strokeWidth",
                strokeOpacity: 1,
                "stroke-opacity": "strokeOpacity",
                suppressContentEditableWarning: 1,
                suppressHydrationWarning: 1,
                surfaceScale: 1,
                systemLanguage: 1,
                tableValues: 1,
                targetX: 1,
                targetY: 1,
                textAnchor: 1,
                "text-anchor": "textAnchor",
                textDecoration: 1,
                "text-decoration": "textDecoration",
                textLength: 1,
                textRendering: 1,
                "text-rendering": "textRendering",
                to: 0,
                transform: 0,
                typeof: 0,
                u1: 0,
                u2: 0,
                underlinePosition: 1,
                "underline-position": "underlinePosition",
                underlineThickness: 1,
                "underline-thickness": "underlineThickness",
                unicode: 0,
                unicodeBidi: 1,
                "unicode-bidi": "unicodeBidi",
                unicodeRange: 1,
                "unicode-range": "unicodeRange",
                unitsPerEm: 1,
                "units-per-em": "unitsPerEm",
                unselectable: 0,
                vAlphabetic: 1,
                "v-alphabetic": "vAlphabetic",
                values: 0,
                vectorEffect: 1,
                "vector-effect": "vectorEffect",
                version: 0,
                vertAdvY: 1,
                "vert-adv-y": "vertAdvY",
                vertOriginX: 1,
                "vert-origin-x": "vertOriginX",
                vertOriginY: 1,
                "vert-origin-y": "vertOriginY",
                vHanging: 1,
                "v-hanging": "vHanging",
                vIdeographic: 1,
                "v-ideographic": "vIdeographic",
                viewBox: 1,
                viewTarget: 1,
                visibility: 0,
                vMathematical: 1,
                "v-mathematical": "vMathematical",
                vocab: 0,
                widths: 0,
                wordSpacing: 1,
                "word-spacing": "wordSpacing",
                writingMode: 1,
                "writing-mode": "writingMode",
                x1: 0,
                x2: 0,
                x: 0,
                xChannelSelector: 1,
                xHeight: 1,
                "x-height": "xHeight",
                xlinkActuate: 1,
                "xlink:actuate": "xlinkActuate",
                xlinkArcrole: 1,
                "xlink:arcrole": "xlinkArcrole",
                xlinkHref: 1,
                "xlink:href": "xlinkHref",
                xlinkRole: 1,
                "xlink:role": "xlinkRole",
                xlinkShow: 1,
                "xlink:show": "xlinkShow",
                xlinkTitle: 1,
                "xlink:title": "xlinkTitle",
                xlinkType: 1,
                "xlink:type": "xlinkType",
                xmlBase: 1,
                "xml:base": "xmlBase",
                xmlLang: 1,
                "xml:lang": "xmlLang",
                xmlns: 0,
                "xml:space": "xmlSpace",
                xmlnsXlink: 1,
                "xmlns:xlink": "xmlnsXlink",
                xmlSpace: 1,
                y1: 0,
                y2: 0,
                y: 0,
                yChannelSelector: 1,
                z: 0,
                zoomAndPan: 1
            }
        },
        2378: function(e, t, n) {
            "use strict";
            n.d(t, {
                cn: function() {
                    return h
                },
                d0: function() {
                    return c
                },
                Ix: function() {
                    return d
                },
                ZP: function() {
                    return g
                }
            });
            var r = n(5142),
                i = n(959),
                s = n(422),
                a = {
                    disabled: !1
                },
                o = n(6222),
                l = "unmounted",
                u = "exited",
                c = "entering",
                h = "entered",
                d = "exiting",
                f = function(e) {
                    function t(t, n) {
                        r = e.call(this, t, n) || this;
                        var r, i, s = n && !n.isMounting ? t.enter : t.appear;
                        return r.appearStatus = null, t.in ? s ? (i = u, r.appearStatus = c) : i = h : i = t.unmountOnExit || t.mountOnEnter ? l : u, r.state = {
                            status: i
                        }, r.nextCallback = null, r
                    }(0, r.Z)(t, e), t.getDerivedStateFromProps = function(e, t) {
                        return e.in && t.status === l ? {
                            status: u
                        } : null
                    };
                    var n = t.prototype;
                    return n.componentDidMount = function() {
                        this.updateStatus(!0, this.appearStatus)
                    }, n.componentDidUpdate = function(e) {
                        var t = null;
                        if (e !== this.props) {
                            var n = this.state.status;
                            this.props.in ? n !== c && n !== h && (t = c) : (n === c || n === h) && (t = d)
                        }
                        this.updateStatus(!1, t)
                    }, n.componentWillUnmount = function() {
                        this.cancelNextCallback()
                    }, n.getTimeouts = function() {
                        var e, t, n, r = this.props.timeout;
                        return e = t = n = r, null != r && "number" != typeof r && (e = r.exit, t = r.enter, n = void 0 !== r.appear ? r.appear : t), {
                            exit: e,
                            enter: t,
                            appear: n
                        }
                    }, n.updateStatus = function(e, t) {
                        if (void 0 === e && (e = !1), null !== t) {
                            if (this.cancelNextCallback(), t === c) {
                                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                                    var n = this.props.nodeRef ? this.props.nodeRef.current : s.findDOMNode(this);
                                    n && n.scrollTop
                                }
                                this.performEnter(e)
                            } else this.performExit()
                        } else this.props.unmountOnExit && this.state.status === u && this.setState({
                            status: l
                        })
                    }, n.performEnter = function(e) {
                        var t = this,
                            n = this.props.enter,
                            r = this.context ? this.context.isMounting : e,
                            i = this.props.nodeRef ? [r] : [s.findDOMNode(this), r],
                            o = i[0],
                            l = i[1],
                            u = this.getTimeouts(),
                            d = r ? u.appear : u.enter;
                        if (!e && !n || a.disabled) {
                            this.safeSetState({
                                status: h
                            }, function() {
                                t.props.onEntered(o)
                            });
                            return
                        }
                        this.props.onEnter(o, l), this.safeSetState({
                            status: c
                        }, function() {
                            t.props.onEntering(o, l), t.onTransitionEnd(d, function() {
                                t.safeSetState({
                                    status: h
                                }, function() {
                                    t.props.onEntered(o, l)
                                })
                            })
                        })
                    }, n.performExit = function() {
                        var e = this,
                            t = this.props.exit,
                            n = this.getTimeouts(),
                            r = this.props.nodeRef ? void 0 : s.findDOMNode(this);
                        if (!t || a.disabled) {
                            this.safeSetState({
                                status: u
                            }, function() {
                                e.props.onExited(r)
                            });
                            return
                        }
                        this.props.onExit(r), this.safeSetState({
                            status: d
                        }, function() {
                            e.props.onExiting(r), e.onTransitionEnd(n.exit, function() {
                                e.safeSetState({
                                    status: u
                                }, function() {
                                    e.props.onExited(r)
                                })
                            })
                        })
                    }, n.cancelNextCallback = function() {
                        null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null)
                    }, n.safeSetState = function(e, t) {
                        t = this.setNextCallback(t), this.setState(e, t)
                    }, n.setNextCallback = function(e) {
                        var t = this,
                            n = !0;
                        return this.nextCallback = function(r) {
                            n && (n = !1, t.nextCallback = null, e(r))
                        }, this.nextCallback.cancel = function() {
                            n = !1
                        }, this.nextCallback
                    }, n.onTransitionEnd = function(e, t) {
                        this.setNextCallback(t);
                        var n = this.props.nodeRef ? this.props.nodeRef.current : s.findDOMNode(this),
                            r = null == e && !this.props.addEndListener;
                        if (!n || r) {
                            setTimeout(this.nextCallback, 0);
                            return
                        }
                        if (this.props.addEndListener) {
                            var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback],
                                a = i[0],
                                o = i[1];
                            this.props.addEndListener(a, o)
                        }
                        null != e && setTimeout(this.nextCallback, e)
                    }, n.render = function() {
                        var e = this.state.status;
                        if (e === l) return null;
                        var t = this.props,
                            n = t.children,
                            r = (t.in, t.mountOnEnter, t.unmountOnExit, t.appear, t.enter, t.exit, t.timeout, t.addEndListener, t.onEnter, t.onEntering, t.onEntered, t.onExit, t.onExiting, t.onExited, t.nodeRef, function(e, t) {
                                if (null == e) return {};
                                var n = {};
                                for (var r in e)
                                    if (({}).hasOwnProperty.call(e, r)) {
                                        if (t.includes(r)) continue;
                                        n[r] = e[r]
                                    }
                                return n
                            }(t, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
                        return i.createElement(o.Z.Provider, {
                            value: null
                        }, "function" == typeof n ? n(e, r) : i.cloneElement(i.Children.only(n), r))
                    }, t
                }(i.Component);

            function p() {}
            f.contextType = o.Z, f.propTypes = {}, f.defaultProps = { in: !1,
                mountOnEnter: !1,
                unmountOnExit: !1,
                appear: !1,
                enter: !0,
                exit: !0,
                onEnter: p,
                onEntering: p,
                onEntered: p,
                onExit: p,
                onExiting: p,
                onExited: p
            }, f.UNMOUNTED = l, f.EXITED = u, f.ENTERING = c, f.ENTERED = h, f.EXITING = d;
            var g = f
        },
        6222: function(e, t, n) {
            "use strict";
            var r = n(959);
            t.Z = r.createContext(null)
        },
        6263: function(e, t, n) {
            "use strict";
            var r = (this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                })(n(4075)),
                i = n(4878);

            function s(e, t) {
                var n = {};
                return e && "string" == typeof e && (0, r.default)(e, function(e, r) {
                    e && r && (n[(0, i.camelCase)(e, t)] = r)
                }), n
            }
            s.default = s, e.exports = s
        },
        4878: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.camelCase = void 0;
            var n = /^--[a-zA-Z0-9_-]+$/,
                r = /-([a-z])/g,
                i = /^[^-]+$/,
                s = /^-(webkit|moz|ms|o|khtml)-/,
                a = /^-(ms)-/,
                o = function(e, t) {
                    return t.toUpperCase()
                },
                l = function(e, t) {
                    return "".concat(t, "-")
                };
            t.camelCase = function(e, t) {
                var u;
                return (void 0 === t && (t = {}), !(u = e) || i.test(u) || n.test(u)) ? e : (e = e.toLowerCase(), (e = t.reactCompat ? e.replace(a, l) : e.replace(s, l)).replace(r, o))
            }
        },
        4075: function(e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function(e, t) {
                var n = null;
                if (!e || "string" != typeof e) return n;
                var r = (0, i.default)(e),
                    s = "function" == typeof t;
                return r.forEach(function(e) {
                    if ("declaration" === e.type) {
                        var r = e.property,
                            i = e.value;
                        s ? t(r, i, e) : i && ((n = n || {})[r] = i)
                    }
                }), n
            };
            var i = r(n(2640))
        },
        1438: function(e) {
            let t = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g,
                n = e => e.match(t) || [],
                r = e => e[0].toUpperCase() + e.slice(1),
                i = (e, t) => n(e).join(t).toLowerCase(),
                s = e => n(e).reduce((e, t) => `${e}${e?t[0].toUpperCase()+t.slice(1).toLowerCase():t.toLowerCase()}`, "");
            e.exports = {
                words: n,
                upperFirst: r,
                camelCase: s,
                pascalCase: e => r(s(e)),
                snakeCase: e => i(e, "_"),
                kebabCase: e => i(e, "-"),
                sentenceCase: e => r(i(e, " ")),
                titleCase: e => n(e).map(r).join(" ")
            }
        },
        1916: function(e) {
            function t(e, t) {
                var n = e.length,
                    r = Array(n),
                    i = {},
                    s = n,
                    a = function(e) {
                        for (var t = new Map, n = 0, r = e.length; n < r; n++) {
                            var i = e[n];
                            t.has(i[0]) || t.set(i[0], new Set), t.has(i[1]) || t.set(i[1], new Set), t.get(i[0]).add(i[1])
                        }
                        return t
                    }(t),
                    o = function(e) {
                        for (var t = new Map, n = 0, r = e.length; n < r; n++) t.set(e[n], n);
                        return t
                    }(e);
                for (t.forEach(function(e) {
                        if (!o.has(e[0]) || !o.has(e[1])) throw Error("Unknown node. There is an unknown node in the supplied edges.")
                    }); s--;) i[s] || function e(t, s, l) {
                    if (l.has(t)) {
                        var u;
                        try {
                            u = ", node was:" + JSON.stringify(t)
                        } catch (e) {
                            u = ""
                        }
                        throw Error("Cyclic dependency" + u)
                    }
                    if (!o.has(t)) throw Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(t));
                    if (!i[s]) {
                        i[s] = !0;
                        var c = a.get(t) || new Set;
                        if (s = (c = Array.from(c)).length) {
                            l.add(t);
                            do {
                                var h = c[--s];
                                e(h, o.get(h), l)
                            } while (s);
                            l.delete(t)
                        }
                        r[--n] = t
                    }
                }(e[s], s, new Set);
                return r
            }
            e.exports = function(e) {
                return t(function(e) {
                    for (var t = new Set, n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.add(i[0]), t.add(i[1])
                    }
                    return Array.from(t)
                }(e), e)
            }, e.exports.array = t
        },
        9627: function(e, t, n) {
            "use strict";
            var r = n(959),
                i = "function" == typeof Object.is ? Object.is : function(e, t) {
                    return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t
                },
                s = r.useState,
                a = r.useEffect,
                o = r.useLayoutEffect,
                l = r.useDebugValue;

            function u(e) {
                var t = e.getSnapshot;
                e = e.value;
                try {
                    var n = t();
                    return !i(e, n)
                } catch (e) {
                    return !0
                }
            }
            var c = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function(e, t) {
                return t()
            } : function(e, t) {
                var n = t(),
                    r = s({
                        inst: {
                            value: n,
                            getSnapshot: t
                        }
                    }),
                    i = r[0].inst,
                    c = r[1];
                return o(function() {
                    i.value = n, i.getSnapshot = t, u(i) && c({
                        inst: i
                    })
                }, [e, n, t]), a(function() {
                    return u(i) && c({
                        inst: i
                    }), e(function() {
                        u(i) && c({
                            inst: i
                        })
                    })
                }, [e]), l(n), n
            };
            t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : c
        },
        6550: function(e, t, n) {
            "use strict";
            var r = n(959),
                i = n(7287),
                s = "function" == typeof Object.is ? Object.is : function(e, t) {
                    return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t
                },
                a = i.useSyncExternalStore,
                o = r.useRef,
                l = r.useEffect,
                u = r.useMemo,
                c = r.useDebugValue;
            t.useSyncExternalStoreWithSelector = function(e, t, n, r, i) {
                var h = o(null);
                if (null === h.current) {
                    var d = {
                        hasValue: !1,
                        value: null
                    };
                    h.current = d
                } else d = h.current;
                var f = a(e, (h = u(function() {
                    function e(e) {
                        if (!l) {
                            if (l = !0, a = e, e = r(e), void 0 !== i && d.hasValue) {
                                var t = d.value;
                                if (i(t, e)) return o = t
                            }
                            return o = e
                        }
                        if (t = o, s(a, e)) return t;
                        var n = r(e);
                        return void 0 !== i && i(t, n) ? t : (a = e, o = n)
                    }
                    var a, o, l = !1,
                        u = void 0 === n ? null : n;
                    return [function() {
                        return e(t())
                    }, null === u ? void 0 : function() {
                        return e(u())
                    }]
                }, [t, n, r, i]))[0], h[1]);
                return l(function() {
                    d.hasValue = !0, d.value = f
                }, [f]), c(f), f
            }
        },
        7287: function(e, t, n) {
            "use strict";
            e.exports = n(9627)
        },
        9714: function(e, t, n) {
            "use strict";
            e.exports = n(6550)
        },
        788: function(e, t, n) {
            var r = {
                "./en.json": 6124,
                "./it.json": 8267
            };

            function i(e) {
                return n(s(e))
            }

            function s(e) {
                if (!n.o(r, e)) {
                    var t = Error("Cannot find module '" + e + "'");
                    throw t.code = "MODULE_NOT_FOUND", t
                }
                return r[e]
            }
            i.keys = function() {
                return Object.keys(r)
            }, i.resolve = s, e.exports = i, i.id = 788
        },
        5142: function(e, t, n) {
            "use strict";

            function r(e, t) {
                return (r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function i(e, t) {
                e.prototype = Object.create(t.prototype), e.prototype.constructor = e, r(e, t)
            }
            n.d(t, {
                Z: function() {
                    return i
                }
            })
        },
        5061: function(e, t, n) {
            "use strict";

            function r(e, t, {
                checkForDefaultPrevented: n = !0
            } = {}) {
                return function(r) {
                    if (e ? .(r), !1 === n || !r.defaultPrevented) return t ? .(r)
                }
            }
            n.d(t, {
                M: function() {
                    return r
                }
            })
        },
        3079: function(e, t, n) {
            "use strict";
            n.d(t, {
                F: function() {
                    return i
                },
                e: function() {
                    return s
                }
            });
            var r = n(959);

            function i(...e) {
                return t => e.forEach(e => {
                    "function" == typeof e ? e(t) : null != e && (e.current = t)
                })
            }

            function s(...e) {
                return r.useCallback(i(...e), e)
            }
        },
        1354: function(e, t, n) {
            "use strict";
            n.d(t, {
                b: function() {
                    return s
                }
            });
            var r = n(959),
                i = n(1527);

            function s(e, t = []) {
                let n = [],
                    s = () => {
                        let t = n.map(e => r.createContext(e));
                        return function(n) {
                            let i = n ? .[e] || t;
                            return r.useMemo(() => ({
                                [`__scope${e}`]: { ...n,
                                    [e]: i
                                }
                            }), [n, i])
                        }
                    };
                return s.scopeName = e, [function(t, s) {
                    let a = r.createContext(s),
                        o = n.length;

                    function l(t) {
                        let {
                            scope: n,
                            children: s,
                            ...l
                        } = t, u = n ? .[e][o] || a, c = r.useMemo(() => l, Object.values(l));
                        return (0, i.jsx)(u.Provider, {
                            value: c,
                            children: s
                        })
                    }
                    return n = [...n, s], l.displayName = t + "Provider", [l, function(n, i) {
                        let l = i ? .[e][o] || a,
                            u = r.useContext(l);
                        if (u) return u;
                        if (void 0 !== s) return s;
                        throw Error(`\`${n}\` must be used within \`${t}\``)
                    }]
                }, function(...e) {
                    let t = e[0];
                    if (1 === e.length) return t;
                    let n = () => {
                        let n = e.map(e => ({
                            useScope: e(),
                            scopeName: e.scopeName
                        }));
                        return function(e) {
                            let i = n.reduce((t, {
                                useScope: n,
                                scopeName: r
                            }) => {
                                let i = n(e)[`__scope${r}`];
                                return { ...t,
                                    ...i
                                }
                            }, {});
                            return r.useMemo(() => ({
                                [`__scope${t.scopeName}`]: i
                            }), [i])
                        }
                    };
                    return n.scopeName = t.scopeName, n
                }(s, ...t)]
            }
        },
        9650: function(e, t, n) {
            "use strict";
            n.d(t, {
                b: function() {
                    return s
                }
            });
            var r = n(959),
                i = n(1527);

            function s(e, t = []) {
                let n = [],
                    s = () => {
                        let t = n.map(e => r.createContext(e));
                        return function(n) {
                            let i = n ? .[e] || t;
                            return r.useMemo(() => ({
                                [`__scope${e}`]: { ...n,
                                    [e]: i
                                }
                            }), [n, i])
                        }
                    };
                return s.scopeName = e, [function(t, s) {
                    let a = r.createContext(s),
                        o = n.length;
                    n = [...n, s];
                    let l = t => {
                        let {
                            scope: n,
                            children: s,
                            ...l
                        } = t, u = n ? .[e] ? .[o] || a, c = r.useMemo(() => l, Object.values(l));
                        return (0, i.jsx)(u.Provider, {
                            value: c,
                            children: s
                        })
                    };
                    return l.displayName = t + "Provider", [l, function(n, i) {
                        let l = i ? .[e] ? .[o] || a,
                            u = r.useContext(l);
                        if (u) return u;
                        if (void 0 !== s) return s;
                        throw Error(`\`${n}\` must be used within \`${t}\``)
                    }]
                }, function(...e) {
                    let t = e[0];
                    if (1 === e.length) return t;
                    let n = () => {
                        let n = e.map(e => ({
                            useScope: e(),
                            scopeName: e.scopeName
                        }));
                        return function(e) {
                            let i = n.reduce((t, {
                                useScope: n,
                                scopeName: r
                            }) => {
                                let i = n(e)[`__scope${r}`];
                                return { ...t,
                                    ...i
                                }
                            }, {});
                            return r.useMemo(() => ({
                                [`__scope${t.scopeName}`]: i
                            }), [i])
                        }
                    };
                    return n.scopeName = t.scopeName, n
                }(s, ...t)]
            }
        },
        3190: function(e, t, n) {
            "use strict";
            n.d(t, {
                XB: function() {
                    return d
                }
            });
            var r, i = n(959),
                s = n(5061),
                a = n(5176),
                o = n(3079),
                l = n(5203),
                u = n(1527),
                c = "dismissableLayer.update",
                h = i.createContext({
                    layers: new Set,
                    layersWithOutsidePointerEventsDisabled: new Set,
                    branches: new Set
                }),
                d = i.forwardRef((e, t) => {
                    let {
                        disableOutsidePointerEvents: n = !1,
                        onEscapeKeyDown: d,
                        onPointerDownOutside: g,
                        onFocusOutside: A,
                        onInteractOutside: m,
                        onDismiss: v,
                        ...y
                    } = e, x = i.useContext(h), [E, _] = i.useState(null), b = E ? .ownerDocument ? ? globalThis ? .document, [, w] = i.useState({}), C = (0, o.e)(t, e => _(e)), S = Array.from(x.layers), [I] = [...x.layersWithOutsidePointerEventsDisabled].slice(-1), M = S.indexOf(I), T = E ? S.indexOf(E) : -1, B = x.layersWithOutsidePointerEventsDisabled.size > 0, R = T >= M, D = function(e, t = globalThis ? .document) {
                        let n = (0, l.W)(e),
                            r = i.useRef(!1),
                            s = i.useRef(() => {});
                        return i.useEffect(() => {
                            let e = e => {
                                    if (e.target && !r.current) {
                                        let r = function() {
                                                p("dismissableLayer.pointerDownOutside", n, i, {
                                                    discrete: !0
                                                })
                                            },
                                            i = {
                                                originalEvent: e
                                            };
                                        "touch" === e.pointerType ? (t.removeEventListener("click", s.current), s.current = r, t.addEventListener("click", s.current, {
                                            once: !0
                                        })) : r()
                                    } else t.removeEventListener("click", s.current);
                                    r.current = !1
                                },
                                i = window.setTimeout(() => {
                                    t.addEventListener("pointerdown", e)
                                }, 0);
                            return () => {
                                window.clearTimeout(i), t.removeEventListener("pointerdown", e), t.removeEventListener("click", s.current)
                            }
                        }, [t, n]), {
                            onPointerDownCapture: () => r.current = !0
                        }
                    }(e => {
                        let t = e.target,
                            n = [...x.branches].some(e => e.contains(t));
                        !R || n || (g ? .(e), m ? .(e), e.defaultPrevented || v ? .())
                    }, b), L = function(e, t = globalThis ? .document) {
                        let n = (0, l.W)(e),
                            r = i.useRef(!1);
                        return i.useEffect(() => {
                            let e = e => {
                                e.target && !r.current && p("dismissableLayer.focusOutside", n, {
                                    originalEvent: e
                                }, {
                                    discrete: !1
                                })
                            };
                            return t.addEventListener("focusin", e), () => t.removeEventListener("focusin", e)
                        }, [t, n]), {
                            onFocusCapture: () => r.current = !0,
                            onBlurCapture: () => r.current = !1
                        }
                    }(e => {
                        let t = e.target;
                        [...x.branches].some(e => e.contains(t)) || (A ? .(e), m ? .(e), e.defaultPrevented || v ? .())
                    }, b);
                    return ! function(e, t = globalThis ? .document) {
                        let n = (0, l.W)(e);
                        i.useEffect(() => {
                            let e = e => {
                                "Escape" === e.key && n(e)
                            };
                            return t.addEventListener("keydown", e, {
                                capture: !0
                            }), () => t.removeEventListener("keydown", e, {
                                capture: !0
                            })
                        }, [n, t])
                    }(e => {
                        T !== x.layers.size - 1 || (d ? .(e), !e.defaultPrevented && v && (e.preventDefault(), v()))
                    }, b), i.useEffect(() => {
                        if (E) return n && (0 === x.layersWithOutsidePointerEventsDisabled.size && (r = b.body.style.pointerEvents, b.body.style.pointerEvents = "none"), x.layersWithOutsidePointerEventsDisabled.add(E)), x.layers.add(E), f(), () => {
                            n && 1 === x.layersWithOutsidePointerEventsDisabled.size && (b.body.style.pointerEvents = r)
                        }
                    }, [E, b, n, x]), i.useEffect(() => () => {
                        E && (x.layers.delete(E), x.layersWithOutsidePointerEventsDisabled.delete(E), f())
                    }, [E, x]), i.useEffect(() => {
                        let e = () => w({});
                        return document.addEventListener(c, e), () => document.removeEventListener(c, e)
                    }, []), (0, u.jsx)(a.WV.div, { ...y,
                        ref: C,
                        style: {
                            pointerEvents: B ? R ? "auto" : "none" : void 0,
                            ...e.style
                        },
                        onFocusCapture: (0, s.M)(e.onFocusCapture, L.onFocusCapture),
                        onBlurCapture: (0, s.M)(e.onBlurCapture, L.onBlurCapture),
                        onPointerDownCapture: (0, s.M)(e.onPointerDownCapture, D.onPointerDownCapture)
                    })
                });

            function f() {
                let e = new CustomEvent(c);
                document.dispatchEvent(e)
            }

            function p(e, t, n, {
                discrete: r
            }) {
                let i = n.originalEvent.target,
                    s = new CustomEvent(e, {
                        bubbles: !1,
                        cancelable: !0,
                        detail: n
                    });
                t && i.addEventListener(e, t, {
                    once: !0
                }), r ? (0, a.jH)(i, s) : i.dispatchEvent(s)
            }
            d.displayName = "DismissableLayer", i.forwardRef((e, t) => {
                let n = i.useContext(h),
                    r = i.useRef(null),
                    s = (0, o.e)(t, r);
                return i.useEffect(() => {
                    let e = r.current;
                    if (e) return n.branches.add(e), () => {
                        n.branches.delete(e)
                    }
                }, [n.branches]), (0, u.jsx)(a.WV.div, { ...e,
                    ref: s
                })
            }).displayName = "DismissableLayerBranch"
        },
        4774: function(e, t, n) {
            "use strict";
            n.d(t, {
                M: function() {
                    return l
                }
            });
            var r, i = n(959),
                s = n(4898),
                a = (r || (r = n.t(i, 2)))["useId".toString()] || (() => void 0),
                o = 0;

            function l(e) {
                let [t, n] = i.useState(a());
                return (0, s.b)(() => {
                    e || n(e => e ? ? String(o++))
                }, [e]), e || (t ? `radix-${t}` : "")
            }
        },
        9429: function(e, t, n) {
            "use strict";
            n.d(t, {
                ee: function() {
                    return eY
                },
                Eh: function() {
                    return eq
                },
                VY: function() {
                    return eX
                },
                fC: function() {
                    return eW
                },
                D7: function() {
                    return eB
                }
            });
            var r = n(959);
            let i = ["top", "right", "bottom", "left"],
                s = Math.min,
                a = Math.max,
                o = Math.round,
                l = Math.floor,
                u = e => ({
                    x: e,
                    y: e
                }),
                c = {
                    left: "right",
                    right: "left",
                    bottom: "top",
                    top: "bottom"
                },
                h = {
                    start: "end",
                    end: "start"
                };

            function d(e, t) {
                return "function" == typeof e ? e(t) : e
            }

            function f(e) {
                return e.split("-")[0]
            }

            function p(e) {
                return e.split("-")[1]
            }

            function g(e) {
                return "x" === e ? "y" : "x"
            }

            function A(e) {
                return "y" === e ? "height" : "width"
            }

            function m(e) {
                return ["top", "bottom"].includes(f(e)) ? "y" : "x"
            }

            function v(e) {
                return e.replace(/start|end/g, e => h[e])
            }

            function y(e) {
                return e.replace(/left|right|bottom|top/g, e => c[e])
            }

            function x(e) {
                return "number" != typeof e ? {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    ...e
                } : {
                    top: e,
                    right: e,
                    bottom: e,
                    left: e
                }
            }

            function E(e) {
                let {
                    x: t,
                    y: n,
                    width: r,
                    height: i
                } = e;
                return {
                    width: r,
                    height: i,
                    top: n,
                    left: t,
                    right: t + r,
                    bottom: n + i,
                    x: t,
                    y: n
                }
            }

            function _(e, t, n) {
                let r, {
                        reference: i,
                        floating: s
                    } = e,
                    a = m(t),
                    o = g(m(t)),
                    l = A(o),
                    u = f(t),
                    c = "y" === a,
                    h = i.x + i.width / 2 - s.width / 2,
                    d = i.y + i.height / 2 - s.height / 2,
                    v = i[l] / 2 - s[l] / 2;
                switch (u) {
                    case "top":
                        r = {
                            x: h,
                            y: i.y - s.height
                        };
                        break;
                    case "bottom":
                        r = {
                            x: h,
                            y: i.y + i.height
                        };
                        break;
                    case "right":
                        r = {
                            x: i.x + i.width,
                            y: d
                        };
                        break;
                    case "left":
                        r = {
                            x: i.x - s.width,
                            y: d
                        };
                        break;
                    default:
                        r = {
                            x: i.x,
                            y: i.y
                        }
                }
                switch (p(t)) {
                    case "start":
                        r[o] -= v * (n && c ? -1 : 1);
                        break;
                    case "end":
                        r[o] += v * (n && c ? -1 : 1)
                }
                return r
            }
            let b = async (e, t, n) => {
                let {
                    placement: r = "bottom",
                    strategy: i = "absolute",
                    middleware: s = [],
                    platform: a
                } = n, o = s.filter(Boolean), l = await (null == a.isRTL ? void 0 : a.isRTL(t)), u = await a.getElementRects({
                    reference: e,
                    floating: t,
                    strategy: i
                }), {
                    x: c,
                    y: h
                } = _(u, r, l), d = r, f = {}, p = 0;
                for (let n = 0; n < o.length; n++) {
                    let {
                        name: s,
                        fn: g
                    } = o[n], {
                        x: A,
                        y: m,
                        data: v,
                        reset: y
                    } = await g({
                        x: c,
                        y: h,
                        initialPlacement: r,
                        placement: d,
                        strategy: i,
                        middlewareData: f,
                        rects: u,
                        platform: a,
                        elements: {
                            reference: e,
                            floating: t
                        }
                    });
                    c = null != A ? A : c, h = null != m ? m : h, f = { ...f,
                        [s]: { ...f[s],
                            ...v
                        }
                    }, y && p <= 50 && (p++, "object" == typeof y && (y.placement && (d = y.placement), y.rects && (u = !0 === y.rects ? await a.getElementRects({
                        reference: e,
                        floating: t,
                        strategy: i
                    }) : y.rects), {
                        x: c,
                        y: h
                    } = _(u, d, l)), n = -1)
                }
                return {
                    x: c,
                    y: h,
                    placement: d,
                    strategy: i,
                    middlewareData: f
                }
            };
            async function w(e, t) {
                var n;
                void 0 === t && (t = {});
                let {
                    x: r,
                    y: i,
                    platform: s,
                    rects: a,
                    elements: o,
                    strategy: l
                } = e, {
                    boundary: u = "clippingAncestors",
                    rootBoundary: c = "viewport",
                    elementContext: h = "floating",
                    altBoundary: f = !1,
                    padding: p = 0
                } = d(t, e), g = x(p), A = o[f ? "floating" === h ? "reference" : "floating" : h], m = E(await s.getClippingRect({
                    element: null == (n = await (null == s.isElement ? void 0 : s.isElement(A))) || n ? A : A.contextElement || await (null == s.getDocumentElement ? void 0 : s.getDocumentElement(o.floating)),
                    boundary: u,
                    rootBoundary: c,
                    strategy: l
                })), v = "floating" === h ? {
                    x: r,
                    y: i,
                    width: a.floating.width,
                    height: a.floating.height
                } : a.reference, y = await (null == s.getOffsetParent ? void 0 : s.getOffsetParent(o.floating)), _ = await (null == s.isElement ? void 0 : s.isElement(y)) && await (null == s.getScale ? void 0 : s.getScale(y)) || {
                    x: 1,
                    y: 1
                }, b = E(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
                    elements: o,
                    rect: v,
                    offsetParent: y,
                    strategy: l
                }) : v);
                return {
                    top: (m.top - b.top + g.top) / _.y,
                    bottom: (b.bottom - m.bottom + g.bottom) / _.y,
                    left: (m.left - b.left + g.left) / _.x,
                    right: (b.right - m.right + g.right) / _.x
                }
            }

            function C(e, t) {
                return {
                    top: e.top - t.height,
                    right: e.right - t.width,
                    bottom: e.bottom - t.height,
                    left: e.left - t.width
                }
            }

            function S(e) {
                return i.some(t => e[t] >= 0)
            }
            async function I(e, t) {
                let {
                    placement: n,
                    platform: r,
                    elements: i
                } = e, s = await (null == r.isRTL ? void 0 : r.isRTL(i.floating)), a = f(n), o = p(n), l = "y" === m(n), u = ["left", "top"].includes(a) ? -1 : 1, c = s && l ? -1 : 1, h = d(t, e), {
                    mainAxis: g,
                    crossAxis: A,
                    alignmentAxis: v
                } = "number" == typeof h ? {
                    mainAxis: h,
                    crossAxis: 0,
                    alignmentAxis: null
                } : {
                    mainAxis: h.mainAxis || 0,
                    crossAxis: h.crossAxis || 0,
                    alignmentAxis: h.alignmentAxis
                };
                return o && "number" == typeof v && (A = "end" === o ? -1 * v : v), l ? {
                    x: A * c,
                    y: g * u
                } : {
                    x: g * u,
                    y: A * c
                }
            }

            function M() {
                return "undefined" != typeof window
            }

            function T(e) {
                return D(e) ? (e.nodeName || "").toLowerCase() : "#document"
            }

            function B(e) {
                var t;
                return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window
            }

            function R(e) {
                var t;
                return null == (t = (D(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement
            }

            function D(e) {
                return !!M() && (e instanceof Node || e instanceof B(e).Node)
            }

            function L(e) {
                return !!M() && (e instanceof Element || e instanceof B(e).Element)
            }

            function P(e) {
                return !!M() && (e instanceof HTMLElement || e instanceof B(e).HTMLElement)
            }

            function O(e) {
                return !!M() && "undefined" != typeof ShadowRoot && (e instanceof ShadowRoot || e instanceof B(e).ShadowRoot)
            }

            function N(e) {
                let {
                    overflow: t,
                    overflowX: n,
                    overflowY: r,
                    display: i
                } = G(e);
                return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i)
            }

            function U(e) {
                return [":popover-open", ":modal"].some(t => {
                    try {
                        return e.matches(t)
                    } catch (e) {
                        return !1
                    }
                })
            }

            function F(e) {
                let t = k(),
                    n = L(e) ? G(e) : e;
                return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some(e => (n.willChange || "").includes(e)) || ["paint", "layout", "strict", "content"].some(e => (n.contain || "").includes(e))
            }

            function k() {
                return "undefined" != typeof CSS && !!CSS.supports && CSS.supports("-webkit-backdrop-filter", "none")
            }

            function Q(e) {
                return ["html", "body", "#document"].includes(T(e))
            }

            function G(e) {
                return B(e).getComputedStyle(e)
            }

            function z(e) {
                return L(e) ? {
                    scrollLeft: e.scrollLeft,
                    scrollTop: e.scrollTop
                } : {
                    scrollLeft: e.scrollX,
                    scrollTop: e.scrollY
                }
            }

            function H(e) {
                if ("html" === T(e)) return e;
                let t = e.assignedSlot || e.parentNode || O(e) && e.host || R(e);
                return O(t) ? t.host : t
            }

            function V(e, t, n) {
                var r;
                void 0 === t && (t = []), void 0 === n && (n = !0);
                let i = function e(t) {
                        let n = H(t);
                        return Q(n) ? t.ownerDocument ? t.ownerDocument.body : t.body : P(n) && N(n) ? n : e(n)
                    }(e),
                    s = i === (null == (r = e.ownerDocument) ? void 0 : r.body),
                    a = B(i);
                if (s) {
                    let e = j(a);
                    return t.concat(a, a.visualViewport || [], N(i) ? i : [], e && n ? V(e) : [])
                }
                return t.concat(i, V(i, [], n))
            }

            function j(e) {
                return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
            }

            function W(e) {
                let t = G(e),
                    n = parseFloat(t.width) || 0,
                    r = parseFloat(t.height) || 0,
                    i = P(e),
                    s = i ? e.offsetWidth : n,
                    a = i ? e.offsetHeight : r,
                    l = o(n) !== s || o(r) !== a;
                return l && (n = s, r = a), {
                    width: n,
                    height: r,
                    $: l
                }
            }

            function Y(e) {
                return L(e) ? e : e.contextElement
            }

            function X(e) {
                let t = Y(e);
                if (!P(t)) return u(1);
                let n = t.getBoundingClientRect(),
                    {
                        width: r,
                        height: i,
                        $: s
                    } = W(t),
                    a = (s ? o(n.width) : n.width) / r,
                    l = (s ? o(n.height) : n.height) / i;
                return a && Number.isFinite(a) || (a = 1), l && Number.isFinite(l) || (l = 1), {
                    x: a,
                    y: l
                }
            }
            let q = u(0);

            function K(e) {
                let t = B(e);
                return k() && t.visualViewport ? {
                    x: t.visualViewport.offsetLeft,
                    y: t.visualViewport.offsetTop
                } : q
            }

            function J(e, t, n, r) {
                var i;
                void 0 === t && (t = !1), void 0 === n && (n = !1);
                let s = e.getBoundingClientRect(),
                    a = Y(e),
                    o = u(1);
                t && (r ? L(r) && (o = X(r)) : o = X(e));
                let l = (void 0 === (i = n) && (i = !1), r && (!i || r === B(a)) && i) ? K(a) : u(0),
                    c = (s.left + l.x) / o.x,
                    h = (s.top + l.y) / o.y,
                    d = s.width / o.x,
                    f = s.height / o.y;
                if (a) {
                    let e = B(a),
                        t = r && L(r) ? B(r) : r,
                        n = e,
                        i = j(n);
                    for (; i && r && t !== n;) {
                        let e = X(i),
                            t = i.getBoundingClientRect(),
                            r = G(i),
                            s = t.left + (i.clientLeft + parseFloat(r.paddingLeft)) * e.x,
                            a = t.top + (i.clientTop + parseFloat(r.paddingTop)) * e.y;
                        c *= e.x, h *= e.y, d *= e.x, f *= e.y, c += s, h += a, i = j(n = B(i))
                    }
                }
                return E({
                    width: d,
                    height: f,
                    x: c,
                    y: h
                })
            }

            function Z(e, t) {
                let n = z(e).scrollLeft;
                return t ? t.left + n : J(R(e)).left + n
            }

            function $(e, t, n) {
                let r;
                if ("viewport" === t) r = function(e, t) {
                    let n = B(e),
                        r = R(e),
                        i = n.visualViewport,
                        s = r.clientWidth,
                        a = r.clientHeight,
                        o = 0,
                        l = 0;
                    if (i) {
                        s = i.width, a = i.height;
                        let e = k();
                        (!e || e && "fixed" === t) && (o = i.offsetLeft, l = i.offsetTop)
                    }
                    return {
                        width: s,
                        height: a,
                        x: o,
                        y: l
                    }
                }(e, n);
                else if ("document" === t) r = function(e) {
                    let t = R(e),
                        n = z(e),
                        r = e.ownerDocument.body,
                        i = a(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
                        s = a(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight),
                        o = -n.scrollLeft + Z(e),
                        l = -n.scrollTop;
                    return "rtl" === G(r).direction && (o += a(t.clientWidth, r.clientWidth) - i), {
                        width: i,
                        height: s,
                        x: o,
                        y: l
                    }
                }(R(e));
                else if (L(t)) r = function(e, t) {
                    let n = J(e, !0, "fixed" === t),
                        r = n.top + e.clientTop,
                        i = n.left + e.clientLeft,
                        s = P(e) ? X(e) : u(1),
                        a = e.clientWidth * s.x;
                    return {
                        width: a,
                        height: e.clientHeight * s.y,
                        x: i * s.x,
                        y: r * s.y
                    }
                }(t, n);
                else {
                    let n = K(e);
                    r = { ...t,
                        x: t.x - n.x,
                        y: t.y - n.y
                    }
                }
                return E(r)
            }

            function ee(e) {
                return "static" === G(e).position
            }

            function et(e, t) {
                if (!P(e) || "fixed" === G(e).position) return null;
                if (t) return t(e);
                let n = e.offsetParent;
                return R(e) === n && (n = n.ownerDocument.body), n
            }

            function en(e, t) {
                let n = B(e);
                if (U(e)) return n;
                if (!P(e)) {
                    let t = H(e);
                    for (; t && !Q(t);) {
                        if (L(t) && !ee(t)) return t;
                        t = H(t)
                    }
                    return n
                }
                let r = et(e, t);
                for (; r && ["table", "td", "th"].includes(T(r)) && ee(r);) r = et(r, t);
                return r && Q(r) && ee(r) && !F(r) ? n : r || function(e) {
                    let t = H(e);
                    for (; P(t) && !Q(t);) {
                        if (F(t)) return t;
                        if (U(t)) break;
                        t = H(t)
                    }
                    return null
                }(e) || n
            }
            let er = async function(e) {
                    let t = this.getOffsetParent || en,
                        n = this.getDimensions,
                        r = await n(e.floating);
                    return {
                        reference: function(e, t, n) {
                            let r = P(t),
                                i = R(t),
                                s = "fixed" === n,
                                a = J(e, !0, s, t),
                                o = {
                                    scrollLeft: 0,
                                    scrollTop: 0
                                },
                                l = u(0);
                            if (r || !r && !s) {
                                if (("body" !== T(t) || N(i)) && (o = z(t)), r) {
                                    let e = J(t, !0, s, t);
                                    l.x = e.x + t.clientLeft, l.y = e.y + t.clientTop
                                } else i && (l.x = Z(i))
                            }
                            let c = 0,
                                h = 0;
                            if (i && !r && !s) {
                                let e = i.getBoundingClientRect();
                                h = e.top + o.scrollTop, c = e.left + o.scrollLeft - Z(i, e)
                            }
                            return {
                                x: a.left + o.scrollLeft - l.x - c,
                                y: a.top + o.scrollTop - l.y - h,
                                width: a.width,
                                height: a.height
                            }
                        }(e.reference, await t(e.floating), e.strategy),
                        floating: {
                            x: 0,
                            y: 0,
                            width: r.width,
                            height: r.height
                        }
                    }
                },
                ei = {
                    convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
                        let {
                            elements: t,
                            rect: n,
                            offsetParent: r,
                            strategy: i
                        } = e, s = "fixed" === i, a = R(r), o = !!t && U(t.floating);
                        if (r === a || o && s) return n;
                        let l = {
                                scrollLeft: 0,
                                scrollTop: 0
                            },
                            c = u(1),
                            h = u(0),
                            d = P(r);
                        if ((d || !d && !s) && (("body" !== T(r) || N(a)) && (l = z(r)), P(r))) {
                            let e = J(r);
                            c = X(r), h.x = e.x + r.clientLeft, h.y = e.y + r.clientTop
                        }
                        return {
                            width: n.width * c.x,
                            height: n.height * c.y,
                            x: n.x * c.x - l.scrollLeft * c.x + h.x,
                            y: n.y * c.y - l.scrollTop * c.y + h.y
                        }
                    },
                    getDocumentElement: R,
                    getClippingRect: function(e) {
                        let {
                            element: t,
                            boundary: n,
                            rootBoundary: r,
                            strategy: i
                        } = e, o = [..."clippingAncestors" === n ? U(t) ? [] : function(e, t) {
                            let n = t.get(e);
                            if (n) return n;
                            let r = V(e, [], !1).filter(e => L(e) && "body" !== T(e)),
                                i = null,
                                s = "fixed" === G(e).position,
                                a = s ? H(e) : e;
                            for (; L(a) && !Q(a);) {
                                let t = G(a),
                                    n = F(a);
                                n || "fixed" !== t.position || (i = null), (s ? !n && !i : !n && "static" === t.position && !!i && ["absolute", "fixed"].includes(i.position) || N(a) && !n && function e(t, n) {
                                    let r = H(t);
                                    return !(r === n || !L(r) || Q(r)) && ("fixed" === G(r).position || e(r, n))
                                }(e, a)) ? r = r.filter(e => e !== a) : i = t, a = H(a)
                            }
                            return t.set(e, r), r
                        }(t, this._c) : [].concat(n), r], l = o[0], u = o.reduce((e, n) => {
                            let r = $(t, n, i);
                            return e.top = a(r.top, e.top), e.right = s(r.right, e.right), e.bottom = s(r.bottom, e.bottom), e.left = a(r.left, e.left), e
                        }, $(t, l, i));
                        return {
                            width: u.right - u.left,
                            height: u.bottom - u.top,
                            x: u.left,
                            y: u.top
                        }
                    },
                    getOffsetParent: en,
                    getElementRects: er,
                    getClientRects: function(e) {
                        return Array.from(e.getClientRects())
                    },
                    getDimensions: function(e) {
                        let {
                            width: t,
                            height: n
                        } = W(e);
                        return {
                            width: t,
                            height: n
                        }
                    },
                    getScale: X,
                    isElement: L,
                    isRTL: function(e) {
                        return "rtl" === G(e).direction
                    }
                },
                es = e => ({
                    name: "arrow",
                    options: e,
                    async fn(t) {
                        let {
                            x: n,
                            y: r,
                            placement: i,
                            rects: o,
                            platform: l,
                            elements: u,
                            middlewareData: c
                        } = t, {
                            element: h,
                            padding: f = 0
                        } = d(e, t) || {};
                        if (null == h) return {};
                        let v = x(f),
                            y = {
                                x: n,
                                y: r
                            },
                            E = g(m(i)),
                            _ = A(E),
                            b = await l.getDimensions(h),
                            w = "y" === E,
                            C = w ? "clientHeight" : "clientWidth",
                            S = o.reference[_] + o.reference[E] - y[E] - o.floating[_],
                            I = y[E] - o.reference[E],
                            M = await (null == l.getOffsetParent ? void 0 : l.getOffsetParent(h)),
                            T = M ? M[C] : 0;
                        T && await (null == l.isElement ? void 0 : l.isElement(M)) || (T = u.floating[C] || o.floating[_]);
                        let B = T / 2 - b[_] / 2 - 1,
                            R = s(v[w ? "top" : "left"], B),
                            D = s(v[w ? "bottom" : "right"], B),
                            L = T - b[_] - D,
                            P = T / 2 - b[_] / 2 + (S / 2 - I / 2),
                            O = a(R, s(P, L)),
                            N = !c.arrow && null != p(i) && P !== O && o.reference[_] / 2 - (P < R ? R : D) - b[_] / 2 < 0,
                            U = N ? P < R ? P - R : P - L : 0;
                        return {
                            [E]: y[E] + U,
                            data: {
                                [E]: O,
                                centerOffset: P - O - U,
                                ...N && {
                                    alignmentOffset: U
                                }
                            },
                            reset: N
                        }
                    }
                }),
                ea = (e, t, n) => {
                    let r = new Map,
                        i = {
                            platform: ei,
                            ...n
                        },
                        s = { ...i.platform,
                            _c: r
                        };
                    return b(e, t, { ...i,
                        platform: s
                    })
                };
            var eo = n(422),
                el = "undefined" != typeof document ? r.useLayoutEffect : r.useEffect;

            function eu(e, t) {
                let n, r, i;
                if (e === t) return !0;
                if (typeof e != typeof t) return !1;
                if ("function" == typeof e && e.toString() === t.toString()) return !0;
                if (e && t && "object" == typeof e) {
                    if (Array.isArray(e)) {
                        if ((n = e.length) !== t.length) return !1;
                        for (r = n; 0 != r--;)
                            if (!eu(e[r], t[r])) return !1;
                        return !0
                    }
                    if ((n = (i = Object.keys(e)).length) !== Object.keys(t).length) return !1;
                    for (r = n; 0 != r--;)
                        if (!({}).hasOwnProperty.call(t, i[r])) return !1;
                    for (r = n; 0 != r--;) {
                        let n = i[r];
                        if (("_owner" !== n || !e.$$typeof) && !eu(e[n], t[n])) return !1
                    }
                    return !0
                }
                return e != e && t != t
            }

            function ec(e) {
                return "undefined" == typeof window ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
            }

            function eh(e, t) {
                let n = ec(e);
                return Math.round(t * n) / n
            }

            function ed(e) {
                let t = r.useRef(e);
                return el(() => {
                    t.current = e
                }), t
            }
            let ef = e => ({
                    name: "arrow",
                    options: e,
                    fn(t) {
                        let {
                            element: n,
                            padding: r
                        } = "function" == typeof e ? e(t) : e;
                        return n && ({}).hasOwnProperty.call(n, "current") ? null != n.current ? es({
                            element: n.current,
                            padding: r
                        }).fn(t) : {} : n ? es({
                            element: n,
                            padding: r
                        }).fn(t) : {}
                    }
                }),
                ep = (e, t) => {
                    var n;
                    return { ...(void 0 === (n = e) && (n = 0), {
                            name: "offset",
                            options: n,
                            async fn(e) {
                                var t, r;
                                let {
                                    x: i,
                                    y: s,
                                    placement: a,
                                    middlewareData: o
                                } = e, l = await I(e, n);
                                return a === (null == (t = o.offset) ? void 0 : t.placement) && null != (r = o.arrow) && r.alignmentOffset ? {} : {
                                    x: i + l.x,
                                    y: s + l.y,
                                    data: { ...l,
                                        placement: a
                                    }
                                }
                            }
                        }),
                        options: [e, t]
                    }
                },
                eg = (e, t) => {
                    var n;
                    return { ...(void 0 === (n = e) && (n = {}), {
                            name: "shift",
                            options: n,
                            async fn(e) {
                                let {
                                    x: t,
                                    y: r,
                                    placement: i
                                } = e, {
                                    mainAxis: o = !0,
                                    crossAxis: l = !1,
                                    limiter: u = {
                                        fn: e => {
                                            let {
                                                x: t,
                                                y: n
                                            } = e;
                                            return {
                                                x: t,
                                                y: n
                                            }
                                        }
                                    },
                                    ...c
                                } = d(n, e), h = {
                                    x: t,
                                    y: r
                                }, p = await w(e, c), A = m(f(i)), v = g(A), y = h[v], x = h[A];
                                if (o) {
                                    let e = "y" === v ? "top" : "left",
                                        t = "y" === v ? "bottom" : "right",
                                        n = y + p[e],
                                        r = y - p[t];
                                    y = a(n, s(y, r))
                                }
                                if (l) {
                                    let e = "y" === A ? "top" : "left",
                                        t = "y" === A ? "bottom" : "right",
                                        n = x + p[e],
                                        r = x - p[t];
                                    x = a(n, s(x, r))
                                }
                                let E = u.fn({ ...e,
                                    [v]: y,
                                    [A]: x
                                });
                                return { ...E,
                                    data: {
                                        x: E.x - t,
                                        y: E.y - r,
                                        enabled: {
                                            [v]: o,
                                            [A]: l
                                        }
                                    }
                                }
                            }
                        }),
                        options: [e, t]
                    }
                },
                eA = (e, t) => {
                    var n;
                    return { ...(void 0 === (n = e) && (n = {}), {
                            options: n,
                            fn(e) {
                                let {
                                    x: t,
                                    y: r,
                                    placement: i,
                                    rects: s,
                                    middlewareData: a
                                } = e, {
                                    offset: o = 0,
                                    mainAxis: l = !0,
                                    crossAxis: u = !0
                                } = d(n, e), c = {
                                    x: t,
                                    y: r
                                }, h = m(i), p = g(h), A = c[p], v = c[h], y = d(o, e), x = "number" == typeof y ? {
                                    mainAxis: y,
                                    crossAxis: 0
                                } : {
                                    mainAxis: 0,
                                    crossAxis: 0,
                                    ...y
                                };
                                if (l) {
                                    let e = "y" === p ? "height" : "width",
                                        t = s.reference[p] - s.floating[e] + x.mainAxis,
                                        n = s.reference[p] + s.reference[e] - x.mainAxis;
                                    A < t ? A = t : A > n && (A = n)
                                }
                                if (u) {
                                    var E, _;
                                    let e = "y" === p ? "width" : "height",
                                        t = ["top", "left"].includes(f(i)),
                                        n = s.reference[h] - s.floating[e] + (t && (null == (E = a.offset) ? void 0 : E[h]) || 0) + (t ? 0 : x.crossAxis),
                                        r = s.reference[h] + s.reference[e] + (t ? 0 : (null == (_ = a.offset) ? void 0 : _[h]) || 0) - (t ? x.crossAxis : 0);
                                    v < n ? v = n : v > r && (v = r)
                                }
                                return {
                                    [p]: A,
                                    [h]: v
                                }
                            }
                        }),
                        options: [e, t]
                    }
                },
                em = (e, t) => {
                    var n;
                    return { ...(void 0 === (n = e) && (n = {}), {
                            name: "flip",
                            options: n,
                            async fn(e) {
                                var t, r, i, s, a;
                                let {
                                    placement: o,
                                    middlewareData: l,
                                    rects: u,
                                    initialPlacement: c,
                                    platform: h,
                                    elements: x
                                } = e, {
                                    mainAxis: E = !0,
                                    crossAxis: _ = !0,
                                    fallbackPlacements: b,
                                    fallbackStrategy: C = "bestFit",
                                    fallbackAxisSideDirection: S = "none",
                                    flipAlignment: I = !0,
                                    ...M
                                } = d(n, e);
                                if (null != (t = l.arrow) && t.alignmentOffset) return {};
                                let T = f(o),
                                    B = m(c),
                                    R = f(c) === c,
                                    D = await (null == h.isRTL ? void 0 : h.isRTL(x.floating)),
                                    L = b || (R || !I ? [y(c)] : function(e) {
                                        let t = y(e);
                                        return [v(e), t, v(t)]
                                    }(c)),
                                    P = "none" !== S;
                                !b && P && L.push(... function(e, t, n, r) {
                                    let i = p(e),
                                        s = function(e, t, n) {
                                            let r = ["left", "right"],
                                                i = ["right", "left"];
                                            switch (e) {
                                                case "top":
                                                case "bottom":
                                                    if (n) return t ? i : r;
                                                    return t ? r : i;
                                                case "left":
                                                case "right":
                                                    return t ? ["top", "bottom"] : ["bottom", "top"];
                                                default:
                                                    return []
                                            }
                                        }(f(e), "start" === n, r);
                                    return i && (s = s.map(e => e + "-" + i), t && (s = s.concat(s.map(v)))), s
                                }(c, I, S, D));
                                let O = [c, ...L],
                                    N = await w(e, M),
                                    U = [],
                                    F = (null == (r = l.flip) ? void 0 : r.overflows) || [];
                                if (E && U.push(N[T]), _) {
                                    let e = function(e, t, n) {
                                        void 0 === n && (n = !1);
                                        let r = p(e),
                                            i = g(m(e)),
                                            s = A(i),
                                            a = "x" === i ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top";
                                        return t.reference[s] > t.floating[s] && (a = y(a)), [a, y(a)]
                                    }(o, u, D);
                                    U.push(N[e[0]], N[e[1]])
                                }
                                if (F = [...F, {
                                        placement: o,
                                        overflows: U
                                    }], !U.every(e => e <= 0)) {
                                    let e = ((null == (i = l.flip) ? void 0 : i.index) || 0) + 1,
                                        t = O[e];
                                    if (t) return {
                                        data: {
                                            index: e,
                                            overflows: F
                                        },
                                        reset: {
                                            placement: t
                                        }
                                    };
                                    let n = null == (s = F.filter(e => e.overflows[0] <= 0).sort((e, t) => e.overflows[1] - t.overflows[1])[0]) ? void 0 : s.placement;
                                    if (!n) switch (C) {
                                        case "bestFit":
                                            {
                                                let e = null == (a = F.filter(e => {
                                                    if (P) {
                                                        let t = m(e.placement);
                                                        return t === B || "y" === t
                                                    }
                                                    return !0
                                                }).map(e => [e.placement, e.overflows.filter(e => e > 0).reduce((e, t) => e + t, 0)]).sort((e, t) => e[1] - t[1])[0]) ? void 0 : a[0];e && (n = e);
                                                break
                                            }
                                        case "initialPlacement":
                                            n = c
                                    }
                                    if (o !== n) return {
                                        reset: {
                                            placement: n
                                        }
                                    }
                                }
                                return {}
                            }
                        }),
                        options: [e, t]
                    }
                },
                ev = (e, t) => {
                    var n;
                    return { ...(void 0 === (n = e) && (n = {}), {
                            name: "size",
                            options: n,
                            async fn(e) {
                                var t, r;
                                let i, o;
                                let {
                                    placement: l,
                                    rects: u,
                                    platform: c,
                                    elements: h
                                } = e, {
                                    apply: g = () => {},
                                    ...A
                                } = d(n, e), v = await w(e, A), y = f(l), x = p(l), E = "y" === m(l), {
                                    width: _,
                                    height: b
                                } = u.floating;
                                "top" === y || "bottom" === y ? (i = y, o = x === (await (null == c.isRTL ? void 0 : c.isRTL(h.floating)) ? "start" : "end") ? "left" : "right") : (o = y, i = "end" === x ? "top" : "bottom");
                                let C = b - v.top - v.bottom,
                                    S = _ - v.left - v.right,
                                    I = s(b - v[i], C),
                                    M = s(_ - v[o], S),
                                    T = !e.middlewareData.shift,
                                    B = I,
                                    R = M;
                                if (null != (t = e.middlewareData.shift) && t.enabled.x && (R = S), null != (r = e.middlewareData.shift) && r.enabled.y && (B = C), T && !x) {
                                    let e = a(v.left, 0),
                                        t = a(v.right, 0),
                                        n = a(v.top, 0),
                                        r = a(v.bottom, 0);
                                    E ? R = _ - 2 * (0 !== e || 0 !== t ? e + t : a(v.left, v.right)) : B = b - 2 * (0 !== n || 0 !== r ? n + r : a(v.top, v.bottom))
                                }
                                await g({ ...e,
                                    availableWidth: R,
                                    availableHeight: B
                                });
                                let D = await c.getDimensions(h.floating);
                                return _ !== D.width || b !== D.height ? {
                                    reset: {
                                        rects: !0
                                    }
                                } : {}
                            }
                        }),
                        options: [e, t]
                    }
                },
                ey = (e, t) => {
                    var n;
                    return { ...(void 0 === (n = e) && (n = {}), {
                            name: "hide",
                            options: n,
                            async fn(e) {
                                let {
                                    rects: t
                                } = e, {
                                    strategy: r = "referenceHidden",
                                    ...i
                                } = d(n, e);
                                switch (r) {
                                    case "referenceHidden":
                                        {
                                            let n = C(await w(e, { ...i,
                                                elementContext: "reference"
                                            }), t.reference);
                                            return {
                                                data: {
                                                    referenceHiddenOffsets: n,
                                                    referenceHidden: S(n)
                                                }
                                            }
                                        }
                                    case "escaped":
                                        {
                                            let n = C(await w(e, { ...i,
                                                altBoundary: !0
                                            }), t.floating);
                                            return {
                                                data: {
                                                    escapedOffsets: n,
                                                    escaped: S(n)
                                                }
                                            }
                                        }
                                    default:
                                        return {}
                                }
                            }
                        }),
                        options: [e, t]
                    }
                },
                ex = (e, t) => ({ ...ef(e),
                    options: [e, t]
                });
            var eE = n(5176),
                e_ = n(1527),
                eb = r.forwardRef((e, t) => {
                    let {
                        children: n,
                        width: r = 10,
                        height: i = 5,
                        ...s
                    } = e;
                    return (0, e_.jsx)(eE.WV.svg, { ...s,
                        ref: t,
                        width: r,
                        height: i,
                        viewBox: "0 0 30 10",
                        preserveAspectRatio: "none",
                        children: e.asChild ? n : (0, e_.jsx)("polygon", {
                            points: "0,0 30,0 15,10"
                        })
                    })
                });
            eb.displayName = "Arrow";
            var ew = n(3079),
                eC = n(1354),
                eS = n(5203),
                eI = n(4898),
                eM = "Popper",
                [eT, eB] = (0, eC.b)(eM),
                [eR, eD] = eT(eM),
                eL = e => {
                    let {
                        __scopePopper: t,
                        children: n
                    } = e, [i, s] = r.useState(null);
                    return (0, e_.jsx)(eR, {
                        scope: t,
                        anchor: i,
                        onAnchorChange: s,
                        children: n
                    })
                };
            eL.displayName = eM;
            var eP = "PopperAnchor",
                eO = r.forwardRef((e, t) => {
                    let {
                        __scopePopper: n,
                        virtualRef: i,
                        ...s
                    } = e, a = eD(eP, n), o = r.useRef(null), l = (0, ew.e)(t, o);
                    return r.useEffect(() => {
                        a.onAnchorChange(i ? .current || o.current)
                    }), i ? null : (0, e_.jsx)(eE.WV.div, { ...s,
                        ref: l
                    })
                });
            eO.displayName = eP;
            var eN = "PopperContent",
                [eU, eF] = eT(eN),
                ek = r.forwardRef((e, t) => {
                    let {
                        __scopePopper: n,
                        side: i = "bottom",
                        sideOffset: o = 0,
                        align: u = "center",
                        alignOffset: c = 0,
                        arrowPadding: h = 0,
                        avoidCollisions: d = !0,
                        collisionBoundary: f = [],
                        collisionPadding: p = 0,
                        sticky: g = "partial",
                        hideWhenDetached: A = !1,
                        updatePositionStrategy: m = "optimized",
                        onPlaced: v,
                        ...y
                    } = e, x = eD(eN, n), [E, _] = r.useState(null), b = (0, ew.e)(t, e => _(e)), [w, C] = r.useState(null), S = function(e) {
                        let [t, n] = r.useState(void 0);
                        return (0, eI.b)(() => {
                            if (e) {
                                n({
                                    width: e.offsetWidth,
                                    height: e.offsetHeight
                                });
                                let t = new ResizeObserver(t => {
                                    let r, i;
                                    if (!Array.isArray(t) || !t.length) return;
                                    let s = t[0];
                                    if ("borderBoxSize" in s) {
                                        let e = s.borderBoxSize,
                                            t = Array.isArray(e) ? e[0] : e;
                                        r = t.inlineSize, i = t.blockSize
                                    } else r = e.offsetWidth, i = e.offsetHeight;
                                    n({
                                        width: r,
                                        height: i
                                    })
                                });
                                return t.observe(e, {
                                    box: "border-box"
                                }), () => t.unobserve(e)
                            }
                            n(void 0)
                        }, [e]), t
                    }(w), I = S ? .width ? ? 0, M = S ? .height ? ? 0, T = "number" == typeof p ? p : {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0,
                        ...p
                    }, B = Array.isArray(f) ? f : [f], D = B.length > 0, L = {
                        padding: T,
                        boundary: B.filter(eH),
                        altBoundary: D
                    }, {
                        refs: P,
                        floatingStyles: O,
                        placement: N,
                        isPositioned: U,
                        middlewareData: F
                    } = function(e) {
                        void 0 === e && (e = {});
                        let {
                            placement: t = "bottom",
                            strategy: n = "absolute",
                            middleware: i = [],
                            platform: s,
                            elements: {
                                reference: a,
                                floating: o
                            } = {},
                            transform: l = !0,
                            whileElementsMounted: u,
                            open: c
                        } = e, [h, d] = r.useState({
                            x: 0,
                            y: 0,
                            strategy: n,
                            placement: t,
                            middlewareData: {},
                            isPositioned: !1
                        }), [f, p] = r.useState(i);
                        eu(f, i) || p(i);
                        let [g, A] = r.useState(null), [m, v] = r.useState(null), y = r.useCallback(e => {
                            e !== b.current && (b.current = e, A(e))
                        }, []), x = r.useCallback(e => {
                            e !== w.current && (w.current = e, v(e))
                        }, []), E = a || g, _ = o || m, b = r.useRef(null), w = r.useRef(null), C = r.useRef(h), S = null != u, I = ed(u), M = ed(s), T = ed(c), B = r.useCallback(() => {
                            if (!b.current || !w.current) return;
                            let e = {
                                placement: t,
                                strategy: n,
                                middleware: f
                            };
                            M.current && (e.platform = M.current), ea(b.current, w.current, e).then(e => {
                                let t = { ...e,
                                    isPositioned: !1 !== T.current
                                };
                                R.current && !eu(C.current, t) && (C.current = t, eo.flushSync(() => {
                                    d(t)
                                }))
                            })
                        }, [f, t, n, M, T]);
                        el(() => {
                            !1 === c && C.current.isPositioned && (C.current.isPositioned = !1, d(e => ({ ...e,
                                isPositioned: !1
                            })))
                        }, [c]);
                        let R = r.useRef(!1);
                        el(() => (R.current = !0, () => {
                            R.current = !1
                        }), []), el(() => {
                            if (E && (b.current = E), _ && (w.current = _), E && _) {
                                if (I.current) return I.current(E, _, B);
                                B()
                            }
                        }, [E, _, B, I, S]);
                        let D = r.useMemo(() => ({
                                reference: b,
                                floating: w,
                                setReference: y,
                                setFloating: x
                            }), [y, x]),
                            L = r.useMemo(() => ({
                                reference: E,
                                floating: _
                            }), [E, _]),
                            P = r.useMemo(() => {
                                let e = {
                                    position: n,
                                    left: 0,
                                    top: 0
                                };
                                if (!L.floating) return e;
                                let t = eh(L.floating, h.x),
                                    r = eh(L.floating, h.y);
                                return l ? { ...e,
                                    transform: "translate(" + t + "px, " + r + "px)",
                                    ...ec(L.floating) >= 1.5 && {
                                        willChange: "transform"
                                    }
                                } : {
                                    position: n,
                                    left: t,
                                    top: r
                                }
                            }, [n, l, L.floating, h.x, h.y]);
                        return r.useMemo(() => ({ ...h,
                            update: B,
                            refs: D,
                            elements: L,
                            floatingStyles: P
                        }), [h, B, D, L, P])
                    }({
                        strategy: "fixed",
                        placement: i + ("center" !== u ? "-" + u : ""),
                        whileElementsMounted: (...e) => (function(e, t, n, r) {
                            let i;
                            void 0 === r && (r = {});
                            let {
                                ancestorScroll: o = !0,
                                ancestorResize: u = !0,
                                elementResize: c = "function" == typeof ResizeObserver,
                                layoutShift: h = "function" == typeof IntersectionObserver,
                                animationFrame: d = !1
                            } = r, f = Y(e), p = o || u ? [...f ? V(f) : [], ...V(t)] : [];
                            p.forEach(e => {
                                o && e.addEventListener("scroll", n, {
                                    passive: !0
                                }), u && e.addEventListener("resize", n)
                            });
                            let g = f && h ? function(e, t) {
                                    let n, r = null,
                                        i = R(e);

                                    function o() {
                                        var e;
                                        clearTimeout(n), null == (e = r) || e.disconnect(), r = null
                                    }
                                    return ! function u(c, h) {
                                        void 0 === c && (c = !1), void 0 === h && (h = 1), o();
                                        let {
                                            left: d,
                                            top: f,
                                            width: p,
                                            height: g
                                        } = e.getBoundingClientRect();
                                        if (c || t(), !p || !g) return;
                                        let A = l(f),
                                            m = l(i.clientWidth - (d + p)),
                                            v = {
                                                rootMargin: -A + "px " + -m + "px " + -l(i.clientHeight - (f + g)) + "px " + -l(d) + "px",
                                                threshold: a(0, s(1, h)) || 1
                                            },
                                            y = !0;

                                        function x(e) {
                                            let t = e[0].intersectionRatio;
                                            if (t !== h) {
                                                if (!y) return u();
                                                t ? u(!1, t) : n = setTimeout(() => {
                                                    u(!1, 1e-7)
                                                }, 1e3)
                                            }
                                            y = !1
                                        }
                                        try {
                                            r = new IntersectionObserver(x, { ...v,
                                                root: i.ownerDocument
                                            })
                                        } catch (e) {
                                            r = new IntersectionObserver(x, v)
                                        }
                                        r.observe(e)
                                    }(!0), o
                                }(f, n) : null,
                                A = -1,
                                m = null;
                            c && (m = new ResizeObserver(e => {
                                let [r] = e;
                                r && r.target === f && m && (m.unobserve(t), cancelAnimationFrame(A), A = requestAnimationFrame(() => {
                                    var e;
                                    null == (e = m) || e.observe(t)
                                })), n()
                            }), f && !d && m.observe(f), m.observe(t));
                            let v = d ? J(e) : null;
                            return d && function t() {
                                let r = J(e);
                                v && (r.x !== v.x || r.y !== v.y || r.width !== v.width || r.height !== v.height) && n(), v = r, i = requestAnimationFrame(t)
                            }(), n(), () => {
                                var e;
                                p.forEach(e => {
                                    o && e.removeEventListener("scroll", n), u && e.removeEventListener("resize", n)
                                }), null == g || g(), null == (e = m) || e.disconnect(), m = null, d && cancelAnimationFrame(i)
                            }
                        })(...e, {
                            animationFrame: "always" === m
                        }),
                        elements: {
                            reference: x.anchor
                        },
                        middleware: [ep({
                            mainAxis: o + M,
                            alignmentAxis: c
                        }), d && eg({
                            mainAxis: !0,
                            crossAxis: !1,
                            limiter: "partial" === g ? eA() : void 0,
                            ...L
                        }), d && em({ ...L
                        }), ev({ ...L,
                            apply: ({
                                elements: e,
                                rects: t,
                                availableWidth: n,
                                availableHeight: r
                            }) => {
                                let {
                                    width: i,
                                    height: s
                                } = t.reference, a = e.floating.style;
                                a.setProperty("--radix-popper-available-width", `${n}px`), a.setProperty("--radix-popper-available-height", `${r}px`), a.setProperty("--radix-popper-anchor-width", `${i}px`), a.setProperty("--radix-popper-anchor-height", `${s}px`)
                            }
                        }), w && ex({
                            element: w,
                            padding: h
                        }), eV({
                            arrowWidth: I,
                            arrowHeight: M
                        }), A && ey({
                            strategy: "referenceHidden",
                            ...L
                        })]
                    }), [k, Q] = ej(N), G = (0, eS.W)(v);
                    (0, eI.b)(() => {
                        U && G ? .()
                    }, [U, G]);
                    let z = F.arrow ? .x,
                        H = F.arrow ? .y,
                        j = F.arrow ? .centerOffset !== 0,
                        [W, X] = r.useState();
                    return (0, eI.b)(() => {
                        E && X(window.getComputedStyle(E).zIndex)
                    }, [E]), (0, e_.jsx)("div", {
                        ref: P.setFloating,
                        "data-radix-popper-content-wrapper": "",
                        style: { ...O,
                            transform: U ? O.transform : "translate(0, -200%)",
                            minWidth: "max-content",
                            zIndex: W,
                            "--radix-popper-transform-origin": [F.transformOrigin ? .x, F.transformOrigin ? .y].join(" "),
                            ...F.hide ? .referenceHidden && {
                                visibility: "hidden",
                                pointerEvents: "none"
                            }
                        },
                        dir: e.dir,
                        children: (0, e_.jsx)(eU, {
                            scope: n,
                            placedSide: k,
                            onArrowChange: C,
                            arrowX: z,
                            arrowY: H,
                            shouldHideArrow: j,
                            children: (0, e_.jsx)(eE.WV.div, {
                                "data-side": k,
                                "data-align": Q,
                                ...y,
                                ref: b,
                                style: { ...y.style,
                                    animation: U ? void 0 : "none"
                                }
                            })
                        })
                    })
                });
            ek.displayName = eN;
            var eQ = "PopperArrow",
                eG = {
                    top: "bottom",
                    right: "left",
                    bottom: "top",
                    left: "right"
                },
                ez = r.forwardRef(function(e, t) {
                    let {
                        __scopePopper: n,
                        ...r
                    } = e, i = eF(eQ, n), s = eG[i.placedSide];
                    return (0, e_.jsx)("span", {
                        ref: i.onArrowChange,
                        style: {
                            position: "absolute",
                            left: i.arrowX,
                            top: i.arrowY,
                            [s]: 0,
                            transformOrigin: {
                                top: "",
                                right: "0 0",
                                bottom: "center 0",
                                left: "100% 0"
                            }[i.placedSide],
                            transform: {
                                top: "translateY(100%)",
                                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                                bottom: "rotate(180deg)",
                                left: "translateY(50%) rotate(-90deg) translateX(50%)"
                            }[i.placedSide],
                            visibility: i.shouldHideArrow ? "hidden" : void 0
                        },
                        children: (0, e_.jsx)(eb, { ...r,
                            ref: t,
                            style: { ...r.style,
                                display: "block"
                            }
                        })
                    })
                });

            function eH(e) {
                return null !== e
            }
            ez.displayName = eQ;
            var eV = e => ({
                name: "transformOrigin",
                options: e,
                fn(t) {
                    let {
                        placement: n,
                        rects: r,
                        middlewareData: i
                    } = t, s = i.arrow ? .centerOffset !== 0, a = s ? 0 : e.arrowWidth, o = s ? 0 : e.arrowHeight, [l, u] = ej(n), c = {
                        start: "0%",
                        center: "50%",
                        end: "100%"
                    }[u], h = (i.arrow ? .x ? ? 0) + a / 2, d = (i.arrow ? .y ? ? 0) + o / 2, f = "", p = "";
                    return "bottom" === l ? (f = s ? c : `${h}px`, p = `${-o}px`) : "top" === l ? (f = s ? c : `${h}px`, p = `${r.floating.height+o}px`) : "right" === l ? (f = `${-o}px`, p = s ? c : `${d}px`) : "left" === l && (f = `${r.floating.width+o}px`, p = s ? c : `${d}px`), {
                        data: {
                            x: f,
                            y: p
                        }
                    }
                }
            });

            function ej(e) {
                let [t, n = "center"] = e.split("-");
                return [t, n]
            }
            var eW = eL,
                eY = eO,
                eX = ek,
                eq = ez
        },
        1120: function(e, t, n) {
            "use strict";
            n.d(t, {
                h: function() {
                    return l
                }
            });
            var r = n(959),
                i = n(422),
                s = n(5176),
                a = n(4898),
                o = n(1527),
                l = r.forwardRef((e, t) => {
                    let {
                        container: n,
                        ...l
                    } = e, [u, c] = r.useState(!1);
                    (0, a.b)(() => c(!0), []);
                    let h = n || u && globalThis ? .document ? .body;
                    return h ? i.createPortal((0, o.jsx)(s.WV.div, { ...l,
                        ref: t
                    }), h) : null
                });
            l.displayName = "Portal"
        },
        5176: function(e, t, n) {
            "use strict";
            n.d(t, {
                WV: function() {
                    return o
                },
                jH: function() {
                    return l
                }
            });
            var r = n(959),
                i = n(422),
                s = n(9310),
                a = n(1527),
                o = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce((e, t) => {
                    let n = r.forwardRef((e, n) => {
                        let {
                            asChild: r,
                            ...i
                        } = e, o = r ? s.g7 : t;
                        return "undefined" != typeof window && (window[Symbol.for("radix-ui")] = !0), (0, a.jsx)(o, { ...i,
                            ref: n
                        })
                    });
                    return n.displayName = `Primitive.${t}`, { ...e,
                        [t]: n
                    }
                }, {});

            function l(e, t) {
                e && i.flushSync(() => e.dispatchEvent(t))
            }
        },
        9310: function(e, t, n) {
            "use strict";
            n.d(t, {
                A4: function() {
                    return l
                },
                g7: function() {
                    return a
                }
            });
            var r = n(959),
                i = n(3079),
                s = n(1527),
                a = r.forwardRef((e, t) => {
                    let {
                        children: n,
                        ...i
                    } = e, a = r.Children.toArray(n), l = a.find(u);
                    if (l) {
                        let e = l.props.children,
                            n = a.map(t => t !== l ? t : r.Children.count(e) > 1 ? r.Children.only(null) : r.isValidElement(e) ? e.props.children : null);
                        return (0, s.jsx)(o, { ...i,
                            ref: t,
                            children: r.isValidElement(e) ? r.cloneElement(e, void 0, n) : null
                        })
                    }
                    return (0, s.jsx)(o, { ...i,
                        ref: t,
                        children: n
                    })
                });
            a.displayName = "Slot";
            var o = r.forwardRef((e, t) => {
                let {
                    children: n,
                    ...s
                } = e;
                if (r.isValidElement(n)) {
                    let e, a;
                    let o = (e = Object.getOwnPropertyDescriptor(n.props, "ref") ? .get) && "isReactWarning" in e && e.isReactWarning ? n.ref : (e = Object.getOwnPropertyDescriptor(n, "ref") ? .get) && "isReactWarning" in e && e.isReactWarning ? n.props.ref : n.props.ref || n.ref;
                    return r.cloneElement(n, { ... function(e, t) {
                            let n = { ...t
                            };
                            for (let r in t) {
                                let i = e[r],
                                    s = t[r];
                                /^on[A-Z]/.test(r) ? i && s ? n[r] = (...e) => {
                                    s(...e), i(...e)
                                } : i && (n[r] = i) : "style" === r ? n[r] = { ...i,
                                    ...s
                                } : "className" === r && (n[r] = [i, s].filter(Boolean).join(" "))
                            }
                            return { ...e,
                                ...n
                            }
                        }(s, n.props),
                        ref: t ? (0, i.F)(t, o) : o
                    })
                }
                return r.Children.count(n) > 1 ? r.Children.only(null) : null
            });
            o.displayName = "SlotClone";
            var l = ({
                children: e
            }) => (0, s.jsx)(s.Fragment, {
                children: e
            });

            function u(e) {
                return r.isValidElement(e) && e.type === l
            }
        },
        5203: function(e, t, n) {
            "use strict";
            n.d(t, {
                W: function() {
                    return i
                }
            });
            var r = n(959);

            function i(e) {
                let t = r.useRef(e);
                return r.useEffect(() => {
                    t.current = e
                }), r.useMemo(() => (...e) => t.current ? .(...e), [])
            }
        },
        5611: function(e, t, n) {
            "use strict";
            n.d(t, {
                T: function() {
                    return s
                }
            });
            var r = n(959),
                i = n(5203);

            function s({
                prop: e,
                defaultProp: t,
                onChange: n = () => {}
            }) {
                let [s, a] = function({
                    defaultProp: e,
                    onChange: t
                }) {
                    let n = r.useState(e),
                        [s] = n,
                        a = r.useRef(s),
                        o = (0, i.W)(t);
                    return r.useEffect(() => {
                        a.current !== s && (o(s), a.current = s)
                    }, [s, a, o]), n
                }({
                    defaultProp: t,
                    onChange: n
                }), o = void 0 !== e, l = o ? e : s, u = (0, i.W)(n);
                return [l, r.useCallback(t => {
                    if (o) {
                        let n = "function" == typeof t ? t(e) : t;
                        n !== e && u(n)
                    } else a(t)
                }, [o, e, a, u])]
            }
        },
        4898: function(e, t, n) {
            "use strict";
            n.d(t, {
                b: function() {
                    return i
                }
            });
            var r = n(959),
                i = globalThis ? .document ? r.useLayoutEffect : () => {}
        },
        3409: function(e, t, n) {
            "use strict";
            n.d(t, {
                T: function() {
                    return a
                },
                f: function() {
                    return o
                }
            });
            var r = n(959),
                i = n(5176),
                s = n(1527),
                a = r.forwardRef((e, t) => (0, s.jsx)(i.WV.span, { ...e,
                    ref: t,
                    style: {
                        position: "absolute",
                        border: 0,
                        width: 1,
                        height: 1,
                        padding: 0,
                        margin: -1,
                        overflow: "hidden",
                        clip: "rect(0, 0, 0, 0)",
                        whiteSpace: "nowrap",
                        wordWrap: "normal",
                        ...e.style
                    }
                }));
            a.displayName = "VisuallyHidden";
            var o = a
        },
        2808: function(e, t, n) {
            "use strict";
            n.d(t, {
                j: function() {
                    return s
                }
            });
            let r = e => "boolean" == typeof e ? "".concat(e) : 0 === e ? "0" : e,
                i = function() {
                    for (var e, t, n = 0, r = ""; n < arguments.length;)(e = arguments[n++]) && (t = function e(t) {
                        var n, r, i = "";
                        if ("string" == typeof t || "number" == typeof t) i += t;
                        else if ("object" == typeof t) {
                            if (Array.isArray(t))
                                for (n = 0; n < t.length; n++) t[n] && (r = e(t[n])) && (i && (i += " "), i += r);
                            else
                                for (n in t) t[n] && (i && (i += " "), i += n)
                        }
                        return i
                    }(e)) && (r && (r += " "), r += t);
                    return r
                },
                s = (e, t) => n => {
                    var s;
                    if ((null == t ? void 0 : t.variants) == null) return i(e, null == n ? void 0 : n.class, null == n ? void 0 : n.className);
                    let {
                        variants: a,
                        defaultVariants: o
                    } = t, l = Object.keys(a).map(e => {
                        let t = null == n ? void 0 : n[e],
                            i = null == o ? void 0 : o[e];
                        if (null === t) return null;
                        let s = r(t) || r(i);
                        return a[e][s]
                    }), u = n && Object.entries(n).reduce((e, t) => {
                        let [n, r] = t;
                        return void 0 === r || (e[n] = r), e
                    }, {});
                    return i(e, l, null == t ? void 0 : null === (s = t.compoundVariants) || void 0 === s ? void 0 : s.reduce((e, t) => {
                        let {
                            class: n,
                            className: r,
                            ...i
                        } = t;
                        return Object.entries(i).every(e => {
                            let [t, n] = e;
                            return Array.isArray(n) ? n.includes({ ...o,
                                ...u
                            }[t]) : ({ ...o,
                                ...u
                            })[t] === n
                        }) ? [...e, n, r] : e
                    }, []), null == n ? void 0 : n.class, null == n ? void 0 : n.className)
                }
        },
        8349: function(e, t, n) {
            "use strict";
            n.d(t, {
                du: function() {
                    return r.domToReact
                }
            });
            var r = n(6913);
            t.ZP = r.default || r
        },
        9793: function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                return Math.max(e, Math.min(t, n))
            }
            n.d(t, {
                Z: function() {
                    return c
                }
            });
            var i = class {
                    isRunning = !1;
                    value = 0;
                    from = 0;
                    to = 0;
                    currentTime = 0;
                    lerp;
                    duration;
                    easing;
                    onUpdate;
                    advance(e) {
                        if (!this.isRunning) return;
                        let t = !1;
                        if (this.duration && this.easing) {
                            this.currentTime += e;
                            let n = r(0, this.currentTime / this.duration, 1),
                                i = (t = n >= 1) ? 1 : this.easing(n);
                            this.value = this.from + (this.to - this.from) * i
                        } else if (this.lerp) {
                            var n, i, s;
                            this.value = (n = this.value, i = this.to, (1 - (s = 1 - Math.exp(-(60 * this.lerp) * e))) * n + s * i), Math.round(this.value) === this.to && (this.value = this.to, t = !0)
                        } else this.value = this.to, t = !0;
                        t && this.stop(), this.onUpdate ? .(this.value, t)
                    }
                    stop() {
                        this.isRunning = !1
                    }
                    fromTo(e, t, {
                        lerp: n,
                        duration: r,
                        easing: i,
                        onStart: s,
                        onUpdate: a
                    }) {
                        this.from = this.value = e, this.to = t, this.lerp = n, this.duration = r, this.easing = i, this.currentTime = 0, this.isRunning = !0, s ? .(), this.onUpdate = a
                    }
                },
                s = class {
                    constructor(e, t, {
                        autoResize: n = !0,
                        debounce: r = 250
                    } = {}) {
                        if (this.wrapper = e, this.content = t, n) {
                            var i;
                            let e;
                            this.debouncedResize = (i = this.resize, function(...t) {
                                let n = this;
                                clearTimeout(e), e = setTimeout(() => {
                                    e = void 0, i.apply(n, t)
                                }, r)
                            }), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)
                        }
                        this.resize()
                    }
                    width = 0;
                    height = 0;
                    scrollHeight = 0;
                    scrollWidth = 0;
                    debouncedResize;
                    wrapperResizeObserver;
                    contentResizeObserver;
                    destroy() {
                        this.wrapperResizeObserver ? .disconnect(), this.contentResizeObserver ? .disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
                    }
                    resize = () => {
                        this.onWrapperResize(), this.onContentResize()
                    };
                    onWrapperResize = () => {
                        this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
                    };
                    onContentResize = () => {
                        this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
                    };
                    get limit() {
                        return {
                            x: this.scrollWidth - this.width,
                            y: this.scrollHeight - this.height
                        }
                    }
                },
                a = class {
                    events = {};
                    emit(e, ...t) {
                        let n = this.events[e] || [];
                        for (let e = 0, r = n.length; e < r; e++) n[e] ? .(...t)
                    }
                    on(e, t) {
                        return this.events[e] ? .push(t) || (this.events[e] = [t]), () => {
                            this.events[e] = this.events[e] ? .filter(e => t !== e)
                        }
                    }
                    off(e, t) {
                        this.events[e] = this.events[e] ? .filter(e => t !== e)
                    }
                    destroy() {
                        this.events = {}
                    }
                },
                o = 100 / 6,
                l = {
                    passive: !1
                },
                u = class {
                    constructor(e, t = {
                        wheelMultiplier: 1,
                        touchMultiplier: 1
                    }) {
                        this.element = e, this.options = t, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, l), this.element.addEventListener("touchstart", this.onTouchStart, l), this.element.addEventListener("touchmove", this.onTouchMove, l), this.element.addEventListener("touchend", this.onTouchEnd, l)
                    }
                    touchStart = {
                        x: 0,
                        y: 0
                    };
                    lastDelta = {
                        x: 0,
                        y: 0
                    };
                    window = {
                        width: 0,
                        height: 0
                    };
                    emitter = new a;
                    on(e, t) {
                        return this.emitter.on(e, t)
                    }
                    destroy() {
                        this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, l), this.element.removeEventListener("touchstart", this.onTouchStart, l), this.element.removeEventListener("touchmove", this.onTouchMove, l), this.element.removeEventListener("touchend", this.onTouchEnd, l)
                    }
                    onTouchStart = e => {
                        let {
                            clientX: t,
                            clientY: n
                        } = e.targetTouches ? e.targetTouches[0] : e;
                        this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                            x: 0,
                            y: 0
                        }, this.emitter.emit("scroll", {
                            deltaX: 0,
                            deltaY: 0,
                            event: e
                        })
                    };
                    onTouchMove = e => {
                        let {
                            clientX: t,
                            clientY: n
                        } = e.targetTouches ? e.targetTouches[0] : e, r = -(t - this.touchStart.x) * this.options.touchMultiplier, i = -(n - this.touchStart.y) * this.options.touchMultiplier;
                        this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                            x: r,
                            y: i
                        }, this.emitter.emit("scroll", {
                            deltaX: r,
                            deltaY: i,
                            event: e
                        })
                    };
                    onTouchEnd = e => {
                        this.emitter.emit("scroll", {
                            deltaX: this.lastDelta.x,
                            deltaY: this.lastDelta.y,
                            event: e
                        })
                    };
                    onWheel = e => {
                        let {
                            deltaX: t,
                            deltaY: n,
                            deltaMode: r
                        } = e, i = 1 === r ? o : 2 === r ? this.window.width : 1, s = 1 === r ? o : 2 === r ? this.window.height : 1;
                        t *= i, n *= s, t *= this.options.wheelMultiplier, n *= this.options.wheelMultiplier, this.emitter.emit("scroll", {
                            deltaX: t,
                            deltaY: n,
                            event: e
                        })
                    };
                    onWindowResize = () => {
                        this.window = {
                            width: window.innerWidth,
                            height: window.innerHeight
                        }
                    }
                },
                c = class {
                    _isScrolling = !1;
                    _isStopped = !1;
                    _isLocked = !1;
                    _preventNextNativeScrollEvent = !1;
                    _resetVelocityTimeout = null;
                    isTouching;
                    time = 0;
                    userData = {};
                    lastVelocity = 0;
                    velocity = 0;
                    direction = 0;
                    options;
                    targetScroll;
                    animatedScroll;
                    animate = new i;
                    emitter = new a;
                    dimensions;
                    virtualScroll;
                    constructor({
                        wrapper: e = window,
                        content: t = document.documentElement,
                        eventsTarget: n = e,
                        smoothWheel: r = !0,
                        syncTouch: i = !1,
                        syncTouchLerp: a = .075,
                        touchInertiaMultiplier: o = 35,
                        duration: l,
                        easing: c = e => Math.min(1, 1.001 - Math.pow(2, -10 * e)),
                        lerp: h = .1,
                        infinite: d = !1,
                        orientation: f = "vertical",
                        gestureOrientation: p = "vertical",
                        touchMultiplier: g = 1,
                        wheelMultiplier: A = 1,
                        autoResize: m = !0,
                        prevent: v,
                        virtualScroll: y,
                        overscroll: x = !0,
                        __experimental__naiveDimensions: E = !1
                    } = {}) {
                        window.lenisVersion = "1.1.14", e && e !== document.documentElement && e !== document.body || (e = window), this.options = {
                            wrapper: e,
                            content: t,
                            eventsTarget: n,
                            smoothWheel: r,
                            syncTouch: i,
                            syncTouchLerp: a,
                            touchInertiaMultiplier: o,
                            duration: l,
                            easing: c,
                            lerp: h,
                            infinite: d,
                            gestureOrientation: p,
                            orientation: f,
                            touchMultiplier: g,
                            wheelMultiplier: A,
                            autoResize: m,
                            prevent: v,
                            virtualScroll: y,
                            overscroll: x,
                            __experimental__naiveDimensions: E
                        }, this.dimensions = new s(e, t, {
                            autoResize: m
                        }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll = new u(n, {
                            touchMultiplier: g,
                            wheelMultiplier: A
                        }), this.virtualScroll.on("scroll", this.onVirtualScroll)
                    }
                    destroy() {
                        this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName()
                    }
                    on(e, t) {
                        return this.emitter.on(e, t)
                    }
                    off(e, t) {
                        return this.emitter.off(e, t)
                    }
                    setScroll(e) {
                        this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
                    }
                    onPointerDown = e => {
                        1 === e.button && this.reset()
                    };
                    onVirtualScroll = e => {
                        if ("function" == typeof this.options.virtualScroll && !1 === this.options.virtualScroll(e)) return;
                        let {
                            deltaX: t,
                            deltaY: n,
                            event: r
                        } = e;
                        if (this.emitter.emit("virtual-scroll", {
                                deltaX: t,
                                deltaY: n,
                                event: r
                            }), r.ctrlKey || r.lenisStopPropagation) return;
                        let i = r.type.includes("touch"),
                            s = r.type.includes("wheel");
                        if (this.isTouching = "touchstart" === r.type || "touchmove" === r.type, this.options.syncTouch && i && "touchstart" === r.type && !this.isStopped && !this.isLocked) {
                            this.reset();
                            return
                        }
                        let a = 0 === t && 0 === n,
                            o = "vertical" === this.options.gestureOrientation && 0 === n || "horizontal" === this.options.gestureOrientation && 0 === t;
                        if (a || o) return;
                        let l = r.composedPath();
                        l = l.slice(0, l.indexOf(this.rootElement));
                        let u = this.options.prevent;
                        if (l.find(e => e instanceof HTMLElement && ("function" == typeof u && u ? .(e) || e.hasAttribute ? .("data-lenis-prevent") || i && e.hasAttribute ? .("data-lenis-prevent-touch") || s && e.hasAttribute ? .("data-lenis-prevent-wheel")))) return;
                        if (this.isStopped || this.isLocked) {
                            r.preventDefault();
                            return
                        }
                        if (!(this.options.syncTouch && i || this.options.smoothWheel && s)) {
                            this.isScrolling = "native", this.animate.stop(), r.lenisStopPropagation = !0;
                            return
                        }
                        let c = n;
                        "both" === this.options.gestureOrientation ? c = Math.abs(n) > Math.abs(t) ? n : t : "horizontal" === this.options.gestureOrientation && (c = t), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || 0 === this.animatedScroll && n > 0 || this.animatedScroll === this.limit && n < 0)) && (r.lenisStopPropagation = !0), r.preventDefault();
                        let h = i && this.options.syncTouch,
                            d = i && "touchend" === r.type && Math.abs(c) > 5;
                        d && (c = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + c, {
                            programmatic: !1,
                            ...h ? {
                                lerp: d ? this.options.syncTouchLerp : 1
                            } : {
                                lerp: this.options.lerp,
                                duration: this.options.duration,
                                easing: this.options.easing
                            }
                        })
                    };
                    resize() {
                        this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit()
                    }
                    emit() {
                        this.emitter.emit("scroll", this)
                    }
                    onNativeScroll = () => {
                        if (null !== this._resetVelocityTimeout && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) {
                            this._preventNextNativeScrollEvent = !1;
                            return
                        }
                        if (!1 === this.isScrolling || "native" === this.isScrolling) {
                            let e = this.animatedScroll;
                            this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - e, this.direction = Math.sign(this.animatedScroll - e), this.isScrolling = "native", this.emit(), 0 !== this.velocity && (this._resetVelocityTimeout = setTimeout(() => {
                                this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit()
                            }, 400))
                        }
                    };
                    reset() {
                        this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop()
                    }
                    start() {
                        this.isStopped && (this.isStopped = !1, this.reset())
                    }
                    stop() {
                        this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
                    }
                    raf(e) {
                        let t = e - (this.time || e);
                        this.time = e, this.animate.advance(.001 * t)
                    }
                    scrollTo(e, {
                        offset: t = 0,
                        immediate: n = !1,
                        lock: i = !1,
                        duration: s = this.options.duration,
                        easing: a = this.options.easing,
                        lerp: o = this.options.lerp,
                        onStart: l,
                        onComplete: u,
                        force: c = !1,
                        programmatic: h = !0,
                        userData: d
                    } = {}) {
                        if (!this.isStopped && !this.isLocked || c) {
                            if ("string" == typeof e && ["top", "left", "start"].includes(e)) e = 0;
                            else if ("string" == typeof e && ["bottom", "right", "end"].includes(e)) e = this.limit;
                            else {
                                let n;
                                if ("string" == typeof e ? n = document.querySelector(e) : e instanceof HTMLElement && e ? .nodeType && (n = e), n) {
                                    if (this.options.wrapper !== window) {
                                        let e = this.rootElement.getBoundingClientRect();
                                        t -= this.isHorizontal ? e.left : e.top
                                    }
                                    let r = n.getBoundingClientRect();
                                    e = (this.isHorizontal ? r.left : r.top) + this.animatedScroll
                                }
                            }
                            if ("number" == typeof e) {
                                if (e += t, e = Math.round(e), this.options.infinite ? h && (this.targetScroll = this.animatedScroll = this.scroll) : e = r(0, e, this.limit), e === this.targetScroll) {
                                    l ? .(this), u ? .(this);
                                    return
                                }
                                if (this.userData = d ? ? {}, n) {
                                    this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), u ? .(this), this.userData = {};
                                    return
                                }
                                h || (this.targetScroll = e), this.animate.fromTo(this.animatedScroll, e, {
                                    duration: s,
                                    easing: a,
                                    lerp: o,
                                    onStart: () => {
                                        i && (this.isLocked = !0), this.isScrolling = "smooth", l ? .(this)
                                    },
                                    onUpdate: (e, t) => {
                                        this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = e - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = e, this.setScroll(this.scroll), h && (this.targetScroll = e), t || this.emit(), t && (this.reset(), this.emit(), u ? .(this), this.userData = {}, this.preventNextNativeScrollEvent())
                                    }
                                })
                            }
                        }
                    }
                    preventNextNativeScrollEvent() {
                        this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => {
                            this._preventNextNativeScrollEvent = !1
                        })
                    }
                    get rootElement() {
                        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
                    }
                    get limit() {
                        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
                    }
                    get isHorizontal() {
                        return "horizontal" === this.options.orientation
                    }
                    get actualScroll() {
                        return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
                    }
                    get scroll() {
                        var e;
                        return this.options.infinite ? (this.animatedScroll % (e = this.limit) + e) % e : this.animatedScroll
                    }
                    get progress() {
                        return 0 === this.limit ? 1 : this.scroll / this.limit
                    }
                    get isScrolling() {
                        return this._isScrolling
                    }
                    set isScrolling(e) {
                        this._isScrolling !== e && (this._isScrolling = e, this.updateClassName())
                    }
                    get isStopped() {
                        return this._isStopped
                    }
                    set isStopped(e) {
                        this._isStopped !== e && (this._isStopped = e, this.updateClassName())
                    }
                    get isLocked() {
                        return this._isLocked
                    }
                    set isLocked(e) {
                        this._isLocked !== e && (this._isLocked = e, this.updateClassName())
                    }
                    get isSmooth() {
                        return "smooth" === this.isScrolling
                    }
                    get className() {
                        let e = "lenis";
                        return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), "smooth" === this.isScrolling && (e += " lenis-smooth"), e
                    }
                    updateClassName() {
                        this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
                    }
                    cleanUpClassName() {
                        this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
                    }
                }
        },
        6636: function(e, t, n) {
            "use strict";

            function r() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                var n = e.filter(Boolean);
                return n.length <= 1 ? n[0] || null : function(e) {
                    for (var t = 0; t < n.length; t++) {
                        var r = n[t];
                        "function" == typeof r ? r(e) : r && (r.current = e)
                    }
                }
            }
            n.d(t, {
                Z: function() {
                    return r
                }
            })
        },
        7691: function(e, t, n) {
            "use strict";
            n.d(t, {
                CI: function() {
                    return k
                },
                DD: function() {
                    return _
                },
                GV: function() {
                    return v
                },
                H5: function() {
                    return et
                },
                M4: function() {
                    return K
                },
                Qm: function() {
                    return R
                },
                VB: function() {
                    return g
                },
                Xs: function() {
                    return J
                },
                YQ: function() {
                    return y
                },
                fY: function() {
                    return Y
                },
                hm: function() {
                    return G
                },
                rk: function() {
                    return D
                },
                w2: function() {
                    return a
                },
                xC: function() {
                    return p
                },
                xV: function() {
                    return z
                }
            });
            var r = n(9892),
                i = class {
                    constructor() {
                        this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1
                    }
                    get autoReset() {
                        return this._autoReset
                    }
                    set autoReset(e) {
                        "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = e)
                    }
                    get delta() {
                        return .001 * this._delta
                    }
                    get fixedDelta() {
                        return .001 * this._fixedDelta
                    }
                    set fixedDelta(e) {
                        this._fixedDelta = 1e3 * e
                    }
                    get elapsed() {
                        return .001 * this._elapsed
                    }
                    update(e) {
                        this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (void 0 !== e ? e : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta
                    }
                    reset() {
                        this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime
                    }
                    getDelta() {
                        return this.delta
                    }
                    getElapsed() {
                        return this.elapsed
                    }
                    handleEvent(e) {
                        document.hidden || (this.currentTime = performance.now() - this.startTime)
                    }
                    dispose() {
                        this.autoReset = !1
                    }
                },
                s = (() => {
                    let e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                        t = new Float32Array([0, 0, 2, 0, 0, 2]),
                        n = new r.BufferGeometry;
                    return n.setAttribute("position", new r.BufferAttribute(e, 3)), n.setAttribute("uv", new r.BufferAttribute(t, 2)), n
                })(),
                a = class e {
                    static get fullscreenGeometry() {
                        return s
                    }
                    constructor(e = "Pass", t = new r.Scene, n = new r.Camera) {
                        this.name = e, this.renderer = null, this.scene = t, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
                    }
                    get renderToScreen() {
                        return !this.rtt
                    }
                    set renderToScreen(e) {
                        if (this.rtt === e) {
                            let t = this.fullscreenMaterial;
                            null !== t && (t.needsUpdate = !0), this.rtt = !e
                        }
                    }
                    set mainScene(e) {}
                    set mainCamera(e) {}
                    setRenderer(e) {
                        this.renderer = e
                    }
                    isEnabled() {
                        return this.enabled
                    }
                    setEnabled(e) {
                        this.enabled = e
                    }
                    get fullscreenMaterial() {
                        return null !== this.screen ? this.screen.material : null
                    }
                    set fullscreenMaterial(t) {
                        let n = this.screen;
                        null !== n ? n.material = t : ((n = new r.Mesh(e.fullscreenGeometry, t)).frustumCulled = !1, null === this.scene && (this.scene = new r.Scene), this.scene.add(n), this.screen = n)
                    }
                    getFullscreenMaterial() {
                        return this.fullscreenMaterial
                    }
                    setFullscreenMaterial(e) {
                        this.fullscreenMaterial = e
                    }
                    getDepthTexture() {
                        return null
                    }
                    setDepthTexture(e, t = r.BasicDepthPacking) {}
                    render(e, t, n, r, i) {
                        throw Error("Render method not implemented!")
                    }
                    setSize(e, t) {}
                    initialize(e, t, n) {}
                    dispose() {
                        for (let t of Object.keys(this)) {
                            let n = this[t];
                            (n instanceof r.WebGLRenderTarget || n instanceof r.Material || n instanceof r.Texture || n instanceof e) && this[t].dispose()
                        }
                        null !== this.fullscreenMaterial && this.fullscreenMaterial.dispose()
                    }
                },
                o = class extends a {
                    constructor() {
                        super("ClearMaskPass", null, null), this.needsSwap = !1
                    }
                    render(e, t, n, r, i) {
                        let s = e.state.buffers.stencil;
                        s.setLocked(!1), s.setTest(!1)
                    }
                },
                l = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
                u = class extends r.ShaderMaterial {
                    constructor() {
                        super({
                            name: "CopyMaterial",
                            uniforms: {
                                inputBuffer: new r.Uniform(null),
                                opacity: new r.Uniform(1)
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}",
                            vertexShader: l
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    getOpacity(e) {
                        return this.uniforms.opacity.value
                    }
                    setOpacity(e) {
                        this.uniforms.opacity.value = e
                    }
                },
                c = class extends a {
                    constructor(e, t = !0) {
                        super("CopyPass"), this.fullscreenMaterial = new u, this.needsSwap = !1, this.renderTarget = e, void 0 === e && (this.renderTarget = new r.WebGLRenderTarget(1, 1, {
                            minFilter: r.LinearFilter,
                            magFilter: r.LinearFilter,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = t
                    }
                    get resize() {
                        return this.autoResize
                    }
                    set resize(e) {
                        this.autoResize = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    setAutoResizeEnabled(e) {
                        this.autoResize = e
                    }
                    render(e, t, n, r, i) {
                        this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        this.autoResize && this.renderTarget.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        void 0 !== n && (this.renderTarget.texture.type = n, n !== r.UnsignedByteType ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : null !== e && e.outputColorSpace === r.SRGBColorSpace && (this.renderTarget.texture.colorSpace = r.SRGBColorSpace))
                    }
                },
                h = new r.Color,
                d = class extends a {
                    constructor(e = !0, t = !0, n = !1) {
                        super("ClearPass", null, null), this.needsSwap = !1, this.color = e, this.depth = t, this.stencil = n, this.overrideClearColor = null, this.overrideClearAlpha = -1
                    }
                    setClearFlags(e, t, n) {
                        this.color = e, this.depth = t, this.stencil = n
                    }
                    getOverrideClearColor() {
                        return this.overrideClearColor
                    }
                    setOverrideClearColor(e) {
                        this.overrideClearColor = e
                    }
                    getOverrideClearAlpha() {
                        return this.overrideClearAlpha
                    }
                    setOverrideClearAlpha(e) {
                        this.overrideClearAlpha = e
                    }
                    render(e, t, n, r, i) {
                        let s = this.overrideClearColor,
                            a = this.overrideClearAlpha,
                            o = e.getClearAlpha(),
                            l = null !== s,
                            u = a >= 0;
                        l ? (e.getClearColor(h), e.setClearColor(s, u ? a : o)) : u && e.setClearAlpha(a), e.setRenderTarget(this.renderToScreen ? null : t), e.clear(this.color, this.depth, this.stencil), l ? e.setClearColor(h, o) : u && e.setClearAlpha(o)
                    }
                },
                f = class extends a {
                    constructor(e, t) {
                        super("MaskPass", e, t), this.needsSwap = !1, this.clearPass = new d(!1, !1, !0), this.inverse = !1
                    }
                    set mainScene(e) {
                        this.scene = e
                    }
                    set mainCamera(e) {
                        this.camera = e
                    }
                    get inverted() {
                        return this.inverse
                    }
                    set inverted(e) {
                        this.inverse = e
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(e) {
                        this.clearPass.enabled = e
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    render(e, t, n, r, i) {
                        let s = e.getContext(),
                            a = e.state.buffers,
                            o = this.scene,
                            l = this.camera,
                            u = this.clearPass,
                            c = this.inverted ? 0 : 1;
                        a.color.setMask(!1), a.depth.setMask(!1), a.color.setLocked(!0), a.depth.setLocked(!0), a.stencil.setTest(!0), a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.stencil.setFunc(s.ALWAYS, c, 4294967295), a.stencil.setClear(1 - c), a.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? u.render(e, null) : (u.render(e, t), u.render(e, n))), this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), e.render(o, l), e.setRenderTarget(n)), e.render(o, l), a.color.setLocked(!1), a.depth.setLocked(!1), a.stencil.setLocked(!1), a.stencil.setFunc(s.EQUAL, 1, 4294967295), a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), a.stencil.setLocked(!0)
                    }
                },
                p = class {
                    constructor(e = null, {
                        depthBuffer: t = !0,
                        stencilBuffer: n = !1,
                        multisampling: r = 0,
                        frameBufferType: s
                    } = {}) {
                        this.renderer = null, this.inputBuffer = this.createBuffer(t, n, s, r), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new c, this.depthTexture = null, this.passes = [], this.timer = new i, this.autoRenderToScreen = !0, this.setRenderer(e)
                    }
                    get multisampling() {
                        return this.inputBuffer.samples || 0
                    }
                    set multisampling(e) {
                        let t = this.inputBuffer,
                            n = this.multisampling;
                        n > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
                    }
                    getTimer() {
                        return this.timer
                    }
                    getRenderer() {
                        return this.renderer
                    }
                    setRenderer(e) {
                        if (this.renderer = e, null !== e) {
                            let t = e.getSize(new r.Vector2),
                                n = e.getContext().getContextAttributes().alpha,
                                i = this.inputBuffer.texture.type;
                            for (let s of (i === r.UnsignedByteType && e.outputColorSpace === r.SRGBColorSpace && (this.inputBuffer.texture.colorSpace = r.SRGBColorSpace, this.outputBuffer.texture.colorSpace = r.SRGBColorSpace, this.inputBuffer.dispose(), this.outputBuffer.dispose()), e.autoClear = !1, this.setSize(t.width, t.height), this.passes)) s.initialize(e, n, i)
                        }
                    }
                    replaceRenderer(e, t = !0) {
                        let n = this.renderer,
                            r = n.domElement.parentNode;
                        return this.setRenderer(e), t && null !== r && (r.removeChild(n.domElement), r.appendChild(e.domElement)), n
                    }
                    createDepthTexture() {
                        let e = this.depthTexture = new r.DepthTexture;
                        return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = r.DepthStencilFormat, e.type = r.UnsignedInt248Type) : e.type = r.UnsignedIntType, e
                    }
                    deleteDepthTexture() {
                        if (null !== this.depthTexture)
                            for (let e of (this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(), this.passes)) e.setDepthTexture(null)
                    }
                    createBuffer(e, t, n, i) {
                        let s = this.renderer,
                            a = null === s ? new r.Vector2 : s.getDrawingBufferSize(new r.Vector2),
                            o = {
                                minFilter: r.LinearFilter,
                                magFilter: r.LinearFilter,
                                stencilBuffer: t,
                                depthBuffer: e,
                                type: n
                            },
                            l = new r.WebGLRenderTarget(a.width, a.height, o);
                        return i > 0 && (l.ignoreDepthForMultisampleCopy = !1, l.samples = i), n === r.UnsignedByteType && null !== s && s.outputColorSpace === r.SRGBColorSpace && (l.texture.colorSpace = r.SRGBColorSpace), l.texture.name = "EffectComposer.Buffer", l.texture.generateMipmaps = !1, l
                    }
                    setMainScene(e) {
                        for (let t of this.passes) t.mainScene = e
                    }
                    setMainCamera(e) {
                        for (let t of this.passes) t.mainCamera = e
                    }
                    addPass(e, t) {
                        let n = this.passes,
                            i = this.renderer,
                            s = i.getDrawingBufferSize(new r.Vector2),
                            a = i.getContext().getContextAttributes().alpha,
                            o = this.inputBuffer.texture.type;
                        if (e.setRenderer(i), e.setSize(s.width, s.height), e.initialize(i, a, o), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), e.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== t ? n.splice(t, 0, e) : n.push(e), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), e.needsDepthTexture || null !== this.depthTexture) {
                            if (null === this.depthTexture) {
                                let t = this.createDepthTexture();
                                for (e of n) e.setDepthTexture(t)
                            } else e.setDepthTexture(this.depthTexture)
                        }
                    }
                    removePass(e) {
                        let t = this.passes,
                            n = t.indexOf(e); - 1 !== n && t.splice(n, 1).length > 0 && (null === this.depthTexture || t.reduce((e, t) => e || t.needsDepthTexture, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture()), this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1, t.length > 0 && (t[t.length - 1].renderToScreen = !0)))
                    }
                    removeAllPasses() {
                        let e = this.passes;
                        this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1), this.passes = [])
                    }
                    render(e) {
                        let t, n, r;
                        let i = this.renderer,
                            s = this.copyPass,
                            a = this.inputBuffer,
                            l = this.outputBuffer,
                            u = !1;
                        for (let c of (void 0 === e && (this.timer.update(), e = this.timer.getDelta()), this.passes)) c.enabled && (c.render(i, a, l, e, u), c.needsSwap && (u && (s.renderToScreen = c.renderToScreen, t = i.getContext(), (n = i.state.buffers.stencil).setFunc(t.NOTEQUAL, 1, 4294967295), s.render(i, a, l, e, u), n.setFunc(t.EQUAL, 1, 4294967295)), r = a, a = l, l = r), c instanceof f ? u = !0 : c instanceof o && (u = !1))
                    }
                    setSize(e, t, n) {
                        let i = this.renderer,
                            s = i.getSize(new r.Vector2);
                        (void 0 === e || void 0 === t) && (e = s.width, t = s.height), (s.width !== e || s.height !== t) && i.setSize(e, t, n);
                        let a = i.getDrawingBufferSize(new r.Vector2);
                        for (let e of (this.inputBuffer.setSize(a.width, a.height), this.outputBuffer.setSize(a.width, a.height), this.passes)) e.setSize(a.width, a.height)
                    }
                    reset() {
                        this.dispose(), this.autoRenderToScreen = !0
                    }
                    dispose() {
                        for (let e of this.passes) e.dispose();
                        this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose(), a.fullscreenGeometry.dispose()
                    }
                },
                g = {
                    NONE: 0,
                    DEPTH: 1,
                    CONVOLUTION: 2
                },
                A = {
                    FRAGMENT_HEAD: "FRAGMENT_HEAD",
                    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
                    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
                    VERTEX_HEAD: "VERTEX_HEAD",
                    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
                },
                m = class {
                    constructor() {
                        this.shaderParts = new Map([
                            [A.FRAGMENT_HEAD, null],
                            [A.FRAGMENT_MAIN_UV, null],
                            [A.FRAGMENT_MAIN_IMAGE, null],
                            [A.VERTEX_HEAD, null],
                            [A.VERTEX_MAIN_SUPPORT, null]
                        ]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = g.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = r.LinearSRGBColorSpace
                    }
                },
                v = class extends r.EventDispatcher {
                    constructor(e, t = -1, n = -1, i = 1) {
                        super(), this.resizable = e, this.baseSize = new r.Vector2(1, 1), this.preferredSize = new r.Vector2(t, n), this.target = this.preferredSize, this.s = i, this.effectiveSize = new r.Vector2, this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize()
                    }
                    updateEffectiveSize() {
                        let e = this.baseSize,
                            t = this.preferredSize,
                            n = this.effectiveSize,
                            r = this.scale; - 1 !== t.width ? n.width = t.width : -1 !== t.height ? n.width = Math.round(t.height * (e.width / Math.max(e.height, 1))) : n.width = Math.round(e.width * r), -1 !== t.height ? n.height = t.height : -1 !== t.width ? n.height = Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : n.height = Math.round(e.height * r)
                    }
                    get width() {
                        return this.effectiveSize.width
                    }
                    set width(e) {
                        this.preferredWidth = e
                    }
                    get height() {
                        return this.effectiveSize.height
                    }
                    set height(e) {
                        this.preferredHeight = e
                    }
                    getWidth() {
                        return this.width
                    }
                    getHeight() {
                        return this.height
                    }
                    get scale() {
                        return this.s
                    }
                    set scale(e) {
                        this.s !== e && (this.s = e, this.preferredSize.setScalar(-1), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getScale() {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    get baseWidth() {
                        return this.baseSize.width
                    }
                    set baseWidth(e) {
                        this.baseSize.width !== e && (this.baseSize.width = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseWidth() {
                        return this.baseWidth
                    }
                    setBaseWidth(e) {
                        this.baseWidth = e
                    }
                    get baseHeight() {
                        return this.baseSize.height
                    }
                    set baseHeight(e) {
                        this.baseSize.height !== e && (this.baseSize.height = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseHeight() {
                        return this.baseHeight
                    }
                    setBaseHeight(e) {
                        this.baseHeight = e
                    }
                    setBaseSize(e, t) {
                        (this.baseSize.width !== e || this.baseSize.height !== t) && (this.baseSize.set(e, t), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    get preferredWidth() {
                        return this.preferredSize.width
                    }
                    set preferredWidth(e) {
                        this.preferredSize.width !== e && (this.preferredSize.width = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredWidth() {
                        return this.preferredWidth
                    }
                    setPreferredWidth(e) {
                        this.preferredWidth = e
                    }
                    get preferredHeight() {
                        return this.preferredSize.height
                    }
                    set preferredHeight(e) {
                        this.preferredSize.height !== e && (this.preferredSize.height = e, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredHeight() {
                        return this.preferredHeight
                    }
                    setPreferredHeight(e) {
                        this.preferredHeight = e
                    }
                    setPreferredSize(e, t) {
                        (this.preferredSize.width !== e || this.preferredSize.height !== t) && (this.preferredSize.set(e, t), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    copy(e) {
                        this.s = e.scale, this.baseSize.set(e.baseWidth, e.baseHeight), this.preferredSize.set(e.preferredWidth, e.preferredHeight), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)
                    }
                    static get AUTO_SIZE() {
                        return -1
                    }
                },
                y = {
                    SKIP: 9,
                    SET: 30,
                    ADD: 0,
                    ALPHA: 1,
                    AVERAGE: 2,
                    COLOR: 3,
                    COLOR_BURN: 4,
                    COLOR_DODGE: 5,
                    DARKEN: 6,
                    DIFFERENCE: 7,
                    DIVIDE: 8,
                    DST: 9,
                    EXCLUSION: 10,
                    HARD_LIGHT: 11,
                    HARD_MIX: 12,
                    HUE: 13,
                    INVERT: 14,
                    INVERT_RGB: 15,
                    LIGHTEN: 16,
                    LINEAR_BURN: 17,
                    LINEAR_DODGE: 18,
                    LINEAR_LIGHT: 19,
                    LUMINOSITY: 20,
                    MULTIPLY: 21,
                    NEGATION: 22,
                    NORMAL: 23,
                    OVERLAY: 24,
                    PIN_LIGHT: 25,
                    REFLECT: 26,
                    SATURATION: 27,
                    SCREEN: 28,
                    SOFT_LIGHT: 29,
                    SRC: 30,
                    SUBTRACT: 31,
                    VIVID_LIGHT: 32
                },
                x = new Map([
                    [y.ADD, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"],
                    [y.ALPHA, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"],
                    [y.AVERAGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"],
                    [y.COLOR, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [y.COLOR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"],
                    [y.COLOR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"],
                    [y.DARKEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"],
                    [y.DIFFERENCE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"],
                    [y.DIVIDE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"],
                    [y.DST, null],
                    [y.EXCLUSION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"],
                    [y.HARD_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}"],
                    [y.HARD_MIX, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"],
                    [y.HUE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [y.INVERT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"],
                    [y.INVERT_RGB, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"],
                    [y.LIGHTEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"],
                    [y.LINEAR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"],
                    [y.LINEAR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"],
                    [y.LINEAR_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"],
                    [y.LUMINOSITY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [y.MULTIPLY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"],
                    [y.NEGATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"],
                    [y.NORMAL, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"],
                    [y.OVERLAY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"],
                    [y.PIN_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"],
                    [y.REFLECT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}"],
                    [y.SATURATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                    [y.SCREEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}"],
                    [y.SOFT_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"],
                    [y.SRC, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"],
                    [y.SUBTRACT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"],
                    [y.VIVID_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}"]
                ]),
                E = class extends r.EventDispatcher {
                    constructor(e, t = 1) {
                        super(), this._blendFunction = e, this.opacity = new r.Uniform(t)
                    }
                    getOpacity() {
                        return this.opacity.value
                    }
                    setOpacity(e) {
                        this.opacity.value = e
                    }
                    get blendFunction() {
                        return this._blendFunction
                    }
                    set blendFunction(e) {
                        this._blendFunction = e, this.dispatchEvent({
                            type: "change"
                        })
                    }
                    getBlendFunction() {
                        return this.blendFunction
                    }
                    setBlendFunction(e) {
                        this.blendFunction = e
                    }
                    getShaderCode() {
                        return x.get(this.blendFunction)
                    }
                },
                _ = {
                    VERY_SMALL: 0,
                    SMALL: 1,
                    MEDIUM: 2,
                    LARGE: 3,
                    VERY_LARGE: 4,
                    HUGE: 5
                },
                b = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])],
                w = class extends r.ShaderMaterial {
                    constructor(e = new r.Vector4) {
                        super({
                            name: "KawaseBlurMaterial",
                            uniforms: {
                                inputBuffer: new r.Uniform(null),
                                texelSize: new r.Uniform(new r.Vector4),
                                scale: new r.Uniform(1),
                                kernel: new r.Uniform(0)
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}",
                            vertexShader: "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                        }), this.setTexelSize(e.x, e.y), this.kernelSize = _.MEDIUM
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.inputBuffer = e
                    }
                    get kernelSequence() {
                        return b[this.kernelSize]
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(e) {
                        this.uniforms.scale.value = e
                    }
                    getScale() {
                        return this.uniforms.scale.value
                    }
                    setScale(e) {
                        this.uniforms.scale.value = e
                    }
                    getKernel() {
                        return null
                    }
                    get kernel() {
                        return this.uniforms.kernel.value
                    }
                    set kernel(e) {
                        this.uniforms.kernel.value = e
                    }
                    setKernel(e) {
                        this.kernel = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t, .5 * e, .5 * t)
                    }
                    setSize(e, t) {
                        let n = 1 / e,
                            r = 1 / t;
                        this.uniforms.texelSize.value.set(n, r, .5 * n, .5 * r)
                    }
                },
                C = class extends a {
                    constructor({
                        kernelSize: e = _.MEDIUM,
                        resolutionScale: t = .5,
                        width: n = v.AUTO_SIZE,
                        height: i = v.AUTO_SIZE,
                        resolutionX: s = n,
                        resolutionY: a = i
                    } = {}) {
                        super("KawaseBlurPass"), this.renderTargetA = new r.WebGLRenderTarget(1, 1, {
                            depthBuffer: !1
                        }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
                        let o = this.resolution = new v(this, s, a, t);
                        o.addEventListener("change", e => this.setSize(o.baseWidth, o.baseHeight)), this._blurMaterial = new w, this._blurMaterial.kernelSize = e, this.copyMaterial = new u
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get blurMaterial() {
                        return this._blurMaterial
                    }
                    set blurMaterial(e) {
                        this._blurMaterial = e
                    }
                    get dithering() {
                        return this.copyMaterial.dithering
                    }
                    set dithering(e) {
                        this.copyMaterial.dithering = e
                    }
                    get kernelSize() {
                        return this.blurMaterial.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurMaterial.kernelSize = e
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get scale() {
                        return this.blurMaterial.scale
                    }
                    set scale(e) {
                        this.blurMaterial.scale = e
                    }
                    getScale() {
                        return this.blurMaterial.scale
                    }
                    setScale(e) {
                        this.blurMaterial.scale = e
                    }
                    getKernelSize() {
                        return this.kernelSize
                    }
                    setKernelSize(e) {
                        this.kernelSize = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, r, i) {
                        let s = this.scene,
                            a = this.camera,
                            o = this.renderTargetA,
                            l = this.renderTargetB,
                            u = this.blurMaterial,
                            c = u.kernelSequence,
                            h = t;
                        this.fullscreenMaterial = u;
                        for (let t = 0, n = c.length; t < n; ++t) {
                            let n = (1 & t) == 0 ? o : l;
                            u.kernel = c[t], u.inputBuffer = h.texture, e.setRenderTarget(n), e.render(s, a), h = n
                        }
                        this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = h.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, a)
                    }
                    setSize(e, t) {
                        let n = this.resolution;
                        n.setBaseSize(e, t);
                        let r = n.width,
                            i = n.height;
                        this.renderTargetA.setSize(r, i), this.renderTargetB.setSize(r, i), this.blurMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        void 0 !== n && (this.renderTargetA.texture.type = n, this.renderTargetB.texture.type = n, n !== r.UnsignedByteType ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : null !== e && e.outputColorSpace === r.SRGBColorSpace && (this.renderTargetA.texture.colorSpace = r.SRGBColorSpace, this.renderTargetB.texture.colorSpace = r.SRGBColorSpace))
                    }
                    static get AUTO_SIZE() {
                        return v.AUTO_SIZE
                    }
                },
                S = class extends r.ShaderMaterial {
                    constructor(e = !1, t = null) {
                        super({
                            name: "LuminanceMaterial",
                            defines: {
                                THREE_REVISION: r.REVISION.replace(/\D+/g, "")
                            },
                            uniforms: {
                                inputBuffer: new r.Uniform(null),
                                threshold: new r.Uniform(0),
                                smoothing: new r.Uniform(1),
                                range: new r.Uniform(null)
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}",
                            vertexShader: l
                        }), this.colorOutput = e, this.luminanceRange = t
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get threshold() {
                        return this.uniforms.threshold.value
                    }
                    set threshold(e) {
                        this.smoothing > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = e
                    }
                    getThreshold() {
                        return this.threshold
                    }
                    setThreshold(e) {
                        this.threshold = e
                    }
                    get smoothing() {
                        return this.uniforms.smoothing.value
                    }
                    set smoothing(e) {
                        this.threshold > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = e
                    }
                    getSmoothingFactor() {
                        return this.smoothing
                    }
                    setSmoothingFactor(e) {
                        this.smoothing = e
                    }
                    get useThreshold() {
                        return this.threshold > 0 || this.smoothing > 0
                    }
                    set useThreshold(e) {}
                    get colorOutput() {
                        return void 0 !== this.defines.COLOR
                    }
                    set colorOutput(e) {
                        e ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0
                    }
                    isColorOutputEnabled(e) {
                        return this.colorOutput
                    }
                    setColorOutputEnabled(e) {
                        this.colorOutput = e
                    }
                    get useRange() {
                        return null !== this.luminanceRange
                    }
                    set useRange(e) {
                        this.luminanceRange = null
                    }
                    get luminanceRange() {
                        return this.uniforms.range.value
                    }
                    set luminanceRange(e) {
                        null !== e ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = e, this.needsUpdate = !0
                    }
                    getLuminanceRange() {
                        return this.luminanceRange
                    }
                    setLuminanceRange(e) {
                        this.luminanceRange = e
                    }
                },
                I = class extends a {
                    constructor({
                        renderTarget: e,
                        luminanceRange: t,
                        colorOutput: n,
                        resolutionScale: i = 1,
                        width: s = v.AUTO_SIZE,
                        height: a = v.AUTO_SIZE,
                        resolutionX: o = s,
                        resolutionY: l = a
                    } = {}) {
                        super("LuminancePass"), this.fullscreenMaterial = new S(n, t), this.needsSwap = !1, this.renderTarget = e, void 0 === this.renderTarget && (this.renderTarget = new r.WebGLRenderTarget(1, 1, {
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "LuminancePass.Target");
                        let u = this.resolution = new v(this, o, l, i);
                        u.addEventListener("change", e => this.setSize(u.baseWidth, u.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    render(e, t, n, r, i) {
                        this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        let n = this.resolution;
                        n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height)
                    }
                    initialize(e, t, n) {
                        void 0 !== n && n !== r.UnsignedByteType && (this.renderTarget.texture.type = n, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                },
                M = class extends r.ShaderMaterial {
                    constructor() {
                        super({
                            name: "DownsamplingMaterial",
                            uniforms: {
                                inputBuffer: new r.Uniform(null),
                                texelSize: new r.Uniform(new r.Vector2)
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}",
                            vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                },
                T = class extends r.ShaderMaterial {
                    constructor() {
                        super({
                            name: "UpsamplingMaterial",
                            uniforms: {
                                inputBuffer: new r.Uniform(null),
                                supportBuffer: new r.Uniform(null),
                                texelSize: new r.Uniform(new r.Vector2),
                                radius: new r.Uniform(.85)
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}",
                            vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    set supportBuffer(e) {
                        this.uniforms.supportBuffer.value = e
                    }
                    get radius() {
                        return this.uniforms.radius.value
                    }
                    set radius(e) {
                        this.uniforms.radius.value = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                },
                B = class extends a {
                    constructor() {
                        super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new r.WebGLRenderTarget(1, 1, {
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new M, this.upsamplingMaterial = new T, this.resolution = new r.Vector2
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    get levels() {
                        return this.downsamplingMipmaps.length
                    }
                    set levels(e) {
                        if (this.levels !== e) {
                            let t = this.renderTarget;
                            this.dispose(), this.downsamplingMipmaps = [], this.upsamplingMipmaps = [];
                            for (let n = 0; n < e; ++n) {
                                let e = t.clone();
                                e.texture.name = "Downsampling.Mipmap" + n, this.downsamplingMipmaps.push(e)
                            }
                            this.upsamplingMipmaps.push(t);
                            for (let n = 1, r = e - 1; n < r; ++n) {
                                let e = t.clone();
                                e.texture.name = "Upsampling.Mipmap" + n, this.upsamplingMipmaps.push(e)
                            }
                            this.setSize(this.resolution.x, this.resolution.y)
                        }
                    }
                    get radius() {
                        return this.upsamplingMaterial.radius
                    }
                    set radius(e) {
                        this.upsamplingMaterial.radius = e
                    }
                    render(e, t, n, r, i) {
                        let {
                            scene: s,
                            camera: a
                        } = this, {
                            downsamplingMaterial: o,
                            upsamplingMaterial: l
                        } = this, {
                            downsamplingMipmaps: u,
                            upsamplingMipmaps: c
                        } = this, h = t;
                        this.fullscreenMaterial = o;
                        for (let t = 0, n = u.length; t < n; ++t) {
                            let n = u[t];
                            o.setSize(h.width, h.height), o.inputBuffer = h.texture, e.setRenderTarget(n), e.render(s, a), h = n
                        }
                        this.fullscreenMaterial = l;
                        for (let t = c.length - 1; t >= 0; --t) {
                            let n = c[t];
                            l.setSize(h.width, h.height), l.inputBuffer = h.texture, l.supportBuffer = u[t].texture, e.setRenderTarget(n), e.render(s, a), h = n
                        }
                    }
                    setSize(e, t) {
                        let n = this.resolution;
                        n.set(e, t);
                        let r = n.width,
                            i = n.height;
                        for (let e = 0, t = this.downsamplingMipmaps.length; e < t; ++e) r = Math.round(.5 * r), i = Math.round(.5 * i), this.downsamplingMipmaps[e].setSize(r, i), e < this.upsamplingMipmaps.length && this.upsamplingMipmaps[e].setSize(r, i)
                    }
                    initialize(e, t, n) {
                        if (void 0 !== n) {
                            let t = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
                            for (let e of t) e.texture.type = n;
                            if (n !== r.UnsignedByteType) this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
                            else if (null !== e && e.outputColorSpace === r.SRGBColorSpace)
                                for (let e of t) e.texture.colorSpace = r.SRGBColorSpace
                        }
                    }
                    dispose() {
                        for (let e of (super.dispose(), this.downsamplingMipmaps.concat(this.upsamplingMipmaps))) e.dispose()
                    }
                },
                R = class extends r.EventDispatcher {
                    constructor(e, t, {
                        attributes: n = g.NONE,
                        blendFunction: i = y.NORMAL,
                        defines: s = new Map,
                        uniforms: a = new Map,
                        extensions: o = null,
                        vertexShader: l = null
                    } = {}) {
                        super(), this.name = e, this.renderer = null, this.attributes = n, this.fragmentShader = t, this.vertexShader = l, this.defines = s, this.uniforms = a, this.extensions = o, this.blendMode = new E(i), this.blendMode.addEventListener("change", e => this.setChanged()), this._inputColorSpace = r.LinearSRGBColorSpace, this._outputColorSpace = r.NoColorSpace
                    }
                    get inputColorSpace() {
                        return this._inputColorSpace
                    }
                    set inputColorSpace(e) {
                        this._inputColorSpace = e, this.setChanged()
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(e) {
                        this._outputColorSpace = e, this.setChanged()
                    }
                    set mainScene(e) {}
                    set mainCamera(e) {}
                    getName() {
                        return this.name
                    }
                    setRenderer(e) {
                        this.renderer = e
                    }
                    getDefines() {
                        return this.defines
                    }
                    getUniforms() {
                        return this.uniforms
                    }
                    getExtensions() {
                        return this.extensions
                    }
                    getBlendMode() {
                        return this.blendMode
                    }
                    getAttributes() {
                        return this.attributes
                    }
                    setAttributes(e) {
                        this.attributes = e, this.setChanged()
                    }
                    getFragmentShader() {
                        return this.fragmentShader
                    }
                    setFragmentShader(e) {
                        this.fragmentShader = e, this.setChanged()
                    }
                    getVertexShader() {
                        return this.vertexShader
                    }
                    setVertexShader(e) {
                        this.vertexShader = e, this.setChanged()
                    }
                    setChanged() {
                        this.dispatchEvent({
                            type: "change"
                        })
                    }
                    setDepthTexture(e, t = r.BasicDepthPacking) {}
                    update(e, t, n) {}
                    setSize(e, t) {}
                    initialize(e, t, n) {}
                    dispose() {
                        for (let e of Object.keys(this)) {
                            let t = this[e];
                            (t instanceof r.WebGLRenderTarget || t instanceof r.Material || t instanceof r.Texture || t instanceof a) && this[e].dispose()
                        }
                    }
                },
                D = class extends R {
                    constructor({
                        blendFunction: e = y.SCREEN,
                        luminanceThreshold: t = .9,
                        luminanceSmoothing: n = .025,
                        mipmapBlur: i = !1,
                        intensity: s = 1,
                        radius: a = .85,
                        levels: o = 8,
                        kernelSize: l = _.LARGE,
                        resolutionScale: u = .5,
                        width: c = v.AUTO_SIZE,
                        height: h = v.AUTO_SIZE,
                        resolutionX: d = c,
                        resolutionY: f = h
                    } = {}) {
                        super("BloomEffect", "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}", {
                            blendFunction: e,
                            uniforms: new Map([
                                ["map", new r.Uniform(null)],
                                ["intensity", new r.Uniform(s)]
                            ])
                        }), this.renderTarget = new r.WebGLRenderTarget(1, 1, {
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new C({
                            kernelSize: l
                        }), this.luminancePass = new I({
                            colorOutput: !0
                        }), this.luminanceMaterial.threshold = t, this.luminanceMaterial.smoothing = n, this.mipmapBlurPass = new B, this.mipmapBlurPass.enabled = i, this.mipmapBlurPass.radius = a, this.mipmapBlurPass.levels = o, this.uniforms.get("map").value = i ? this.mipmapBlurPass.texture : this.renderTarget.texture;
                        let p = this.resolution = new v(this, d, f, u);
                        p.addEventListener("change", e => this.setSize(p.baseWidth, p.baseHeight))
                    }
                    get texture() {
                        return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
                    }
                    getTexture() {
                        return this.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getLuminancePass() {
                        return this.luminancePass
                    }
                    get luminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    getLuminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get dithering() {
                        return this.blurPass.dithering
                    }
                    set dithering(e) {
                        this.blurPass.dithering = e
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurPass.kernelSize = e
                    }
                    get distinction() {
                        return console.warn(this.name, "distinction was removed"), 1
                    }
                    set distinction(e) {
                        console.warn(this.name, "distinction was removed")
                    }
                    get intensity() {
                        return this.uniforms.get("intensity").value
                    }
                    set intensity(e) {
                        this.uniforms.get("intensity").value = e
                    }
                    getIntensity() {
                        return this.intensity
                    }
                    setIntensity(e) {
                        this.intensity = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    update(e, t, n) {
                        let r = this.renderTarget,
                            i = this.luminancePass;
                        i.enabled ? (i.render(e, t), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, i.renderTarget) : this.blurPass.render(e, i.renderTarget, r)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, t) : this.blurPass.render(e, t, r)
                    }
                    setSize(e, t) {
                        let n = this.resolution;
                        n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height), this.blurPass.resolution.copy(n), this.luminancePass.setSize(e, t), this.mipmapBlurPass.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, n), this.luminancePass.initialize(e, t, n), this.mipmapBlurPass.initialize(e, t, n), void 0 !== n && (this.renderTarget.texture.type = n, null !== e && e.outputColorSpace === r.SRGBColorSpace && (this.renderTarget.texture.colorSpace = r.SRGBColorSpace))
                    }
                };
            r.ShaderMaterial, r.ShaderMaterial, r.ShaderMaterial;
            var L = class extends a {
                constructor(e, t = "inputBuffer") {
                    super("ShaderPass"), this.fullscreenMaterial = e, this.input = t
                }
                setInput(e) {
                    this.input = e
                }
                render(e, t, n, r, i) {
                    let s = this.fullscreenMaterial.uniforms;
                    null !== t && void 0 !== s && void 0 !== s[this.input] && (s[this.input].value = t.texture), e.setRenderTarget(this.renderToScreen ? null : n), e.render(this.scene, this.camera)
                }
                initialize(e, t, n) {
                    void 0 !== n && n !== r.UnsignedByteType && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                }
            };
            r.DataTexture, r.ShaderMaterial, r.ShaderMaterial;
            var P = {
                SCALE_UP: "lut.scaleup"
            };

            function O(e, t, n) {
                let r = document.createElement("canvas"),
                    i = r.getContext("2d");
                if (r.width = e, r.height = t, n instanceof Image) i.drawImage(n, 0, 0);
                else {
                    let r = i.createImageData(e, t);
                    r.data.set(n), i.putImageData(r, 0, 0)
                }
                return r
            }
            var N = class e {
                    constructor(e = 0, t = 0, n = null) {
                        this.width = e, this.height = t, this.data = n
                    }
                    toCanvas() {
                        return "undefined" == typeof document ? null : O(this.width, this.height, this.data)
                    }
                    static from(t) {
                        let n;
                        let {
                            width: r,
                            height: i
                        } = t;
                        if (t instanceof Image) {
                            let e = O(r, i, t);
                            null !== e && (n = e.getContext("2d").getImageData(0, 0, r, i).data)
                        } else n = t.data;
                        return new e(r, i, n)
                    }
                },
                U = new r.Color,
                F = class e extends r.Data3DTexture {
                    constructor(e, t) {
                        super(e, t, t, t), this.type = r.FloatType, this.format = r.RGBAFormat, this.minFilter = r.LinearFilter, this.magFilter = r.LinearFilter, this.wrapS = r.ClampToEdgeWrapping, this.wrapT = r.ClampToEdgeWrapping, this.wrapR = r.ClampToEdgeWrapping, this.unpackAlignment = 1, this.needsUpdate = !0, this.colorSpace = r.LinearSRGBColorSpace, this.domainMin = new r.Vector3(0, 0, 0), this.domainMax = new r.Vector3(1, 1, 1)
                    }
                    get isLookupTexture3D() {
                        return !0
                    }
                    scaleUp(t, n = !0) {
                        let r = this.image;
                        return t <= r.width ? Promise.reject(Error("The target size must be greater than the current size")) : new Promise((i, s) => {
                            let a = URL.createObjectURL(new Blob(['"use strict";(()=>{var O={SCALE_UP:"lut.scaleup"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener("message",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\n'], {
                                    type: "text/javascript"
                                })),
                                o = new Worker(a);
                            o.addEventListener("error", e => s(e.error)), o.addEventListener("message", n => {
                                let r = new e(n.data, t);
                                this.colorSpace = r.colorSpace, r.type = this.type, r.name = this.name, URL.revokeObjectURL(a), i(r)
                            });
                            let l = n ? [r.data.buffer] : [];
                            o.postMessage({
                                operation: P.SCALE_UP,
                                data: r.data,
                                size: t
                            }, l)
                        })
                    }
                    applyLUT(e) {
                        let t = this.image,
                            n = e.image,
                            i = Math.min(t.width, t.height, t.depth);
                        if (i !== Math.min(n.width, n.height, n.depth)) console.error("Size mismatch");
                        else if (e.type !== r.FloatType || this.type !== r.FloatType) console.error("Both LUTs must be FloatType textures");
                        else if (e.format !== r.RGBAFormat || this.format !== r.RGBAFormat) console.error("Both LUTs must be RGBA textures");
                        else {
                            let e = t.data,
                                r = n.data,
                                s = i ** 2,
                                a = i - 1;
                            for (let t = 0, n = i ** 3; t < n; ++t) {
                                let n = 4 * t,
                                    o = 4 * Math.round(e[n + 0] * a + e[n + 1] * a * i + e[n + 2] * a * s);
                                e[n + 0] = r[o + 0], e[n + 1] = r[o + 1], e[n + 2] = r[o + 2]
                            }
                            this.needsUpdate = !0
                        }
                        return this
                    }
                    convertToUint8() {
                        if (this.type === r.FloatType) {
                            let e = this.image.data,
                                t = new Uint8Array(e.length);
                            for (let n = 0, r = e.length; n < r; ++n) t[n] = 255 * e[n] + .5;
                            this.image.data = t, this.type = r.UnsignedByteType, this.needsUpdate = !0
                        }
                        return this
                    }
                    convertToFloat() {
                        if (this.type === r.UnsignedByteType) {
                            let e = this.image.data,
                                t = new Float32Array(e.length);
                            for (let n = 0, r = e.length; n < r; ++n) t[n] = e[n] / 255;
                            this.image.data = t, this.type = r.FloatType, this.needsUpdate = !0
                        }
                        return this
                    }
                    convertToRGBA() {
                        return console.warn("LookupTexture", "convertToRGBA() is deprecated, LUTs are now RGBA by default"), this
                    }
                    convertLinearToSRGB() {
                        let e = this.image.data;
                        if (this.type === r.FloatType) {
                            for (let t = 0, n = e.length; t < n; t += 4) U.fromArray(e, t).convertLinearToSRGB().toArray(e, t);
                            this.colorSpace = r.SRGBColorSpace, this.needsUpdate = !0
                        } else console.error("Color space conversion requires FloatType data");
                        return this
                    }
                    convertSRGBToLinear() {
                        let e = this.image.data;
                        if (this.type === r.FloatType) {
                            for (let t = 0, n = e.length; t < n; t += 4) U.fromArray(e, t).convertSRGBToLinear().toArray(e, t);
                            this.colorSpace = r.LinearSRGBColorSpace, this.needsUpdate = !0
                        } else console.error("Color space conversion requires FloatType data");
                        return this
                    }
                    toDataTexture() {
                        let e = this.image.width,
                            t = this.image.height * this.image.depth,
                            n = new r.DataTexture(this.image.data, e, t);
                        return n.name = this.name, n.type = this.type, n.format = this.format, n.minFilter = r.LinearFilter, n.magFilter = r.LinearFilter, n.wrapS = this.wrapS, n.wrapT = this.wrapT, n.generateMipmaps = !1, n.needsUpdate = !0, this.colorSpace = n.colorSpace, n
                    }
                    static from(t) {
                        let n;
                        let r = t.image,
                            {
                                width: i,
                                height: s
                            } = r,
                            a = Math.min(i, s);
                        if (r instanceof Image) {
                            let e = N.from(r).data;
                            if (i > s) {
                                n = new Uint8Array(e.length);
                                for (let t = 0; t < a; ++t)
                                    for (let r = 0; r < a; ++r)
                                        for (let i = 0; i < a; ++i) {
                                            let s = (i + t * a + r * a * a) * 4,
                                                o = (i + r * a + t * a * a) * 4;
                                            n[o + 0] = e[s + 0], n[o + 1] = e[s + 1], n[o + 2] = e[s + 2], n[o + 3] = e[s + 3]
                                        }
                            } else n = new Uint8Array(e.buffer)
                        } else n = r.data.slice();
                        let o = new e(n, a);
                        return o.type = t.type, o.name = t.name, t.colorSpace = o.colorSpace, o
                    }
                    static createNeutral(t) {
                        let n = new Float32Array(t ** 3 * 4),
                            r = t ** 2,
                            i = 1 / (t - 1);
                        for (let e = 0; e < t; ++e)
                            for (let s = 0; s < t; ++s)
                                for (let a = 0; a < t; ++a) {
                                    let o = (e + s * t + a * r) * 4;
                                    n[o + 0] = e * i, n[o + 1] = s * i, n[o + 2] = a * i, n[o + 3] = 1
                                }
                        let s = new e(n, t);
                        return s.name = "neutral", s
                    }
                },
                k = class extends R {
                    constructor(e, {
                        blendFunction: t = y.SRC,
                        tetrahedralInterpolation: n = !1,
                        inputColorSpace: i = r.SRGBColorSpace
                    } = {}) {
                        super("LUT3DEffect", "uniform vec3 scale;uniform vec3 offset;\n#ifdef CUSTOM_INPUT_DOMAIN\nuniform vec3 domainMin;uniform vec3 domainMax;\n#endif\n#ifdef LUT_3D\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler3D lut;\n#else\nuniform mediump sampler3D lut;\n#endif\n#else\nuniform lowp sampler3D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){\n#ifdef TETRAHEDRAL_INTERPOLATION\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\n#else\nreturn texture(lut,rgb);\n#endif\n}\n#else\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\n#ifdef LUT_STRIP_HORIZONTAL\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\n#else\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\n#endif\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;\n#ifdef CUSTOM_INPUT_DOMAIN\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}\n#else\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\nc=clamp(c,0.0,1.0);\n#endif\nc=applyLUT(scale*c+offset).rgb;\n#endif\noutputColor=vec4(c,inputColor.a);}", {
                            blendFunction: t,
                            uniforms: new Map([
                                ["lut", new r.Uniform(null)],
                                ["scale", new r.Uniform(new r.Vector3)],
                                ["offset", new r.Uniform(new r.Vector3)],
                                ["domainMin", new r.Uniform(null)],
                                ["domainMax", new r.Uniform(null)]
                            ])
                        }), this.tetrahedralInterpolation = n, this.inputColorSpace = i, this.lut = e
                    }
                    get lut() {
                        return this.uniforms.get("lut").value
                    }
                    set lut(e) {
                        let t = this.defines,
                            n = this.uniforms;
                        if (this.lut !== e && (n.get("lut").value = e, null !== e)) {
                            let i = e.image,
                                s = this.tetrahedralInterpolation;
                            if (t.clear(), t.set("LUT_SIZE", Math.min(i.width, i.height).toFixed(16)), t.set("LUT_TEXEL_WIDTH", (1 / i.width).toFixed(16)), t.set("LUT_TEXEL_HEIGHT", (1 / i.height).toFixed(16)), n.get("domainMin").value = null, n.get("domainMax").value = null, (e.type === r.FloatType || e.type === r.HalfFloatType) && t.set("LUT_PRECISION_HIGH", "1"), i.width > i.height ? t.set("LUT_STRIP_HORIZONTAL", "1") : e instanceof r.Data3DTexture && t.set("LUT_3D", "1"), e instanceof F) {
                                let r = e.domainMin,
                                    i = e.domainMax;
                                (0 !== r.x || 0 !== r.y || 0 !== r.z || 1 !== i.x || 1 !== i.y || 1 !== i.z) && (t.set("CUSTOM_INPUT_DOMAIN", "1"), n.get("domainMin").value = r.clone(), n.get("domainMax").value = i.clone())
                            }
                            this.tetrahedralInterpolation = s
                        }
                    }
                    getLUT() {
                        return this.lut
                    }
                    setLUT(e) {
                        this.lut = e
                    }
                    updateScaleOffset() {
                        let e = this.lut;
                        if (null !== e) {
                            let t = Math.min(e.image.width, e.image.height),
                                n = this.uniforms.get("scale").value,
                                i = this.uniforms.get("offset").value;
                            if (this.tetrahedralInterpolation && e instanceof r.Data3DTexture) {
                                if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
                                    let r = e.domainMax.clone().sub(e.domainMin);
                                    n.setScalar(t - 1).divide(r), i.copy(e.domainMin).negate().multiply(n)
                                } else n.setScalar(t - 1), i.setScalar(0)
                            } else if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
                                let r = e.domainMax.clone().sub(e.domainMin).multiplyScalar(t);
                                n.setScalar(t - 1).divide(r), i.copy(e.domainMin).negate().multiply(n).addScalar(1 / (2 * t))
                            } else n.setScalar((t - 1) / t), i.setScalar(1 / (2 * t))
                        }
                    }
                    configureTetrahedralInterpolation() {
                        let e = this.lut;
                        null !== e && (e.minFilter = r.LinearFilter, e.magFilter = r.LinearFilter, this.tetrahedralInterpolation && (e instanceof r.Data3DTexture ? (e.minFilter = r.NearestFilter, e.magFilter = r.NearestFilter) : console.warn("Tetrahedral interpolation requires a 3D texture")), e.needsUpdate = !0)
                    }
                    get tetrahedralInterpolation() {
                        return this.defines.has("TETRAHEDRAL_INTERPOLATION")
                    }
                    set tetrahedralInterpolation(e) {
                        e ? this.defines.set("TETRAHEDRAL_INTERPOLATION", "1") : this.defines.delete("TETRAHEDRAL_INTERPOLATION"), this.configureTetrahedralInterpolation(), this.updateScaleOffset(), this.setChanged()
                    }
                    setTetrahedralInterpolationEnabled(e) {
                        this.tetrahedralInterpolation = e
                    }
                },
                Q = {
                    LOW: 0,
                    MEDIUM: 1,
                    HIGH: 2,
                    ULTRA: 3
                },
                G = {
                    LINEAR: 0,
                    REINHARD: 1,
                    REINHARD2: 2,
                    REINHARD2_ADAPTIVE: 3,
                    UNCHARTED2: 4,
                    OPTIMIZED_CINEON: 5,
                    CINEON: 5,
                    ACES_FILMIC: 6,
                    AGX: 7,
                    NEUTRAL: 8
                },
                z = class extends R {
                    constructor({
                        blendFunction: e = y.SCREEN,
                        premultiply: t = !1
                    } = {}) {
                        super("NoiseEffect", "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}", {
                            blendFunction: e
                        }), this.premultiply = t
                    }
                    get premultiply() {
                        return this.defines.has("PREMULTIPLY")
                    }
                    set premultiply(e) {
                        this.premultiply !== e && (e ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged())
                    }
                    isPremultiplied() {
                        return this.premultiply
                    }
                    setPremultiplied(e) {
                        this.premultiply = e
                    }
                };
            r.ShaderMaterial, r.ShaderMaterial;
            var H = class extends r.ShaderMaterial {
                    constructor(e = new r.Vector2, t = 2) {
                        super({
                            name: "EdgeDetectionMaterial",
                            defines: {
                                THREE_REVISION: r.REVISION.replace(/\D+/g, ""),
                                LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                                EDGE_THRESHOLD: "0.1",
                                DEPTH_THRESHOLD: "0.01",
                                PREDICATION_MODE: "0",
                                PREDICATION_THRESHOLD: "0.01",
                                PREDICATION_SCALE: "2.0",
                                PREDICATION_STRENGTH: "1.0",
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                inputBuffer: new r.Uniform(null),
                                depthBuffer: new r.Uniform(null),
                                predicationBuffer: new r.Uniform(null),
                                texelSize: new r.Uniform(e)
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
                            vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}"
                        }), this.edgeDetectionMode = t
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t = r.BasicDepthPacking) {
                        this.depthBuffer = e, this.depthPacking = t
                    }
                    get edgeDetectionMode() {
                        return Number(this.defines.EDGE_DETECTION_MODE)
                    }
                    set edgeDetectionMode(e) {
                        this.defines.EDGE_DETECTION_MODE = e.toFixed(0), this.needsUpdate = !0
                    }
                    getEdgeDetectionMode() {
                        return this.edgeDetectionMode
                    }
                    setEdgeDetectionMode(e) {
                        this.edgeDetectionMode = e
                    }
                    get localContrastAdaptationFactor() {
                        return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
                    }
                    set localContrastAdaptationFactor(e) {
                        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"), this.needsUpdate = !0
                    }
                    getLocalContrastAdaptationFactor() {
                        return this.localContrastAdaptationFactor
                    }
                    setLocalContrastAdaptationFactor(e) {
                        this.localContrastAdaptationFactor = e
                    }
                    get edgeDetectionThreshold() {
                        return Number(this.defines.EDGE_THRESHOLD)
                    }
                    set edgeDetectionThreshold(e) {
                        this.defines.EDGE_THRESHOLD = e.toFixed("6"), this.defines.DEPTH_THRESHOLD = (.1 * e).toFixed("6"), this.needsUpdate = !0
                    }
                    getEdgeDetectionThreshold() {
                        return this.edgeDetectionThreshold
                    }
                    setEdgeDetectionThreshold(e) {
                        this.edgeDetectionThreshold = e
                    }
                    get predicationMode() {
                        return Number(this.defines.PREDICATION_MODE)
                    }
                    set predicationMode(e) {
                        this.defines.PREDICATION_MODE = e.toFixed(0), this.needsUpdate = !0
                    }
                    getPredicationMode() {
                        return this.predicationMode
                    }
                    setPredicationMode(e) {
                        this.predicationMode = e
                    }
                    set predicationBuffer(e) {
                        this.uniforms.predicationBuffer.value = e
                    }
                    setPredicationBuffer(e) {
                        this.uniforms.predicationBuffer.value = e
                    }
                    get predicationThreshold() {
                        return Number(this.defines.PREDICATION_THRESHOLD)
                    }
                    set predicationThreshold(e) {
                        this.defines.PREDICATION_THRESHOLD = e.toFixed("6"), this.needsUpdate = !0
                    }
                    getPredicationThreshold() {
                        return this.predicationThreshold
                    }
                    setPredicationThreshold(e) {
                        this.predicationThreshold = e
                    }
                    get predicationScale() {
                        return Number(this.defines.PREDICATION_SCALE)
                    }
                    set predicationScale(e) {
                        this.defines.PREDICATION_SCALE = e.toFixed("6"), this.needsUpdate = !0
                    }
                    getPredicationScale() {
                        return this.predicationScale
                    }
                    setPredicationScale(e) {
                        this.predicationScale = e
                    }
                    get predicationStrength() {
                        return Number(this.defines.PREDICATION_STRENGTH)
                    }
                    set predicationStrength(e) {
                        this.defines.PREDICATION_STRENGTH = e.toFixed("6"), this.needsUpdate = !0
                    }
                    getPredicationStrength() {
                        return this.predicationStrength
                    }
                    setPredicationStrength(e) {
                        this.predicationStrength = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                },
                V = class extends r.ShaderMaterial {
                    constructor(e = new r.Vector2, t = new r.Vector2) {
                        super({
                            name: "SMAAWeightsMaterial",
                            defines: {
                                MAX_SEARCH_STEPS_INT: "16",
                                MAX_SEARCH_STEPS_FLOAT: "16.0",
                                MAX_SEARCH_STEPS_DIAG_INT: "8",
                                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                                CORNER_ROUNDING: "25",
                                CORNER_ROUNDING_NORM: "0.25",
                                AREATEX_MAX_DISTANCE: "16.0",
                                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                            },
                            uniforms: {
                                inputBuffer: new r.Uniform(null),
                                searchTexture: new r.Uniform(null),
                                areaTexture: new r.Uniform(null),
                                resolution: new r.Uniform(t),
                                texelSize: new r.Uniform(e)
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
                            vertexShader: "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get searchTexture() {
                        return this.uniforms.searchTexture.value
                    }
                    set searchTexture(e) {
                        this.uniforms.searchTexture.value = e
                    }
                    get areaTexture() {
                        return this.uniforms.areaTexture.value
                    }
                    set areaTexture(e) {
                        this.uniforms.areaTexture.value = e
                    }
                    setLookupTextures(e, t) {
                        this.searchTexture = e, this.areaTexture = t
                    }
                    get orthogonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_INT)
                    }
                    set orthogonalSearchSteps(e) {
                        let t = Math.min(Math.max(e, 0), 112);
                        this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"), this.needsUpdate = !0
                    }
                    setOrthogonalSearchSteps(e) {
                        this.orthogonalSearchSteps = e
                    }
                    get diagonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
                    }
                    set diagonalSearchSteps(e) {
                        let t = Math.min(Math.max(e, 0), 20);
                        this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"), this.needsUpdate = !0
                    }
                    setDiagonalSearchSteps(e) {
                        this.diagonalSearchSteps = e
                    }
                    get diagonalDetection() {
                        return void 0 === this.defines.DISABLE_DIAG_DETECTION
                    }
                    set diagonalDetection(e) {
                        e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0
                    }
                    isDiagonalDetectionEnabled() {
                        return this.diagonalDetection
                    }
                    setDiagonalDetectionEnabled(e) {
                        this.diagonalDetection = e
                    }
                    get cornerRounding() {
                        return Number(this.defines.CORNER_ROUNDING)
                    }
                    set cornerRounding(e) {
                        let t = Math.min(Math.max(e, 0), 100);
                        this.defines.CORNER_ROUNDING = t.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"), this.needsUpdate = !0
                    }
                    setCornerRounding(e) {
                        this.cornerRounding = e
                    }
                    get cornerDetection() {
                        return void 0 === this.defines.DISABLE_CORNER_DETECTION
                    }
                    set cornerDetection(e) {
                        e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0
                    }
                    isCornerRoundingEnabled() {
                        return this.cornerDetection
                    }
                    setCornerRoundingEnabled(e) {
                        this.cornerDetection = e
                    }
                    setSize(e, t) {
                        let n = this.uniforms;
                        n.texelSize.value.set(1 / e, 1 / t), n.resolution.value.set(e, t)
                    }
                },
                j = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
                W = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",
                Y = class extends R {
                    constructor({
                        blendFunction: e = y.SRC,
                        preset: t = Q.MEDIUM,
                        edgeDetectionMode: n = 2,
                        predicationMode: i = 0
                    } = {}) {
                        let s, a;
                        super("SMAAEffect", "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", {
                            vertexShader: "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                            blendFunction: e,
                            attributes: g.CONVOLUTION | g.DEPTH,
                            uniforms: new Map([
                                ["weightMap", new r.Uniform(null)]
                            ])
                        }), arguments.length > 1 && (s = arguments[0], a = arguments[1], arguments.length > 2 && (t = arguments[2]), arguments.length > 3 && (n = arguments[3])), this.renderTargetEdges = new r.WebGLRenderTarget(1, 1, {
                            depthBuffer: !1
                        }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new d(!0, !1, !1), this.clearPass.overrideClearColor = new r.Color(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new L(new H), this.edgeDetectionMaterial.edgeDetectionMode = n, this.edgeDetectionMaterial.predicationMode = i, this.weightsPass = new L(new V);
                        let o = new r.LoadingManager;
                        o.onLoad = () => {
                            let e = new r.Texture(s);
                            e.name = "SMAA.Search", e.magFilter = r.NearestFilter, e.minFilter = r.NearestFilter, e.generateMipmaps = !1, e.needsUpdate = !0, e.flipY = !0, this.weightsMaterial.searchTexture = e;
                            let t = new r.Texture(a);
                            t.name = "SMAA.Area", t.magFilter = r.LinearFilter, t.minFilter = r.LinearFilter, t.generateMipmaps = !1, t.needsUpdate = !0, t.flipY = !1, this.weightsMaterial.areaTexture = t, this.dispatchEvent({
                                type: "load"
                            })
                        }, o.itemStart("search"), o.itemStart("area"), void 0 !== s && void 0 !== a ? (o.itemEnd("search"), o.itemEnd("area")) : "undefined" != typeof Image && (s = new Image, a = new Image, s.addEventListener("load", () => o.itemEnd("search")), a.addEventListener("load", () => o.itemEnd("area")), s.src = j, a.src = W), this.applyPreset(t)
                    }
                    get edgesTexture() {
                        return this.renderTargetEdges.texture
                    }
                    getEdgesTexture() {
                        return this.edgesTexture
                    }
                    get weightsTexture() {
                        return this.renderTargetWeights.texture
                    }
                    getWeightsTexture() {
                        return this.weightsTexture
                    }
                    get edgeDetectionMaterial() {
                        return this.edgeDetectionPass.fullscreenMaterial
                    }
                    get colorEdgesMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    getEdgeDetectionMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    get weightsMaterial() {
                        return this.weightsPass.fullscreenMaterial
                    }
                    getWeightsMaterial() {
                        return this.weightsMaterial
                    }
                    setEdgeDetectionThreshold(e) {
                        this.edgeDetectionMaterial.edgeDetectionThreshold = e
                    }
                    setOrthogonalSearchSteps(e) {
                        this.weightsMaterial.orthogonalSearchSteps = e
                    }
                    applyPreset(e) {
                        let t = this.edgeDetectionMaterial,
                            n = this.weightsMaterial;
                        switch (e) {
                            case Q.LOW:
                                t.edgeDetectionThreshold = .15, n.orthogonalSearchSteps = 4, n.diagonalDetection = !1, n.cornerDetection = !1;
                                break;
                            case Q.MEDIUM:
                                t.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 8, n.diagonalDetection = !1, n.cornerDetection = !1;
                                break;
                            case Q.HIGH:
                                t.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 16, n.diagonalSearchSteps = 8, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0;
                                break;
                            case Q.ULTRA:
                                t.edgeDetectionThreshold = .05, n.orthogonalSearchSteps = 32, n.diagonalSearchSteps = 16, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0
                        }
                    }
                    setDepthTexture(e, t = r.BasicDepthPacking) {
                        this.edgeDetectionMaterial.depthBuffer = e, this.edgeDetectionMaterial.depthPacking = t
                    }
                    update(e, t, n) {
                        this.clearPass.render(e, this.renderTargetEdges), this.edgeDetectionPass.render(e, t, this.renderTargetEdges), this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights)
                    }
                    setSize(e, t) {
                        this.edgeDetectionMaterial.setSize(e, t), this.weightsMaterial.setSize(e, t), this.renderTargetEdges.setSize(e, t), this.renderTargetWeights.setSize(e, t)
                    }
                    dispose() {
                        let {
                            searchTexture: e,
                            areaTexture: t
                        } = this.weightsMaterial;
                        null !== e && null !== t && (e.dispose(), t.dispose()), super.dispose()
                    }
                    static get searchImageDataURL() {
                        return j
                    }
                    static get areaImageDataURL() {
                        return W
                    }
                };
            r.ShaderMaterial, r.ShaderMaterial;
            var X = class extends r.ShaderMaterial {
                    constructor() {
                        super({
                            name: "AdaptiveLuminanceMaterial",
                            defines: {
                                MIP_LEVEL_1X1: "0.0"
                            },
                            uniforms: {
                                luminanceBuffer0: new r.Uniform(null),
                                luminanceBuffer1: new r.Uniform(null),
                                minLuminance: new r.Uniform(.01),
                                deltaTime: new r.Uniform(0),
                                tau: new r.Uniform(1)
                            },
                            extensions: {
                                shaderTextureLOD: !0
                            },
                            blending: r.NoBlending,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}",
                            vertexShader: l
                        })
                    }
                    set luminanceBuffer0(e) {
                        this.uniforms.luminanceBuffer0.value = e
                    }
                    setLuminanceBuffer0(e) {
                        this.uniforms.luminanceBuffer0.value = e
                    }
                    set luminanceBuffer1(e) {
                        this.uniforms.luminanceBuffer1.value = e
                    }
                    setLuminanceBuffer1(e) {
                        this.uniforms.luminanceBuffer1.value = e
                    }
                    set mipLevel1x1(e) {
                        this.defines.MIP_LEVEL_1X1 = e.toFixed(1), this.needsUpdate = !0
                    }
                    setMipLevel1x1(e) {
                        this.mipLevel1x1 = e
                    }
                    set deltaTime(e) {
                        this.uniforms.deltaTime.value = e
                    }
                    setDeltaTime(e) {
                        this.uniforms.deltaTime.value = e
                    }
                    get minLuminance() {
                        return this.uniforms.minLuminance.value
                    }
                    set minLuminance(e) {
                        this.uniforms.minLuminance.value = e
                    }
                    getMinLuminance() {
                        return this.uniforms.minLuminance.value
                    }
                    setMinLuminance(e) {
                        this.uniforms.minLuminance.value = e
                    }
                    get adaptationRate() {
                        return this.uniforms.tau.value
                    }
                    set adaptationRate(e) {
                        this.uniforms.tau.value = e
                    }
                    getAdaptationRate() {
                        return this.uniforms.tau.value
                    }
                    setAdaptationRate(e) {
                        this.uniforms.tau.value = e
                    }
                },
                q = class extends a {
                    constructor(e, {
                        minLuminance: t = .01,
                        adaptationRate: n = 1
                    } = {}) {
                        super("AdaptiveLuminancePass"), this.fullscreenMaterial = new X, this.needsSwap = !1, this.renderTargetPrevious = new r.WebGLRenderTarget(1, 1, {
                            minFilter: r.NearestFilter,
                            magFilter: r.NearestFilter,
                            depthBuffer: !1
                        }), this.renderTargetPrevious.texture.name = "Luminance.Previous";
                        let i = this.fullscreenMaterial;
                        i.luminanceBuffer0 = this.renderTargetPrevious.texture, i.luminanceBuffer1 = e, i.minLuminance = t, i.adaptationRate = n, this.renderTargetAdapted = this.renderTargetPrevious.clone(), this.renderTargetAdapted.texture.name = "Luminance.Adapted", this.copyPass = new c(this.renderTargetPrevious, !1)
                    }
                    get texture() {
                        return this.renderTargetAdapted.texture
                    }
                    getTexture() {
                        return this.renderTargetAdapted.texture
                    }
                    set mipLevel1x1(e) {
                        this.fullscreenMaterial.mipLevel1x1 = e
                    }
                    get adaptationRate() {
                        return this.fullscreenMaterial.adaptationRate
                    }
                    set adaptationRate(e) {
                        this.fullscreenMaterial.adaptationRate = e
                    }
                    render(e, t, n, r, i) {
                        this.fullscreenMaterial.deltaTime = r, e.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted), e.render(this.scene, this.camera), this.copyPass.render(e, this.renderTargetAdapted)
                    }
                },
                K = class extends R {
                    constructor({
                        blendFunction: e = y.SRC,
                        adaptive: t = !1,
                        mode: n = t ? G.REINHARD2_ADAPTIVE : G.AGX,
                        resolution: i = 256,
                        maxLuminance: s = 4,
                        whitePoint: a = s,
                        middleGrey: o = .6,
                        minLuminance: l = .01,
                        averageLuminance: u = 1,
                        adaptationRate: c = 1
                    } = {}) {
                        super("ToneMappingEffect", "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}", {
                            blendFunction: e,
                            uniforms: new Map([
                                ["luminanceBuffer", new r.Uniform(null)],
                                ["maxLuminance", new r.Uniform(s)],
                                ["whitePoint", new r.Uniform(a)],
                                ["middleGrey", new r.Uniform(o)],
                                ["averageLuminance", new r.Uniform(u)]
                            ])
                        }), this.renderTargetLuminance = new r.WebGLRenderTarget(1, 1, {
                            minFilter: r.LinearMipmapLinearFilter,
                            depthBuffer: !1
                        }), this.renderTargetLuminance.texture.generateMipmaps = !0, this.renderTargetLuminance.texture.name = "Luminance", this.luminancePass = new I({
                            renderTarget: this.renderTargetLuminance
                        }), this.adaptiveLuminancePass = new q(this.luminancePass.texture, {
                            minLuminance: l,
                            adaptationRate: c
                        }), this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture, this.resolution = i, this.mode = n
                    }
                    get mode() {
                        return Number(this.defines.get("TONE_MAPPING_MODE"))
                    }
                    set mode(e) {
                        if (this.mode === e) return;
                        let t = r.REVISION.replace(/\D+/g, "");
                        switch (this.defines.clear(), this.defines.set("TONE_MAPPING_MODE", e.toFixed(0)), e) {
                            case G.LINEAR:
                                this.defines.set("toneMapping(texel)", "LinearToneMapping(texel)");
                                break;
                            case G.REINHARD:
                                this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
                                break;
                            case G.CINEON:
                            case G.OPTIMIZED_CINEON:
                                this.defines.set("toneMapping(texel)", t >= 168 ? "CineonToneMapping(texel)" : "OptimizedCineonToneMapping(texel)");
                                break;
                            case G.ACES_FILMIC:
                                this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
                                break;
                            case G.AGX:
                                this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)");
                                break;
                            case G.NEUTRAL:
                                this.defines.set("toneMapping(texel)", "NeutralToneMapping(texel)");
                                break;
                            default:
                                this.defines.set("toneMapping(texel)", "texel")
                        }
                        this.adaptiveLuminancePass.enabled = e === G.REINHARD2_ADAPTIVE, this.setChanged()
                    }
                    getMode() {
                        return this.mode
                    }
                    setMode(e) {
                        this.mode = e
                    }
                    get whitePoint() {
                        return this.uniforms.get("whitePoint").value
                    }
                    set whitePoint(e) {
                        this.uniforms.get("whitePoint").value = e
                    }
                    get middleGrey() {
                        return this.uniforms.get("middleGrey").value
                    }
                    set middleGrey(e) {
                        this.uniforms.get("middleGrey").value = e
                    }
                    get averageLuminance() {
                        return this.uniforms.get("averageLuminance").value
                    }
                    set averageLuminance(e) {
                        this.uniforms.get("averageLuminance").value = e
                    }
                    get adaptiveLuminanceMaterial() {
                        return this.adaptiveLuminancePass.fullscreenMaterial
                    }
                    getAdaptiveLuminanceMaterial() {
                        return this.adaptiveLuminanceMaterial
                    }
                    get resolution() {
                        return this.luminancePass.resolution.width
                    }
                    set resolution(e) {
                        let t = Math.max(0, Math.ceil(Math.log2(e))),
                            n = Math.pow(2, t);
                        this.luminancePass.resolution.setPreferredSize(n, n), this.adaptiveLuminanceMaterial.mipLevel1x1 = t
                    }
                    getResolution() {
                        return this.resolution
                    }
                    setResolution(e) {
                        this.resolution = e
                    }
                    get adaptive() {
                        return this.mode === G.REINHARD2_ADAPTIVE
                    }
                    set adaptive(e) {
                        this.mode = e ? G.REINHARD2_ADAPTIVE : G.REINHARD2
                    }
                    get adaptationRate() {
                        return this.adaptiveLuminanceMaterial.adaptationRate
                    }
                    set adaptationRate(e) {
                        this.adaptiveLuminanceMaterial.adaptationRate = e
                    }
                    get distinction() {
                        return console.warn(this.name, "distinction was removed."), 1
                    }
                    set distinction(e) {
                        console.warn(this.name, "distinction was removed.")
                    }
                    update(e, t, n) {
                        this.adaptiveLuminancePass.enabled && (this.luminancePass.render(e, t), this.adaptiveLuminancePass.render(e, null, null, n))
                    }
                    initialize(e, t, n) {
                        this.adaptiveLuminancePass.initialize(e, t, n)
                    }
                },
                J = class extends r.Loader {
                    load(e, t = () => {}, n = () => {}, i = null) {
                        let s = this.manager,
                            a = new r.LoadingManager,
                            o = new r.FileLoader(a);
                        return o.setPath(this.path), o.setResponseType("text"), new Promise((r, l) => {
                            a.onError = e => {
                                s.itemError(e), null !== i ? (i(`Failed to load ${e}`), r()) : l(`Failed to load ${e}`)
                            }, s.itemStart(e), o.load(e, n => {
                                try {
                                    let i = this.parse(n);
                                    s.itemEnd(e), t(i), r(i)
                                } catch (t) {
                                    console.error(t), a.onError(e)
                                }
                            }, n)
                        })
                    }
                    parse(e) {
                        let t = /^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm,
                            n = /TITLE +"([^"]*)"/.exec(e),
                            i = null !== n ? n[1] : null;
                        if (null === (n = /LUT_3D_SIZE +(\d+)/.exec(e))) throw Error("Missing LUT_3D_SIZE information");
                        let s = Number(n[1]),
                            a = new Float32Array(s ** 3 * 4),
                            o = new r.Vector3(0, 0, 0),
                            l = new r.Vector3(1, 1, 1);
                        if (null !== (n = /DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/.exec(e)) && o.set(Number(n[1]), Number(n[2]), Number(n[3])), null !== (n = /DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/.exec(e)) && l.set(Number(n[1]), Number(n[2]), Number(n[3])), o.x > l.x || o.y > l.y || o.z > l.z) throw o.set(0, 0, 0), l.set(1, 1, 1), Error("Invalid input domain");
                        let u = 0;
                        for (; null !== (n = t.exec(e));) a[u++] = Number(n[1]), a[u++] = Number(n[2]), a[u++] = Number(n[3]), a[u++] = 1;
                        let c = new F(a, s);
                        return c.domainMin.copy(o), c.domainMax.copy(l), null !== i && (c.name = i), c
                    }
                };
            r.ShaderMaterial, r.ShaderMaterial;
            var Z = class extends r.ShaderMaterial {
                constructor(e, t, n, i, s = !1) {
                    super({
                        name: "EffectMaterial",
                        defines: {
                            THREE_REVISION: r.REVISION.replace(/\D+/g, ""),
                            DEPTH_PACKING: "0",
                            ENCODE_OUTPUT: "1"
                        },
                        uniforms: {
                            inputBuffer: new r.Uniform(null),
                            depthBuffer: new r.Uniform(null),
                            resolution: new r.Uniform(new r.Vector2),
                            texelSize: new r.Uniform(new r.Vector2),
                            cameraNear: new r.Uniform(.3),
                            cameraFar: new r.Uniform(1e3),
                            aspect: new r.Uniform(1),
                            time: new r.Uniform(0)
                        },
                        blending: r.NoBlending,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        dithering: s
                    }), e && this.setShaderParts(e), t && this.setDefines(t), n && this.setUniforms(n), this.copyCameraSettings(i)
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                get depthBuffer() {
                    return this.uniforms.depthBuffer.value
                }
                set depthBuffer(e) {
                    this.uniforms.depthBuffer.value = e
                }
                get depthPacking() {
                    return Number(this.defines.DEPTH_PACKING)
                }
                set depthPacking(e) {
                    this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                }
                setDepthBuffer(e, t = r.BasicDepthPacking) {
                    this.depthBuffer = e, this.depthPacking = t
                }
                setShaderData(e) {
                    this.setShaderParts(e.shaderParts), this.setDefines(e.defines), this.setUniforms(e.uniforms), this.setExtensions(e.extensions)
                }
                setShaderParts(e) {
                    return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}".replace(A.FRAGMENT_HEAD, e.get(A.FRAGMENT_HEAD) || "").replace(A.FRAGMENT_MAIN_UV, e.get(A.FRAGMENT_MAIN_UV) || "").replace(A.FRAGMENT_MAIN_IMAGE, e.get(A.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}".replace(A.VERTEX_HEAD, e.get(A.VERTEX_HEAD) || "").replace(A.VERTEX_MAIN_SUPPORT, e.get(A.VERTEX_MAIN_SUPPORT) || ""), this.needsUpdate = !0, this
                }
                setDefines(e) {
                    for (let t of e.entries()) this.defines[t[0]] = t[1];
                    return this.needsUpdate = !0, this
                }
                setUniforms(e) {
                    for (let t of e.entries()) this.uniforms[t[0]] = t[1];
                    return this
                }
                setExtensions(e) {
                    for (let t of (this.extensions = {}, e)) this.extensions[t] = !0;
                    return this
                }
                get encodeOutput() {
                    return void 0 !== this.defines.ENCODE_OUTPUT
                }
                set encodeOutput(e) {
                    this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
                }
                isOutputEncodingEnabled(e) {
                    return this.encodeOutput
                }
                setOutputEncodingEnabled(e) {
                    this.encodeOutput = e
                }
                get time() {
                    return this.uniforms.time.value
                }
                set time(e) {
                    this.uniforms.time.value = e
                }
                setDeltaTime(e) {
                    this.uniforms.time.value += e
                }
                adoptCameraSettings(e) {
                    this.copyCameraSettings(e)
                }
                copyCameraSettings(e) {
                    e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof r.PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                }
                setSize(e, t) {
                    let n = this.uniforms;
                    n.resolution.value.set(e, t), n.texelSize.value.set(1 / e, 1 / t), n.aspect.value = e / t
                }
                static get Section() {
                    return A
                }
            };
            r.ShaderMaterial, r.REVISION.replace(/\D+/g, "");
            var $ = 255 / 256;

            function ee(e, t, n) {
                for (let r of t) {
                    let t = "$1" + e + r.charAt(0).toUpperCase() + r.slice(1),
                        i = RegExp("([^\\.])(\\b" + r + "\\b)", "g");
                    for (let e of n.entries()) null !== e[1] && n.set(e[0], e[1].replace(i, t))
                }
            }
            new Float32Array([255 / 256 / 16777216, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]), new Float32Array([$, $ / 256, $ / 65536, 1 / 16777216]);
            var et = class extends a {
                constructor(e, ...t) {
                    super("EffectPass"), this.fullscreenMaterial = new Z(null, null, null, e), this.listener = e => this.handleEvent(e), this.effects = [], this.setEffects(t), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1
                }
                set mainScene(e) {
                    for (let t of this.effects) t.mainScene = e
                }
                set mainCamera(e) {
                    for (let t of (this.fullscreenMaterial.copyCameraSettings(e), this.effects)) t.mainCamera = e
                }
                get encodeOutput() {
                    return this.fullscreenMaterial.encodeOutput
                }
                set encodeOutput(e) {
                    this.fullscreenMaterial.encodeOutput = e
                }
                get dithering() {
                    return this.fullscreenMaterial.dithering
                }
                set dithering(e) {
                    let t = this.fullscreenMaterial;
                    t.dithering = e, t.needsUpdate = !0
                }
                setEffects(e) {
                    for (let e of this.effects) e.removeEventListener("change", this.listener);
                    for (let t of (this.effects = e.sort((e, t) => t.attributes - e.attributes), this.effects)) t.addEventListener("change", this.listener)
                }
                updateMaterial() {
                    let e = new m,
                        t = 0;
                    for (let n of this.effects)
                        if (n.blendMode.blendFunction === y.DST) e.attributes |= n.getAttributes() & g.DEPTH;
                        else if ((e.attributes & n.getAttributes() & g.CONVOLUTION) != 0) throw Error(`Convolution effects cannot be merged (${n.name})`);
                    else ! function(e, t, n) {
                        let i = t.getFragmentShader(),
                            s = t.getVertexShader(),
                            a = void 0 !== i && /mainImage/.test(i),
                            o = void 0 !== i && /mainUv/.test(i);
                        if (n.attributes |= t.getAttributes(), void 0 === i) throw Error(`Missing fragment shader (${t.name})`);
                        if (o && (n.attributes & g.CONVOLUTION) != 0) throw Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);
                        if (a || o) {
                            let l = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
                                u = n.shaderParts,
                                c = u.get(A.FRAGMENT_HEAD) || "",
                                h = u.get(A.FRAGMENT_MAIN_UV) || "",
                                d = u.get(A.FRAGMENT_MAIN_IMAGE) || "",
                                f = u.get(A.VERTEX_HEAD) || "",
                                p = u.get(A.VERTEX_MAIN_SUPPORT) || "",
                                m = new Set,
                                v = new Set;
                            if (o && (h += `	${e}MainUv(UV);
`, n.uvTransformation = !0), null !== s && /mainSupport/.test(s)) {
                                for (let t of (p += `	${e}MainSupport(` + (/mainSupport *\([\w\s]*?uv\s*?\)/.test(s) ? "vUv);\n" : ");\n"), s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)))
                                    for (let e of t[1].split(/\s*,\s*/)) n.varyings.add(e), m.add(e), v.add(e);
                                for (let e of s.matchAll(l)) v.add(e[1])
                            }
                            for (let e of i.matchAll(l)) v.add(e[1]);
                            for (let e of t.defines.keys()) v.add(e.replace(/\([\w\s,]*\)/g, ""));
                            for (let e of t.uniforms.keys()) v.add(e);
                            v.delete("while"), v.delete("for"), v.delete("if"), t.uniforms.forEach((t, r) => n.uniforms.set(e + r.charAt(0).toUpperCase() + r.slice(1), t)), t.defines.forEach((t, r) => n.defines.set(e + r.charAt(0).toUpperCase() + r.slice(1), t));
                            let y = new Map([
                                ["fragment", i],
                                ["vertex", s]
                            ]);
                            ee(e, v, n.defines), ee(e, v, y), i = y.get("fragment"), s = y.get("vertex");
                            let x = t.blendMode;
                            if (n.blendModes.set(x.blendFunction, x), a) {
                                null !== t.inputColorSpace && t.inputColorSpace !== n.colorSpace && (d += t.inputColorSpace === r.SRGBColorSpace ? "color0 = sRGBTransferOETF(color0);\n	" : "color0 = sRGBToLinear(color0);\n	"), t.outputColorSpace !== r.NoColorSpace ? n.colorSpace = t.outputColorSpace : null !== t.inputColorSpace && (n.colorSpace = t.inputColorSpace), d += `${e}MainImage(color0, UV, `, (n.attributes & g.DEPTH) != 0 && /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/.test(i) && (d += "depth, ", n.readDepth = !0), d += "color1);\n	";
                                let s = e + "BlendOpacity";
                                n.uniforms.set(s, x.opacity), d += `color0 = blend${x.blendFunction}(color0, color1, ${s});

	`, c += `uniform float ${s};

`
                            }
                            if (c += i + "\n", null !== s && (f += s + "\n"), u.set(A.FRAGMENT_HEAD, c), u.set(A.FRAGMENT_MAIN_UV, h), u.set(A.FRAGMENT_MAIN_IMAGE, d), u.set(A.VERTEX_HEAD, f), u.set(A.VERTEX_MAIN_SUPPORT, p), null !== t.extensions)
                                for (let e of t.extensions) n.extensions.add(e)
                        } else throw Error(`Could not find mainImage or mainUv function (${t.name})`)
                    }("e" + t++, n, e);
                    let n = e.shaderParts.get(A.FRAGMENT_HEAD),
                        i = e.shaderParts.get(A.FRAGMENT_MAIN_IMAGE),
                        s = e.shaderParts.get(A.FRAGMENT_MAIN_UV),
                        a = /\bblend\b/g;
                    for (let t of e.blendModes.values()) n += t.getShaderCode().replace(a, `blend${t.blendFunction}`) + "\n";
                    for (let [t, a] of ((e.attributes & g.DEPTH) != 0 ? (e.readDepth && (i = "float depth = readDepth(UV);\n\n	" + i), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1, e.colorSpace === r.SRGBColorSpace && (i += "color0 = sRGBToLinear(color0);\n	"), e.uvTransformation ? (s = "vec2 transformedUv = vUv;\n" + s, e.defines.set("UV", "transformedUv")) : e.defines.set("UV", "vUv"), e.shaderParts.set(A.FRAGMENT_HEAD, n), e.shaderParts.set(A.FRAGMENT_MAIN_IMAGE, i), e.shaderParts.set(A.FRAGMENT_MAIN_UV, s), e.shaderParts)) null !== a && e.shaderParts.set(t, a.trim().replace(/^#/, "\n#"));
                    this.skipRendering = 0 === t, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(e)
                }
                recompile() {
                    this.updateMaterial()
                }
                getDepthTexture() {
                    return this.fullscreenMaterial.depthBuffer
                }
                setDepthTexture(e, t = r.BasicDepthPacking) {
                    for (let n of (this.fullscreenMaterial.depthBuffer = e, this.fullscreenMaterial.depthPacking = t, this.effects)) n.setDepthTexture(e, t)
                }
                render(e, t, n, r, i) {
                    for (let n of this.effects) n.update(e, t, r);
                    if (!this.skipRendering || this.renderToScreen) {
                        let i = this.fullscreenMaterial;
                        i.inputBuffer = t.texture, i.time += r * this.timeScale, e.setRenderTarget(this.renderToScreen ? null : n), e.render(this.scene, this.camera)
                    }
                }
                setSize(e, t) {
                    for (let n of (this.fullscreenMaterial.setSize(e, t), this.effects)) n.setSize(e, t)
                }
                initialize(e, t, n) {
                    for (let r of (this.renderer = e, this.effects)) r.initialize(e, t, n);
                    this.updateMaterial(), void 0 !== n && n !== r.UnsignedByteType && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                }
                dispose() {
                    for (let e of (super.dispose(), this.effects)) e.removeEventListener("change", this.listener), e.dispose()
                }
                handleEvent(e) {
                    "change" === e.type && this.recompile()
                }
            };

            function en(e, t, n, r) {
                var i;
                return (i = e + (t - e) * .75) + (n + (r - n) * .75 - i) * .875
            }
            new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array(2), new Float32Array(2), new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]), en(0, 0, 0, 0), new Float32Array([0, 0, 0, 0]), en(0, 0, 0, 1), new Float32Array([0, 0, 0, 1]), en(0, 0, 1, 0), new Float32Array([0, 0, 1, 0]), en(0, 0, 1, 1), new Float32Array([0, 0, 1, 1]), en(0, 1, 0, 0), new Float32Array([0, 1, 0, 0]), en(0, 1, 0, 1), new Float32Array([0, 1, 0, 1]), en(0, 1, 1, 0), new Float32Array([0, 1, 1, 0]), en(0, 1, 1, 1), new Float32Array([0, 1, 1, 1]), en(1, 0, 0, 0), new Float32Array([1, 0, 0, 0]), en(1, 0, 0, 1), new Float32Array([1, 0, 0, 1]), en(1, 0, 1, 0), new Float32Array([1, 0, 1, 0]), en(1, 0, 1, 1), new Float32Array([1, 0, 1, 1]), en(1, 1, 0, 0), new Float32Array([1, 1, 0, 0]), en(1, 1, 0, 1), new Float32Array([1, 1, 0, 1]), en(1, 1, 1, 0), new Float32Array([1, 1, 1, 0]), en(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])
        },
        9892: function(e, t, n) {
            "use strict";
            let r, i, s, a, o;
            n.r(t), n.d(t, {
                ACESFilmicToneMapping: function() {
                    return eu
                },
                AddEquation: function() {
                    return M
                },
                AddOperation: function() {
                    return ei
                },
                AdditiveAnimationBlendMode: function() {
                    return tU
                },
                AdditiveBlending: function() {
                    return w
                },
                AgXToneMapping: function() {
                    return eh
                },
                AlphaFormat: function() {
                    return eW
                },
                AlwaysCompare: function() {
                    return ng
                },
                AlwaysDepth: function() {
                    return q
                },
                AlwaysStencilFunc: function() {
                    return no
                },
                AmbientLight: function() {
                    return ha
                },
                AnimationAction: function() {
                    return hK
                },
                AnimationClip: function() {
                    return cG
                },
                AnimationLoader: function() {
                    return cq
                },
                AnimationMixer: function() {
                    return hZ
                },
                AnimationObjectGroup: function() {
                    return hq
                },
                AnimationUtils: function() {
                    return cM
                },
                ArcCurve: function() {
                    return uh
                },
                ArrayCamera: function() {
                    return oR
                },
                ArrowHelper: function() {
                    return dL
                },
                AttachedBindMode: function() {
                    return ef
                },
                Audio: function() {
                    return hD
                },
                AudioAnalyser: function() {
                    return hF
                },
                AudioContext: function() {
                    return hy
                },
                AudioListener: function() {
                    return hR
                },
                AudioLoader: function() {
                    return hx
                },
                AxesHelper: function() {
                    return dP
                },
                BackSide: function() {
                    return x
                },
                BasicDepthPacking: function() {
                    return tG
                },
                BasicShadowMap: function() {
                    return g
                },
                BatchedMesh: function() {
                    return lj
                },
                Bone: function() {
                    return lp
                },
                BooleanKeyframeTrack: function() {
                    return cP
                },
                Box2: function() {
                    return dn
                },
                Box3: function() {
                    return rh
                },
                Box3Helper: function() {
                    return dB
                },
                BoxGeometry: function() {
                    return se
                },
                BoxHelper: function() {
                    return dT
                },
                BufferAttribute: function() {
                    return iL
                },
                BufferGeometry: function() {
                    return iK
                },
                BufferGeometryLoader: function() {
                    return hf
                },
                ByteType: function() {
                    return eO
                },
                Cache: function() {
                    return cz
                },
                Camera: function() {
                    return sa
                },
                CameraHelper: function() {
                    return dS
                },
                CanvasTexture: function() {
                    return ul
                },
                CapsuleGeometry: function() {
                    return uD
                },
                CatmullRomCurve3: function() {
                    return um
                },
                CineonToneMapping: function() {
                    return el
                },
                CircleGeometry: function() {
                    return uL
                },
                ClampToEdgeWrapping: function() {
                    return e_
                },
                Clock: function() {
                    return hC
                },
                Color: function() {
                    return i_
                },
                ColorKeyframeTrack: function() {
                    return cO
                },
                ColorManagement: function() {
                    return n1
                },
                CompressedArrayTexture: function() {
                    return ua
                },
                CompressedCubeTexture: function() {
                    return uo
                },
                CompressedTexture: function() {
                    return us
                },
                CompressedTextureLoader: function() {
                    return cK
                },
                ConeGeometry: function() {
                    return uO
                },
                ConstantAlphaFactor: function() {
                    return W
                },
                ConstantColorFactor: function() {
                    return V
                },
                Controls: function() {
                    return dN
                },
                CubeCamera: function() {
                    return sh
                },
                CubeReflectionMapping: function() {
                    return eA
                },
                CubeRefractionMapping: function() {
                    return em
                },
                CubeTexture: function() {
                    return sd
                },
                CubeTextureLoader: function() {
                    return cZ
                },
                CubeUVReflectionMapping: function() {
                    return ex
                },
                CubicBezierCurve: function() {
                    return uE
                },
                CubicBezierCurve3: function() {
                    return u_
                },
                CubicInterpolant: function() {
                    return cB
                },
                CullFaceBack: function() {
                    return d
                },
                CullFaceFront: function() {
                    return f
                },
                CullFaceFrontBack: function() {
                    return p
                },
                CullFaceNone: function() {
                    return h
                },
                Curve: function() {
                    return uu
                },
                CurvePath: function() {
                    return uT
                },
                CustomBlending: function() {
                    return I
                },
                CustomToneMapping: function() {
                    return ec
                },
                CylinderGeometry: function() {
                    return uP
                },
                Cylindrical: function() {
                    return h7
                },
                Data3DTexture: function() {
                    return rs
                },
                DataArrayTexture: function() {
                    return rr
                },
                DataTexture: function() {
                    return lg
                },
                DataTextureLoader: function() {
                    return c$
                },
                DataUtils: function() {
                    return iB
                },
                DecrementStencilOp: function() {
                    return t6
                },
                DecrementWrapStencilOp: function() {
                    return t9
                },
                DefaultLoadingManager: function() {
                    return cV
                },
                DepthFormat: function() {
                    return eJ
                },
                DepthStencilFormat: function() {
                    return eZ
                },
                DepthTexture: function() {
                    return s6
                },
                DetachedBindMode: function() {
                    return ep
                },
                DirectionalLight: function() {
                    return hs
                },
                DirectionalLightHelper: function() {
                    return db
                },
                DiscreteInterpolant: function() {
                    return cD
                },
                DisplayP3ColorSpace: function() {
                    return tK
                },
                DodecahedronGeometry: function() {
                    return uU
                },
                DoubleSide: function() {
                    return E
                },
                DstAlphaFactor: function() {
                    return k
                },
                DstColorFactor: function() {
                    return G
                },
                DynamicCopyUsage: function() {
                    return nb
                },
                DynamicDrawUsage: function() {
                    return nm
                },
                DynamicReadUsage: function() {
                    return nx
                },
                EdgesGeometry: function() {
                    return uz
                },
                EllipseCurve: function() {
                    return uc
                },
                EqualCompare: function() {
                    return nc
                },
                EqualDepth: function() {
                    return Z
                },
                EqualStencilFunc: function() {
                    return nn
                },
                EquirectangularReflectionMapping: function() {
                    return ev
                },
                EquirectangularRefractionMapping: function() {
                    return ey
                },
                Euler: function() {
                    return rX
                },
                EventDispatcher: function() {
                    return nT
                },
                ExtrudeGeometry: function() {
                    return u7
                },
                FileLoader: function() {
                    return cX
                },
                Float16BufferAttribute: function() {
                    return iG
                },
                Float32BufferAttribute: function() {
                    return iz
                },
                FloatType: function() {
                    return eQ
                },
                Fog: function() {
                    return oj
                },
                FogExp2: function() {
                    return oV
                },
                FramebufferTexture: function() {
                    return ui
                },
                FrontSide: function() {
                    return y
                },
                Frustum: function() {
                    return sx
                },
                GLBufferAttribute: function() {
                    return h3
                },
                GLSL1: function() {
                    return nC
                },
                GLSL3: function() {
                    return nS
                },
                GreaterCompare: function() {
                    return nd
                },
                GreaterDepth: function() {
                    return ee
                },
                GreaterEqualCompare: function() {
                    return np
                },
                GreaterEqualDepth: function() {
                    return $
                },
                GreaterEqualStencilFunc: function() {
                    return na
                },
                GreaterStencilFunc: function() {
                    return ni
                },
                GridHelper: function() {
                    return dv
                },
                Group: function() {
                    return oD
                },
                HalfFloatType: function() {
                    return eG
                },
                HemisphereLight: function() {
                    return c2
                },
                HemisphereLightHelper: function() {
                    return dm
                },
                IcosahedronGeometry: function() {
                    return ct
                },
                ImageBitmapLoader: function() {
                    return hv
                },
                ImageLoader: function() {
                    return cJ
                },
                ImageUtils: function() {
                    return n4
                },
                IncrementStencilOp: function() {
                    return t5
                },
                IncrementWrapStencilOp: function() {
                    return t8
                },
                InstancedBufferAttribute: function() {
                    return ly
                },
                InstancedBufferGeometry: function() {
                    return hd
                },
                InstancedInterleavedBuffer: function() {
                    return h2
                },
                InstancedMesh: function() {
                    return lI
                },
                Int16BufferAttribute: function() {
                    return iU
                },
                Int32BufferAttribute: function() {
                    return ik
                },
                Int8BufferAttribute: function() {
                    return iP
                },
                IntType: function() {
                    return eF
                },
                InterleavedBuffer: function() {
                    return oY
                },
                InterleavedBufferAttribute: function() {
                    return oq
                },
                Interpolant: function() {
                    return cT
                },
                InterpolateDiscrete: function() {
                    return tB
                },
                InterpolateLinear: function() {
                    return tR
                },
                InterpolateSmooth: function() {
                    return tD
                },
                InvertStencilOp: function() {
                    return t7
                },
                KeepStencilOp: function() {
                    return t3
                },
                KeyframeTrack: function() {
                    return cL
                },
                LOD: function() {
                    return lr
                },
                LatheGeometry: function() {
                    return uR
                },
                Layers: function() {
                    return rq
                },
                LessCompare: function() {
                    return nu
                },
                LessDepth: function() {
                    return K
                },
                LessEqualCompare: function() {
                    return nh
                },
                LessEqualDepth: function() {
                    return J
                },
                LessEqualStencilFunc: function() {
                    return nr
                },
                LessStencilFunc: function() {
                    return nt
                },
                Light: function() {
                    return c1
                },
                LightProbe: function() {
                    return hu
                },
                Line: function() {
                    return l0
                },
                Line3: function() {
                    return ds
                },
                LineBasicMaterial: function() {
                    return lW
                },
                LineCurve: function() {
                    return ub
                },
                LineCurve3: function() {
                    return uw
                },
                LineDashedMaterial: function() {
                    return c_
                },
                LineLoop: function() {
                    return l5
                },
                LineSegments: function() {
                    return l4
                },
                LinearDisplayP3ColorSpace: function() {
                    return tJ
                },
                LinearFilter: function() {
                    return eT
                },
                LinearInterpolant: function() {
                    return cR
                },
                LinearMipMapLinearFilter: function() {
                    return eL
                },
                LinearMipMapNearestFilter: function() {
                    return eR
                },
                LinearMipmapLinearFilter: function() {
                    return eD
                },
                LinearMipmapNearestFilter: function() {
                    return eB
                },
                LinearSRGBColorSpace: function() {
                    return tq
                },
                LinearToneMapping: function() {
                    return ea
                },
                LinearTransfer: function() {
                    return tZ
                },
                Loader: function() {
                    return cj
                },
                LoaderUtils: function() {
                    return hh
                },
                LoadingManager: function() {
                    return cH
                },
                LoopOnce: function() {
                    return tI
                },
                LoopPingPong: function() {
                    return tT
                },
                LoopRepeat: function() {
                    return tM
                },
                LuminanceAlphaFormat: function() {
                    return eK
                },
                LuminanceFormat: function() {
                    return eq
                },
                MOUSE: function() {
                    return u
                },
                Material: function() {
                    return iC
                },
                MaterialLoader: function() {
                    return hc
                },
                MathUtils: function() {
                    return nQ
                },
                Matrix2: function() {
                    return de
                },
                Matrix3: function() {
                    return nz
                },
                Matrix4: function() {
                    return rF
                },
                MaxEquation: function() {
                    return D
                },
                Mesh: function() {
                    return i9
                },
                MeshBasicMaterial: function() {
                    return iS
                },
                MeshDepthMaterial: function() {
                    return o_
                },
                MeshDistanceMaterial: function() {
                    return ob
                },
                MeshLambertMaterial: function() {
                    return cx
                },
                MeshMatcapMaterial: function() {
                    return cE
                },
                MeshNormalMaterial: function() {
                    return cy
                },
                MeshPhongMaterial: function() {
                    return cm
                },
                MeshPhysicalMaterial: function() {
                    return cA
                },
                MeshStandardMaterial: function() {
                    return cg
                },
                MeshToonMaterial: function() {
                    return cv
                },
                MinEquation: function() {
                    return R
                },
                MirroredRepeatWrapping: function() {
                    return eb
                },
                MixOperation: function() {
                    return er
                },
                MultiplyBlending: function() {
                    return S
                },
                MultiplyOperation: function() {
                    return en
                },
                NearestFilter: function() {
                    return ew
                },
                NearestMipMapLinearFilter: function() {
                    return eM
                },
                NearestMipMapNearestFilter: function() {
                    return eS
                },
                NearestMipmapLinearFilter: function() {
                    return eI
                },
                NearestMipmapNearestFilter: function() {
                    return eC
                },
                NeutralToneMapping: function() {
                    return ed
                },
                NeverCompare: function() {
                    return nl
                },
                NeverDepth: function() {
                    return X
                },
                NeverStencilFunc: function() {
                    return ne
                },
                NoBlending: function() {
                    return _
                },
                NoColorSpace: function() {
                    return tY
                },
                NoToneMapping: function() {
                    return es
                },
                NormalAnimationBlendMode: function() {
                    return tN
                },
                NormalBlending: function() {
                    return b
                },
                NotEqualCompare: function() {
                    return nf
                },
                NotEqualDepth: function() {
                    return et
                },
                NotEqualStencilFunc: function() {
                    return ns
                },
                NumberKeyframeTrack: function() {
                    return cN
                },
                Object3D: function() {
                    return it
                },
                ObjectLoader: function() {
                    return hp
                },
                ObjectSpaceNormalMap: function() {
                    return tW
                },
                OctahedronGeometry: function() {
                    return cn
                },
                OneFactor: function() {
                    return P
                },
                OneMinusConstantAlphaFactor: function() {
                    return Y
                },
                OneMinusConstantColorFactor: function() {
                    return j
                },
                OneMinusDstAlphaFactor: function() {
                    return Q
                },
                OneMinusDstColorFactor: function() {
                    return z
                },
                OneMinusSrcAlphaFactor: function() {
                    return F
                },
                OneMinusSrcColorFactor: function() {
                    return N
                },
                OrthographicCamera: function() {
                    return sN
                },
                P3Primaries: function() {
                    return t1
                },
                PCFShadowMap: function() {
                    return A
                },
                PCFSoftShadowMap: function() {
                    return m
                },
                PMREMGenerator: function() {
                    return sY
                },
                Path: function() {
                    return uB
                },
                PerspectiveCamera: function() {
                    return sc
                },
                Plane: function() {
                    return sm
                },
                PlaneGeometry: function() {
                    return sb
                },
                PlaneHelper: function() {
                    return dR
                },
                PointLight: function() {
                    return hr
                },
                PointLightHelper: function() {
                    return df
                },
                Points: function() {
                    return ut
                },
                PointsMaterial: function() {
                    return l6
                },
                PolarGridHelper: function() {
                    return dy
                },
                PolyhedronGeometry: function() {
                    return uN
                },
                PositionalAudio: function() {
                    return hU
                },
                PropertyBinding: function() {
                    return hX
                },
                PropertyMixer: function() {
                    return hk
                },
                QuadraticBezierCurve: function() {
                    return uC
                },
                QuadraticBezierCurve3: function() {
                    return uS
                },
                Quaternion: function() {
                    return ro
                },
                QuaternionKeyframeTrack: function() {
                    return cF
                },
                QuaternionLinearInterpolant: function() {
                    return cU
                },
                RED_GREEN_RGTC2_Format: function() {
                    return tC
                },
                RED_RGTC1_Format: function() {
                    return tb
                },
                REVISION: function() {
                    return l
                },
                RGBADepthPacking: function() {
                    return tz
                },
                RGBAFormat: function() {
                    return eX
                },
                RGBAIntegerFormat: function() {
                    return e4
                },
                RGBA_ASTC_10x10_Format: function() {
                    return tm
                },
                RGBA_ASTC_10x5_Format: function() {
                    return tp
                },
                RGBA_ASTC_10x6_Format: function() {
                    return tg
                },
                RGBA_ASTC_10x8_Format: function() {
                    return tA
                },
                RGBA_ASTC_12x10_Format: function() {
                    return tv
                },
                RGBA_ASTC_12x12_Format: function() {
                    return ty
                },
                RGBA_ASTC_4x4_Format: function() {
                    return ta
                },
                RGBA_ASTC_5x4_Format: function() {
                    return to
                },
                RGBA_ASTC_5x5_Format: function() {
                    return tl
                },
                RGBA_ASTC_6x5_Format: function() {
                    return tu
                },
                RGBA_ASTC_6x6_Format: function() {
                    return tc
                },
                RGBA_ASTC_8x5_Format: function() {
                    return th
                },
                RGBA_ASTC_8x6_Format: function() {
                    return td
                },
                RGBA_ASTC_8x8_Format: function() {
                    return tf
                },
                RGBA_BPTC_Format: function() {
                    return tx
                },
                RGBA_ETC2_EAC_Format: function() {
                    return ts
                },
                RGBA_PVRTC_2BPPV1_Format: function() {
                    return tn
                },
                RGBA_PVRTC_4BPPV1_Format: function() {
                    return tt
                },
                RGBA_S3TC_DXT1_Format: function() {
                    return e6
                },
                RGBA_S3TC_DXT3_Format: function() {
                    return e8
                },
                RGBA_S3TC_DXT5_Format: function() {
                    return e9
                },
                RGBDepthPacking: function() {
                    return tH
                },
                RGBFormat: function() {
                    return eY
                },
                RGBIntegerFormat: function() {
                    return e3
                },
                RGB_BPTC_SIGNED_Format: function() {
                    return tE
                },
                RGB_BPTC_UNSIGNED_Format: function() {
                    return t_
                },
                RGB_ETC1_Format: function() {
                    return tr
                },
                RGB_ETC2_Format: function() {
                    return ti
                },
                RGB_PVRTC_2BPPV1_Format: function() {
                    return te
                },
                RGB_PVRTC_4BPPV1_Format: function() {
                    return e7
                },
                RGB_S3TC_DXT1_Format: function() {
                    return e5
                },
                RGDepthPacking: function() {
                    return tV
                },
                RGFormat: function() {
                    return e1
                },
                RGIntegerFormat: function() {
                    return e2
                },
                RawShaderMaterial: function() {
                    return cp
                },
                Ray: function() {
                    return rU
                },
                Raycaster: function() {
                    return h5
                },
                Rec709Primaries: function() {
                    return t0
                },
                RectAreaLight: function() {
                    return ho
                },
                RedFormat: function() {
                    return e$
                },
                RedIntegerFormat: function() {
                    return e0
                },
                ReinhardToneMapping: function() {
                    return eo
                },
                RenderTarget: function() {
                    return rt
                },
                RepeatWrapping: function() {
                    return eE
                },
                ReplaceStencilOp: function() {
                    return t4
                },
                ReverseSubtractEquation: function() {
                    return B
                },
                RingGeometry: function() {
                    return cr
                },
                SIGNED_RED_GREEN_RGTC2_Format: function() {
                    return tS
                },
                SIGNED_RED_RGTC1_Format: function() {
                    return tw
                },
                SRGBColorSpace: function() {
                    return tX
                },
                SRGBTransfer: function() {
                    return t$
                },
                Scene: function() {
                    return oW
                },
                ShaderChunk: function() {
                    return sw
                },
                ShaderLib: function() {
                    return sS
                },
                ShaderMaterial: function() {
                    return ss
                },
                ShadowMaterial: function() {
                    return cf
                },
                Shape: function() {
                    return uH
                },
                ShapeGeometry: function() {
                    return ci
                },
                ShapePath: function() {
                    return dO
                },
                ShapeUtils: function() {
                    return u6
                },
                ShortType: function() {
                    return eN
                },
                Skeleton: function() {
                    return lv
                },
                SkeletonHelper: function() {
                    return dd
                },
                SkinnedMesh: function() {
                    return lf
                },
                Source: function() {
                    return n6
                },
                Sphere: function() {
                    return rT
                },
                SphereGeometry: function() {
                    return cs
                },
                Spherical: function() {
                    return h9
                },
                SphericalHarmonics3: function() {
                    return hl
                },
                SplineCurve: function() {
                    return uI
                },
                SpotLight: function() {
                    return c9
                },
                SpotLightHelper: function() {
                    return dl
                },
                Sprite: function() {
                    return o7
                },
                SpriteMaterial: function() {
                    return oK
                },
                SrcAlphaFactor: function() {
                    return U
                },
                SrcAlphaSaturateFactor: function() {
                    return H
                },
                SrcColorFactor: function() {
                    return O
                },
                StaticCopyUsage: function() {
                    return n_
                },
                StaticDrawUsage: function() {
                    return nA
                },
                StaticReadUsage: function() {
                    return ny
                },
                StereoCamera: function() {
                    return hw
                },
                StreamCopyUsage: function() {
                    return nw
                },
                StreamDrawUsage: function() {
                    return nv
                },
                StreamReadUsage: function() {
                    return nE
                },
                StringKeyframeTrack: function() {
                    return ck
                },
                SubtractEquation: function() {
                    return T
                },
                SubtractiveBlending: function() {
                    return C
                },
                TOUCH: function() {
                    return c
                },
                TangentSpaceNormalMap: function() {
                    return tj
                },
                TetrahedronGeometry: function() {
                    return ca
                },
                Texture: function() {
                    return n7
                },
                TextureLoader: function() {
                    return c0
                },
                TextureUtils: function() {
                    return oM
                },
                TorusGeometry: function() {
                    return co
                },
                TorusKnotGeometry: function() {
                    return cl
                },
                Triangle: function() {
                    return im
                },
                TriangleFanDrawMode: function() {
                    return tQ
                },
                TriangleStripDrawMode: function() {
                    return tk
                },
                TrianglesDrawMode: function() {
                    return tF
                },
                TubeGeometry: function() {
                    return cu
                },
                UVMapping: function() {
                    return eg
                },
                Uint16BufferAttribute: function() {
                    return iF
                },
                Uint32BufferAttribute: function() {
                    return iQ
                },
                Uint8BufferAttribute: function() {
                    return iO
                },
                Uint8ClampedBufferAttribute: function() {
                    return iN
                },
                Uniform: function() {
                    return h$
                },
                UniformsGroup: function() {
                    return h1
                },
                UniformsLib: function() {
                    return sC
                },
                UniformsUtils: function() {
                    return si
                },
                UnsignedByteType: function() {
                    return eP
                },
                UnsignedInt248Type: function() {
                    return eV
                },
                UnsignedInt5999Type: function() {
                    return ej
                },
                UnsignedIntType: function() {
                    return ek
                },
                UnsignedShort4444Type: function() {
                    return ez
                },
                UnsignedShort5551Type: function() {
                    return eH
                },
                UnsignedShortType: function() {
                    return eU
                },
                VSMShadowMap: function() {
                    return v
                },
                Vector2: function() {
                    return nG
                },
                Vector3: function() {
                    return rl
                },
                Vector4: function() {
                    return re
                },
                VectorKeyframeTrack: function() {
                    return cQ
                },
                VideoTexture: function() {
                    return ur
                },
                WebGL3DRenderTarget: function() {
                    return ra
                },
                WebGLArrayRenderTarget: function() {
                    return ri
                },
                WebGLCoordinateSystem: function() {
                    return nI
                },
                WebGLCubeRenderTarget: function() {
                    return sf
                },
                WebGLMultipleRenderTargets: function() {
                    return dU
                },
                WebGLRenderTarget: function() {
                    return rn
                },
                WebGLRenderer: function() {
                    return oH
                },
                WebGLUtils: function() {
                    return oB
                },
                WebGPUCoordinateSystem: function() {
                    return nM
                },
                WireframeGeometry: function() {
                    return cc
                },
                WrapAroundEnding: function() {
                    return tO
                },
                ZeroCurvatureEnding: function() {
                    return tL
                },
                ZeroFactor: function() {
                    return L
                },
                ZeroSlopeEnding: function() {
                    return tP
                },
                ZeroStencilOp: function() {
                    return t2
                },
                createCanvasElement: function() {
                    return nX
                }
            });
            let l = "169",
                u = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                },
                c = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                h = 0,
                d = 1,
                f = 2,
                p = 3,
                g = 0,
                A = 1,
                m = 2,
                v = 3,
                y = 0,
                x = 1,
                E = 2,
                _ = 0,
                b = 1,
                w = 2,
                C = 3,
                S = 4,
                I = 5,
                M = 100,
                T = 101,
                B = 102,
                R = 103,
                D = 104,
                L = 200,
                P = 201,
                O = 202,
                N = 203,
                U = 204,
                F = 205,
                k = 206,
                Q = 207,
                G = 208,
                z = 209,
                H = 210,
                V = 211,
                j = 212,
                W = 213,
                Y = 214,
                X = 0,
                q = 1,
                K = 2,
                J = 3,
                Z = 4,
                $ = 5,
                ee = 6,
                et = 7,
                en = 0,
                er = 1,
                ei = 2,
                es = 0,
                ea = 1,
                eo = 2,
                el = 3,
                eu = 4,
                ec = 5,
                eh = 6,
                ed = 7,
                ef = "attached",
                ep = "detached",
                eg = 300,
                eA = 301,
                em = 302,
                ev = 303,
                ey = 304,
                ex = 306,
                eE = 1e3,
                e_ = 1001,
                eb = 1002,
                ew = 1003,
                eC = 1004,
                eS = 1004,
                eI = 1005,
                eM = 1005,
                eT = 1006,
                eB = 1007,
                eR = 1007,
                eD = 1008,
                eL = 1008,
                eP = 1009,
                eO = 1010,
                eN = 1011,
                eU = 1012,
                eF = 1013,
                ek = 1014,
                eQ = 1015,
                eG = 1016,
                ez = 1017,
                eH = 1018,
                eV = 1020,
                ej = 35902,
                eW = 1021,
                eY = 1022,
                eX = 1023,
                eq = 1024,
                eK = 1025,
                eJ = 1026,
                eZ = 1027,
                e$ = 1028,
                e0 = 1029,
                e1 = 1030,
                e2 = 1031,
                e3 = 1032,
                e4 = 1033,
                e5 = 33776,
                e6 = 33777,
                e8 = 33778,
                e9 = 33779,
                e7 = 35840,
                te = 35841,
                tt = 35842,
                tn = 35843,
                tr = 36196,
                ti = 37492,
                ts = 37496,
                ta = 37808,
                to = 37809,
                tl = 37810,
                tu = 37811,
                tc = 37812,
                th = 37813,
                td = 37814,
                tf = 37815,
                tp = 37816,
                tg = 37817,
                tA = 37818,
                tm = 37819,
                tv = 37820,
                ty = 37821,
                tx = 36492,
                tE = 36494,
                t_ = 36495,
                tb = 36283,
                tw = 36284,
                tC = 36285,
                tS = 36286,
                tI = 2200,
                tM = 2201,
                tT = 2202,
                tB = 2300,
                tR = 2301,
                tD = 2302,
                tL = 2400,
                tP = 2401,
                tO = 2402,
                tN = 2500,
                tU = 2501,
                tF = 0,
                tk = 1,
                tQ = 2,
                tG = 3200,
                tz = 3201,
                tH = 3202,
                tV = 3203,
                tj = 0,
                tW = 1,
                tY = "",
                tX = "srgb",
                tq = "srgb-linear",
                tK = "display-p3",
                tJ = "display-p3-linear",
                tZ = "linear",
                t$ = "srgb",
                t0 = "rec709",
                t1 = "p3",
                t2 = 0,
                t3 = 7680,
                t4 = 7681,
                t5 = 7682,
                t6 = 7683,
                t8 = 34055,
                t9 = 34056,
                t7 = 5386,
                ne = 512,
                nt = 513,
                nn = 514,
                nr = 515,
                ni = 516,
                ns = 517,
                na = 518,
                no = 519,
                nl = 512,
                nu = 513,
                nc = 514,
                nh = 515,
                nd = 516,
                nf = 517,
                np = 518,
                ng = 519,
                nA = 35044,
                nm = 35048,
                nv = 35040,
                ny = 35045,
                nx = 35049,
                nE = 35041,
                n_ = 35046,
                nb = 35050,
                nw = 35042,
                nC = "100",
                nS = "300 es",
                nI = 2e3,
                nM = 2001;
            class nT {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    let n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return !1;
                    let n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return;
                    let n = this._listeners[e];
                    if (void 0 !== n) {
                        let e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return;
                    let t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        let n = t.slice(0);
                        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
                        e.target = null
                    }
                }
            }
            let nB = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
                nR = 1234567,
                nD = Math.PI / 180,
                nL = 180 / Math.PI;

            function nP() {
                let e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (nB[255 & e] + nB[e >> 8 & 255] + nB[e >> 16 & 255] + nB[e >> 24 & 255] + "-" + nB[255 & t] + nB[t >> 8 & 255] + "-" + nB[t >> 16 & 15 | 64] + nB[t >> 24 & 255] + "-" + nB[63 & n | 128] + nB[n >> 8 & 255] + "-" + nB[n >> 16 & 255] + nB[n >> 24 & 255] + nB[255 & r] + nB[r >> 8 & 255] + nB[r >> 16 & 255] + nB[r >> 24 & 255]).toLowerCase()
            }

            function nO(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }

            function nN(e, t) {
                return (e % t + t) % t
            }

            function nU(e, t, n) {
                return (1 - n) * e + n * t
            }

            function nF(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return e / 4294967295;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int32Array:
                        return Math.max(e / 2147483647, -1);
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw Error("Invalid component type.")
                }
            }

            function nk(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return Math.round(4294967295 * e);
                    case Uint16Array:
                        return Math.round(65535 * e);
                    case Uint8Array:
                        return Math.round(255 * e);
                    case Int32Array:
                        return Math.round(2147483647 * e);
                    case Int16Array:
                        return Math.round(32767 * e);
                    case Int8Array:
                        return Math.round(127 * e);
                    default:
                        throw Error("Invalid component type.")
                }
            }
            let nQ = {
                DEG2RAD: nD,
                RAD2DEG: nL,
                generateUUID: nP,
                clamp: nO,
                euclideanModulo: nN,
                mapLinear: function(e, t, n, r, i) {
                    return r + (e - t) * (i - r) / (n - t)
                },
                inverseLerp: function(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                },
                lerp: nU,
                damp: function(e, t, n, r) {
                    return nU(e, t, 1 - Math.exp(-n * r))
                },
                pingpong: function(e, t = 1) {
                    return t - Math.abs(nN(e, 2 * t) - t)
                },
                smoothstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    void 0 !== e && (nR = e);
                    let t = nR += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, 1 | t), (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 4294967296
                },
                degToRad: function(e) {
                    return e * nD
                },
                radToDeg: function(e) {
                    return e * nL
                },
                isPowerOfTwo: function(e) {
                    return (e & e - 1) == 0 && 0 !== e
                },
                ceilPowerOfTwo: function(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                },
                floorPowerOfTwo: function(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(e, t, n, r, i) {
                    let s = Math.cos,
                        a = Math.sin,
                        o = s(n / 2),
                        l = a(n / 2),
                        u = s((t + r) / 2),
                        c = a((t + r) / 2),
                        h = s((t - r) / 2),
                        d = a((t - r) / 2),
                        f = s((r - t) / 2),
                        p = a((r - t) / 2);
                    switch (i) {
                        case "XYX":
                            e.set(o * c, l * h, l * d, o * u);
                            break;
                        case "YZY":
                            e.set(l * d, o * c, l * h, o * u);
                            break;
                        case "ZXZ":
                            e.set(l * h, l * d, o * c, o * u);
                            break;
                        case "XZX":
                            e.set(o * c, l * p, l * f, o * u);
                            break;
                        case "YXY":
                            e.set(l * f, o * c, l * p, o * u);
                            break;
                        case "ZYZ":
                            e.set(l * p, l * f, o * c, o * u);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                    }
                },
                normalize: nk,
                denormalize: nF
            };
            class nG {
                constructor(e = 0, t = 0) {
                    nG.prototype.isVector2 = !0, this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    let t = this.x,
                        n = this.y,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    let n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                angleTo(e) {
                    let t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    return 0 === t ? Math.PI / 2 : Math.acos(nO(this.dot(e) / t, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    let t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    let n = Math.cos(t),
                        r = Math.sin(t),
                        i = this.x - e.x,
                        s = this.y - e.y;
                    return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            class nz {
                constructor(e, t, n, r, i, s, a, o, l) {
                    nz.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, r, i, s, a, o, l)
                }
                set(e, t, n, r, i, s, a, o, l) {
                    let u = this.elements;
                    return u[0] = e, u[1] = r, u[2] = a, u[3] = t, u[4] = i, u[5] = o, u[6] = n, u[7] = s, u[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(e) {
                    let t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    let t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    let n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        s = n[0],
                        a = n[3],
                        o = n[6],
                        l = n[1],
                        u = n[4],
                        c = n[7],
                        h = n[2],
                        d = n[5],
                        f = n[8],
                        p = r[0],
                        g = r[3],
                        A = r[6],
                        m = r[1],
                        v = r[4],
                        y = r[7],
                        x = r[2],
                        E = r[5],
                        _ = r[8];
                    return i[0] = s * p + a * m + o * x, i[3] = s * g + a * v + o * E, i[6] = s * A + a * y + o * _, i[1] = l * p + u * m + c * x, i[4] = l * g + u * v + c * E, i[7] = l * A + u * y + c * _, i[2] = h * p + d * m + f * x, i[5] = h * g + d * v + f * E, i[8] = h * A + d * y + f * _, this
                }
                multiplyScalar(e) {
                    let t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    let e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        s = e[4],
                        a = e[5],
                        o = e[6],
                        l = e[7],
                        u = e[8];
                    return t * s * u - t * a * l - n * i * u + n * a * o + r * i * l - r * s * o
                }
                invert() {
                    let e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        s = e[4],
                        a = e[5],
                        o = e[6],
                        l = e[7],
                        u = e[8],
                        c = u * s - a * l,
                        h = a * o - u * i,
                        d = l * i - s * o,
                        f = t * c + n * h + r * d;
                    if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let p = 1 / f;
                    return e[0] = c * p, e[1] = (r * l - u * n) * p, e[2] = (a * n - r * s) * p, e[3] = h * p, e[4] = (u * t - r * o) * p, e[5] = (r * i - a * t) * p, e[6] = d * p, e[7] = (n * o - l * t) * p, e[8] = (s * t - n * i) * p, this
                }
                transpose() {
                    let e;
                    let t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    let t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, n, r, i, s, a) {
                    let o = Math.cos(i),
                        l = Math.sin(i);
                    return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -r * l, r * o, -r * (-l * s + o * a) + a + t, 0, 0, 1), this
                }
                scale(e, t) {
                    return this.premultiply(nH.makeScale(e, t)), this
                }
                rotate(e) {
                    return this.premultiply(nH.makeRotation(-e)), this
                }
                translate(e, t) {
                    return this.premultiply(nH.makeTranslation(e, t)), this
                }
                makeTranslation(e, t) {
                    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
                }
                makeRotation(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
                }
                makeScale(e, t) {
                    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
                }
                equals(e) {
                    let t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    let n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
                clone() {
                    return new this.constructor().fromArray(this.elements)
                }
            }
            let nH = new nz;

            function nV(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] >= 65535) return !0;
                return !1
            }
            let nj = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function nW(e, t) {
                return new nj[e](t)
            }

            function nY(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }

            function nX() {
                let e = nY("canvas");
                return e.style.display = "block", e
            }
            let nq = {};

            function nK(e) {
                e in nq || (nq[e] = !0, console.warn(e))
            }
            let nJ = new nz().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
                nZ = new nz().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
                n$ = {
                    [tq]: {
                        transfer: tZ,
                        primaries: t0,
                        luminanceCoefficients: [.2126, .7152, .0722],
                        toReference: e => e,
                        fromReference: e => e
                    },
                    [tX]: {
                        transfer: t$,
                        primaries: t0,
                        luminanceCoefficients: [.2126, .7152, .0722],
                        toReference: e => e.convertSRGBToLinear(),
                        fromReference: e => e.convertLinearToSRGB()
                    },
                    [tJ]: {
                        transfer: tZ,
                        primaries: t1,
                        luminanceCoefficients: [.2289, .6917, .0793],
                        toReference: e => e.applyMatrix3(nZ),
                        fromReference: e => e.applyMatrix3(nJ)
                    },
                    [tK]: {
                        transfer: t$,
                        primaries: t1,
                        luminanceCoefficients: [.2289, .6917, .0793],
                        toReference: e => e.convertSRGBToLinear().applyMatrix3(nZ),
                        fromReference: e => e.applyMatrix3(nJ).convertLinearToSRGB()
                    }
                },
                n0 = new Set([tq, tJ]),
                n1 = {
                    enabled: !0,
                    _workingColorSpace: tq,
                    get workingColorSpace() {
                        return this._workingColorSpace
                    },
                    set workingColorSpace(colorSpace) {
                        if (!n0.has(colorSpace)) throw Error(`Unsupported working color space, "${colorSpace}".`);
                        this._workingColorSpace = colorSpace
                    },
                    convert: function(e, t, n) {
                        if (!1 === this.enabled || t === n || !t || !n) return e;
                        let r = n$[t].toReference;
                        return (0, n$[n].fromReference)(r(e))
                    },
                    fromWorkingColorSpace: function(e, t) {
                        return this.convert(e, this._workingColorSpace, t)
                    },
                    toWorkingColorSpace: function(e, t) {
                        return this.convert(e, t, this._workingColorSpace)
                    },
                    getPrimaries: function(e) {
                        return n$[e].primaries
                    },
                    getTransfer: function(e) {
                        return e === tY ? tZ : n$[e].transfer
                    },
                    getLuminanceCoefficients: function(e, t = this._workingColorSpace) {
                        return e.fromArray(n$[t].luminanceCoefficients)
                    }
                };

            function n2(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function n3(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            class n4 {
                static getDataURL(e) {
                    let t;
                    if (/^data:/i.test(e.src) || "undefined" == typeof HTMLCanvasElement) return e.src;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === r && (r = nY("canvas")), r.width = e.width, r.height = e.height;
                        let n = r.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = r
                    }
                    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        let t = nY("canvas");
                        t.width = e.width, t.height = e.height;
                        let n = t.getContext("2d");
                        n.drawImage(e, 0, 0, e.width, e.height);
                        let r = n.getImageData(0, 0, e.width, e.height),
                            i = r.data;
                        for (let e = 0; e < i.length; e++) i[e] = 255 * n2(i[e] / 255);
                        return n.putImageData(r, 0, 0), t
                    }
                    if (!e.data) return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e; {
                        let t = e.data.slice(0);
                        for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * n2(t[e] / 255)) : t[e] = n2(t[e]);
                        return {
                            data: t,
                            width: e.width,
                            height: e.height
                        }
                    }
                }
            }
            let n5 = 0;
            class n6 {
                constructor(e = null) {
                    this.isSource = !0, Object.defineProperty(this, "id", {
                        value: n5++
                    }), this.uuid = nP(), this.data = e, this.dataReady = !0, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                    let n = {
                            uuid: this.uuid,
                            url: ""
                        },
                        r = this.data;
                    if (null !== r) {
                        let e;
                        if (Array.isArray(r)) {
                            e = [];
                            for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(n8(r[t].image)) : e.push(n8(r[t]))
                        } else e = n8(r);
                        n.url = e
                    }
                    return t || (e.images[this.uuid] = n), n
                }
            }

            function n8(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? n4.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            let n9 = 0;
            class n7 extends nT {
                constructor(e = n7.DEFAULT_IMAGE, t = n7.DEFAULT_MAPPING, n = e_, r = e_, i = eT, s = eD, a = eX, o = eP, l = n7.DEFAULT_ANISOTROPY, u = tY) {
                    super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                        value: n9++
                    }), this.uuid = nP(), this.name = "", this.source = new n6(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new nG(0, 0), this.repeat = new nG(1, 1), this.center = new nG(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new nz, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
                }
                get image() {
                    return this.source.data
                }
                set image(e = null) {
                    this.source.data = e
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    let n = {
                        metadata: {
                            version: 4.6,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(e).uuid,
                        mapping: this.mapping,
                        channel: this.channel,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        internalFormat: this.internalFormat,
                        type: this.type,
                        colorSpace: this.colorSpace,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        generateMipmaps: this.generateMipmaps,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (this.mapping !== eg) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case eE:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case e_:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case eb:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case eE:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case e_:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case eb:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
                set needsUpdate(e) {
                    !0 === e && (this.version++, this.source.needsUpdate = !0)
                }
                set needsPMREMUpdate(e) {
                    !0 === e && this.pmremVersion++
                }
            }
            n7.DEFAULT_IMAGE = null, n7.DEFAULT_MAPPING = eg, n7.DEFAULT_ANISOTROPY = 1;
            class re {
                constructor(e = 0, t = 0, n = 0, r = 1) {
                    re.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, r) {
                    return this.x = e, this.y = t, this.z = n, this.w = r, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        s = e.elements;
                    return this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    let t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, r, i;
                    let s = e.elements,
                        a = s[0],
                        o = s[4],
                        l = s[8],
                        u = s[1],
                        c = s[5],
                        h = s[9],
                        d = s[2],
                        f = s[6],
                        p = s[10];
                    if (.01 > Math.abs(o - u) && .01 > Math.abs(l - d) && .01 > Math.abs(h - f)) {
                        if (.1 > Math.abs(o + u) && .1 > Math.abs(l + d) && .1 > Math.abs(h + f) && .1 > Math.abs(a + c + p - 3)) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        let e = (a + 1) / 2,
                            s = (c + 1) / 2,
                            g = (p + 1) / 2,
                            A = (o + u) / 4,
                            m = (l + d) / 4,
                            v = (h + f) / 4;
                        return e > s && e > g ? e < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = A / (n = Math.sqrt(e)), i = m / n) : s > g ? s < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = A / (r = Math.sqrt(s)), i = v / r) : g < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = m / (i = Math.sqrt(g)), r = v / i), this.set(n, r, i, t), this
                    }
                    let g = Math.sqrt((f - h) * (f - h) + (l - d) * (l - d) + (u - o) * (u - o));
                    return .001 > Math.abs(g) && (g = 1), this.x = (f - h) / g, this.y = (l - d) / g, this.z = (u - o) / g, this.w = Math.acos((a + c + p - 1) / 2), this
                }
                setFromMatrixPosition(e) {
                    let t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    let n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            class rt extends nT {
                constructor(e = 1, t = 1, n = {}) {
                    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new re(0, 0, e, t), this.scissorTest = !1, this.viewport = new re(0, 0, e, t);
                    let r = new n7({
                        width: e,
                        height: t,
                        depth: 1
                    }, (n = Object.assign({
                        generateMipmaps: !1,
                        internalFormat: null,
                        minFilter: eT,
                        depthBuffer: !0,
                        stencilBuffer: !1,
                        resolveDepthBuffer: !0,
                        resolveStencilBuffer: !0,
                        depthTexture: null,
                        samples: 0,
                        count: 1
                    }, n)).mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
                    r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
                    let i = n.count;
                    for (let e = 0; e < i; e++) this.textures[e] = r.clone(), this.textures[e].isRenderTargetTexture = !0;
                    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
                }
                get texture() {
                    return this.textures[0]
                }
                set texture(e) {
                    this.textures[0] = e
                }
                setSize(e, t, n = 1) {
                    if (this.width !== e || this.height !== t || this.depth !== n) {
                        this.width = e, this.height = t, this.depth = n;
                        for (let r = 0, i = this.textures.length; r < i; r++) this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = n;
                        this.dispose()
                    }
                    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
                    for (let t = 0, n = e.textures.length; t < n; t++) this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0;
                    let t = Object.assign({}, e.texture.image);
                    return this.texture.source = new n6(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class rn extends rt {
                constructor(e = 1, t = 1, n = {}) {
                    super(e, t, n), this.isWebGLRenderTarget = !0
                }
            }
            class rr extends n7 {
                constructor(e = null, t = 1, n = 1, r = 1) {
                    super(null), this.isDataArrayTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    }, this.magFilter = ew, this.minFilter = ew, this.wrapR = e_, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
                }
                addLayerUpdate(e) {
                    this.layerUpdates.add(e)
                }
                clearLayerUpdates() {
                    this.layerUpdates.clear()
                }
            }
            class ri extends rn {
                constructor(e = 1, t = 1, n = 1, r = {}) {
                    super(e, t, r), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new rr(null, e, t, n), this.texture.isRenderTargetTexture = !0
                }
            }
            class rs extends n7 {
                constructor(e = null, t = 1, n = 1, r = 1) {
                    super(null), this.isData3DTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    }, this.magFilter = ew, this.minFilter = ew, this.wrapR = e_, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class ra extends rn {
                constructor(e = 1, t = 1, n = 1, r = {}) {
                    super(e, t, r), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new rs(null, e, t, n), this.texture.isRenderTargetTexture = !0
                }
            }
            class ro {
                constructor(e = 0, t = 0, n = 0, r = 1) {
                    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r
                }
                static slerpFlat(e, t, n, r, i, s, a) {
                    let o = n[r + 0],
                        l = n[r + 1],
                        u = n[r + 2],
                        c = n[r + 3],
                        h = i[s + 0],
                        d = i[s + 1],
                        f = i[s + 2],
                        p = i[s + 3];
                    if (0 === a) {
                        e[t + 0] = o, e[t + 1] = l, e[t + 2] = u, e[t + 3] = c;
                        return
                    }
                    if (1 === a) {
                        e[t + 0] = h, e[t + 1] = d, e[t + 2] = f, e[t + 3] = p;
                        return
                    }
                    if (c !== p || o !== h || l !== d || u !== f) {
                        let e = 1 - a,
                            t = o * h + l * d + u * f + c * p,
                            n = t >= 0 ? 1 : -1,
                            r = 1 - t * t;
                        if (r > Number.EPSILON) {
                            let i = Math.sqrt(r),
                                s = Math.atan2(i, t * n);
                            e = Math.sin(e * s) / i, a = Math.sin(a * s) / i
                        }
                        let i = a * n;
                        if (o = o * e + h * i, l = l * e + d * i, u = u * e + f * i, c = c * e + p * i, e === 1 - a) {
                            let e = 1 / Math.sqrt(o * o + l * l + u * u + c * c);
                            o *= e, l *= e, u *= e, c *= e
                        }
                    }
                    e[t] = o, e[t + 1] = l, e[t + 2] = u, e[t + 3] = c
                }
                static multiplyQuaternionsFlat(e, t, n, r, i, s) {
                    let a = n[r],
                        o = n[r + 1],
                        l = n[r + 2],
                        u = n[r + 3],
                        c = i[s],
                        h = i[s + 1],
                        d = i[s + 2],
                        f = i[s + 3];
                    return e[t] = a * f + u * c + o * d - l * h, e[t + 1] = o * f + u * h + l * c - a * d, e[t + 2] = l * f + u * d + a * h - o * c, e[t + 3] = u * f - a * c - o * h - l * d, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t = !0) {
                    let n = e._x,
                        r = e._y,
                        i = e._z,
                        s = e._order,
                        a = Math.cos,
                        o = Math.sin,
                        l = a(n / 2),
                        u = a(r / 2),
                        c = a(i / 2),
                        h = o(n / 2),
                        d = o(r / 2),
                        f = o(i / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                            break;
                        case "YXZ":
                            this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                            break;
                        case "ZXY":
                            this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                            break;
                        case "ZYX":
                            this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                            break;
                        case "YZX":
                            this._x = h * u * c + l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c - h * d * f;
                            break;
                        case "XZY":
                            this._x = h * u * c - l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c + h * d * f;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                    }
                    return !0 === t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    let n = t / 2,
                        r = Math.sin(n);
                    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    let t = e.elements,
                        n = t[0],
                        r = t[4],
                        i = t[8],
                        s = t[1],
                        a = t[5],
                        o = t[9],
                        l = t[2],
                        u = t[6],
                        c = t[10],
                        h = n + a + c;
                    if (h > 0) {
                        let e = .5 / Math.sqrt(h + 1);
                        this._w = .25 / e, this._x = (u - o) * e, this._y = (i - l) * e, this._z = (s - r) * e
                    } else if (n > a && n > c) {
                        let e = 2 * Math.sqrt(1 + n - a - c);
                        this._w = (u - o) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (i + l) / e
                    } else if (a > c) {
                        let e = 2 * Math.sqrt(1 + a - n - c);
                        this._w = (i - l) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (o + u) / e
                    } else {
                        let e = 2 * Math.sqrt(1 + c - n - a);
                        this._w = (s - r) / e, this._x = (i + l) / e, this._y = (o + u) / e, this._z = .25 * e
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(nO(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    let n = this.angleTo(e);
                    if (0 === n) return this;
                    let r = Math.min(1, t / n);
                    return this.slerp(e, r), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e) {
                    return this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    let n = e._x,
                        r = e._y,
                        i = e._z,
                        s = e._w,
                        a = t._x,
                        o = t._y,
                        l = t._z,
                        u = t._w;
                    return this._x = n * u + s * a + r * l - i * o, this._y = r * u + s * o + i * a - n * l, this._z = i * u + s * l + n * o - r * a, this._w = s * u - n * a - r * o - i * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    let n = this._x,
                        r = this._y,
                        i = this._z,
                        s = this._w,
                        a = s * e._w + n * e._x + r * e._y + i * e._z;
                    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this;
                    let o = 1 - a * a;
                    if (o <= Number.EPSILON) {
                        let e = 1 - t;
                        return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this
                    }
                    let l = Math.sqrt(o),
                        u = Math.atan2(l, a),
                        c = Math.sin((1 - t) * u) / l,
                        h = Math.sin(t * u) / l;
                    return this._w = s * c + this._w * h, this._x = n * c + this._x * h, this._y = r * c + this._y * h, this._z = i * c + this._z * h, this._onChangeCallback(), this
                }
                slerpQuaternions(e, t, n) {
                    return this.copy(e).slerp(t, n)
                }
                random() {
                    let e = 2 * Math.PI * Math.random(),
                        t = 2 * Math.PI * Math.random(),
                        n = Math.random(),
                        r = Math.sqrt(1 - n),
                        i = Math.sqrt(n);
                    return this.set(r * Math.sin(e), r * Math.cos(e), i * Math.sin(t), i * Math.cos(t))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
                }
                toJSON() {
                    return this.toArray()
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._w
                }
            }
            class rl {
                constructor(e = 0, t = 0, n = 0) {
                    rl.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return this.applyQuaternion(rc.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(rc.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements,
                        s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s, this
                }
                applyQuaternion(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.x,
                        s = e.y,
                        a = e.z,
                        o = e.w,
                        l = 2 * (s * r - a * n),
                        u = 2 * (a * t - i * r),
                        c = 2 * (i * n - s * t);
                    return this.x = t + o * l + s * c - a * u, this.y = n + o * u + a * l - i * c, this.z = r + o * c + i * u - s * l, this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    let n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                }
                cross(e) {
                    return this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z,
                        s = t.x,
                        a = t.y,
                        o = t.z;
                    return this.x = r * o - i * a, this.y = i * s - n * o, this.z = n * a - r * s, this
                }
                projectOnVector(e) {
                    let t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    let n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return ru.copy(this).projectOnVector(e), this.sub(ru)
                }
                reflect(e) {
                    return this.sub(ru.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    let t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    return 0 === t ? Math.PI / 2 : Math.acos(nO(this.dot(e) / t, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    let t = this.x - e.x,
                        n = this.y - e.y,
                        r = this.z - e.z;
                    return t * t + n * n + r * r
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    let r = Math.sin(t) * e;
                    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    let t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    let t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = r, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                setFromEuler(e) {
                    return this.x = e._x, this.y = e._y, this.z = e._z, this
                }
                setFromColor(e) {
                    return this.x = e.r, this.y = e.g, this.z = e.b, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    let e = Math.random() * Math.PI * 2,
                        t = 2 * Math.random() - 1,
                        n = Math.sqrt(1 - t * t);
                    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            let ru = new rl,
                rc = new ro;
            class rh {
                constructor(e = new rl(Infinity, Infinity, Infinity), t = new rl(-1 / 0, -1 / 0, -1 / 0)) {
                    this.isBox3 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(rf.fromArray(e, t));
                    return this
                }
                setFromBufferAttribute(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(rf.fromBufferAttribute(e, t));
                    return this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    let n = rf.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                setFromObject(e, t = !1) {
                    return this.makeEmpty(), this.expandByObject(e, t)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e, t = !1) {
                    e.updateWorldMatrix(!1, !1);
                    let n = e.geometry;
                    if (void 0 !== n) {
                        let r = n.getAttribute("position");
                        if (!0 === t && void 0 !== r && !0 !== e.isInstancedMesh)
                            for (let t = 0, n = r.count; t < n; t++) !0 === e.isMesh ? e.getVertexPosition(t, rf) : rf.fromBufferAttribute(r, t), rf.applyMatrix4(e.matrixWorld), this.expandByPoint(rf);
                        else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), rp.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), rp.copy(n.boundingBox)), rp.applyMatrix4(e.matrixWorld), this.union(rp)
                    }
                    let r = e.children;
                    for (let e = 0, n = r.length; e < n; e++) this.expandByObject(r[e], t);
                    return this
                }
                containsPoint(e) {
                    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, rf), rf.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(rE), r_.subVectors(this.max, rE), rg.subVectors(e.a, rE), rA.subVectors(e.b, rE), rm.subVectors(e.c, rE), rv.subVectors(rA, rg), ry.subVectors(rm, rA), rx.subVectors(rg, rm);
                    let t = [0, -rv.z, rv.y, 0, -ry.z, ry.y, 0, -rx.z, rx.y, rv.z, 0, -rv.x, ry.z, 0, -ry.x, rx.z, 0, -rx.x, -rv.y, rv.x, 0, -ry.y, ry.x, 0, -rx.y, rx.x, 0];
                    return !!(rC(t, rg, rA, rm, r_) && rC(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], rg, rA, rm, r_)) && (rb.crossVectors(rv, ry), rC(t = [rb.x, rb.y, rb.z], rg, rA, rm, r_))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return this.clampPoint(e, rf).distanceTo(e)
                }
                getBoundingSphere(e) {
                    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(rf).length()), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (rd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), rd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), rd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), rd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), rd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), rd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), rd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), rd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(rd)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            let rd = [new rl, new rl, new rl, new rl, new rl, new rl, new rl, new rl],
                rf = new rl,
                rp = new rh,
                rg = new rl,
                rA = new rl,
                rm = new rl,
                rv = new rl,
                ry = new rl,
                rx = new rl,
                rE = new rl,
                r_ = new rl,
                rb = new rl,
                rw = new rl;

            function rC(e, t, n, r, i) {
                for (let s = 0, a = e.length - 3; s <= a; s += 3) {
                    rw.fromArray(e, s);
                    let a = i.x * Math.abs(rw.x) + i.y * Math.abs(rw.y) + i.z * Math.abs(rw.z),
                        o = t.dot(rw),
                        l = n.dot(rw),
                        u = r.dot(rw);
                    if (Math.max(-Math.max(o, l, u), Math.min(o, l, u)) > a) return !1
                }
                return !0
            }
            let rS = new rh,
                rI = new rl,
                rM = new rl;
            class rT {
                constructor(e = new rl, t = -1) {
                    this.isSphere = !0, this.center = e, this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    let n = this.center;
                    void 0 !== t ? n.copy(t) : rS.setFromPoints(e).getCenter(n);
                    let r = 0;
                    for (let t = 0, i = e.length; t < i; t++) r = Math.max(r, n.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(r), this
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    let t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    let n = this.center.distanceToSquared(e);
                    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? e.makeEmpty() : (e.set(this.center, this.center), e.expandByScalar(this.radius)), e
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                expandByPoint(e) {
                    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                    rI.subVectors(e, this.center);
                    let t = rI.lengthSq();
                    if (t > this.radius * this.radius) {
                        let e = Math.sqrt(t),
                            n = (e - this.radius) * .5;
                        this.center.addScaledVector(rI, n / e), this.radius += n
                    }
                    return this
                }
                union(e) {
                    return e.isEmpty() || (this.isEmpty() ? this.copy(e) : !0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (rM.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(rI.copy(e.center).add(rM)), this.expandByPoint(rI.copy(e.center).sub(rM)))), this
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let rB = new rl,
                rR = new rl,
                rD = new rl,
                rL = new rl,
                rP = new rl,
                rO = new rl,
                rN = new rl;
            class rU {
                constructor(e = new rl, t = new rl(0, 0, -1)) {
                    this.origin = e, this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return t.copy(this.origin).addScaledVector(this.direction, e)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, rB)), this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    let n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    let t = rB.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (rB.copy(this.origin).addScaledVector(this.direction, t), rB.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, r) {
                    let i, s, a, o;
                    rR.copy(e).add(t).multiplyScalar(.5), rD.copy(t).sub(e).normalize(), rL.copy(this.origin).sub(rR);
                    let l = .5 * e.distanceTo(t),
                        u = -this.direction.dot(rD),
                        c = rL.dot(this.direction),
                        h = -rL.dot(rD),
                        d = rL.lengthSq(),
                        f = Math.abs(1 - u * u);
                    if (f > 0) {
                        if (i = u * h - c, s = u * c - h, o = l * f, i >= 0) {
                            if (s >= -o) {
                                if (s <= o) {
                                    let e = 1 / f;
                                    i *= e, s *= e, a = i * (i + u * s + 2 * c) + s * (u * i + s + 2 * h) + d
                                } else a = -(i = Math.max(0, -(u * (s = l) + c))) * i + s * (s + 2 * h) + d
                            } else a = -(i = Math.max(0, -(u * (s = -l) + c))) * i + s * (s + 2 * h) + d
                        } else s <= -o ? (s = (i = Math.max(0, -(-u * l + c))) > 0 ? -l : Math.min(Math.max(-l, -h), l), a = -i * i + s * (s + 2 * h) + d) : s <= o ? (i = 0, a = (s = Math.min(Math.max(-l, -h), l)) * (s + 2 * h) + d) : (s = (i = Math.max(0, -(u * l + c))) > 0 ? l : Math.min(Math.max(-l, -h), l), a = -i * i + s * (s + 2 * h) + d)
                    } else s = u > 0 ? -l : l, a = -(i = Math.max(0, -(u * s + c))) * i + s * (s + 2 * h) + d;
                    return n && n.copy(this.origin).addScaledVector(this.direction, i), r && r.copy(rR).addScaledVector(rD, s), a
                }
                intersectSphere(e, t) {
                    rB.subVectors(e.center, this.origin);
                    let n = rB.dot(this.direction),
                        r = rB.dot(rB) - n * n,
                        i = e.radius * e.radius;
                    if (r > i) return null;
                    let s = Math.sqrt(i - r),
                        a = n - s,
                        o = n + s;
                    return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    let t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    let n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    let n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    let t = e.distanceToPoint(this.origin);
                    return !!(0 === t || e.normal.dot(this.direction) * t < 0)
                }
                intersectBox(e, t) {
                    let n, r, i, s, a, o;
                    let l = 1 / this.direction.x,
                        u = 1 / this.direction.y,
                        c = 1 / this.direction.z,
                        h = this.origin;
                    return (l >= 0 ? (n = (e.min.x - h.x) * l, r = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, r = (e.min.x - h.x) * l), u >= 0 ? (i = (e.min.y - h.y) * u, s = (e.max.y - h.y) * u) : (i = (e.max.y - h.y) * u, s = (e.min.y - h.y) * u), n > s || i > r) ? null : ((i > n || isNaN(n)) && (n = i), (s < r || isNaN(r)) && (r = s), c >= 0 ? (a = (e.min.z - h.z) * c, o = (e.max.z - h.z) * c) : (a = (e.max.z - h.z) * c, o = (e.min.z - h.z) * c), n > o || a > r) ? null : ((a > n || n != n) && (n = a), (o < r || r != r) && (r = o), r < 0) ? null : this.at(n >= 0 ? n : r, t)
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, rB)
                }
                intersectTriangle(e, t, n, r, i) {
                    let s;
                    rP.subVectors(t, e), rO.subVectors(n, e), rN.crossVectors(rP, rO);
                    let a = this.direction.dot(rN);
                    if (a > 0) {
                        if (r) return null;
                        s = 1
                    } else {
                        if (!(a < 0)) return null;
                        s = -1, a = -a
                    }
                    rL.subVectors(this.origin, e);
                    let o = s * this.direction.dot(rO.crossVectors(rL, rO));
                    if (o < 0) return null;
                    let l = s * this.direction.dot(rP.cross(rL));
                    if (l < 0 || o + l > a) return null;
                    let u = -s * rL.dot(rN);
                    return u < 0 ? null : this.at(u / a, i)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class rF {
                constructor(e, t, n, r, i, s, a, o, l, u, c, h, d, f, p, g) {
                    rF.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, r, i, s, a, o, l, u, c, h, d, f, p, g)
                }
                set(e, t, n, r, i, s, a, o, l, u, c, h, d, f, p, g) {
                    let A = this.elements;
                    return A[0] = e, A[4] = t, A[8] = n, A[12] = r, A[1] = i, A[5] = s, A[9] = a, A[13] = o, A[2] = l, A[6] = u, A[10] = c, A[14] = h, A[3] = d, A[7] = f, A[11] = p, A[15] = g, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return new rF().fromArray(this.elements)
                }
                copy(e) {
                    let t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                }
                copyPosition(e) {
                    let t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                }
                setFromMatrix3(e) {
                    let t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    let t = this.elements,
                        n = e.elements,
                        r = 1 / rk.setFromMatrixColumn(e, 0).length(),
                        i = 1 / rk.setFromMatrixColumn(e, 1).length(),
                        s = 1 / rk.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    let t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z,
                        s = Math.cos(n),
                        a = Math.sin(n),
                        o = Math.cos(r),
                        l = Math.sin(r),
                        u = Math.cos(i),
                        c = Math.sin(i);
                    if ("XYZ" === e.order) {
                        let e = s * u,
                            n = s * c,
                            r = a * u,
                            i = a * c;
                        t[0] = o * u, t[4] = -o * c, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -a * o, t[2] = i - e * l, t[6] = r + n * l, t[10] = s * o
                    } else if ("YXZ" === e.order) {
                        let e = o * u,
                            n = o * c,
                            r = l * u,
                            i = l * c;
                        t[0] = e + i * a, t[4] = r * a - n, t[8] = s * l, t[1] = s * c, t[5] = s * u, t[9] = -a, t[2] = n * a - r, t[6] = i + e * a, t[10] = s * o
                    } else if ("ZXY" === e.order) {
                        let e = o * u,
                            n = o * c,
                            r = l * u,
                            i = l * c;
                        t[0] = e - i * a, t[4] = -s * c, t[8] = r + n * a, t[1] = n + r * a, t[5] = s * u, t[9] = i - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o
                    } else if ("ZYX" === e.order) {
                        let e = s * u,
                            n = s * c,
                            r = a * u,
                            i = a * c;
                        t[0] = o * u, t[4] = r * l - n, t[8] = e * l + i, t[1] = o * c, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = a * o, t[10] = s * o
                    } else if ("YZX" === e.order) {
                        let e = s * o,
                            n = s * l,
                            r = a * o,
                            i = a * l;
                        t[0] = o * u, t[4] = i - e * c, t[8] = r * c + n, t[1] = c, t[5] = s * u, t[9] = -a * u, t[2] = -l * u, t[6] = n * c + r, t[10] = e - i * c
                    } else if ("XZY" === e.order) {
                        let e = s * o,
                            n = s * l,
                            r = a * o,
                            i = a * l;
                        t[0] = o * u, t[4] = -c, t[8] = l * u, t[1] = e * c + i, t[5] = s * u, t[9] = n * c - r, t[2] = r * c - n, t[6] = a * u, t[10] = i * c + e
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(rG, e, rz)
                }
                lookAt(e, t, n) {
                    let r = this.elements;
                    return rj.subVectors(e, t), 0 === rj.lengthSq() && (rj.z = 1), rj.normalize(), rH.crossVectors(n, rj), 0 === rH.lengthSq() && (1 === Math.abs(n.z) ? rj.x += 1e-4 : rj.z += 1e-4, rj.normalize(), rH.crossVectors(n, rj)), rH.normalize(), rV.crossVectors(rj, rH), r[0] = rH.x, r[4] = rV.x, r[8] = rj.x, r[1] = rH.y, r[5] = rV.y, r[9] = rj.y, r[2] = rH.z, r[6] = rV.z, r[10] = rj.z, this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    let n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        s = n[0],
                        a = n[4],
                        o = n[8],
                        l = n[12],
                        u = n[1],
                        c = n[5],
                        h = n[9],
                        d = n[13],
                        f = n[2],
                        p = n[6],
                        g = n[10],
                        A = n[14],
                        m = n[3],
                        v = n[7],
                        y = n[11],
                        x = n[15],
                        E = r[0],
                        _ = r[4],
                        b = r[8],
                        w = r[12],
                        C = r[1],
                        S = r[5],
                        I = r[9],
                        M = r[13],
                        T = r[2],
                        B = r[6],
                        R = r[10],
                        D = r[14],
                        L = r[3],
                        P = r[7],
                        O = r[11],
                        N = r[15];
                    return i[0] = s * E + a * C + o * T + l * L, i[4] = s * _ + a * S + o * B + l * P, i[8] = s * b + a * I + o * R + l * O, i[12] = s * w + a * M + o * D + l * N, i[1] = u * E + c * C + h * T + d * L, i[5] = u * _ + c * S + h * B + d * P, i[9] = u * b + c * I + h * R + d * O, i[13] = u * w + c * M + h * D + d * N, i[2] = f * E + p * C + g * T + A * L, i[6] = f * _ + p * S + g * B + A * P, i[10] = f * b + p * I + g * R + A * O, i[14] = f * w + p * M + g * D + A * N, i[3] = m * E + v * C + y * T + x * L, i[7] = m * _ + v * S + y * B + x * P, i[11] = m * b + v * I + y * R + x * O, i[15] = m * w + v * M + y * D + x * N, this
                }
                multiplyScalar(e) {
                    let t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    let e = this.elements,
                        t = e[0],
                        n = e[4],
                        r = e[8],
                        i = e[12],
                        s = e[1],
                        a = e[5],
                        o = e[9],
                        l = e[13],
                        u = e[2],
                        c = e[6],
                        h = e[10],
                        d = e[14],
                        f = e[3];
                    return f * (+i * o * c - r * l * c - i * a * h + n * l * h + r * a * d - n * o * d) + e[7] * (+t * o * d - t * l * h + i * s * h - r * s * d + r * l * u - i * o * u) + e[11] * (+t * l * c - t * a * d - i * s * c + n * s * d + i * a * u - n * l * u) + e[15] * (-r * a * u - t * o * c + t * a * h + r * s * c - n * s * h + n * o * u)
                }
                transpose() {
                    let e;
                    let t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(e, t, n) {
                    let r = this.elements;
                    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
                }
                invert() {
                    let e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        s = e[4],
                        a = e[5],
                        o = e[6],
                        l = e[7],
                        u = e[8],
                        c = e[9],
                        h = e[10],
                        d = e[11],
                        f = e[12],
                        p = e[13],
                        g = e[14],
                        A = e[15],
                        m = c * g * l - p * h * l + p * o * d - a * g * d - c * o * A + a * h * A,
                        v = f * h * l - u * g * l - f * o * d + s * g * d + u * o * A - s * h * A,
                        y = u * p * l - f * c * l + f * a * d - s * p * d - u * a * A + s * c * A,
                        x = f * c * o - u * p * o - f * a * h + s * p * h + u * a * g - s * c * g,
                        E = t * m + n * v + r * y + i * x;
                    if (0 === E) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let _ = 1 / E;
                    return e[0] = m * _, e[1] = (p * h * i - c * g * i - p * r * d + n * g * d + c * r * A - n * h * A) * _, e[2] = (a * g * i - p * o * i + p * r * l - n * g * l - a * r * A + n * o * A) * _, e[3] = (c * o * i - a * h * i - c * r * l + n * h * l + a * r * d - n * o * d) * _, e[4] = v * _, e[5] = (u * g * i - f * h * i + f * r * d - t * g * d - u * r * A + t * h * A) * _, e[6] = (f * o * i - s * g * i - f * r * l + t * g * l + s * r * A - t * o * A) * _, e[7] = (s * h * i - u * o * i + u * r * l - t * h * l - s * r * d + t * o * d) * _, e[8] = y * _, e[9] = (f * c * i - u * p * i - f * n * d + t * p * d + u * n * A - t * c * A) * _, e[10] = (s * p * i - f * a * i + f * n * l - t * p * l - s * n * A + t * a * A) * _, e[11] = (u * a * i - s * c * i - u * n * l + t * c * l + s * n * d - t * a * d) * _, e[12] = x * _, e[13] = (u * p * r - f * c * r + f * n * h - t * p * h - u * n * g + t * c * g) * _, e[14] = (f * a * r - s * p * r - f * n * o + t * p * o + s * n * g - t * a * g) * _, e[15] = (s * c * r - u * a * r + u * n * o - t * c * o - s * n * h + t * a * h) * _, this
                }
                scale(e) {
                    let t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z;
                    return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                }
                getMaxScaleOnAxis() {
                    let e = this.elements;
                    return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
                }
                makeTranslation(e, t, n) {
                    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    let n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 - n,
                        s = e.x,
                        a = e.y,
                        o = e.z,
                        l = i * s,
                        u = i * a;
                    return this.set(l * s + n, l * a - r * o, l * o + r * a, 0, l * a + r * o, u * a + n, u * o - r * s, 0, l * o - r * a, u * o + r * s, i * o * o + n, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, n, r, i, s) {
                    return this.set(1, n, i, 0, e, 1, s, 0, t, r, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, n) {
                    let r = this.elements,
                        i = t._x,
                        s = t._y,
                        a = t._z,
                        o = t._w,
                        l = i + i,
                        u = s + s,
                        c = a + a,
                        h = i * l,
                        d = i * u,
                        f = i * c,
                        p = s * u,
                        g = s * c,
                        A = a * c,
                        m = o * l,
                        v = o * u,
                        y = o * c,
                        x = n.x,
                        E = n.y,
                        _ = n.z;
                    return r[0] = (1 - (p + A)) * x, r[1] = (d + y) * x, r[2] = (f - v) * x, r[3] = 0, r[4] = (d - y) * E, r[5] = (1 - (h + A)) * E, r[6] = (g + m) * E, r[7] = 0, r[8] = (f + v) * _, r[9] = (g - m) * _, r[10] = (1 - (h + p)) * _, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                }
                decompose(e, t, n) {
                    let r = this.elements,
                        i = rk.set(r[0], r[1], r[2]).length(),
                        s = rk.set(r[4], r[5], r[6]).length(),
                        a = rk.set(r[8], r[9], r[10]).length();
                    0 > this.determinant() && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], rQ.copy(this);
                    let o = 1 / i,
                        l = 1 / s,
                        u = 1 / a;
                    return rQ.elements[0] *= o, rQ.elements[1] *= o, rQ.elements[2] *= o, rQ.elements[4] *= l, rQ.elements[5] *= l, rQ.elements[6] *= l, rQ.elements[8] *= u, rQ.elements[9] *= u, rQ.elements[10] *= u, t.setFromRotationMatrix(rQ), n.x = i, n.y = s, n.z = a, this
                }
                makePerspective(e, t, n, r, i, s, a = nI) {
                    let o, l;
                    let u = this.elements;
                    if (a === nI) o = -(s + i) / (s - i), l = -2 * s * i / (s - i);
                    else if (a === nM) o = -s / (s - i), l = -s * i / (s - i);
                    else throw Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                    return u[0] = 2 * i / (t - e), u[4] = 0, u[8] = (t + e) / (t - e), u[12] = 0, u[1] = 0, u[5] = 2 * i / (n - r), u[9] = (n + r) / (n - r), u[13] = 0, u[2] = 0, u[6] = 0, u[10] = o, u[14] = l, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this
                }
                makeOrthographic(e, t, n, r, i, s, a = nI) {
                    let o, l;
                    let u = this.elements,
                        c = 1 / (t - e),
                        h = 1 / (n - r),
                        d = 1 / (s - i);
                    if (a === nI) o = (s + i) * d, l = -2 * d;
                    else if (a === nM) o = i * d, l = -1 * d;
                    else throw Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -((t + e) * c), u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -((n + r) * h), u[2] = 0, u[6] = 0, u[10] = l, u[14] = -o, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this
                }
                equals(e) {
                    let t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    let n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }
            let rk = new rl,
                rQ = new rF,
                rG = new rl(0, 0, 0),
                rz = new rl(1, 1, 1),
                rH = new rl,
                rV = new rl,
                rj = new rl,
                rW = new rF,
                rY = new ro;
            class rX {
                constructor(e = 0, t = 0, n = 0, r = rX.DEFAULT_ORDER) {
                    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, n, r = this._order) {
                    return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t = this._order, n = !0) {
                    let r = e.elements,
                        i = r[0],
                        s = r[4],
                        a = r[8],
                        o = r[1],
                        l = r[5],
                        u = r[9],
                        c = r[2],
                        h = r[6],
                        d = r[10];
                    switch (t) {
                        case "XYZ":
                            this._y = Math.asin(nO(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(h, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-nO(u, -1, 1)), .9999999 > Math.abs(u) ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, i), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(nO(h, -1, 1)), .9999999 > Math.abs(h) ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, i));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-nO(c, -1, 1)), .9999999 > Math.abs(c) ? (this._x = Math.atan2(h, d), this._z = Math.atan2(o, i)) : (this._x = 0, this._z = Math.atan2(-s, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(nO(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-c, i)) : (this._x = 0, this._y = Math.atan2(a, d));
                            break;
                        case "XZY":
                            this._z = Math.asin(-nO(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(h, l), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-u, d), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t, !0 === n && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, n) {
                    return rW.makeRotationFromQuaternion(e), this.setFromRotationMatrix(rW, t, n)
                }
                setFromVector3(e, t = this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return rY.setFromEuler(this), this.setFromQuaternion(rY, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._order
                }
            }
            rX.DEFAULT_ORDER = "XYZ";
            class rq {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = (1 << e | 0) >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return (this.mask & e.mask) != 0
                }
                isEnabled(e) {
                    return (this.mask & (1 << e | 0)) != 0
                }
            }
            let rK = 0,
                rJ = new rl,
                rZ = new ro,
                r$ = new rF,
                r0 = new rl,
                r1 = new rl,
                r2 = new rl,
                r3 = new ro,
                r4 = new rl(1, 0, 0),
                r5 = new rl(0, 1, 0),
                r6 = new rl(0, 0, 1),
                r8 = {
                    type: "added"
                },
                r9 = {
                    type: "removed"
                },
                r7 = {
                    type: "childadded",
                    child: null
                },
                ie = {
                    type: "childremoved",
                    child: null
                };
            class it extends nT {
                constructor() {
                    super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                        value: rK++
                    }), this.uuid = nP(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = it.DEFAULT_UP.clone();
                    let e = new rl,
                        t = new rX,
                        n = new ro,
                        r = new rl(1, 1, 1);
                    t._onChange(function() {
                        n.setFromEuler(t, !1)
                    }), n._onChange(function() {
                        t.setFromQuaternion(n, void 0, !1)
                    }), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: r
                        },
                        modelViewMatrix: {
                            value: new rF
                        },
                        normalMatrix: {
                            value: new nz
                        }
                    }), this.matrix = new rF, this.matrixWorld = new rF, this.matrixAutoUpdate = it.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = it.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new rq, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeShadow() {}
                onAfterShadow() {}
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e), this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return rZ.setFromAxisAngle(e, t), this.quaternion.multiply(rZ), this
                }
                rotateOnWorldAxis(e, t) {
                    return rZ.setFromAxisAngle(e, t), this.quaternion.premultiply(rZ), this
                }
                rotateX(e) {
                    return this.rotateOnAxis(r4, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(r5, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(r6, e)
                }
                translateOnAxis(e, t) {
                    return rJ.copy(e).applyQuaternion(this.quaternion), this.position.add(rJ.multiplyScalar(t)), this
                }
                translateX(e) {
                    return this.translateOnAxis(r4, e)
                }
                translateY(e) {
                    return this.translateOnAxis(r5, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(r6, e)
                }
                localToWorld(e) {
                    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(r$.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, n) {
                    e.isVector3 ? r0.copy(e) : r0.set(e, t, n);
                    let r = this.parent;
                    this.updateWorldMatrix(!0, !1), r1.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? r$.lookAt(r1, r0, this.up) : r$.lookAt(r0, r1, this.up), this.quaternion.setFromRotationMatrix(r$), r && (r$.extractRotation(r.matrixWorld), rZ.setFromRotationMatrix(r$), this.quaternion.premultiply(rZ.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(r8), r7.child = e, this.dispatchEvent(r7), r7.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    let t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(r9), ie.child = e, this.dispatchEvent(ie), ie.child = null), this
                }
                removeFromParent() {
                    let e = this.parent;
                    return null !== e && e.remove(this), this
                }
                clear() {
                    return this.remove(...this.children)
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1), r$.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), r$.multiply(e.parent.matrixWorld)), e.applyMatrix4(r$), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(r8), r7.child = e, this.dispatchEvent(r7), r7.child = null, this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t) return this;
                    for (let n = 0, r = this.children.length; n < r; n++) {
                        let r = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== r) return r
                    }
                }
                getObjectsByProperty(e, t, n = []) {
                    this[e] === t && n.push(this);
                    let r = this.children;
                    for (let i = 0, s = r.length; i < s; i++) r[i].getObjectsByProperty(e, t, n);
                    return n
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(r1, e, r2), e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(r1, r3, e), e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    let t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    let t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    let t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                }
                traverseAncestors(e) {
                    let t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
                    let t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
                }
                updateWorldMatrix(e, t) {
                    let n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) {
                        let e = this.children;
                        for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, n.metadata = {
                        version: 4.6,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    let r = {};

                    function i(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map(e => ({
                            boxInitialized: e.boxInitialized,
                            boxMin: e.box.min.toArray(),
                            boxMax: e.box.max.toArray(),
                            sphereInitialized: e.sphereInitialized,
                            sphereRadius: e.sphere.radius,
                            sphereCenter: e.sphere.center.toArray()
                        })), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), null !== this._colorsTexture && (r.colorsTexture = this._colorsTexture.toJSON(e)), null !== this.boundingSphere && (r.boundingSphere = {
                            center: r.boundingSphere.center.toArray(),
                            radius: r.boundingSphere.radius
                        }), null !== this.boundingBox && (r.boundingBox = {
                            min: r.boundingBox.min.toArray(),
                            max: r.boundingBox.max.toArray()
                        })), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(e.geometries, this.geometry);
                        let t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            let n = t.shapes;
                            if (Array.isArray(n))
                                for (let t = 0, r = n.length; t < r; t++) {
                                    let r = n[t];
                                    i(e.shapes, r)
                                } else i(e.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
                        if (Array.isArray(this.material)) {
                            let t = [];
                            for (let n = 0, r = this.material.length; n < r; n++) t.push(i(e.materials, this.material[n]));
                            r.material = t
                        } else r.material = i(e.materials, this.material)
                    }
                    if (this.children.length > 0) {
                        r.children = [];
                        for (let t = 0; t < this.children.length; t++) r.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        r.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            let n = this.animations[t];
                            r.animations.push(i(e.animations, n))
                        }
                    }
                    if (t) {
                        let t = s(e.geometries),
                            r = s(e.materials),
                            i = s(e.textures),
                            a = s(e.images),
                            o = s(e.shapes),
                            l = s(e.skeletons),
                            u = s(e.animations),
                            c = s(e.nodes);
                        t.length > 0 && (n.geometries = t), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), u.length > 0 && (n.animations = u), c.length > 0 && (n.nodes = c)
                    }
                    return n.object = r, n;

                    function s(e) {
                        let t = [];
                        for (let n in e) {
                            let r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                }
                clone(e) {
                    return new this.constructor().copy(this, e)
                }
                copy(e, t = !0) {
                    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            let n = e.children[t];
                            this.add(n.clone())
                        }
                    return this
                }
            }
            it.DEFAULT_UP = new rl(0, 1, 0), it.DEFAULT_MATRIX_AUTO_UPDATE = !0, it.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
            let ir = new rl,
                ii = new rl,
                is = new rl,
                ia = new rl,
                io = new rl,
                il = new rl,
                iu = new rl,
                ic = new rl,
                ih = new rl,
                id = new rl,
                ip = new re,
                ig = new re,
                iA = new re;
            class im {
                constructor(e = new rl, t = new rl, n = new rl) {
                    this.a = e, this.b = t, this.c = n
                }
                static getNormal(e, t, n, r) {
                    r.subVectors(n, t), ir.subVectors(e, t), r.cross(ir);
                    let i = r.lengthSq();
                    return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, r, i) {
                    ir.subVectors(r, t), ii.subVectors(n, t), is.subVectors(e, t);
                    let s = ir.dot(ir),
                        a = ir.dot(ii),
                        o = ir.dot(is),
                        l = ii.dot(ii),
                        u = ii.dot(is),
                        c = s * l - a * a;
                    if (0 === c) return i.set(0, 0, 0), null;
                    let h = 1 / c,
                        d = (l * o - a * u) * h,
                        f = (s * u - a * o) * h;
                    return i.set(1 - d - f, f, d)
                }
                static containsPoint(e, t, n, r) {
                    return null !== this.getBarycoord(e, t, n, r, ia) && ia.x >= 0 && ia.y >= 0 && ia.x + ia.y <= 1
                }
                static getInterpolation(e, t, n, r, i, s, a, o) {
                    return null === this.getBarycoord(e, t, n, r, ia) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(i, ia.x), o.addScaledVector(s, ia.y), o.addScaledVector(a, ia.z), o)
                }
                static getInterpolatedAttribute(e, t, n, r, i, s) {
                    return ip.setScalar(0), ig.setScalar(0), iA.setScalar(0), ip.fromBufferAttribute(e, t), ig.fromBufferAttribute(e, n), iA.fromBufferAttribute(e, r), s.setScalar(0), s.addScaledVector(ip, i.x), s.addScaledVector(ig, i.y), s.addScaledVector(iA, i.z), s
                }
                static isFrontFacing(e, t, n, r) {
                    return ir.subVectors(n, t), ii.subVectors(e, t), 0 > ir.cross(ii).dot(r)
                }
                set(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                }
                setFromPointsAndIndices(e, t, n, r) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                }
                setFromAttributeAndIndices(e, t, n, r) {
                    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return ir.subVectors(this.c, this.b), ii.subVectors(this.a, this.b), .5 * ir.cross(ii).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return im.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return im.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getInterpolation(e, t, n, r, i) {
                    return im.getInterpolation(e, this.a, this.b, this.c, t, n, r, i)
                }
                containsPoint(e) {
                    return im.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return im.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    let n, r;
                    let i = this.a,
                        s = this.b,
                        a = this.c;
                    io.subVectors(s, i), il.subVectors(a, i), ic.subVectors(e, i);
                    let o = io.dot(ic),
                        l = il.dot(ic);
                    if (o <= 0 && l <= 0) return t.copy(i);
                    ih.subVectors(e, s);
                    let u = io.dot(ih),
                        c = il.dot(ih);
                    if (u >= 0 && c <= u) return t.copy(s);
                    let h = o * c - u * l;
                    if (h <= 0 && o >= 0 && u <= 0) return n = o / (o - u), t.copy(i).addScaledVector(io, n);
                    id.subVectors(e, a);
                    let d = io.dot(id),
                        f = il.dot(id);
                    if (f >= 0 && d <= f) return t.copy(a);
                    let p = d * l - o * f;
                    if (p <= 0 && l >= 0 && f <= 0) return r = l / (l - f), t.copy(i).addScaledVector(il, r);
                    let g = u * f - d * c;
                    if (g <= 0 && c - u >= 0 && d - f >= 0) return iu.subVectors(a, s), r = (c - u) / (c - u + (d - f)), t.copy(s).addScaledVector(iu, r);
                    let A = 1 / (g + p + h);
                    return n = p * A, r = h * A, t.copy(i).addScaledVector(io, n).addScaledVector(il, r)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            let iv = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                iy = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                ix = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function iE(e, t, n) {
                return (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6) ? e + (t - e) * 6 * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e
            }
            class i_ {
                constructor(e, t, n) {
                    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
                }
                set(e, t, n) {
                    return void 0 === t && void 0 === n ? e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e) : this.setRGB(e, t, n), this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e, t = tX) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, n1.toWorkingColorSpace(this, t), this
                }
                setRGB(e, t, n, r = n1.workingColorSpace) {
                    return this.r = e, this.g = t, this.b = n, n1.toWorkingColorSpace(this, r), this
                }
                setHSL(e, t, n, r = n1.workingColorSpace) {
                    if (e = nN(e, 1), t = nO(t, 0, 1), n = nO(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                    else {
                        let r = n <= .5 ? n * (1 + t) : n + t - n * t,
                            i = 2 * n - r;
                        this.r = iE(i, r, e + 1 / 3), this.g = iE(i, r, e), this.b = iE(i, r, e - 1 / 3)
                    }
                    return n1.toWorkingColorSpace(this, r), this
                }
                setStyle(e, t = tX) {
                    let n;

                    function r(t) {
                        void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                        let i;
                        let s = n[1],
                            a = n[2];
                        switch (s) {
                            case "rgb":
                            case "rgba":
                                if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(i[4]), this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, t);
                                if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(i[4]), this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, t);
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(i[4]), this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, t);
                                break;
                            default:
                                console.warn("THREE.Color: Unknown color model " + e)
                        }
                    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        let r = n[1],
                            i = r.length;
                        if (3 === i) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
                        if (6 === i) return this.setHex(parseInt(r, 16), t);
                        console.warn("THREE.Color: Invalid hex color " + e)
                    } else if (e && e.length > 0) return this.setColorName(e, t);
                    return this
                }
                setColorName(e, t = tX) {
                    let n = iv[e.toLowerCase()];
                    return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copySRGBToLinear(e) {
                    return this.r = n2(e.r), this.g = n2(e.g), this.b = n2(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = n3(e.r), this.g = n3(e.g), this.b = n3(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(e = tX) {
                    return n1.fromWorkingColorSpace(ib.copy(this), e), 65536 * Math.round(nO(255 * ib.r, 0, 255)) + 256 * Math.round(nO(255 * ib.g, 0, 255)) + Math.round(nO(255 * ib.b, 0, 255))
                }
                getHexString(e = tX) {
                    return ("000000" + this.getHex(e).toString(16)).slice(-6)
                }
                getHSL(e, t = n1.workingColorSpace) {
                    let n, r;
                    n1.fromWorkingColorSpace(ib.copy(this), t);
                    let i = ib.r,
                        s = ib.g,
                        a = ib.b,
                        o = Math.max(i, s, a),
                        l = Math.min(i, s, a),
                        u = (l + o) / 2;
                    if (l === o) n = 0, r = 0;
                    else {
                        let e = o - l;
                        switch (r = u <= .5 ? e / (o + l) : e / (2 - o - l), o) {
                            case i:
                                n = (s - a) / e + (s < a ? 6 : 0);
                                break;
                            case s:
                                n = (a - i) / e + 2;
                                break;
                            case a:
                                n = (i - s) / e + 4
                        }
                        n /= 6
                    }
                    return e.h = n, e.s = r, e.l = u, e
                }
                getRGB(e, t = n1.workingColorSpace) {
                    return n1.fromWorkingColorSpace(ib.copy(this), t), e.r = ib.r, e.g = ib.g, e.b = ib.b, e
                }
                getStyle(e = tX) {
                    n1.fromWorkingColorSpace(ib.copy(this), e);
                    let t = ib.r,
                        n = ib.g,
                        r = ib.b;
                    return e !== tX ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255*t)},${Math.round(255*n)},${Math.round(255*r)})`
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(iy), this.setHSL(iy.h + e, iy.s + t, iy.l + n)
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpColors(e, t, n) {
                    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
                }
                lerpHSL(e, t) {
                    this.getHSL(iy), e.getHSL(ix);
                    let n = nU(iy.h, ix.h, t),
                        r = nU(iy.s, ix.s, t),
                        i = nU(iy.l, ix.l, t);
                    return this.setHSL(n, r, i), this
                }
                setFromVector3(e) {
                    return this.r = e.x, this.g = e.y, this.b = e.z, this
                }
                applyMatrix3(e) {
                    let t = this.r,
                        n = this.g,
                        r = this.b,
                        i = e.elements;
                    return this.r = i[0] * t + i[3] * n + i[6] * r, this.g = i[1] * t + i[4] * n + i[7] * r, this.b = i[2] * t + i[5] * n + i[8] * r, this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
                }
                toJSON() {
                    return this.getHex()
                }*[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b
                }
            }
            let ib = new i_;
            i_.NAMES = iv;
            let iw = 0;
            class iC extends nT {
                constructor() {
                    super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                        value: iw++
                    }), this.uuid = nP(), this.name = "", this.type = "Material", this.blending = b, this.side = y, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = U, this.blendDst = F, this.blendEquation = M, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new i_(0, 0, 0), this.blendAlpha = 0, this.depthFunc = J, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = no, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = t3, this.stencilZFail = t3, this.stencilZPass = t3, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                }
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (let t in e) {
                            let n = e[t];
                            if (void 0 === n) {
                                console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                                continue
                            }
                            let r = this[t];
                            if (void 0 === r) {
                                console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                                continue
                            }
                            r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n
                        }
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    let n = {
                        metadata: {
                            version: 4.6,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(e) {
                        let t = [];
                        for (let n in e) {
                            let r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (n.dispersion = this.dispersion), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== b && (n.blending = this.blending), this.side !== y && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), this.blendSrc !== U && (n.blendSrc = this.blendSrc), this.blendDst !== F && (n.blendDst = this.blendDst), this.blendEquation !== M && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), this.depthFunc !== J && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== no && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== t3 && (n.stencilFail = this.stencilFail), this.stencilZFail !== t3 && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== t3 && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
                        let t = r(e.textures),
                            i = r(e.images);
                        t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i)
                    }
                    return n
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    let t = e.clippingPlanes,
                        n = null;
                    if (null !== t) {
                        let e = t.length;
                        n = Array(e);
                        for (let r = 0; r !== e; ++r) n[r] = t[r].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                onBuild() {
                    console.warn("Material: onBuild() has been removed.")
                }
            }
            class iS extends iC {
                constructor(e) {
                    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new i_(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rX, this.combine = en, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            let iI = function() {
                let e = new ArrayBuffer(4),
                    t = new Float32Array(e),
                    n = new Uint32Array(e),
                    r = new Uint32Array(512),
                    i = new Uint32Array(512);
                for (let e = 0; e < 256; ++e) {
                    let t = e - 127;
                    t < -27 ? (r[e] = 0, r[256 | e] = 32768, i[e] = 24, i[256 | e] = 24) : t < -14 ? (r[e] = 1024 >> -t - 14, r[256 | e] = 1024 >> -t - 14 | 32768, i[e] = -t - 1, i[256 | e] = -t - 1) : t <= 15 ? (r[e] = t + 15 << 10, r[256 | e] = t + 15 << 10 | 32768, i[e] = 13, i[256 | e] = 13) : t < 128 ? (r[e] = 31744, r[256 | e] = 64512, i[e] = 24, i[256 | e] = 24) : (r[e] = 31744, r[256 | e] = 64512, i[e] = 13, i[256 | e] = 13)
                }
                let s = new Uint32Array(2048),
                    a = new Uint32Array(64),
                    o = new Uint32Array(64);
                for (let e = 1; e < 1024; ++e) {
                    let t = e << 13,
                        n = 0;
                    for (;
                        (8388608 & t) == 0;) t <<= 1, n -= 8388608;
                    t &= -8388609, n += 947912704, s[e] = t | n
                }
                for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + (e - 1024 << 13);
                for (let e = 1; e < 31; ++e) a[e] = e << 23;
                a[31] = 1199570944, a[32] = 2147483648;
                for (let e = 33; e < 63; ++e) a[e] = 2147483648 + (e - 32 << 23);
                a[63] = 3347054592;
                for (let e = 1; e < 64; ++e) 32 !== e && (o[e] = 1024);
                return {
                    floatView: t,
                    uint32View: n,
                    baseTable: r,
                    shiftTable: i,
                    mantissaTable: s,
                    exponentTable: a,
                    offsetTable: o
                }
            }();

            function iM(e) {
                Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = nO(e, -65504, 65504), iI.floatView[0] = e;
                let t = iI.uint32View[0],
                    n = t >> 23 & 511;
                return iI.baseTable[n] + ((8388607 & t) >> iI.shiftTable[n])
            }

            function iT(e) {
                let t = e >> 10;
                return iI.uint32View[0] = iI.mantissaTable[iI.offsetTable[t] + (1023 & e)] + iI.exponentTable[t], iI.floatView[0]
            }
            let iB = {
                    toHalfFloat: iM,
                    fromHalfFloat: iT
                },
                iR = new rl,
                iD = new nG;
            class iL {
                constructor(e, t, n = !1) {
                    if (Array.isArray(e)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = nA, this.updateRanges = [], this.gpuType = eQ, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
                }
                copyAt(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (let r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e), this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) iD.fromBufferAttribute(this, t), iD.applyMatrix3(e), this.setXY(t, iD.x, iD.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) iR.fromBufferAttribute(this, t), iR.applyMatrix3(e), this.setXYZ(t, iR.x, iR.y, iR.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.count; t < n; t++) iR.fromBufferAttribute(this, t), iR.applyMatrix4(e), this.setXYZ(t, iR.x, iR.y, iR.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) iR.fromBufferAttribute(this, t), iR.applyNormalMatrix(e), this.setXYZ(t, iR.x, iR.y, iR.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) iR.fromBufferAttribute(this, t), iR.transformDirection(e), this.setXYZ(t, iR.x, iR.y, iR.z);
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                getComponent(e, t) {
                    let n = this.array[e * this.itemSize + t];
                    return this.normalized && (n = nF(n, this.array)), n
                }
                setComponent(e, t, n) {
                    return this.normalized && (n = nk(n, this.array)), this.array[e * this.itemSize + t] = n, this
                }
                getX(e) {
                    let t = this.array[e * this.itemSize];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setX(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize] = t, this
                }
                getY(e) {
                    let t = this.array[e * this.itemSize + 1];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setY(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize + 1] = t, this
                }
                getZ(e) {
                    let t = this.array[e * this.itemSize + 2];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setZ(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize + 2] = t, this
                }
                getW(e) {
                    let t = this.array[e * this.itemSize + 3];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setW(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize + 3] = t, this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize, this.normalized && (t = nk(t, this.array), n = nk(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
                }
                setXYZ(e, t, n, r) {
                    return e *= this.itemSize, this.normalized && (t = nk(t, this.array), n = nk(n, this.array), r = nk(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
                }
                setXYZW(e, t, n, r, i) {
                    return e *= this.itemSize, this.normalized && (t = nk(t, this.array), n = nk(n, this.array), r = nk(r, this.array), i = nk(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    let e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name), this.usage !== nA && (e.usage = this.usage), e
                }
            }
            class iP extends iL {
                constructor(e, t, n) {
                    super(new Int8Array(e), t, n)
                }
            }
            class iO extends iL {
                constructor(e, t, n) {
                    super(new Uint8Array(e), t, n)
                }
            }
            class iN extends iL {
                constructor(e, t, n) {
                    super(new Uint8ClampedArray(e), t, n)
                }
            }
            class iU extends iL {
                constructor(e, t, n) {
                    super(new Int16Array(e), t, n)
                }
            }
            class iF extends iL {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            class ik extends iL {
                constructor(e, t, n) {
                    super(new Int32Array(e), t, n)
                }
            }
            class iQ extends iL {
                constructor(e, t, n) {
                    super(new Uint32Array(e), t, n)
                }
            }
            class iG extends iL {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0
                }
                getX(e) {
                    let t = iT(this.array[e * this.itemSize]);
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setX(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize] = iM(t), this
                }
                getY(e) {
                    let t = iT(this.array[e * this.itemSize + 1]);
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setY(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize + 1] = iM(t), this
                }
                getZ(e) {
                    let t = iT(this.array[e * this.itemSize + 2]);
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setZ(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize + 2] = iM(t), this
                }
                getW(e) {
                    let t = iT(this.array[e * this.itemSize + 3]);
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setW(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.array[e * this.itemSize + 3] = iM(t), this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize, this.normalized && (t = nk(t, this.array), n = nk(n, this.array)), this.array[e + 0] = iM(t), this.array[e + 1] = iM(n), this
                }
                setXYZ(e, t, n, r) {
                    return e *= this.itemSize, this.normalized && (t = nk(t, this.array), n = nk(n, this.array), r = nk(r, this.array)), this.array[e + 0] = iM(t), this.array[e + 1] = iM(n), this.array[e + 2] = iM(r), this
                }
                setXYZW(e, t, n, r, i) {
                    return e *= this.itemSize, this.normalized && (t = nk(t, this.array), n = nk(n, this.array), r = nk(r, this.array), i = nk(i, this.array)), this.array[e + 0] = iM(t), this.array[e + 1] = iM(n), this.array[e + 2] = iM(r), this.array[e + 3] = iM(i), this
                }
            }
            class iz extends iL {
                constructor(e, t, n) {
                    super(new Float32Array(e), t, n)
                }
            }
            let iH = 0,
                iV = new rF,
                ij = new it,
                iW = new rl,
                iY = new rh,
                iX = new rh,
                iq = new rl;
            class iK extends nT {
                constructor() {
                    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                        value: iH++
                    }), this.uuid = nP(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new(nV(e) ? iQ : iF)(e, 1) : this.index = e, this
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t, this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e], this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, n = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                }
                applyMatrix4(e) {
                    let t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    let n = this.attributes.normal;
                    if (void 0 !== n) {
                        let t = new nz().getNormalMatrix(e);
                        n.applyNormalMatrix(t), n.needsUpdate = !0
                    }
                    let r = this.attributes.tangent;
                    return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(e) {
                    return iV.makeRotationFromQuaternion(e), this.applyMatrix4(iV), this
                }
                rotateX(e) {
                    return iV.makeRotationX(e), this.applyMatrix4(iV), this
                }
                rotateY(e) {
                    return iV.makeRotationY(e), this.applyMatrix4(iV), this
                }
                rotateZ(e) {
                    return iV.makeRotationZ(e), this.applyMatrix4(iV), this
                }
                translate(e, t, n) {
                    return iV.makeTranslation(e, t, n), this.applyMatrix4(iV), this
                }
                scale(e, t, n) {
                    return iV.makeScale(e, t, n), this.applyMatrix4(iV), this
                }
                lookAt(e) {
                    return ij.lookAt(e), ij.updateMatrix(), this.applyMatrix4(ij.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(iW).negate(), this.translate(iW.x, iW.y, iW.z), this
                }
                setFromPoints(e) {
                    let t = [];
                    for (let n = 0, r = e.length; n < r; n++) {
                        let r = e[n];
                        t.push(r.x, r.y, r.z || 0)
                    }
                    return this.setAttribute("position", new iz(t, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new rh);
                    let e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) {
                        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new rl(-1 / 0, -1 / 0, -1 / 0), new rl(Infinity, Infinity, Infinity));
                        return
                    }
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                let n = t[e];
                                iY.setFromBufferAttribute(n), this.morphTargetsRelative ? (iq.addVectors(this.boundingBox.min, iY.min), this.boundingBox.expandByPoint(iq), iq.addVectors(this.boundingBox.max, iY.max), this.boundingBox.expandByPoint(iq)) : (this.boundingBox.expandByPoint(iY.min), this.boundingBox.expandByPoint(iY.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new rT);
                    let e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) {
                        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new rl, 1 / 0);
                        return
                    }
                    if (e) {
                        let n = this.boundingSphere.center;
                        if (iY.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                let n = t[e];
                                iX.setFromBufferAttribute(n), this.morphTargetsRelative ? (iq.addVectors(iY.min, iX.min), iY.expandByPoint(iq), iq.addVectors(iY.max, iX.max), iY.expandByPoint(iq)) : (iY.expandByPoint(iX.min), iY.expandByPoint(iX.max))
                            }
                        iY.getCenter(n);
                        let r = 0;
                        for (let t = 0, i = e.count; t < i; t++) iq.fromBufferAttribute(e, t), r = Math.max(r, n.distanceToSquared(iq));
                        if (t)
                            for (let i = 0, s = t.length; i < s; i++) {
                                let s = t[i],
                                    a = this.morphTargetsRelative;
                                for (let t = 0, i = s.count; t < i; t++) iq.fromBufferAttribute(s, t), a && (iW.fromBufferAttribute(e, t), iq.add(iW)), r = Math.max(r, n.distanceToSquared(iq))
                            }
                        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    let e = this.index,
                        t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) {
                        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        return
                    }
                    let n = t.position,
                        r = t.normal,
                        i = t.uv;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new iL(new Float32Array(4 * n.count), 4));
                    let s = this.getAttribute("tangent"),
                        a = [],
                        o = [];
                    for (let e = 0; e < n.count; e++) a[e] = new rl, o[e] = new rl;
                    let l = new rl,
                        u = new rl,
                        c = new rl,
                        h = new nG,
                        d = new nG,
                        f = new nG,
                        p = new rl,
                        g = new rl,
                        A = this.groups;
                    0 === A.length && (A = [{
                        start: 0,
                        count: e.count
                    }]);
                    for (let t = 0, r = A.length; t < r; ++t) {
                        let r = A[t],
                            s = r.start,
                            m = r.count;
                        for (let t = s, r = s + m; t < r; t += 3) ! function(e, t, r) {
                            l.fromBufferAttribute(n, e), u.fromBufferAttribute(n, t), c.fromBufferAttribute(n, r), h.fromBufferAttribute(i, e), d.fromBufferAttribute(i, t), f.fromBufferAttribute(i, r), u.sub(l), c.sub(l), d.sub(h), f.sub(h);
                            let s = 1 / (d.x * f.y - f.x * d.y);
                            isFinite(s) && (p.copy(u).multiplyScalar(f.y).addScaledVector(c, -d.y).multiplyScalar(s), g.copy(c).multiplyScalar(d.x).addScaledVector(u, -f.x).multiplyScalar(s), a[e].add(p), a[t].add(p), a[r].add(p), o[e].add(g), o[t].add(g), o[r].add(g))
                        }(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                    }
                    let m = new rl,
                        v = new rl,
                        y = new rl,
                        x = new rl;

                    function E(e) {
                        y.fromBufferAttribute(r, e), x.copy(y);
                        let t = a[e];
                        m.copy(t), m.sub(y.multiplyScalar(y.dot(t))).normalize(), v.crossVectors(x, t);
                        let n = v.dot(o[e]);
                        s.setXYZW(e, m.x, m.y, m.z, n < 0 ? -1 : 1)
                    }
                    for (let t = 0, n = A.length; t < n; ++t) {
                        let n = A[t],
                            r = n.start,
                            i = n.count;
                        for (let t = r, n = r + i; t < n; t += 3) E(e.getX(t + 0)), E(e.getX(t + 1)), E(e.getX(t + 2))
                    }
                }
                computeVertexNormals() {
                    let e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new iL(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                        else
                            for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                        let r = new rl,
                            i = new rl,
                            s = new rl,
                            a = new rl,
                            o = new rl,
                            l = new rl,
                            u = new rl,
                            c = new rl;
                        if (e)
                            for (let h = 0, d = e.count; h < d; h += 3) {
                                let d = e.getX(h + 0),
                                    f = e.getX(h + 1),
                                    p = e.getX(h + 2);
                                r.fromBufferAttribute(t, d), i.fromBufferAttribute(t, f), s.fromBufferAttribute(t, p), u.subVectors(s, i), c.subVectors(r, i), u.cross(c), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, f), l.fromBufferAttribute(n, p), a.add(u), o.add(u), l.add(u), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(f, o.x, o.y, o.z), n.setXYZ(p, l.x, l.y, l.z)
                            } else
                                for (let e = 0, a = t.count; e < a; e += 3) r.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), u.subVectors(s, i), c.subVectors(r, i), u.cross(c), n.setXYZ(e + 0, u.x, u.y, u.z), n.setXYZ(e + 1, u.x, u.y, u.z), n.setXYZ(e + 2, u.x, u.y, u.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                }
                normalizeNormals() {
                    let e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++) iq.fromBufferAttribute(e, t), iq.normalize(), e.setXYZ(t, iq.x, iq.y, iq.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        let n = e.array,
                            r = e.itemSize,
                            i = e.normalized,
                            s = new n.constructor(t.length * r),
                            a = 0,
                            o = 0;
                        for (let i = 0, l = t.length; i < l; i++) {
                            a = e.isInterleavedBufferAttribute ? t[i] * e.data.stride + e.offset : t[i] * r;
                            for (let e = 0; e < r; e++) s[o++] = n[a++]
                        }
                        return new iL(s, r, i)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    let t = new iK,
                        n = this.index.array,
                        r = this.attributes;
                    for (let i in r) {
                        let s = e(r[i], n);
                        t.setAttribute(i, s)
                    }
                    let i = this.morphAttributes;
                    for (let r in i) {
                        let s = [],
                            a = i[r];
                        for (let t = 0, r = a.length; t < r; t++) {
                            let r = e(a[t], n);
                            s.push(r)
                        }
                        t.morphAttributes[r] = s
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    let s = this.groups;
                    for (let e = 0, n = s.length; e < n; e++) {
                        let n = s[e];
                        t.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.6,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        let t = this.parameters;
                        for (let n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    let t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    let n = this.attributes;
                    for (let t in n) {
                        let r = n[t];
                        e.data.attributes[t] = r.toJSON(e.data)
                    }
                    let r = {},
                        i = !1;
                    for (let t in this.morphAttributes) {
                        let n = this.morphAttributes[t],
                            s = [];
                        for (let t = 0, r = n.length; t < r; t++) {
                            let r = n[t];
                            s.push(r.toJSON(e.data))
                        }
                        s.length > 0 && (r[t] = s, i = !0)
                    }
                    i && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    let s = this.groups;
                    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    let a = this.boundingSphere;
                    return null !== a && (e.data.boundingSphere = {
                        center: a.center.toArray(),
                        radius: a.radius
                    }), e
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    let t = {};
                    this.name = e.name;
                    let n = e.index;
                    null !== n && this.setIndex(n.clone(t));
                    let r = e.attributes;
                    for (let e in r) {
                        let n = r[e];
                        this.setAttribute(e, n.clone(t))
                    }
                    let i = e.morphAttributes;
                    for (let e in i) {
                        let n = [],
                            r = i[e];
                        for (let e = 0, i = r.length; e < i; e++) n.push(r[e].clone(t));
                        this.morphAttributes[e] = n
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    let s = e.groups;
                    for (let e = 0, t = s.length; e < t; e++) {
                        let t = s[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    let a = e.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    let o = e.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            let iJ = new rF,
                iZ = new rU,
                i$ = new rT,
                i0 = new rl,
                i1 = new rl,
                i2 = new rl,
                i3 = new rl,
                i4 = new rl,
                i5 = new rl,
                i6 = new rl,
                i8 = new rl;
            class i9 extends it {
                constructor(e = new iK, t = new iS) {
                    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                }
                updateMorphTargets() {
                    let e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        let n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                let t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
                getVertexPosition(e, t) {
                    let n = this.geometry,
                        r = n.attributes.position,
                        i = n.morphAttributes.position,
                        s = n.morphTargetsRelative;
                    t.fromBufferAttribute(r, e);
                    let a = this.morphTargetInfluences;
                    if (i && a) {
                        i5.set(0, 0, 0);
                        for (let n = 0, r = i.length; n < r; n++) {
                            let r = a[n],
                                o = i[n];
                            0 !== r && (i4.fromBufferAttribute(o, e), s ? i5.addScaledVector(i4, r) : i5.addScaledVector(i4.sub(t), r))
                        }
                        t.add(i5)
                    }
                    return t
                }
                raycast(e, t) {
                    let n = this.geometry,
                        r = this.material,
                        i = this.matrixWorld;
                    if (void 0 !== r) {
                        if (null === n.boundingSphere && n.computeBoundingSphere(), i$.copy(n.boundingSphere), i$.applyMatrix4(i), iZ.copy(e.ray).recast(e.near), !1 === i$.containsPoint(iZ.origin) && (null === iZ.intersectSphere(i$, i0) || iZ.origin.distanceToSquared(i0) > (e.far - e.near) ** 2) || (iJ.copy(i).invert(), iZ.copy(e.ray).applyMatrix4(iJ), null !== n.boundingBox && !1 === iZ.intersectsBox(n.boundingBox))) return;
                        this._computeIntersections(e, t, iZ)
                    }
                }
                _computeIntersections(e, t, n) {
                    let r;
                    let i = this.geometry,
                        s = this.material,
                        a = i.index,
                        o = i.attributes.position,
                        l = i.attributes.uv,
                        u = i.attributes.uv1,
                        c = i.attributes.normal,
                        h = i.groups,
                        d = i.drawRange;
                    if (null !== a) {
                        if (Array.isArray(s))
                            for (let i = 0, o = h.length; i < o; i++) {
                                let o = h[i],
                                    f = s[o.materialIndex],
                                    p = Math.max(o.start, d.start),
                                    g = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count));
                                for (let i = p; i < g; i += 3)(r = i7(this, f, e, n, l, u, c, a.getX(i), a.getX(i + 1), a.getX(i + 2))) && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = o.materialIndex, t.push(r))
                            } else {
                                let i = Math.max(0, d.start),
                                    o = Math.min(a.count, d.start + d.count);
                                for (let h = i; h < o; h += 3)(r = i7(this, s, e, n, l, u, c, a.getX(h), a.getX(h + 1), a.getX(h + 2))) && (r.faceIndex = Math.floor(h / 3), t.push(r))
                            }
                    } else if (void 0 !== o) {
                        if (Array.isArray(s))
                            for (let i = 0, a = h.length; i < a; i++) {
                                let a = h[i],
                                    f = s[a.materialIndex],
                                    p = Math.max(a.start, d.start),
                                    g = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count));
                                for (let i = p; i < g; i += 3)(r = i7(this, f, e, n, l, u, c, i, i + 1, i + 2)) && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = a.materialIndex, t.push(r))
                            } else {
                                let i = Math.max(0, d.start),
                                    a = Math.min(o.count, d.start + d.count);
                                for (let o = i; o < a; o += 3)(r = i7(this, s, e, n, l, u, c, o, o + 1, o + 2)) && (r.faceIndex = Math.floor(o / 3), t.push(r))
                            }
                    }
                }
            }

            function i7(e, t, n, r, i, s, a, o, l, u) {
                e.getVertexPosition(o, i1), e.getVertexPosition(l, i2), e.getVertexPosition(u, i3);
                let c = function(e, t, n, r, i, s, a, o) {
                    if (null === (t.side === x ? r.intersectTriangle(a, s, i, !0, o) : r.intersectTriangle(i, s, a, t.side === y, o))) return null;
                    i8.copy(o), i8.applyMatrix4(e.matrixWorld);
                    let l = n.ray.origin.distanceTo(i8);
                    return l < n.near || l > n.far ? null : {
                        distance: l,
                        point: i8.clone(),
                        object: e
                    }
                }(e, t, n, r, i1, i2, i3, i6);
                if (c) {
                    let e = new rl;
                    im.getBarycoord(i6, i1, i2, i3, e), i && (c.uv = im.getInterpolatedAttribute(i, o, l, u, e, new nG)), s && (c.uv1 = im.getInterpolatedAttribute(s, o, l, u, e, new nG)), a && (c.normal = im.getInterpolatedAttribute(a, o, l, u, e, new rl), c.normal.dot(r.direction) > 0 && c.normal.multiplyScalar(-1));
                    let t = {
                        a: o,
                        b: l,
                        c: u,
                        normal: new rl,
                        materialIndex: 0
                    };
                    im.getNormal(i1, i2, i3, t.normal), c.face = t, c.barycoord = e
                }
                return c
            }
            class se extends iK {
                constructor(e = 1, t = 1, n = 1, r = 1, i = 1, s = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: s
                    };
                    let a = this;
                    r = Math.floor(r), i = Math.floor(i);
                    let o = [],
                        l = [],
                        u = [],
                        c = [],
                        h = 0,
                        d = 0;

                    function f(e, t, n, r, i, s, f, p, g, A, m) {
                        let v = s / g,
                            y = f / A,
                            x = s / 2,
                            E = f / 2,
                            _ = p / 2,
                            b = g + 1,
                            w = A + 1,
                            C = 0,
                            S = 0,
                            I = new rl;
                        for (let s = 0; s < w; s++) {
                            let a = s * y - E;
                            for (let o = 0; o < b; o++) {
                                let h = o * v - x;
                                I[e] = h * r, I[t] = a * i, I[n] = _, l.push(I.x, I.y, I.z), I[e] = 0, I[t] = 0, I[n] = p > 0 ? 1 : -1, u.push(I.x, I.y, I.z), c.push(o / g), c.push(1 - s / A), C += 1
                            }
                        }
                        for (let e = 0; e < A; e++)
                            for (let t = 0; t < g; t++) {
                                let n = h + t + b * e,
                                    r = h + t + b * (e + 1),
                                    i = h + (t + 1) + b * (e + 1),
                                    s = h + (t + 1) + b * e;
                                o.push(n, r, s), o.push(r, i, s), S += 6
                            }
                        a.addGroup(d, S, m), d += S, h += C
                    }
                    f("z", "y", "x", -1, -1, n, t, e, s = Math.floor(s), i, 0), f("z", "y", "x", 1, -1, n, t, -e, s, i, 1), f("x", "z", "y", 1, 1, e, n, t, r, s, 2), f("x", "z", "y", 1, -1, e, n, -t, r, s, 3), f("x", "y", "z", 1, -1, e, t, n, r, i, 4), f("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(o), this.setAttribute("position", new iz(l, 3)), this.setAttribute("normal", new iz(u, 3)), this.setAttribute("uv", new iz(c, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new se(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                }
            }

            function st(e) {
                let t = {};
                for (let n in e)
                    for (let r in t[n] = {}, e[n]) {
                        let i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[n][r] = null) : t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                return t
            }

            function sn(e) {
                let t = {};
                for (let n = 0; n < e.length; n++) {
                    let r = st(e[n]);
                    for (let e in r) t[e] = r[e]
                }
                return t
            }

            function sr(e) {
                let t = e.getRenderTarget();
                return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : n1.workingColorSpace
            }
            let si = {
                clone: st,
                merge: sn
            };
            class ss extends iC {
                constructor(e) {
                    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                        clipCullDistance: !1,
                        multiDraw: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv1: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = st(e.uniforms), this.uniformsGroups = function(e) {
                        let t = [];
                        for (let n = 0; n < e.length; n++) t.push(e[n].clone());
                        return t
                    }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    for (let n in t.glslVersion = this.glslVersion, t.uniforms = {}, this.uniforms) {
                        let r = this.uniforms[n].value;
                        r && r.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: r.toJSON(e).uuid
                        } : r && r.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: r.getHex()
                        } : r && r.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: r.toArray()
                        } : r && r.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: r.toArray()
                        } : r && r.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: r.toArray()
                        } : r && r.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: r.toArray()
                        } : r && r.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: r.toArray()
                        } : t.uniforms[n] = {
                            value: r
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
                    let n = {};
                    for (let e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
                    return Object.keys(n).length > 0 && (t.extensions = n), t
                }
            }
            class sa extends it {
                constructor() {
                    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new rF, this.projectionMatrix = new rF, this.projectionMatrixInverse = new rF, this.coordinateSystem = nI
                }
                copy(e, t) {
                    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
                }
                getWorldDirection(e) {
                    return super.getWorldDirection(e).negate()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let so = new rl,
                sl = new nG,
                su = new nG;
            class sc extends sa {
                constructor(e = 50, t = 1, n = .1, r = 2e3) {
                    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                }
                setFocalLength(e) {
                    let t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * nL * Math.atan(t), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    let e = Math.tan(.5 * nD * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * nL * Math.atan(Math.tan(.5 * nD * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                getViewBounds(e, t, n) {
                    so.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(so.x, so.y).multiplyScalar(-e / so.z), so.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(so.x, so.y).multiplyScalar(-e / so.z)
                }
                getViewSize(e, t) {
                    return this.getViewBounds(e, sl, su), t.subVectors(su, sl)
                }
                setViewOffset(e, t, n, r, i, s) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let e = this.near,
                        t = e * Math.tan(.5 * nD * this.fov) / this.zoom,
                        n = 2 * t,
                        r = this.aspect * n,
                        i = -.5 * r,
                        s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        let e = s.fullWidth,
                            a = s.fullHeight;
                        i += s.offsetX * r / e, t -= s.offsetY * n / a, r *= s.width / e, n *= s.height / a
                    }
                    let a = this.filmOffset;
                    0 !== a && (i += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }
            class sh extends it {
                constructor(e, t, n) {
                    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                    let r = new sc(-90, 1, e, t);
                    r.layers = this.layers, this.add(r);
                    let i = new sc(-90, 1, e, t);
                    i.layers = this.layers, this.add(i);
                    let s = new sc(-90, 1, e, t);
                    s.layers = this.layers, this.add(s);
                    let a = new sc(-90, 1, e, t);
                    a.layers = this.layers, this.add(a);
                    let o = new sc(-90, 1, e, t);
                    o.layers = this.layers, this.add(o);
                    let l = new sc(-90, 1, e, t);
                    l.layers = this.layers, this.add(l)
                }
                updateCoordinateSystem() {
                    let e = this.coordinateSystem,
                        t = this.children.concat(),
                        [n, r, i, s, a, o] = t;
                    for (let e of t) this.remove(e);
                    if (e === nI) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), i.up.set(0, 0, -1), i.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);
                    else if (e === nM) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), i.up.set(0, 0, 1), i.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1);
                    else throw Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                    for (let e of t) this.add(e), e.updateMatrixWorld()
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    let {
                        renderTarget: n,
                        activeMipmapLevel: r
                    } = this;
                    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
                    let [i, s, a, o, l, u] = this.children, c = e.getRenderTarget(), h = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), f = e.xr.enabled;
                    e.xr.enabled = !1;
                    let p = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, r), e.render(t, i), e.setRenderTarget(n, 1, r), e.render(t, s), e.setRenderTarget(n, 2, r), e.render(t, a), e.setRenderTarget(n, 3, r), e.render(t, o), e.setRenderTarget(n, 4, r), e.render(t, l), n.texture.generateMipmaps = p, e.setRenderTarget(n, 5, r), e.render(t, u), e.setRenderTarget(c, h, d), e.xr.enabled = f, n.texture.needsPMREMUpdate = !0
                }
            }
            class sd extends n7 {
                constructor(e, t, n, r, i, s, a, o, l, u) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : eA, n, r, i, s, a, o, l, u), this.isCubeTexture = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class sf extends rn {
                constructor(e = 1, t = {}) {
                    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                    let n = {
                        width: e,
                        height: e,
                        depth: 1
                    };
                    this.texture = new sd([n, n, n, n, n, n], t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : eT
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                    let n = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        },
                        r = new se(5, 5, 5),
                        i = new ss({
                            name: "CubemapFromEquirect",
                            uniforms: st(n.uniforms),
                            vertexShader: n.vertexShader,
                            fragmentShader: n.fragmentShader,
                            side: x,
                            blending: _
                        });
                    i.uniforms.tEquirect.value = t;
                    let s = new i9(r, i),
                        a = t.minFilter;
                    return t.minFilter === eD && (t.minFilter = eT), new sh(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
                }
                clear(e, t, n, r) {
                    let i = e.getRenderTarget();
                    for (let i = 0; i < 6; i++) e.setRenderTarget(this, i), e.clear(t, n, r);
                    e.setRenderTarget(i)
                }
            }
            let sp = new rl,
                sg = new rl,
                sA = new nz;
            class sm {
                constructor(e = new rl(1, 0, 0), t = 0) {
                    this.isPlane = !0, this.normal = e, this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, n, r) {
                    return this.normal.set(e, t, n), this.constant = r, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, n) {
                    let r = sp.subVectors(n, t).cross(sg.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(r, e), this
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    let e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                }
                intersectLine(e, t) {
                    let n = e.delta(sp),
                        r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    let i = -(e.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || i > 1 ? null : t.copy(e.start).addScaledVector(n, i)
                }
                intersectsLine(e) {
                    let t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    let n = t || sA.getNormalMatrix(e),
                        r = this.coplanarPoint(sp).applyMatrix4(e),
                        i = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -r.dot(i), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let sv = new rT,
                sy = new rl;
            class sx {
                constructor(e = new sm, t = new sm, n = new sm, r = new sm, i = new sm, s = new sm) {
                    this.planes = [e, t, n, r, i, s]
                }
                set(e, t, n, r, i, s) {
                    let a = this.planes;
                    return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(s), this
                }
                copy(e) {
                    let t = this.planes;
                    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e, t = nI) {
                    let n = this.planes,
                        r = e.elements,
                        i = r[0],
                        s = r[1],
                        a = r[2],
                        o = r[3],
                        l = r[4],
                        u = r[5],
                        c = r[6],
                        h = r[7],
                        d = r[8],
                        f = r[9],
                        p = r[10],
                        g = r[11],
                        A = r[12],
                        m = r[13],
                        v = r[14],
                        y = r[15];
                    if (n[0].setComponents(o - i, h - l, g - d, y - A).normalize(), n[1].setComponents(o + i, h + l, g + d, y + A).normalize(), n[2].setComponents(o + s, h + u, g + f, y + m).normalize(), n[3].setComponents(o - s, h - u, g - f, y - m).normalize(), n[4].setComponents(o - a, h - c, g - p, y - v).normalize(), t === nI) n[5].setComponents(o + a, h + c, g + p, y + v).normalize();
                    else if (t === nM) n[5].setComponents(a, c, p, v).normalize();
                    else throw Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                    return this
                }
                intersectsObject(e) {
                    if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), sv.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                    else {
                        let t = e.geometry;
                        null === t.boundingSphere && t.computeBoundingSphere(), sv.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                    }
                    return this.intersectsSphere(sv)
                }
                intersectsSprite(e) {
                    return sv.center.set(0, 0, 0), sv.radius = .7071067811865476, sv.applyMatrix4(e.matrixWorld), this.intersectsSphere(sv)
                }
                intersectsSphere(e) {
                    let t = this.planes,
                        n = e.center,
                        r = -e.radius;
                    for (let e = 0; e < 6; e++)
                        if (t[e].distanceToPoint(n) < r) return !1;
                    return !0
                }
                intersectsBox(e) {
                    let t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        let r = t[n];
                        if (sy.x = r.normal.x > 0 ? e.max.x : e.min.x, sy.y = r.normal.y > 0 ? e.max.y : e.min.y, sy.z = r.normal.z > 0 ? e.max.z : e.min.z, 0 > r.distanceToPoint(sy)) return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    let t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (0 > t[n].distanceToPoint(e)) return !1;
                    return !0
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }

            function sE() {
                let e = null,
                    t = !1,
                    n = null,
                    r = null;

                function i(t, s) {
                    n(t, s), r = e.requestAnimationFrame(i)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(r), t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function s_(e) {
                let t = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        let r = t.get(n);
                        r && (e.deleteBuffer(r.buffer), t.delete(n))
                    },
                    update: function(n, r) {
                        if (n.isInterleavedBufferAttribute && (n = n.data), n.isGLBufferAttribute) {
                            let e = t.get(n);
                            (!e || e.version < n.version) && t.set(n, {
                                buffer: n.buffer,
                                type: n.type,
                                bytesPerElement: n.elementSize,
                                version: n.version
                            });
                            return
                        }
                        let i = t.get(n);
                        if (void 0 === i) t.set(n, function(t, n) {
                            let r;
                            let i = t.array,
                                s = t.usage,
                                a = i.byteLength,
                                o = e.createBuffer();
                            if (e.bindBuffer(n, o), e.bufferData(n, i, s), t.onUploadCallback(), i instanceof Float32Array) r = e.FLOAT;
                            else if (i instanceof Uint16Array) r = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                            else if (i instanceof Int16Array) r = e.SHORT;
                            else if (i instanceof Uint32Array) r = e.UNSIGNED_INT;
                            else if (i instanceof Int32Array) r = e.INT;
                            else if (i instanceof Int8Array) r = e.BYTE;
                            else if (i instanceof Uint8Array) r = e.UNSIGNED_BYTE;
                            else if (i instanceof Uint8ClampedArray) r = e.UNSIGNED_BYTE;
                            else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                            return {
                                buffer: o,
                                type: r,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version,
                                size: a
                            }
                        }(n, r));
                        else if (i.version < n.version) {
                            if (i.size !== n.array.byteLength) throw Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            ! function(t, n, r) {
                                let i = n.array,
                                    s = n.updateRanges;
                                if (e.bindBuffer(r, t), 0 === s.length) e.bufferSubData(r, 0, i);
                                else {
                                    s.sort((e, t) => e.start - t.start);
                                    let t = 0;
                                    for (let e = 1; e < s.length; e++) {
                                        let n = s[t],
                                            r = s[e];
                                        r.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, r.start + r.count - n.start) : s[++t] = r
                                    }
                                    s.length = t + 1;
                                    for (let t = 0, n = s.length; t < n; t++) {
                                        let n = s[t];
                                        e.bufferSubData(r, n.start * i.BYTES_PER_ELEMENT, i, n.start, n.count)
                                    }
                                    n.clearUpdateRanges()
                                }
                                n.onUploadCallback()
                            }(i.buffer, n, r), i.version = n.version
                        }
                    }
                }
            }
            class sb extends iK {
                constructor(e = 1, t = 1, n = 1, r = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: r
                    };
                    let i = e / 2,
                        s = t / 2,
                        a = Math.floor(n),
                        o = Math.floor(r),
                        l = a + 1,
                        u = o + 1,
                        c = e / a,
                        h = t / o,
                        d = [],
                        f = [],
                        p = [],
                        g = [];
                    for (let e = 0; e < u; e++) {
                        let t = e * h - s;
                        for (let n = 0; n < l; n++) {
                            let r = n * c - i;
                            f.push(r, -t, 0), p.push(0, 0, 1), g.push(n / a), g.push(1 - e / o)
                        }
                    }
                    for (let e = 0; e < o; e++)
                        for (let t = 0; t < a; t++) {
                            let n = t + l * e,
                                r = t + l * (e + 1),
                                i = t + 1 + l * (e + 1),
                                s = t + 1 + l * e;
                            d.push(n, r, s), d.push(r, i, s)
                        }
                    this.setIndex(d), this.setAttribute("position", new iz(f, 3)), this.setAttribute("normal", new iz(p, 3)), this.setAttribute("uv", new iz(g, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new sb(e.width, e.height, e.widthSegments, e.heightSegments)
                }
            }
            let sw = {
                    alphahash_fragment: "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                    alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif",
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
                    batching_pars_vertex: "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif",
                    batching_vertex: "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated",
                    iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
                    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
                    envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
                    lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                    lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
                    map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
                    morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif",
                    morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                    normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif",
                    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif",
                    opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif",
                    shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
                    shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif",
                    uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
                    uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
                    uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
                    backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
                    backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
                    depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}"
                },
                sC = {
                    common: {
                        diffuse: {
                            value: new i_(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new nz
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new nz
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new nz
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: new nz
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new nz
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new nz
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new nz
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new nz
                        },
                        normalScale: {
                            value: new nG(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new nz
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new nz
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new nz
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new nz
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new i_(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new i_(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new nz
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new nz
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new i_(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new nG(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new nz
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new nz
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                },
                sS = {
                    basic: {
                        uniforms: sn([sC.common, sC.specularmap, sC.envmap, sC.aomap, sC.lightmap, sC.fog]),
                        vertexShader: sw.meshbasic_vert,
                        fragmentShader: sw.meshbasic_frag
                    },
                    lambert: {
                        uniforms: sn([sC.common, sC.specularmap, sC.envmap, sC.aomap, sC.lightmap, sC.emissivemap, sC.bumpmap, sC.normalmap, sC.displacementmap, sC.fog, sC.lights, {
                            emissive: {
                                value: new i_(0)
                            }
                        }]),
                        vertexShader: sw.meshlambert_vert,
                        fragmentShader: sw.meshlambert_frag
                    },
                    phong: {
                        uniforms: sn([sC.common, sC.specularmap, sC.envmap, sC.aomap, sC.lightmap, sC.emissivemap, sC.bumpmap, sC.normalmap, sC.displacementmap, sC.fog, sC.lights, {
                            emissive: {
                                value: new i_(0)
                            },
                            specular: {
                                value: new i_(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: sw.meshphong_vert,
                        fragmentShader: sw.meshphong_frag
                    },
                    standard: {
                        uniforms: sn([sC.common, sC.envmap, sC.aomap, sC.lightmap, sC.emissivemap, sC.bumpmap, sC.normalmap, sC.displacementmap, sC.roughnessmap, sC.metalnessmap, sC.fog, sC.lights, {
                            emissive: {
                                value: new i_(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: sw.meshphysical_vert,
                        fragmentShader: sw.meshphysical_frag
                    },
                    toon: {
                        uniforms: sn([sC.common, sC.aomap, sC.lightmap, sC.emissivemap, sC.bumpmap, sC.normalmap, sC.displacementmap, sC.gradientmap, sC.fog, sC.lights, {
                            emissive: {
                                value: new i_(0)
                            }
                        }]),
                        vertexShader: sw.meshtoon_vert,
                        fragmentShader: sw.meshtoon_frag
                    },
                    matcap: {
                        uniforms: sn([sC.common, sC.bumpmap, sC.normalmap, sC.displacementmap, sC.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: sw.meshmatcap_vert,
                        fragmentShader: sw.meshmatcap_frag
                    },
                    points: {
                        uniforms: sn([sC.points, sC.fog]),
                        vertexShader: sw.points_vert,
                        fragmentShader: sw.points_frag
                    },
                    dashed: {
                        uniforms: sn([sC.common, sC.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: sw.linedashed_vert,
                        fragmentShader: sw.linedashed_frag
                    },
                    depth: {
                        uniforms: sn([sC.common, sC.displacementmap]),
                        vertexShader: sw.depth_vert,
                        fragmentShader: sw.depth_frag
                    },
                    normal: {
                        uniforms: sn([sC.common, sC.bumpmap, sC.normalmap, sC.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: sw.meshnormal_vert,
                        fragmentShader: sw.meshnormal_frag
                    },
                    sprite: {
                        uniforms: sn([sC.sprite, sC.fog]),
                        vertexShader: sw.sprite_vert,
                        fragmentShader: sw.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new nz
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: sw.background_vert,
                        fragmentShader: sw.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            },
                            backgroundRotation: {
                                value: new nz
                            }
                        },
                        vertexShader: sw.backgroundCube_vert,
                        fragmentShader: sw.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: sw.cube_vert,
                        fragmentShader: sw.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: sw.equirect_vert,
                        fragmentShader: sw.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: sn([sC.common, sC.displacementmap, {
                            referencePosition: {
                                value: new rl
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: sw.distanceRGBA_vert,
                        fragmentShader: sw.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: sn([sC.lights, sC.fog, {
                            color: {
                                value: new i_(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: sw.shadow_vert,
                        fragmentShader: sw.shadow_frag
                    }
                };
            sS.physical = {
                uniforms: sn([sS.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatMapTransform: {
                        value: new nz
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    clearcoatNormalMapTransform: {
                        value: new nz
                    },
                    clearcoatNormalScale: {
                        value: new nG(1, 1)
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatRoughnessMapTransform: {
                        value: new nz
                    },
                    dispersion: {
                        value: 0
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceMapTransform: {
                        value: new nz
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    iridescenceThicknessMapTransform: {
                        value: new nz
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new i_(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenColorMapTransform: {
                        value: new nz
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    sheenRoughnessMapTransform: {
                        value: new nz
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionMapTransform: {
                        value: new nz
                    },
                    transmissionSamplerSize: {
                        value: new nG
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    thicknessMapTransform: {
                        value: new nz
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new i_(0)
                    },
                    specularColor: {
                        value: new i_(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    },
                    specularColorMapTransform: {
                        value: new nz
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularIntensityMapTransform: {
                        value: new nz
                    },
                    anisotropyVector: {
                        value: new nG
                    },
                    anisotropyMap: {
                        value: null
                    },
                    anisotropyMapTransform: {
                        value: new nz
                    }
                }]),
                vertexShader: sw.meshphysical_vert,
                fragmentShader: sw.meshphysical_frag
            };
            let sI = {
                    r: 0,
                    b: 0,
                    g: 0
                },
                sM = new rX,
                sT = new rF;

            function sB(e, t, n, r, i, s, a) {
                let o, l;
                let u = new i_(0),
                    c = !0 === s ? 0 : 1,
                    h = null,
                    d = 0,
                    f = null;

                function p(e) {
                    let r = !0 === e.isScene ? e.background : null;
                    return r && r.isTexture && (r = (e.backgroundBlurriness > 0 ? n : t).get(r)), r
                }

                function g(t, n) {
                    t.getRGB(sI, sr(e)), r.buffers.color.setClear(sI.r, sI.g, sI.b, n, a)
                }
                return {
                    getClearColor: function() {
                        return u
                    },
                    setClearColor: function(e, t = 1) {
                        u.set(e), g(u, c = t)
                    },
                    getClearAlpha: function() {
                        return c
                    },
                    setClearAlpha: function(e) {
                        g(u, c = e)
                    },
                    render: function(t) {
                        let n = !1,
                            i = p(t);
                        null === i ? g(u, c) : i && i.isColor && (g(i, 1), n = !0);
                        let s = e.xr.getEnvironmentBlendMode();
                        "additive" === s ? r.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === s && r.buffers.color.setClear(0, 0, 0, 0, a), (e.autoClear || n) && (r.buffers.depth.setTest(!0), r.buffers.depth.setMask(!0), r.buffers.color.setMask(!0), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                    },
                    addToRenderList: function(t, n) {
                        let r = p(n);
                        r && (r.isCubeTexture || r.mapping === ex) ? (void 0 === l && ((l = new i9(new se(1, 1, 1), new ss({
                            name: "BackgroundCubeMaterial",
                            uniforms: st(sS.backgroundCube.uniforms),
                            vertexShader: sS.backgroundCube.vertexShader,
                            fragmentShader: sS.backgroundCube.fragmentShader,
                            side: x,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(l.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), i.update(l)), sM.copy(n.backgroundRotation), sM.x *= -1, sM.y *= -1, sM.z *= -1, r.isCubeTexture && !1 === r.isRenderTargetTexture && (sM.y *= -1, sM.z *= -1), l.material.uniforms.envMap.value = r, l.material.uniforms.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, l.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, l.material.uniforms.backgroundRotation.value.setFromMatrix4(sT.makeRotationFromEuler(sM)), l.material.toneMapped = n1.getTransfer(r.colorSpace) !== t$, (h !== r || d !== r.version || f !== e.toneMapping) && (l.material.needsUpdate = !0, h = r, d = r.version, f = e.toneMapping), l.layers.enableAll(), t.unshift(l, l.geometry, l.material, 0, 0, null)) : r && r.isTexture && (void 0 === o && ((o = new i9(new sb(2, 2), new ss({
                            name: "BackgroundMaterial",
                            uniforms: st(sS.background.uniforms),
                            vertexShader: sS.background.vertexShader,
                            fragmentShader: sS.background.fragmentShader,
                            side: y,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), i.update(o)), o.material.uniforms.t2D.value = r, o.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, o.material.toneMapped = n1.getTransfer(r.colorSpace) !== t$, !0 === r.matrixAutoUpdate && r.updateMatrix(), o.material.uniforms.uvTransform.value.copy(r.matrix), (h !== r || d !== r.version || f !== e.toneMapping) && (o.material.needsUpdate = !0, h = r, d = r.version, f = e.toneMapping), o.layers.enableAll(), t.unshift(o, o.geometry, o.material, 0, 0, null))
                    }
                }
            }

            function sR(e, t) {
                let n = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                    r = {},
                    i = u(null),
                    s = i,
                    a = !1;

                function o(t) {
                    return e.bindVertexArray(t)
                }

                function l(t) {
                    return e.deleteVertexArray(t)
                }

                function u(e) {
                    let t = [],
                        r = [],
                        i = [];
                    for (let e = 0; e < n; e++) t[e] = 0, r[e] = 0, i[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: r,
                        attributeDivisors: i,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function c() {
                    let e = s.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++) e[t] = 0
                }

                function h(e) {
                    d(e, 0)
                }

                function d(t, n) {
                    let r = s.newAttributes,
                        i = s.enabledAttributes,
                        a = s.attributeDivisors;
                    r[t] = 1, 0 === i[t] && (e.enableVertexAttribArray(t), i[t] = 1), a[t] !== n && (e.vertexAttribDivisor(t, n), a[t] = n)
                }

                function f() {
                    let t = s.newAttributes,
                        n = s.enabledAttributes;
                    for (let r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
                }

                function p(t, n, r, i, s, a, o) {
                    !0 === o ? e.vertexAttribIPointer(t, n, r, s, a) : e.vertexAttribPointer(t, n, r, i, s, a)
                }

                function g() {
                    A(), a = !0, s !== i && o((s = i).object)
                }

                function A() {
                    i.geometry = null, i.program = null, i.wireframe = !1
                }
                return {
                    setup: function(n, i, l, g, A) {
                        let m = !1,
                            v = function(t, n, i) {
                                let s = !0 === i.wireframe,
                                    a = r[t.id];
                                void 0 === a && (a = {}, r[t.id] = a);
                                let o = a[n.id];
                                void 0 === o && (o = {}, a[n.id] = o);
                                let l = o[s];
                                return void 0 === l && (l = u(e.createVertexArray()), o[s] = l), l
                            }(g, l, i);
                        s !== v && o((s = v).object), (m = function(e, t, n, r) {
                            let i = s.attributes,
                                a = t.attributes,
                                o = 0,
                                l = n.getAttributes();
                            for (let t in l)
                                if (l[t].location >= 0) {
                                    let n = i[t],
                                        r = a[t];
                                    if (void 0 === r && ("instanceMatrix" === t && e.instanceMatrix && (r = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (r = e.instanceColor)), void 0 === n || n.attribute !== r || r && n.data !== r.data) return !0;
                                    o++
                                }
                            return s.attributesNum !== o || s.index !== r
                        }(n, g, l, A)) && function(e, t, n, r) {
                            let i = {},
                                a = t.attributes,
                                o = 0,
                                l = n.getAttributes();
                            for (let t in l)
                                if (l[t].location >= 0) {
                                    let n = a[t];
                                    void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                    let r = {};
                                    r.attribute = n, n && n.data && (r.data = n.data), i[t] = r, o++
                                }
                            s.attributes = i, s.attributesNum = o, s.index = r
                        }(n, g, l, A), null !== A && t.update(A, e.ELEMENT_ARRAY_BUFFER), (m || a) && (a = !1, function(n, r, i, s) {
                            c();
                            let a = s.attributes,
                                o = i.getAttributes(),
                                l = r.defaultAttributeValues;
                            for (let r in o) {
                                let i = o[r];
                                if (i.location >= 0) {
                                    let o = a[r];
                                    if (void 0 === o && ("instanceMatrix" === r && n.instanceMatrix && (o = n.instanceMatrix), "instanceColor" === r && n.instanceColor && (o = n.instanceColor)), void 0 !== o) {
                                        let r = o.normalized,
                                            a = o.itemSize,
                                            l = t.get(o);
                                        if (void 0 === l) continue;
                                        let u = l.buffer,
                                            c = l.type,
                                            f = l.bytesPerElement,
                                            g = c === e.INT || c === e.UNSIGNED_INT || o.gpuType === eF;
                                        if (o.isInterleavedBufferAttribute) {
                                            let t = o.data,
                                                l = t.stride,
                                                A = o.offset;
                                            if (t.isInstancedInterleavedBuffer) {
                                                for (let e = 0; e < i.locationSize; e++) d(i.location + e, t.meshPerAttribute);
                                                !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = t.meshPerAttribute * t.count)
                                            } else
                                                for (let e = 0; e < i.locationSize; e++) h(i.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, u);
                                            for (let e = 0; e < i.locationSize; e++) p(i.location + e, a / i.locationSize, c, r, l * f, (A + a / i.locationSize * e) * f, g)
                                        } else {
                                            if (o.isInstancedBufferAttribute) {
                                                for (let e = 0; e < i.locationSize; e++) d(i.location + e, o.meshPerAttribute);
                                                !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = o.meshPerAttribute * o.count)
                                            } else
                                                for (let e = 0; e < i.locationSize; e++) h(i.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, u);
                                            for (let e = 0; e < i.locationSize; e++) p(i.location + e, a / i.locationSize, c, r, a * f, a / i.locationSize * e * f, g)
                                        }
                                    } else if (void 0 !== l) {
                                        let t = l[r];
                                        if (void 0 !== t) switch (t.length) {
                                            case 2:
                                                e.vertexAttrib2fv(i.location, t);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(i.location, t);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(i.location, t);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(i.location, t)
                                        }
                                    }
                                }
                            }
                            f()
                        }(n, i, l, g), null !== A && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(A).buffer))
                    },
                    reset: g,
                    resetDefaultState: A,
                    dispose: function() {
                        for (let e in g(), r) {
                            let t = r[e];
                            for (let e in t) {
                                let n = t[e];
                                for (let e in n) l(n[e].object), delete n[e];
                                delete t[e]
                            }
                            delete r[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === r[e.id]) return;
                        let t = r[e.id];
                        for (let e in t) {
                            let n = t[e];
                            for (let e in n) l(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete r[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (let t in r) {
                            let n = r[t];
                            if (void 0 === n[e.id]) continue;
                            let i = n[e.id];
                            for (let e in i) l(i[e].object), delete i[e];
                            delete n[e.id]
                        }
                    },
                    initAttributes: c,
                    enableAttribute: h,
                    disableUnusedAttributes: f
                }
            }

            function sD(e, t, n) {
                let r;

                function i(t, i, s) {
                    0 !== s && (e.drawArraysInstanced(r, t, i, s), n.update(i, r, s))
                }
                this.setMode = function(e) {
                    r = e
                }, this.render = function(t, i) {
                    e.drawArrays(r, t, i), n.update(i, r, 1)
                }, this.renderInstances = i, this.renderMultiDraw = function(e, i, s) {
                    if (0 === s) return;
                    t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, e, 0, i, 0, s);
                    let a = 0;
                    for (let e = 0; e < s; e++) a += i[e];
                    n.update(a, r, 1)
                }, this.renderMultiDrawInstances = function(e, s, a, o) {
                    if (0 === a) return;
                    let l = t.get("WEBGL_multi_draw");
                    if (null === l)
                        for (let t = 0; t < e.length; t++) i(e[t], s[t], o[t]);
                    else {
                        l.multiDrawArraysInstancedWEBGL(r, e, 0, s, 0, o, 0, a);
                        let t = 0;
                        for (let e = 0; e < a; e++) t += s[e];
                        for (let e = 0; e < o.length; e++) n.update(t, r, o[e])
                    }
                }
            }

            function sL(e, t, n, r) {
                let i;

                function s(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                let a = void 0 !== n.precision ? n.precision : "highp",
                    o = s(a);
                o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
                let l = !0 === n.logarithmicDepthBuffer,
                    u = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control");
                if (!0 === u) {
                    let e = t.get("EXT_clip_control");
                    e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT)
                }
                let c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                    h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    d = e.getParameter(e.MAX_TEXTURE_SIZE),
                    f = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                    p = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                    g = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS);
                return {
                    isWebGL2: !0,
                    getMaxAnisotropy: function() {
                        if (void 0 !== i) return i;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            let n = t.get("EXT_texture_filter_anisotropic");
                            i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else i = 0;
                        return i
                    },
                    getMaxPrecision: s,
                    textureFormatReadable: function(t) {
                        return t === eX || r.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
                    },
                    textureTypeReadable: function(n) {
                        let i = n === eG && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                        return n === eP || r.convert(n) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) || n === eQ || !!i
                    },
                    precision: a,
                    logarithmicDepthBuffer: l,
                    reverseDepthBuffer: u,
                    maxTextures: c,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: f,
                    maxAttributes: p,
                    maxVertexUniforms: g,
                    maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
                    maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                    vertexTextures: h > 0,
                    maxSamples: e.getParameter(e.MAX_SAMPLES)
                }
            }

            function sP(e) {
                let t = this,
                    n = null,
                    r = 0,
                    i = !1,
                    s = !1,
                    a = new sm,
                    o = new nz,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function u(e, n, r, i) {
                    let s = null !== e ? e.length : 0,
                        u = null;
                    if (0 !== s) {
                        if (u = l.value, !0 !== i || null === u) {
                            let t = r + 4 * s,
                                i = n.matrixWorldInverse;
                            o.getNormalMatrix(i), (null === u || u.length < t) && (u = new Float32Array(t));
                            for (let t = 0, n = r; t !== s; ++t, n += 4) a.copy(e[t]).applyMatrix4(i, o), a.normal.toArray(u, n), u[n + 3] = a.constant
                        }
                        l.value = u, l.needsUpdate = !0
                    }
                    return t.numPlanes = s, t.numIntersection = 0, u
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t) {
                    let n = 0 !== e.length || t || 0 !== r || i;
                    return i = t, r = e.length, n
                }, this.beginShadows = function() {
                    s = !0, u(null)
                }, this.endShadows = function() {
                    s = !1
                }, this.setGlobalState = function(e, t) {
                    n = u(e, t, 0)
                }, this.setState = function(a, o, c) {
                    let h = a.clippingPlanes,
                        d = a.clipIntersection,
                        f = a.clipShadows,
                        p = e.get(a);
                    if (i && null !== h && 0 !== h.length && (!s || f)) {
                        let e = s ? 0 : r,
                            t = 4 * e,
                            i = p.clippingState || null;
                        l.value = i, i = u(h, o, t, c);
                        for (let e = 0; e !== t; ++e) i[e] = n[e];
                        p.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
                    } else s ? u(null) : (l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0)
                }
            }

            function sO(e) {
                let t = new WeakMap;

                function n(e, t) {
                    return t === ev ? e.mapping = eA : t === ey && (e.mapping = em), e
                }

                function r(e) {
                    let n = e.target;
                    n.removeEventListener("dispose", r);
                    let i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture) {
                            let s = i.mapping;
                            if (s === ev || s === ey) {
                                if (t.has(i)) return n(t.get(i).texture, i.mapping); {
                                    let s = i.image;
                                    if (!s || !(s.height > 0)) return null; {
                                        let a = new sf(s.height);
                                        return a.fromEquirectangularTexture(e, i), t.set(i, a), i.addEventListener("dispose", r), n(a.texture, i.mapping)
                                    }
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            class sN extends sa {
                constructor(e = -1, t = 1, n = 1, r = -1, i = .1, s = 2e3) {
                    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                }
                setViewOffset(e, t, n, r, i, s) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2,
                        i = n - e,
                        s = n + e,
                        a = r + t,
                        o = r - t;
                    if (null !== this.view && this.view.enabled) {
                        let e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        i += e * this.view.offsetX, s = i + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(i, s, a, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }
            let sU = [.125, .215, .35, .446, .526, .582],
                sF = new sN,
                sk = new i_,
                sQ = null,
                sG = 0,
                sz = 0,
                sH = !1,
                sV = (1 + Math.sqrt(5)) / 2,
                sj = 1 / sV,
                sW = [new rl(-sV, sj, 0), new rl(sV, sj, 0), new rl(-sj, 0, sV), new rl(sj, 0, sV), new rl(0, sV, -sj), new rl(0, sV, sj), new rl(-1, 1, -1), new rl(1, 1, -1), new rl(-1, 1, 1), new rl(1, 1, 1)];
            class sY {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, n = .1, r = 100) {
                    sQ = this._renderer.getRenderTarget(), sG = this._renderer.getActiveCubeFace(), sz = this._renderer.getActiveMipmapLevel(), sH = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
                    let i = this._allocateTargets();
                    return i.depthBuffer = !0, this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i
                }
                fromEquirectangular(e, t = null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t = null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = sJ(), this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = sK(), this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                }
                _setSize(e) {
                    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(sQ, sG, sz), this._renderer.xr.enabled = sH, e.scissorTest = !1, sq(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    e.mapping === eA || e.mapping === em ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), sQ = this._renderer.getRenderTarget(), sG = this._renderer.getActiveCubeFace(), sz = this._renderer.getActiveMipmapLevel(), sH = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
                    let n = t || this._allocateTargets();
                    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
                }
                _allocateTargets() {
                    let e = 3 * Math.max(this._cubeSize, 112),
                        t = 4 * this._cubeSize,
                        n = {
                            magFilter: eT,
                            minFilter: eT,
                            generateMipmaps: !1,
                            type: eG,
                            format: eX,
                            colorSpace: tq,
                            depthBuffer: !1
                        },
                        r = sX(e, t, n);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = sX(e, t, n);
                        let {
                            _lodMax: r
                        } = this;
                        ({
                            sizeLods: this._sizeLods,
                            lodPlanes: this._lodPlanes,
                            sigmas: this._sigmas
                        } = function(e) {
                            let t = [],
                                n = [],
                                r = [],
                                i = e,
                                s = e - 4 + 1 + sU.length;
                            for (let a = 0; a < s; a++) {
                                let s = Math.pow(2, i);
                                n.push(s);
                                let o = 1 / s;
                                a > e - 4 ? o = sU[a - e + 4 - 1] : 0 === a && (o = 0), r.push(o);
                                let l = 1 / (s - 2),
                                    u = -l,
                                    c = 1 + l,
                                    h = [u, u, c, u, c, c, u, u, c, c, u, c],
                                    d = new Float32Array(108),
                                    f = new Float32Array(72),
                                    p = new Float32Array(36);
                                for (let e = 0; e < 6; e++) {
                                    let t = e % 3 * 2 / 3 - 1,
                                        n = e > 2 ? 0 : -1,
                                        r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                    d.set(r, 18 * e), f.set(h, 12 * e);
                                    let i = [e, e, e, e, e, e];
                                    p.set(i, 6 * e)
                                }
                                let g = new iK;
                                g.setAttribute("position", new iL(d, 3)), g.setAttribute("uv", new iL(f, 2)), g.setAttribute("faceIndex", new iL(p, 1)), t.push(g), i > 4 && i--
                            }
                            return {
                                lodPlanes: t,
                                sizeLods: n,
                                sigmas: r
                            }
                        }(r)), this._blurMaterial = new ss({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / e,
                                CUBEUV_TEXEL_HEIGHT: 1 / t,
                                CUBEUV_MAX_MIP: `${r}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: new Float32Array(20)
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: new rl(0, 1, 0)
                                }
                            },
                            vertexShader: sZ(),
                            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                            blending: _,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }
                    return r
                }
                _compileMaterial(e) {
                    let t = new i9(this._lodPlanes[0], e);
                    this._renderer.compile(t, sF)
                }
                _sceneToCubeUV(e, t, n, r) {
                    let i = new sc(90, 1, t, n),
                        s = [1, -1, 1, 1, 1, 1],
                        a = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        l = o.autoClear,
                        u = o.toneMapping;
                    o.getClearColor(sk), o.toneMapping = es, o.autoClear = !1;
                    let c = new iS({
                            name: "PMREM.Background",
                            side: x,
                            depthWrite: !1,
                            depthTest: !1
                        }),
                        h = new i9(new se, c),
                        d = !1,
                        f = e.background;
                    f ? f.isColor && (c.color.copy(f), e.background = null, d = !0) : (c.color.copy(sk), d = !0);
                    for (let t = 0; t < 6; t++) {
                        let n = t % 3;
                        0 === n ? (i.up.set(0, s[t], 0), i.lookAt(a[t], 0, 0)) : 1 === n ? (i.up.set(0, 0, s[t]), i.lookAt(0, a[t], 0)) : (i.up.set(0, s[t], 0), i.lookAt(0, 0, a[t]));
                        let l = this._cubeSize;
                        sq(r, n * l, t > 2 ? l : 0, l, l), o.setRenderTarget(r), d && o.render(h, i), o.render(e, i)
                    }
                    h.geometry.dispose(), h.material.dispose(), o.toneMapping = u, o.autoClear = l, e.background = f
                }
                _textureToCubeUV(e, t) {
                    let n = this._renderer,
                        r = e.mapping === eA || e.mapping === em;
                    r ? (null === this._cubemapMaterial && (this._cubemapMaterial = sJ()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = sK());
                    let i = r ? this._cubemapMaterial : this._equirectMaterial,
                        s = new i9(this._lodPlanes[0], i);
                    i.uniforms.envMap.value = e;
                    let a = this._cubeSize;
                    sq(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(s, sF)
                }
                _applyPMREM(e) {
                    let t = this._renderer,
                        n = t.autoClear;
                    t.autoClear = !1;
                    let r = this._lodPlanes.length;
                    for (let t = 1; t < r; t++) {
                        let n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
                            i = sW[(r - t - 1) % sW.length];
                        this._blur(e, t - 1, t, n, i)
                    }
                    t.autoClear = n
                }
                _blur(e, t, n, r, i) {
                    let s = this._pingPongRenderTarget;
                    this._halfBlur(e, s, t, n, r, "latitudinal", i), this._halfBlur(s, e, n, n, r, "longitudinal", i)
                }
                _halfBlur(e, t, n, r, i, s, a) {
                    let o = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                    let u = new i9(this._lodPlanes[r], l),
                        c = l.uniforms,
                        h = this._sizeLods[n] - 1,
                        d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                        f = i / d,
                        p = isFinite(i) ? 1 + Math.floor(3 * f) : 20;
                    p > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
                    let g = [],
                        A = 0;
                    for (let e = 0; e < 20; ++e) {
                        let t = e / f,
                            n = Math.exp(-t * t / 2);
                        g.push(n), 0 === e ? A += n : e < p && (A += 2 * n)
                    }
                    for (let e = 0; e < g.length; e++) g[e] = g[e] / A;
                    c.envMap.value = e.texture, c.samples.value = p, c.weights.value = g, c.latitudinal.value = "latitudinal" === s, a && (c.poleAxis.value = a);
                    let {
                        _lodMax: m
                    } = this;
                    c.dTheta.value = d, c.mipInt.value = m - n;
                    let v = this._sizeLods[r],
                        y = 4 * (this._cubeSize - v);
                    sq(t, 3 * v * (r > m - 4 ? r - m + 4 : 0), y, 3 * v, 2 * v), o.setRenderTarget(t), o.render(u, sF)
                }
            }

            function sX(e, t, n) {
                let r = new rn(e, t, n);
                return r.texture.mapping = ex, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
            }

            function sq(e, t, n, r, i) {
                e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
            }

            function sK() {
                return new ss({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: sZ(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                    blending: _,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function sJ() {
                return new ss({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: sZ(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                    blending: _,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function sZ() {
                return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
            }

            function s$(e) {
                let t = new WeakMap,
                    n = null;

                function r(e) {
                    let n = e.target;
                    n.removeEventListener("dispose", r);
                    let i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture) {
                            let s = i.mapping,
                                a = s === ev || s === ey,
                                o = s === eA || s === em;
                            if (a || o) {
                                let s = t.get(i),
                                    l = void 0 !== s ? s.texture.pmremVersion : 0;
                                if (i.isRenderTargetTexture && i.pmremVersion !== l) return null === n && (n = new sY(e)), (s = a ? n.fromEquirectangular(i, s) : n.fromCubemap(i, s)).texture.pmremVersion = i.pmremVersion, t.set(i, s), s.texture;
                                if (void 0 !== s) return s.texture; {
                                    let l = i.image;
                                    return a && l && l.height > 0 || o && l && function(e) {
                                        let t = 0;
                                        for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                        return 6 === t
                                    }(l) ? (null === n && (n = new sY(e)), (s = a ? n.fromEquirectangular(i) : n.fromCubemap(i)).texture.pmremVersion = i.pmremVersion, t.set(i, s), i.addEventListener("dispose", r), s.texture) : null
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap, null !== n && (n.dispose(), n = null)
                    }
                }
            }

            function s0(e) {
                let t = {};

                function n(n) {
                    let r;
                    if (void 0 !== t[n]) return t[n];
                    switch (n) {
                        case "WEBGL_depth_texture":
                            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            r = e.getExtension(n)
                    }
                    return t[n] = r, r
                }
                return {
                    has: function(e) {
                        return null !== n(e)
                    },
                    init: function() {
                        n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent")
                    },
                    get: function(e) {
                        let t = n(e);
                        return null === t && nK("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function s1(e, t, n, r) {
                let i = {},
                    s = new WeakMap;

                function a(e) {
                    let o = e.target;
                    for (let e in null !== o.index && t.remove(o.index), o.attributes) t.remove(o.attributes[e]);
                    for (let e in o.morphAttributes) {
                        let n = o.morphAttributes[e];
                        for (let e = 0, r = n.length; e < r; e++) t.remove(n[e])
                    }
                    o.removeEventListener("dispose", a), delete i[o.id];
                    let l = s.get(o);
                    l && (t.remove(l), s.delete(o)), r.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
                }

                function o(e) {
                    let n = [],
                        r = e.index,
                        i = e.attributes.position,
                        a = 0;
                    if (null !== r) {
                        let e = r.array;
                        a = r.version;
                        for (let t = 0, r = e.length; t < r; t += 3) {
                            let r = e[t + 0],
                                i = e[t + 1],
                                s = e[t + 2];
                            n.push(r, i, i, s, s, r)
                        }
                    } else {
                        if (void 0 === i) return;
                        let e = i.array;
                        a = i.version;
                        for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                            let e = t + 0,
                                r = t + 1,
                                i = t + 2;
                            n.push(e, r, r, i, i, e)
                        }
                    }
                    let o = new(nV(n) ? iQ : iF)(n, 1);
                    o.version = a;
                    let l = s.get(e);
                    l && t.remove(l), s.set(e, o)
                }
                return {
                    get: function(e, t) {
                        return !0 === i[t.id] || (t.addEventListener("dispose", a), i[t.id] = !0, n.memory.geometries++), t
                    },
                    update: function(n) {
                        let r = n.attributes;
                        for (let n in r) t.update(r[n], e.ARRAY_BUFFER);
                        let i = n.morphAttributes;
                        for (let n in i) {
                            let r = i[n];
                            for (let n = 0, i = r.length; n < i; n++) t.update(r[n], e.ARRAY_BUFFER)
                        }
                    },
                    getWireframeAttribute: function(e) {
                        let t = s.get(e);
                        if (t) {
                            let n = e.index;
                            null !== n && t.version < n.version && o(e)
                        } else o(e);
                        return s.get(e)
                    }
                }
            }

            function s2(e, t, n) {
                let r, i, s;

                function a(t, a, o) {
                    0 !== o && (e.drawElementsInstanced(r, a, i, t * s, o), n.update(a, r, o))
                }
                this.setMode = function(e) {
                    r = e
                }, this.setIndex = function(e) {
                    i = e.type, s = e.bytesPerElement
                }, this.render = function(t, a) {
                    e.drawElements(r, a, i, t * s), n.update(a, r, 1)
                }, this.renderInstances = a, this.renderMultiDraw = function(e, s, a) {
                    if (0 === a) return;
                    t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, s, 0, i, e, 0, a);
                    let o = 0;
                    for (let e = 0; e < a; e++) o += s[e];
                    n.update(o, r, 1)
                }, this.renderMultiDrawInstances = function(e, o, l, u) {
                    if (0 === l) return;
                    let c = t.get("WEBGL_multi_draw");
                    if (null === c)
                        for (let t = 0; t < e.length; t++) a(e[t] / s, o[t], u[t]);
                    else {
                        c.multiDrawElementsInstancedWEBGL(r, o, 0, i, e, 0, u, 0, l);
                        let t = 0;
                        for (let e = 0; e < l; e++) t += o[e];
                        for (let e = 0; e < u.length; e++) n.update(t, r, u[e])
                    }
                }
            }

            function s3(e) {
                let t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function(n, r, i) {
                        switch (t.calls++, r) {
                            case e.TRIANGLES:
                                t.triangles += n / 3 * i;
                                break;
                            case e.LINES:
                                t.lines += n / 2 * i;
                                break;
                            case e.LINE_STRIP:
                                t.lines += i * (n - 1);
                                break;
                            case e.LINE_LOOP:
                                t.lines += i * n;
                                break;
                            case e.POINTS:
                                t.points += i * n;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }

            function s4(e, t, n) {
                let r = new WeakMap,
                    i = new re;
                return {
                    update: function(s, a, o) {
                        let l = s.morphTargetInfluences,
                            u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
                            c = void 0 !== u ? u.length : 0,
                            h = r.get(a);
                        if (void 0 === h || h.count !== c) {
                            void 0 !== h && h.texture.dispose();
                            let e = void 0 !== a.morphAttributes.position,
                                n = void 0 !== a.morphAttributes.normal,
                                s = void 0 !== a.morphAttributes.color,
                                o = a.morphAttributes.position || [],
                                l = a.morphAttributes.normal || [],
                                u = a.morphAttributes.color || [],
                                d = 0;
                            !0 === e && (d = 1), !0 === n && (d = 2), !0 === s && (d = 3);
                            let f = a.attributes.position.count * d,
                                p = 1;
                            f > t.maxTextureSize && (p = Math.ceil(f / t.maxTextureSize), f = t.maxTextureSize);
                            let g = new Float32Array(f * p * 4 * c),
                                A = new rr(g, f, p, c);
                            A.type = eQ, A.needsUpdate = !0;
                            let m = 4 * d;
                            for (let t = 0; t < c; t++) {
                                let r = o[t],
                                    a = l[t],
                                    c = u[t],
                                    h = f * p * 4 * t;
                                for (let t = 0; t < r.count; t++) {
                                    let o = t * m;
                                    !0 === e && (i.fromBufferAttribute(r, t), g[h + o + 0] = i.x, g[h + o + 1] = i.y, g[h + o + 2] = i.z, g[h + o + 3] = 0), !0 === n && (i.fromBufferAttribute(a, t), g[h + o + 4] = i.x, g[h + o + 5] = i.y, g[h + o + 6] = i.z, g[h + o + 7] = 0), !0 === s && (i.fromBufferAttribute(c, t), g[h + o + 8] = i.x, g[h + o + 9] = i.y, g[h + o + 10] = i.z, g[h + o + 11] = 4 === c.itemSize ? i.w : 1)
                                }
                            }
                            h = {
                                count: c,
                                texture: A,
                                size: new nG(f, p)
                            }, r.set(a, h), a.addEventListener("dispose", function e() {
                                A.dispose(), r.delete(a), a.removeEventListener("dispose", e)
                            })
                        }
                        if (!0 === s.isInstancedMesh && null !== s.morphTexture) o.getUniforms().setValue(e, "morphTexture", s.morphTexture, n);
                        else {
                            let t = 0;
                            for (let e = 0; e < l.length; e++) t += l[e];
                            let n = a.morphTargetsRelative ? 1 : 1 - t;
                            o.getUniforms().setValue(e, "morphTargetBaseInfluence", n), o.getUniforms().setValue(e, "morphTargetInfluences", l)
                        }
                        o.getUniforms().setValue(e, "morphTargetsTexture", h.texture, n), o.getUniforms().setValue(e, "morphTargetsTextureSize", h.size)
                    }
                }
            }

            function s5(e, t, n, r) {
                let i = new WeakMap;

                function s(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function(a) {
                        let o = r.render.frame,
                            l = a.geometry,
                            u = t.get(a, l);
                        if (i.get(u) !== o && (t.update(u), i.set(u, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), i.get(a) !== o && (n.update(a.instanceMatrix, e.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, e.ARRAY_BUFFER), i.set(a, o))), a.isSkinnedMesh) {
                            let e = a.skeleton;
                            i.get(e) !== o && (e.update(), i.set(e, o))
                        }
                        return u
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            class s6 extends n7 {
                constructor(e, t, n, r, i, s, a, o, l, u = eJ) {
                    if (u !== eJ && u !== eZ) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && u === eJ && (n = ek), void 0 === n && u === eZ && (n = eV), super(null, r, i, s, a, o, u, n, l), this.isDepthTexture = !0, this.image = {
                        width: e,
                        height: t
                    }, this.magFilter = void 0 !== a ? a : ew, this.minFilter = void 0 !== o ? o : ew, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
                }
                copy(e) {
                    return super.copy(e), this.compareFunction = e.compareFunction, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t
                }
            }
            let s8 = new n7,
                s9 = new s6(1, 1),
                s7 = new rr,
                ae = new rs,
                at = new sd,
                an = [],
                ar = [],
                ai = new Float32Array(16),
                as = new Float32Array(9),
                aa = new Float32Array(4);

            function ao(e, t, n) {
                let r = e[0];
                if (r <= 0 || r > 0) return e;
                let i = t * n,
                    s = an[i];
                if (void 0 === s && (s = new Float32Array(i), an[i] = s), 0 !== t) {
                    r.toArray(s, 0);
                    for (let r = 1, i = 0; r !== t; ++r) i += n, e[r].toArray(s, i)
                }
                return s
            }

            function al(e, t) {
                if (e.length !== t.length) return !1;
                for (let n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function au(e, t) {
                for (let n = 0, r = t.length; n < r; n++) e[n] = t[n]
            }

            function ac(e, t) {
                let n = ar[t];
                void 0 === n && (n = new Int32Array(t), ar[t] = n);
                for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
                return n
            }

            function ah(e, t) {
                let n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function ad(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (al(n, t)) return;
                    e.uniform2fv(this.addr, t), au(n, t)
                }
            }

            function af(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r)(n[0] !== t.r || n[1] !== t.g || n[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (al(n, t)) return;
                    e.uniform3fv(this.addr, t), au(n, t)
                }
            }

            function ap(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (al(n, t)) return;
                    e.uniform4fv(this.addr, t), au(n, t)
                }
            }

            function ag(e, t) {
                let n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (al(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), au(n, t)
                } else {
                    if (al(n, r)) return;
                    aa.set(r), e.uniformMatrix2fv(this.addr, !1, aa), au(n, r)
                }
            }

            function aA(e, t) {
                let n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (al(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), au(n, t)
                } else {
                    if (al(n, r)) return;
                    as.set(r), e.uniformMatrix3fv(this.addr, !1, as), au(n, r)
                }
            }

            function am(e, t) {
                let n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (al(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), au(n, t)
                } else {
                    if (al(n, r)) return;
                    ai.set(r), e.uniformMatrix4fv(this.addr, !1, ai), au(n, r)
                }
            }

            function av(e, t) {
                let n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function ay(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y) && (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (al(n, t)) return;
                    e.uniform2iv(this.addr, t), au(n, t)
                }
            }

            function ax(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else {
                    if (al(n, t)) return;
                    e.uniform3iv(this.addr, t), au(n, t)
                }
            }

            function aE(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (al(n, t)) return;
                    e.uniform4iv(this.addr, t), au(n, t)
                }
            }

            function a_(e, t) {
                let n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }

            function ab(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y) && (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (al(n, t)) return;
                    e.uniform2uiv(this.addr, t), au(n, t)
                }
            }

            function aw(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else {
                    if (al(n, t)) return;
                    e.uniform3uiv(this.addr, t), au(n, t)
                }
            }

            function aC(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (al(n, t)) return;
                    e.uniform4uiv(this.addr, t), au(n, t)
                }
            }

            function aS(e, t, n) {
                let r;
                let i = this.cache,
                    s = n.allocateTextureUnit();
                i[0] !== s && (e.uniform1i(this.addr, s), i[0] = s), this.type === e.SAMPLER_2D_SHADOW ? (s9.compareFunction = nh, r = s9) : r = s8, n.setTexture2D(t || r, s)
            }

            function aI(e, t, n) {
                let r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || ae, i)
            }

            function aM(e, t, n) {
                let r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || at, i)
            }

            function aT(e, t, n) {
                let r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || s7, i)
            }

            function aB(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function aR(e, t) {
                let n = ao(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function aD(e, t) {
                let n = ao(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function aL(e, t) {
                let n = ao(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function aP(e, t) {
                let n = ao(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function aO(e, t) {
                let n = ao(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function aN(e, t) {
                let n = ao(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function aU(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function aF(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function ak(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function aQ(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function aG(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function az(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function aH(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function aV(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function aj(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    s = ac(n, i);
                al(r, s) || (e.uniform1iv(this.addr, s), au(r, s));
                for (let e = 0; e !== i; ++e) n.setTexture2D(t[e] || s8, s[e])
            }

            function aW(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    s = ac(n, i);
                al(r, s) || (e.uniform1iv(this.addr, s), au(r, s));
                for (let e = 0; e !== i; ++e) n.setTexture3D(t[e] || ae, s[e])
            }

            function aY(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    s = ac(n, i);
                al(r, s) || (e.uniform1iv(this.addr, s), au(r, s));
                for (let e = 0; e !== i; ++e) n.setTextureCube(t[e] || at, s[e])
            }

            function aX(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    s = ac(n, i);
                al(r, s) || (e.uniform1iv(this.addr, s), au(r, s));
                for (let e = 0; e !== i; ++e) n.setTexture2DArray(t[e] || s7, s[e])
            }
            class aq {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return ah;
                            case 35664:
                                return ad;
                            case 35665:
                                return af;
                            case 35666:
                                return ap;
                            case 35674:
                                return ag;
                            case 35675:
                                return aA;
                            case 35676:
                                return am;
                            case 5124:
                            case 35670:
                                return av;
                            case 35667:
                            case 35671:
                                return ay;
                            case 35668:
                            case 35672:
                                return ax;
                            case 35669:
                            case 35673:
                                return aE;
                            case 5125:
                                return a_;
                            case 36294:
                                return ab;
                            case 36295:
                                return aw;
                            case 36296:
                                return aC;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return aS;
                            case 35679:
                            case 36299:
                            case 36307:
                                return aI;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return aM;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return aT
                        }
                    }(t.type)
                }
            }
            class aK {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return aB;
                            case 35664:
                                return aR;
                            case 35665:
                                return aD;
                            case 35666:
                                return aL;
                            case 35674:
                                return aP;
                            case 35675:
                                return aO;
                            case 35676:
                                return aN;
                            case 5124:
                            case 35670:
                                return aU;
                            case 35667:
                            case 35671:
                                return aF;
                            case 35668:
                            case 35672:
                                return ak;
                            case 35669:
                            case 35673:
                                return aQ;
                            case 5125:
                                return aG;
                            case 36294:
                                return az;
                            case 36295:
                                return aH;
                            case 36296:
                                return aV;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return aj;
                            case 35679:
                            case 36299:
                            case 36307:
                                return aW;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return aY;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return aX
                        }
                    }(t.type)
                }
            }
            class aJ {
                constructor(e) {
                    this.id = e, this.seq = [], this.map = {}
                }
                setValue(e, t, n) {
                    let r = this.seq;
                    for (let i = 0, s = r.length; i !== s; ++i) {
                        let s = r[i];
                        s.setValue(e, t[s.id], n)
                    }
                }
            }
            let aZ = /(\w+)(\])?(\[|\.)?/g;

            function a$(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }
            class a0 {
                constructor(e, t) {
                    this.seq = [], this.map = {};
                    let n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                    for (let r = 0; r < n; ++r) {
                        let n = e.getActiveUniform(t, r),
                            i = e.getUniformLocation(t, n.name);
                        ! function(e, t, n) {
                            let r = e.name,
                                i = r.length;
                            for (aZ.lastIndex = 0;;) {
                                let s = aZ.exec(r),
                                    a = aZ.lastIndex,
                                    o = s[1],
                                    l = "]" === s[2],
                                    u = s[3];
                                if (l && (o |= 0), void 0 === u || "[" === u && a + 2 === i) {
                                    a$(n, void 0 === u ? new aq(o, e, t) : new aK(o, e, t));
                                    break
                                } {
                                    let e = n.map[o];
                                    void 0 === e && a$(n, e = new aJ(o)), n = e
                                }
                            }
                        }(n, i, this)
                    }
                }
                setValue(e, t, n, r) {
                    let i = this.map[t];
                    void 0 !== i && i.setValue(e, n, r)
                }
                setOptional(e, t, n) {
                    let r = t[n];
                    void 0 !== r && this.setValue(e, n, r)
                }
                static upload(e, t, n, r) {
                    for (let i = 0, s = t.length; i !== s; ++i) {
                        let s = t[i],
                            a = n[s.id];
                        !1 !== a.needsUpdate && s.setValue(e, a.value, r)
                    }
                }
                static seqWithValue(e, t) {
                    let n = [];
                    for (let r = 0, i = e.length; r !== i; ++r) {
                        let i = e[r];
                        i.id in t && n.push(i)
                    }
                    return n
                }
            }

            function a1(e, t, n) {
                let r = e.createShader(t);
                return e.shaderSource(r, n), e.compileShader(r), r
            }
            let a2 = 0;

            function a3(e, t, n) {
                let r = e.getShaderParameter(t, e.COMPILE_STATUS),
                    i = e.getShaderInfoLog(t).trim();
                if (r && "" === i) return "";
                let s = /ERROR: 0:(\d+)/.exec(i);
                if (!s) return i; {
                    let r = parseInt(s[1]);
                    return n.toUpperCase() + "\n\n" + i + "\n\n" + function(e, t) {
                        let n = e.split("\n"),
                            r = [],
                            i = Math.max(t - 6, 0),
                            s = Math.min(t + 6, n.length);
                        for (let e = i; e < s; e++) {
                            let i = e + 1;
                            r.push(`${i===t?">":" "} ${i}: ${n[e]}`)
                        }
                        return r.join("\n")
                    }(e.getShaderSource(t), r)
                }
            }
            let a4 = new rl;

            function a5(e) {
                return "" !== e
            }

            function a6(e, t) {
                let n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function a8(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            let a9 = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function a7(e) {
                return e.replace(a9, ot)
            }
            let oe = new Map;

            function ot(e, t) {
                let n = sw[t];
                if (void 0 === n) {
                    let e = oe.get(t);
                    if (void 0 !== e) n = sw[e], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e);
                    else throw Error("Can not resolve #include <" + t + ">")
                }
                return a7(n)
            }
            let on = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function or(e) {
                return e.replace(on, oi)
            }

            function oi(e, t, n, r) {
                let i = "";
                for (let e = parseInt(t); e < parseInt(n); e++) i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return i
            }

            function os(e) {
                let t = `precision ${e.precision} float;
	precision ${e.precision} int;
	precision ${e.precision} sampler2D;
	precision ${e.precision} samplerCube;
	precision ${e.precision} sampler3D;
	precision ${e.precision} sampler2DArray;
	precision ${e.precision} sampler2DShadow;
	precision ${e.precision} samplerCubeShadow;
	precision ${e.precision} sampler2DArrayShadow;
	precision ${e.precision} isampler2D;
	precision ${e.precision} isampler3D;
	precision ${e.precision} isamplerCube;
	precision ${e.precision} isampler2DArray;
	precision ${e.precision} usampler2D;
	precision ${e.precision} usampler3D;
	precision ${e.precision} usamplerCube;
	precision ${e.precision} usampler2DArray;
	`;
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function oa(e, t, n, r) {
                let i, s, a, o, l, u;
                let c = e.getContext(),
                    h = n.defines,
                    d = n.vertexShader,
                    f = n.fragmentShader,
                    p = (l = "SHADOWMAP_TYPE_BASIC", n.shadowMapType === A ? l = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === m ? l = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === v && (l = "SHADOWMAP_TYPE_VSM"), l),
                    g = function(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case eA:
                            case em:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case ex:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    y = (u = "ENVMAP_MODE_REFLECTION", n.envMap && n.envMapMode === em && (u = "ENVMAP_MODE_REFRACTION"), u),
                    x = function(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case en:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case er:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case ei:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    E = function(e) {
                        let t = e.envMapCubeUVHeight;
                        if (null === t) return null;
                        let n = Math.log2(t) - 2;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                            texelHeight: 1 / t,
                            maxMip: n
                        }
                    }(n),
                    _ = [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(a5).join("\n"),
                    b = function(e) {
                        let t = [];
                        for (let n in e) {
                            let r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(h),
                    w = c.createProgram(),
                    C = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? ((i = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b].filter(a5).join("\n")).length > 0 && (i += "\n"), (s = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b].filter(a5).join("\n")).length > 0 && (s += "\n")) : (i = [os(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + y : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(a5).join("\n"), s = [os(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + g : "", n.envMap ? "#define " + y : "", n.envMap ? "#define " + x : "", E ? "#define CUBEUV_TEXEL_WIDTH " + E.texelWidth : "", E ? "#define CUBEUV_TEXEL_HEIGHT " + E.texelHeight : "", E ? "#define CUBEUV_MAX_MIP " + E.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== es ? "#define TONE_MAPPING" : "", n.toneMapping !== es ? sw.tonemapping_pars_fragment : "", n.toneMapping !== es ? function(e, t) {
                    let n;
                    switch (t) {
                        case ea:
                            n = "Linear";
                            break;
                        case eo:
                            n = "Reinhard";
                            break;
                        case el:
                            n = "Cineon";
                            break;
                        case eu:
                            n = "ACESFilmic";
                            break;
                        case eh:
                            n = "AgX";
                            break;
                        case ed:
                            n = "Neutral";
                            break;
                        case ec:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", sw.colorspace_pars_fragment, function(e, t) {
                    let n = function(e) {
                        let t;
                        let n = n1.getPrimaries(n1.workingColorSpace),
                            r = n1.getPrimaries(e);
                        switch (n === r ? t = "" : n === t1 && r === t0 ? t = "LinearDisplayP3ToLinearSRGB" : n === t0 && r === t1 && (t = "LinearSRGBToLinearDisplayP3"), e) {
                            case tq:
                            case tJ:
                                return [t, "LinearTransferOETF"];
                            case tX:
                            case tK:
                                return [t, "sRGBTransferOETF"];
                            default:
                                return console.warn("THREE.WebGLProgram: Unsupported color space:", e), [t, "LinearTransferOETF"]
                        }
                    }(t);
                    return `vec4 ${e}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
                }("linearToOutputTexel", n.outputColorSpace), function() {
                    n1.getLuminanceCoefficients(a4);
                    let e = a4.x.toFixed(4),
                        t = a4.y.toFixed(4),
                        n = a4.z.toFixed(4);
                    return `float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( ${e}, ${t}, ${n} );
	return dot( weights, rgb );
}`
                }(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(a5).join("\n")), d = a8(d = a6(d = a7(d), n), n), f = a8(f = a6(f = a7(f), n), n), d = or(d), f = or(f), !0 !== n.isRawShaderMaterial && (C = "#version 300 es\n", i = [_, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, s = ["#define varying in", n.glslVersion === nS ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === nS ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + s);
                let S = C + i + d,
                    I = C + s + f,
                    M = a1(c, c.VERTEX_SHADER, S),
                    T = a1(c, c.FRAGMENT_SHADER, I);

                function B(t) {
                    if (e.debug.checkShaderErrors) {
                        let n = c.getProgramInfoLog(w).trim(),
                            r = c.getShaderInfoLog(M).trim(),
                            a = c.getShaderInfoLog(T).trim(),
                            o = !0,
                            l = !0;
                        if (!1 === c.getProgramParameter(w, c.LINK_STATUS)) {
                            if (o = !1, "function" == typeof e.debug.onShaderError) e.debug.onShaderError(c, w, M, T);
                            else {
                                let e = a3(c, M, "vertex"),
                                    r = a3(c, T, "fragment");
                                console.error("THREE.WebGLProgram: Shader Error " + c.getError() + " - VALIDATE_STATUS " + c.getProgramParameter(w, c.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + r)
                            }
                        } else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : ("" === r || "" === a) && (l = !1);
                        l && (t.diagnostics = {
                            runnable: o,
                            programLog: n,
                            vertexShader: {
                                log: r,
                                prefix: i
                            },
                            fragmentShader: {
                                log: a,
                                prefix: s
                            }
                        })
                    }
                    c.deleteShader(M), c.deleteShader(T), a = new a0(c, w), o = function(e, t) {
                        let n = {},
                            r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                        for (let i = 0; i < r; i++) {
                            let r = e.getActiveAttrib(t, i),
                                s = r.name,
                                a = 1;
                            r.type === e.FLOAT_MAT2 && (a = 2), r.type === e.FLOAT_MAT3 && (a = 3), r.type === e.FLOAT_MAT4 && (a = 4), n[s] = {
                                type: r.type,
                                location: e.getAttribLocation(t, s),
                                locationSize: a
                            }
                        }
                        return n
                    }(c, w)
                }
                c.attachShader(w, M), c.attachShader(w, T), void 0 !== n.index0AttributeName ? c.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === n.morphTargets && c.bindAttribLocation(w, 0, "position"), c.linkProgram(w), this.getUniforms = function() {
                    return void 0 === a && B(this), a
                }, this.getAttributes = function() {
                    return void 0 === o && B(this), o
                };
                let R = !1 === n.rendererExtensionParallelShaderCompile;
                return this.isReady = function() {
                    return !1 === R && (R = c.getProgramParameter(w, 37297)), R
                }, this.destroy = function() {
                    r.releaseStatesOfProgram(this), c.deleteProgram(w), this.program = void 0
                }, this.type = n.shaderType, this.name = n.shaderName, this.id = a2++, this.cacheKey = t, this.usedTimes = 1, this.program = w, this.vertexShader = M, this.fragmentShader = T, this
            }
            let oo = 0;
            class ol {
                constructor() {
                    this.shaderCache = new Map, this.materialCache = new Map
                }
                update(e) {
                    let t = e.vertexShader,
                        n = e.fragmentShader,
                        r = this._getShaderStage(t),
                        i = this._getShaderStage(n),
                        s = this._getShaderCacheForMaterial(e);
                    return !1 === s.has(r) && (s.add(r), r.usedTimes++), !1 === s.has(i) && (s.add(i), i.usedTimes++), this
                }
                remove(e) {
                    for (let t of this.materialCache.get(e)) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                    return this.materialCache.delete(e), this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(), this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    let t = this.materialCache,
                        n = t.get(e);
                    return void 0 === n && (n = new Set, t.set(e, n)), n
                }
                _getShaderStage(e) {
                    let t = this.shaderCache,
                        n = t.get(e);
                    return void 0 === n && (n = new ou(e), t.set(e, n)), n
                }
            }
            class ou {
                constructor(e) {
                    this.id = oo++, this.code = e, this.usedTimes = 0
                }
            }

            function oc(e, t, n, r, i, s, a) {
                let o = new rq,
                    l = new ol,
                    u = new Set,
                    c = [],
                    h = i.logarithmicDepthBuffer,
                    d = i.reverseDepthBuffer,
                    f = i.vertexTextures,
                    p = i.precision,
                    g = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };

                function A(e) {
                    return (u.add(e), 0 === e) ? "uv" : `uv${e}`
                }
                return {
                    getParameters: function(s, o, c, m, v) {
                        let y, _, w, C;
                        let S = m.fog,
                            I = v.geometry,
                            M = s.isMeshStandardMaterial ? m.environment : null,
                            T = (s.isMeshStandardMaterial ? n : t).get(s.envMap || M),
                            B = T && T.mapping === ex ? T.image.height : null,
                            R = g[s.type];
                        null !== s.precision && (p = i.getMaxPrecision(s.precision)) !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead.");
                        let D = I.morphAttributes.position || I.morphAttributes.normal || I.morphAttributes.color,
                            L = void 0 !== D ? D.length : 0,
                            P = 0;
                        if (void 0 !== I.morphAttributes.position && (P = 1), void 0 !== I.morphAttributes.normal && (P = 2), void 0 !== I.morphAttributes.color && (P = 3), R) {
                            let e = sS[R];
                            y = e.vertexShader, _ = e.fragmentShader
                        } else y = s.vertexShader, _ = s.fragmentShader, l.update(s), w = l.getVertexShaderID(s), C = l.getFragmentShaderID(s);
                        let O = e.getRenderTarget(),
                            N = !0 === v.isInstancedMesh,
                            U = !0 === v.isBatchedMesh,
                            F = !!s.map,
                            k = !!s.matcap,
                            Q = !!T,
                            G = !!s.aoMap,
                            z = !!s.lightMap,
                            H = !!s.bumpMap,
                            V = !!s.normalMap,
                            j = !!s.displacementMap,
                            W = !!s.emissiveMap,
                            Y = !!s.metalnessMap,
                            X = !!s.roughnessMap,
                            q = s.anisotropy > 0,
                            K = s.clearcoat > 0,
                            J = s.dispersion > 0,
                            Z = s.iridescence > 0,
                            $ = s.sheen > 0,
                            ee = s.transmission > 0,
                            et = q && !!s.anisotropyMap,
                            en = K && !!s.clearcoatMap,
                            er = K && !!s.clearcoatNormalMap,
                            ei = K && !!s.clearcoatRoughnessMap,
                            ea = Z && !!s.iridescenceMap,
                            eo = Z && !!s.iridescenceThicknessMap,
                            el = $ && !!s.sheenColorMap,
                            eu = $ && !!s.sheenRoughnessMap,
                            ec = !!s.specularMap,
                            eh = !!s.specularColorMap,
                            ed = !!s.specularIntensityMap,
                            ef = ee && !!s.transmissionMap,
                            ep = ee && !!s.thicknessMap,
                            eg = !!s.gradientMap,
                            eA = !!s.alphaMap,
                            em = s.alphaTest > 0,
                            ev = !!s.alphaHash,
                            ey = !!s.extensions,
                            eE = es;
                        s.toneMapped && (null === O || !0 === O.isXRRenderTarget) && (eE = e.toneMapping);
                        let e_ = {
                            shaderID: R,
                            shaderType: s.type,
                            shaderName: s.name,
                            vertexShader: y,
                            fragmentShader: _,
                            defines: s.defines,
                            customVertexShaderID: w,
                            customFragmentShaderID: C,
                            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                            glslVersion: s.glslVersion,
                            precision: p,
                            batching: U,
                            batchingColor: U && null !== v._colorsTexture,
                            instancing: N,
                            instancingColor: N && null !== v.instanceColor,
                            instancingMorph: N && null !== v.morphTexture,
                            supportsVertexTextures: f,
                            outputColorSpace: null === O ? e.outputColorSpace : !0 === O.isXRRenderTarget ? O.texture.colorSpace : tq,
                            alphaToCoverage: !!s.alphaToCoverage,
                            map: F,
                            matcap: k,
                            envMap: Q,
                            envMapMode: Q && T.mapping,
                            envMapCubeUVHeight: B,
                            aoMap: G,
                            lightMap: z,
                            bumpMap: H,
                            normalMap: V,
                            displacementMap: f && j,
                            emissiveMap: W,
                            normalMapObjectSpace: V && s.normalMapType === tW,
                            normalMapTangentSpace: V && s.normalMapType === tj,
                            metalnessMap: Y,
                            roughnessMap: X,
                            anisotropy: q,
                            anisotropyMap: et,
                            clearcoat: K,
                            clearcoatMap: en,
                            clearcoatNormalMap: er,
                            clearcoatRoughnessMap: ei,
                            dispersion: J,
                            iridescence: Z,
                            iridescenceMap: ea,
                            iridescenceThicknessMap: eo,
                            sheen: $,
                            sheenColorMap: el,
                            sheenRoughnessMap: eu,
                            specularMap: ec,
                            specularColorMap: eh,
                            specularIntensityMap: ed,
                            transmission: ee,
                            transmissionMap: ef,
                            thicknessMap: ep,
                            gradientMap: eg,
                            opaque: !1 === s.transparent && s.blending === b && !1 === s.alphaToCoverage,
                            alphaMap: eA,
                            alphaTest: em,
                            alphaHash: ev,
                            combine: s.combine,
                            mapUv: F && A(s.map.channel),
                            aoMapUv: G && A(s.aoMap.channel),
                            lightMapUv: z && A(s.lightMap.channel),
                            bumpMapUv: H && A(s.bumpMap.channel),
                            normalMapUv: V && A(s.normalMap.channel),
                            displacementMapUv: j && A(s.displacementMap.channel),
                            emissiveMapUv: W && A(s.emissiveMap.channel),
                            metalnessMapUv: Y && A(s.metalnessMap.channel),
                            roughnessMapUv: X && A(s.roughnessMap.channel),
                            anisotropyMapUv: et && A(s.anisotropyMap.channel),
                            clearcoatMapUv: en && A(s.clearcoatMap.channel),
                            clearcoatNormalMapUv: er && A(s.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: ei && A(s.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: ea && A(s.iridescenceMap.channel),
                            iridescenceThicknessMapUv: eo && A(s.iridescenceThicknessMap.channel),
                            sheenColorMapUv: el && A(s.sheenColorMap.channel),
                            sheenRoughnessMapUv: eu && A(s.sheenRoughnessMap.channel),
                            specularMapUv: ec && A(s.specularMap.channel),
                            specularColorMapUv: eh && A(s.specularColorMap.channel),
                            specularIntensityMapUv: ed && A(s.specularIntensityMap.channel),
                            transmissionMapUv: ef && A(s.transmissionMap.channel),
                            thicknessMapUv: ep && A(s.thicknessMap.channel),
                            alphaMapUv: eA && A(s.alphaMap.channel),
                            vertexTangents: !!I.attributes.tangent && (V || q),
                            vertexColors: s.vertexColors,
                            vertexAlphas: !0 === s.vertexColors && !!I.attributes.color && 4 === I.attributes.color.itemSize,
                            pointsUvs: !0 === v.isPoints && !!I.attributes.uv && (F || eA),
                            fog: !!S,
                            useFog: !0 === s.fog,
                            fogExp2: !!S && S.isFogExp2,
                            flatShading: !0 === s.flatShading,
                            sizeAttenuation: !0 === s.sizeAttenuation,
                            logarithmicDepthBuffer: h,
                            reverseDepthBuffer: d,
                            skinning: !0 === v.isSkinnedMesh,
                            morphTargets: void 0 !== I.morphAttributes.position,
                            morphNormals: void 0 !== I.morphAttributes.normal,
                            morphColors: void 0 !== I.morphAttributes.color,
                            morphTargetsCount: L,
                            morphTextureStride: P,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numSpotLightMaps: o.spotLightMap.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                            numLightProbes: o.numLightProbes,
                            numClippingPlanes: a.numPlanes,
                            numClipIntersection: a.numIntersection,
                            dithering: s.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: eE,
                            decodeVideoTexture: F && !0 === s.map.isVideoTexture && n1.getTransfer(s.map.colorSpace) === t$,
                            premultipliedAlpha: s.premultipliedAlpha,
                            doubleSided: s.side === E,
                            flipSided: s.side === x,
                            useDepthPacking: s.depthPacking >= 0,
                            depthPacking: s.depthPacking || 0,
                            index0AttributeName: s.index0AttributeName,
                            extensionClipCullDistance: ey && !0 === s.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: (ey && !0 === s.extensions.multiDraw || U) && r.has("WEBGL_multi_draw"),
                            rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: s.customProgramCacheKey()
                        };
                        return e_.vertexUv1s = u.has(1), e_.vertexUv2s = u.has(2), e_.vertexUv3s = u.has(3), u.clear(), e_
                    },
                    getProgramCacheKey: function(t) {
                        let n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (let e in t.defines) n.push(e), n.push(t.defines[e]);
                        return !1 === t.isRawShaderMaterial && (n.push(t.precision), n.push(t.outputColorSpace), n.push(t.envMapMode), n.push(t.envMapCubeUVHeight), n.push(t.mapUv), n.push(t.alphaMapUv), n.push(t.lightMapUv), n.push(t.aoMapUv), n.push(t.bumpMapUv), n.push(t.normalMapUv), n.push(t.displacementMapUv), n.push(t.emissiveMapUv), n.push(t.metalnessMapUv), n.push(t.roughnessMapUv), n.push(t.anisotropyMapUv), n.push(t.clearcoatMapUv), n.push(t.clearcoatNormalMapUv), n.push(t.clearcoatRoughnessMapUv), n.push(t.iridescenceMapUv), n.push(t.iridescenceThicknessMapUv), n.push(t.sheenColorMapUv), n.push(t.sheenRoughnessMapUv), n.push(t.specularMapUv), n.push(t.specularColorMapUv), n.push(t.specularIntensityMapUv), n.push(t.transmissionMapUv), n.push(t.thicknessMapUv), n.push(t.combine), n.push(t.fogExp2), n.push(t.sizeAttenuation), n.push(t.morphTargetsCount), n.push(t.morphAttributeCount), n.push(t.numDirLights), n.push(t.numPointLights), n.push(t.numSpotLights), n.push(t.numSpotLightMaps), n.push(t.numHemiLights), n.push(t.numRectAreaLights), n.push(t.numDirLightShadows), n.push(t.numPointLightShadows), n.push(t.numSpotLightShadows), n.push(t.numSpotLightShadowsWithMaps), n.push(t.numLightProbes), n.push(t.shadowMapType), n.push(t.toneMapping), n.push(t.numClippingPlanes), n.push(t.numClipIntersection), n.push(t.depthPacking), o.disableAll(), t.supportsVertexTextures && o.enable(0), t.instancing && o.enable(1), t.instancingColor && o.enable(2), t.instancingMorph && o.enable(3), t.matcap && o.enable(4), t.envMap && o.enable(5), t.normalMapObjectSpace && o.enable(6), t.normalMapTangentSpace && o.enable(7), t.clearcoat && o.enable(8), t.iridescence && o.enable(9), t.alphaTest && o.enable(10), t.vertexColors && o.enable(11), t.vertexAlphas && o.enable(12), t.vertexUv1s && o.enable(13), t.vertexUv2s && o.enable(14), t.vertexUv3s && o.enable(15), t.vertexTangents && o.enable(16), t.anisotropy && o.enable(17), t.alphaHash && o.enable(18), t.batching && o.enable(19), t.dispersion && o.enable(20), t.batchingColor && o.enable(21), n.push(o.mask), o.disableAll(), t.fog && o.enable(0), t.useFog && o.enable(1), t.flatShading && o.enable(2), t.logarithmicDepthBuffer && o.enable(3), t.reverseDepthBuffer && o.enable(4), t.skinning && o.enable(5), t.morphTargets && o.enable(6), t.morphNormals && o.enable(7), t.morphColors && o.enable(8), t.premultipliedAlpha && o.enable(9), t.shadowMapEnabled && o.enable(10), t.doubleSided && o.enable(11), t.flipSided && o.enable(12), t.useDepthPacking && o.enable(13), t.dithering && o.enable(14), t.transmission && o.enable(15), t.sheen && o.enable(16), t.opaque && o.enable(17), t.pointsUvs && o.enable(18), t.decodeVideoTexture && o.enable(19), t.alphaToCoverage && o.enable(20), n.push(o.mask), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join()
                    },
                    getUniforms: function(e) {
                        let t;
                        let n = g[e.type];
                        if (n) {
                            let e = sS[n];
                            t = si.clone(e.uniforms)
                        } else t = e.uniforms;
                        return t
                    },
                    acquireProgram: function(t, n) {
                        let r;
                        for (let e = 0, t = c.length; e < t; e++) {
                            let t = c[e];
                            if (t.cacheKey === n) {
                                r = t, ++r.usedTimes;
                                break
                            }
                        }
                        return void 0 === r && (r = new oa(e, n, t, s), c.push(r)), r
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            let t = c.indexOf(e);
                            c[t] = c[c.length - 1], c.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        l.remove(e)
                    },
                    programs: c,
                    dispose: function() {
                        l.dispose()
                    }
                }
            }

            function oh() {
                let e = new WeakMap;
                return {
                    has: function(t) {
                        return e.has(t)
                    },
                    get: function(t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, n, r) {
                        e.get(t)[n] = r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function od(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function of (e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function op() {
                let e = [],
                    t = 0,
                    n = [],
                    r = [],
                    i = [];

                function s(n, r, i, s, a, o) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: r,
                        material: i,
                        groupOrder: s,
                        renderOrder: n.renderOrder,
                        z: a,
                        group: o
                    }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = o), t++, l
                }
                return {
                    opaque: n,
                    transmissive: r,
                    transparent: i,
                    init: function() {
                        t = 0, n.length = 0, r.length = 0, i.length = 0
                    },
                    push: function(e, t, a, o, l, u) {
                        let c = s(e, t, a, o, l, u);
                        a.transmission > 0 ? r.push(c) : !0 === a.transparent ? i.push(c) : n.push(c)
                    },
                    unshift: function(e, t, a, o, l, u) {
                        let c = s(e, t, a, o, l, u);
                        a.transmission > 0 ? r.unshift(c) : !0 === a.transparent ? i.unshift(c) : n.unshift(c)
                    },
                    finish: function() {
                        for (let n = t, r = e.length; n < r; n++) {
                            let t = e[n];
                            if (null === t.id) break;
                            t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                        }
                    },
                    sort: function(e, t) {
                        n.length > 1 && n.sort(e || od), r.length > 1 && r.sort(t || of ), i.length > 1 && i.sort(t || of )
                    }
                }
            }

            function og() {
                let e = new WeakMap;
                return {
                    get: function(t, n) {
                        let r;
                        let i = e.get(t);
                        return void 0 === i ? (r = new op, e.set(t, [r])) : n >= i.length ? (r = new op, i.push(r)) : r = i[n], r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function oA() {
                let e = {};
                return {
                    get: function(t) {
                        let n;
                        if (void 0 !== e[t.id]) return e[t.id];
                        switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new rl,
                                    color: new i_
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new rl,
                                    direction: new rl,
                                    color: new i_,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new rl,
                                    color: new i_,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new rl,
                                    skyColor: new i_,
                                    groundColor: new i_
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new i_,
                                    position: new rl,
                                    halfWidth: new rl,
                                    halfHeight: new rl
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }
            let om = 0;

            function ov(e, t) {
                return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
            }

            function oy(e) {
                let t = new oA,
                    n = function() {
                        let e = {};
                        return {
                            get: function(t) {
                                let n;
                                if (void 0 !== e[t.id]) return e[t.id];
                                switch (t.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        n = {
                                            shadowIntensity: 1,
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new nG
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            shadowIntensity: 1,
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new nG,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return e[t.id] = n, n
                            }
                        }
                    }(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1,
                            numLightProbes: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0,
                        numLightProbes: 0
                    };
                for (let e = 0; e < 9; e++) r.probe.push(new rl);
                let i = new rl,
                    s = new rF,
                    a = new rF;
                return {
                    setup: function(i) {
                        let s = 0,
                            a = 0,
                            o = 0;
                        for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                        let l = 0,
                            u = 0,
                            c = 0,
                            h = 0,
                            d = 0,
                            f = 0,
                            p = 0,
                            g = 0,
                            A = 0,
                            m = 0,
                            v = 0;
                        i.sort(ov);
                        for (let e = 0, y = i.length; e < y; e++) {
                            let y = i[e],
                                x = y.color,
                                E = y.intensity,
                                _ = y.distance,
                                b = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                            if (y.isAmbientLight) s += x.r * E, a += x.g * E, o += x.b * E;
                            else if (y.isLightProbe) {
                                for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(y.sh.coefficients[e], E);
                                v++
                            } else if (y.isDirectionalLight) {
                                let e = t.get(y);
                                if (e.color.copy(y.color).multiplyScalar(y.intensity), y.castShadow) {
                                    let e = y.shadow,
                                        t = n.get(y);
                                    t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, r.directionalShadow[l] = t, r.directionalShadowMap[l] = b, r.directionalShadowMatrix[l] = y.shadow.matrix, f++
                                }
                                r.directional[l] = e, l++
                            } else if (y.isSpotLight) {
                                let e = t.get(y);
                                e.position.setFromMatrixPosition(y.matrixWorld), e.color.copy(x).multiplyScalar(E), e.distance = _, e.coneCos = Math.cos(y.angle), e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), e.decay = y.decay, r.spot[c] = e;
                                let i = y.shadow;
                                if (y.map && (r.spotLightMap[A] = y.map, A++, i.updateMatrices(y), y.castShadow && m++), r.spotLightMatrix[c] = i.matrix, y.castShadow) {
                                    let e = n.get(y);
                                    e.shadowIntensity = i.intensity, e.shadowBias = i.bias, e.shadowNormalBias = i.normalBias, e.shadowRadius = i.radius, e.shadowMapSize = i.mapSize, r.spotShadow[c] = e, r.spotShadowMap[c] = b, g++
                                }
                                c++
                            } else if (y.isRectAreaLight) {
                                let e = t.get(y);
                                e.color.copy(x).multiplyScalar(E), e.halfWidth.set(.5 * y.width, 0, 0), e.halfHeight.set(0, .5 * y.height, 0), r.rectArea[h] = e, h++
                            } else if (y.isPointLight) {
                                let e = t.get(y);
                                if (e.color.copy(y.color).multiplyScalar(y.intensity), e.distance = y.distance, e.decay = y.decay, y.castShadow) {
                                    let e = y.shadow,
                                        t = n.get(y);
                                    t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, t.shadowCameraNear = e.camera.near, t.shadowCameraFar = e.camera.far, r.pointShadow[u] = t, r.pointShadowMap[u] = b, r.pointShadowMatrix[u] = y.shadow.matrix, p++
                                }
                                r.point[u] = e, u++
                            } else if (y.isHemisphereLight) {
                                let e = t.get(y);
                                e.skyColor.copy(y.color).multiplyScalar(E), e.groundColor.copy(y.groundColor).multiplyScalar(E), r.hemi[d] = e, d++
                            }
                        }
                        h > 0 && (!0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = sC.LTC_FLOAT_1, r.rectAreaLTC2 = sC.LTC_FLOAT_2) : (r.rectAreaLTC1 = sC.LTC_HALF_1, r.rectAreaLTC2 = sC.LTC_HALF_2)), r.ambient[0] = s, r.ambient[1] = a, r.ambient[2] = o;
                        let y = r.hash;
                        (y.directionalLength !== l || y.pointLength !== u || y.spotLength !== c || y.rectAreaLength !== h || y.hemiLength !== d || y.numDirectionalShadows !== f || y.numPointShadows !== p || y.numSpotShadows !== g || y.numSpotMaps !== A || y.numLightProbes !== v) && (r.directional.length = l, r.spot.length = c, r.rectArea.length = h, r.point.length = u, r.hemi.length = d, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = p, r.pointShadowMap.length = p, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = p, r.spotLightMatrix.length = g + A - m, r.spotLightMap.length = A, r.numSpotLightShadowsWithMaps = m, r.numLightProbes = v, y.directionalLength = l, y.pointLength = u, y.spotLength = c, y.rectAreaLength = h, y.hemiLength = d, y.numDirectionalShadows = f, y.numPointShadows = p, y.numSpotShadows = g, y.numSpotMaps = A, y.numLightProbes = v, r.version = om++)
                    },
                    setupView: function(e, t) {
                        let n = 0,
                            o = 0,
                            l = 0,
                            u = 0,
                            c = 0,
                            h = t.matrixWorldInverse;
                        for (let t = 0, d = e.length; t < d; t++) {
                            let d = e[t];
                            if (d.isDirectionalLight) {
                                let e = r.directional[n];
                                e.direction.setFromMatrixPosition(d.matrixWorld), i.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(i), e.direction.transformDirection(h), n++
                            } else if (d.isSpotLight) {
                                let e = r.spot[l];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(d.matrixWorld), i.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(i), e.direction.transformDirection(h), l++
                            } else if (d.isRectAreaLight) {
                                let e = r.rectArea[u];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), a.identity(), s.copy(d.matrixWorld), s.premultiply(h), a.extractRotation(s), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(a), e.halfHeight.applyMatrix4(a), u++
                            } else if (d.isPointLight) {
                                let e = r.point[o];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), o++
                            } else if (d.isHemisphereLight) {
                                let e = r.hemi[c];
                                e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(h), c++
                            }
                        }
                    },
                    state: r
                }
            }

            function ox(e) {
                let t = new oy(e),
                    n = [],
                    r = [],
                    i = {
                        lightsArray: n,
                        shadowsArray: r,
                        camera: null,
                        lights: t,
                        transmissionRenderTarget: {}
                    };
                return {
                    init: function(e) {
                        i.camera = e, n.length = 0, r.length = 0
                    },
                    state: i,
                    setupLights: function() {
                        t.setup(n)
                    },
                    setupLightsView: function(e) {
                        t.setupView(n, e)
                    },
                    pushLight: function(e) {
                        n.push(e)
                    },
                    pushShadow: function(e) {
                        r.push(e)
                    }
                }
            }

            function oE(e) {
                let t = new WeakMap;
                return {
                    get: function(n, r = 0) {
                        let i;
                        let s = t.get(n);
                        return void 0 === s ? (i = new ox(e), t.set(n, [i])) : r >= s.length ? (i = new ox(e), s.push(i)) : i = s[r], i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            class o_ extends iC {
                constructor(e) {
                    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = tG, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                }
            }
            class ob extends iC {
                constructor(e) {
                    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                }
            }

            function ow(e, t, n) {
                let r = new sx,
                    i = new nG,
                    s = new nG,
                    a = new re,
                    o = new o_({
                        depthPacking: tz
                    }),
                    l = new ob,
                    u = {},
                    c = n.maxTextureSize,
                    h = {
                        [y]: x,
                        [x]: y,
                        [E]: E
                    },
                    d = new ss({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new nG
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    f = d.clone();
                f.defines.HORIZONTAL_PASS = 1;
                let p = new iK;
                p.setAttribute("position", new iL(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                let g = new i9(p, d),
                    m = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = A;
                let b = this.type;

                function w(t, n, r, i) {
                    let s = null,
                        a = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (void 0 !== a) s = a;
                    else if (s = !0 === r.isPointLight ? l : o, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                        let e = s.uuid,
                            t = n.uuid,
                            r = u[e];
                        void 0 === r && (r = {}, u[e] = r);
                        let i = r[t];
                        void 0 === i && (i = s.clone(), r[t] = i, n.addEventListener("dispose", C)), s = i
                    }
                    return s.visible = n.visible, s.wireframe = n.wireframe, i === v ? s.side = null !== n.shadowSide ? n.shadowSide : n.side : s.side = null !== n.shadowSide ? n.shadowSide : h[n.side], s.alphaMap = n.alphaMap, s.alphaTest = n.alphaTest, s.map = n.map, s.clipShadows = n.clipShadows, s.clippingPlanes = n.clippingPlanes, s.clipIntersection = n.clipIntersection, s.displacementMap = n.displacementMap, s.displacementScale = n.displacementScale, s.displacementBias = n.displacementBias, s.wireframeLinewidth = n.wireframeLinewidth, s.linewidth = n.linewidth, !0 === r.isPointLight && !0 === s.isMeshDistanceMaterial && (e.properties.get(s).light = r), s
                }

                function C(e) {
                    for (let t in e.target.removeEventListener("dispose", C), u) {
                        let n = u[t],
                            r = e.target.uuid;
                        r in n && (n[r].dispose(), delete n[r])
                    }
                }
                this.render = function(n, o, l) {
                    if (!1 === m.enabled || !1 === m.autoUpdate && !1 === m.needsUpdate || 0 === n.length) return;
                    let u = e.getRenderTarget(),
                        h = e.getActiveCubeFace(),
                        p = e.getActiveMipmapLevel(),
                        A = e.state;
                    A.setBlending(_), A.buffers.color.setClear(1, 1, 1, 1), A.buffers.depth.setTest(!0), A.setScissorTest(!1);
                    let y = b !== v && this.type === v,
                        x = b === v && this.type !== v;
                    for (let u = 0, h = n.length; u < h; u++) {
                        let h = n[u],
                            p = h.shadow;
                        if (void 0 === p) {
                            console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                            continue
                        }
                        if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
                        i.copy(p.mapSize);
                        let m = p.getFrameExtents();
                        if (i.multiply(m), s.copy(p.mapSize), (i.x > c || i.y > c) && (i.x > c && (s.x = Math.floor(c / m.x), i.x = s.x * m.x, p.mapSize.x = s.x), i.y > c && (s.y = Math.floor(c / m.y), i.y = s.y * m.y, p.mapSize.y = s.y)), null === p.map || !0 === y || !0 === x) {
                            let e = this.type !== v ? {
                                minFilter: ew,
                                magFilter: ew
                            } : {};
                            null !== p.map && p.map.dispose(), p.map = new rn(i.x, i.y, e), p.map.texture.name = h.name + ".shadowMap", p.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(p.map), e.clear();
                        let E = p.getViewportCount();
                        for (let n = 0; n < E; n++) {
                            let i = p.getViewport(n);
                            a.set(s.x * i.x, s.y * i.y, s.x * i.z, s.y * i.w), A.viewport(a), p.updateMatrices(h, n), r = p.getFrustum(),
                                function n(i, s, a, o, l) {
                                    if (!1 === i.visible) return;
                                    if (i.layers.test(s.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && l === v) && (!i.frustumCulled || r.intersectsObject(i))) {
                                        i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld);
                                        let n = t.update(i),
                                            r = i.material;
                                        if (Array.isArray(r)) {
                                            let t = n.groups;
                                            for (let u = 0, c = t.length; u < c; u++) {
                                                let c = t[u],
                                                    h = r[c.materialIndex];
                                                if (h && h.visible) {
                                                    let t = w(i, h, o, l);
                                                    i.onBeforeShadow(e, i, s, a, n, t, c), e.renderBufferDirect(a, null, n, t, i, c), i.onAfterShadow(e, i, s, a, n, t, c)
                                                }
                                            }
                                        } else if (r.visible) {
                                            let t = w(i, r, o, l);
                                            i.onBeforeShadow(e, i, s, a, n, t, null), e.renderBufferDirect(a, null, n, t, i, null), i.onAfterShadow(e, i, s, a, n, t, null)
                                        }
                                    }
                                    let u = i.children;
                                    for (let e = 0, t = u.length; e < t; e++) n(u[e], s, a, o, l)
                                }(o, l, p.camera, h, this.type)
                        }!0 !== p.isPointLightShadow && this.type === v && function(n, r) {
                            let s = t.update(g);
                            d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), null === n.mapPass && (n.mapPass = new rn(i.x, i.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, s, d, g, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, s, f, g, null)
                        }(p, l), p.needsUpdate = !1
                    }
                    b = this.type, m.needsUpdate = !1, e.setRenderTarget(u, h, p)
                }
            }
            let oC = {
                [X]: q,
                [K]: ee,
                [Z]: et,
                [J]: $,
                [q]: X,
                [ee]: K,
                [et]: Z,
                [$]: J
            };

            function oS(e) {
                let t = new function() {
                        let t = !1,
                            n = new re,
                            r = null,
                            i = new re(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                r === n || t || (e.colorMask(n, n, n, n), r = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, r, s, a, o) {
                                !0 === o && (t *= a, r *= a, s *= a), n.set(t, r, s, a), !1 === i.equals(n) && (e.clearColor(t, r, s, a), i.copy(n))
                            },
                            reset: function() {
                                t = !1, r = null, i.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    n = new function() {
                        let t = !1,
                            n = !1,
                            r = null,
                            i = null,
                            s = null;
                        return {
                            setReversed: function(e) {
                                n = e
                            },
                            setTest: function(t) {
                                t ? eb(e.DEPTH_TEST) : ew(e.DEPTH_TEST)
                            },
                            setMask: function(n) {
                                r === n || t || (e.depthMask(n), r = n)
                            },
                            setFunc: function(t) {
                                if (n && (t = oC[t]), i !== t) {
                                    switch (t) {
                                        case X:
                                            e.depthFunc(e.NEVER);
                                            break;
                                        case q:
                                            e.depthFunc(e.ALWAYS);
                                            break;
                                        case K:
                                            e.depthFunc(e.LESS);
                                            break;
                                        case J:
                                            e.depthFunc(e.LEQUAL);
                                            break;
                                        case Z:
                                            e.depthFunc(e.EQUAL);
                                            break;
                                        case $:
                                            e.depthFunc(e.GEQUAL);
                                            break;
                                        case ee:
                                            e.depthFunc(e.GREATER);
                                            break;
                                        case et:
                                            e.depthFunc(e.NOTEQUAL);
                                            break;
                                        default:
                                            e.depthFunc(e.LEQUAL)
                                    }
                                    i = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                s !== t && (e.clearDepth(t), s = t)
                            },
                            reset: function() {
                                t = !1, r = null, i = null, s = null
                            }
                        }
                    },
                    r = new function() {
                        let t = !1,
                            n = null,
                            r = null,
                            i = null,
                            s = null,
                            a = null,
                            o = null,
                            l = null,
                            u = null;
                        return {
                            setTest: function(n) {
                                t || (n ? eb(e.STENCIL_TEST) : ew(e.STENCIL_TEST))
                            },
                            setMask: function(r) {
                                n === r || t || (e.stencilMask(r), n = r)
                            },
                            setFunc: function(t, n, a) {
                                (r !== t || i !== n || s !== a) && (e.stencilFunc(t, n, a), r = t, i = n, s = a)
                            },
                            setOp: function(t, n, r) {
                                (a !== t || o !== n || l !== r) && (e.stencilOp(t, n, r), a = t, o = n, l = r)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                u !== t && (e.clearStencil(t), u = t)
                            },
                            reset: function() {
                                t = !1, n = null, r = null, i = null, s = null, a = null, o = null, l = null, u = null
                            }
                        }
                    },
                    i = new WeakMap,
                    s = new WeakMap,
                    a = {},
                    o = {},
                    l = new WeakMap,
                    u = [],
                    c = null,
                    p = !1,
                    g = null,
                    A = null,
                    m = null,
                    v = null,
                    y = null,
                    en = null,
                    er = null,
                    ei = new i_(0, 0, 0),
                    es = 0,
                    ea = !1,
                    eo = null,
                    el = null,
                    eu = null,
                    ec = null,
                    eh = null,
                    ed = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    ef = !1,
                    ep = e.getParameter(e.VERSION); - 1 !== ep.indexOf("WebGL") ? ef = parseFloat(/^WebGL (\d)/.exec(ep)[1]) >= 1 : -1 !== ep.indexOf("OpenGL ES") && (ef = parseFloat(/^OpenGL ES (\d)/.exec(ep)[1]) >= 2);
                let eg = null,
                    eA = {},
                    em = e.getParameter(e.SCISSOR_BOX),
                    ev = e.getParameter(e.VIEWPORT),
                    ey = new re().fromArray(em),
                    ex = new re().fromArray(ev);

                function eE(t, n, r, i) {
                    let s = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                    for (let a = 0; a < r; a++) t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, i, 0, e.RGBA, e.UNSIGNED_BYTE, s) : e.texImage2D(n + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s);
                    return a
                }
                let e_ = {};

                function eb(t) {
                    !0 !== a[t] && (e.enable(t), a[t] = !0)
                }

                function ew(t) {
                    !1 !== a[t] && (e.disable(t), a[t] = !1)
                }
                e_[e.TEXTURE_2D] = eE(e.TEXTURE_2D, e.TEXTURE_2D, 1), e_[e.TEXTURE_CUBE_MAP] = eE(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), e_[e.TEXTURE_2D_ARRAY] = eE(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), e_[e.TEXTURE_3D] = eE(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), t.setClear(0, 0, 0, 1), n.setClear(1), r.setClear(0), eb(e.DEPTH_TEST), n.setFunc(J), eM(!1), eT(d), eb(e.CULL_FACE), eI(_);
                let eC = {
                    [M]: e.FUNC_ADD,
                    [T]: e.FUNC_SUBTRACT,
                    [B]: e.FUNC_REVERSE_SUBTRACT
                };
                eC[R] = e.MIN, eC[D] = e.MAX;
                let eS = {
                    [L]: e.ZERO,
                    [P]: e.ONE,
                    [O]: e.SRC_COLOR,
                    [U]: e.SRC_ALPHA,
                    [H]: e.SRC_ALPHA_SATURATE,
                    [G]: e.DST_COLOR,
                    [k]: e.DST_ALPHA,
                    [N]: e.ONE_MINUS_SRC_COLOR,
                    [F]: e.ONE_MINUS_SRC_ALPHA,
                    [z]: e.ONE_MINUS_DST_COLOR,
                    [Q]: e.ONE_MINUS_DST_ALPHA,
                    [V]: e.CONSTANT_COLOR,
                    [j]: e.ONE_MINUS_CONSTANT_COLOR,
                    [W]: e.CONSTANT_ALPHA,
                    [Y]: e.ONE_MINUS_CONSTANT_ALPHA
                };

                function eI(t, n, r, i, s, a, o, l, u, c) {
                    if (t === _) {
                        !0 === p && (ew(e.BLEND), p = !1);
                        return
                    }
                    if (!1 === p && (eb(e.BLEND), p = !0), t !== I) {
                        if (t !== g || c !== ea) {
                            if ((A !== M || y !== M) && (e.blendEquation(e.FUNC_ADD), A = M, y = M), c) switch (t) {
                                case b:
                                    e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case w:
                                    e.blendFunc(e.ONE, e.ONE);
                                    break;
                                case C:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case S:
                                    e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                                case b:
                                    e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case w:
                                    e.blendFunc(e.SRC_ALPHA, e.ONE);
                                    break;
                                case C:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case S:
                                    e.blendFunc(e.ZERO, e.SRC_COLOR);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            m = null, v = null, en = null, er = null, ei.set(0, 0, 0), es = 0, g = t, ea = c
                        }
                        return
                    }
                    s = s || n, a = a || r, o = o || i, (n !== A || s !== y) && (e.blendEquationSeparate(eC[n], eC[s]), A = n, y = s), (r !== m || i !== v || a !== en || o !== er) && (e.blendFuncSeparate(eS[r], eS[i], eS[a], eS[o]), m = r, v = i, en = a, er = o), (!1 === l.equals(ei) || u !== es) && (e.blendColor(l.r, l.g, l.b, u), ei.copy(l), es = u), g = t, ea = !1
                }

                function eM(t) {
                    eo !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), eo = t)
                }

                function eT(t) {
                    t !== h ? (eb(e.CULL_FACE), t !== el && (t === d ? e.cullFace(e.BACK) : t === f ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : ew(e.CULL_FACE), el = t
                }

                function eB(t, n, r) {
                    t ? (eb(e.POLYGON_OFFSET_FILL), (ec !== n || eh !== r) && (e.polygonOffset(n, r), ec = n, eh = r)) : ew(e.POLYGON_OFFSET_FILL)
                }
                return {
                    buffers: {
                        color: t,
                        depth: n,
                        stencil: r
                    },
                    enable: eb,
                    disable: ew,
                    bindFramebuffer: function(t, n) {
                        return o[t] !== n && (e.bindFramebuffer(t, n), o[t] = n, t === e.DRAW_FRAMEBUFFER && (o[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (o[e.DRAW_FRAMEBUFFER] = n), !0)
                    },
                    drawBuffers: function(t, n) {
                        let r = u,
                            i = !1;
                        if (t) {
                            void 0 === (r = l.get(n)) && (r = [], l.set(n, r));
                            let s = t.textures;
                            if (r.length !== s.length || r[0] !== e.COLOR_ATTACHMENT0) {
                                for (let t = 0, n = s.length; t < n; t++) r[t] = e.COLOR_ATTACHMENT0 + t;
                                r.length = s.length, i = !0
                            }
                        } else r[0] !== e.BACK && (r[0] = e.BACK, i = !0);
                        i && e.drawBuffers(r)
                    },
                    useProgram: function(t) {
                        return c !== t && (e.useProgram(t), c = t, !0)
                    },
                    setBlending: eI,
                    setMaterial: function(i, s) {
                        i.side === E ? ew(e.CULL_FACE) : eb(e.CULL_FACE);
                        let a = i.side === x;
                        s && (a = !a), eM(a), i.blending === b && !1 === i.transparent ? eI(_) : eI(i.blending, i.blendEquation, i.blendSrc, i.blendDst, i.blendEquationAlpha, i.blendSrcAlpha, i.blendDstAlpha, i.blendColor, i.blendAlpha, i.premultipliedAlpha), n.setFunc(i.depthFunc), n.setTest(i.depthTest), n.setMask(i.depthWrite), t.setMask(i.colorWrite);
                        let o = i.stencilWrite;
                        r.setTest(o), o && (r.setMask(i.stencilWriteMask), r.setFunc(i.stencilFunc, i.stencilRef, i.stencilFuncMask), r.setOp(i.stencilFail, i.stencilZFail, i.stencilZPass)), eB(i.polygonOffset, i.polygonOffsetFactor, i.polygonOffsetUnits), !0 === i.alphaToCoverage ? eb(e.SAMPLE_ALPHA_TO_COVERAGE) : ew(e.SAMPLE_ALPHA_TO_COVERAGE)
                    },
                    setFlipSided: eM,
                    setCullFace: eT,
                    setLineWidth: function(t) {
                        t !== eu && (ef && e.lineWidth(t), eu = t)
                    },
                    setPolygonOffset: eB,
                    setScissorTest: function(t) {
                        t ? eb(e.SCISSOR_TEST) : ew(e.SCISSOR_TEST)
                    },
                    activeTexture: function(t) {
                        void 0 === t && (t = e.TEXTURE0 + ed - 1), eg !== t && (e.activeTexture(t), eg = t)
                    },
                    bindTexture: function(t, n, r) {
                        void 0 === r && (r = null === eg ? e.TEXTURE0 + ed - 1 : eg);
                        let i = eA[r];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, eA[r] = i), (i.type !== t || i.texture !== n) && (eg !== r && (e.activeTexture(r), eg = r), e.bindTexture(t, n || e_[t]), i.type = t, i.texture = n)
                    },
                    unbindTexture: function() {
                        let t = eA[eg];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexImage3D: function() {
                        try {
                            e.compressedTexImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    updateUBOMapping: function(t, n) {
                        let r = s.get(n);
                        void 0 === r && (r = new WeakMap, s.set(n, r));
                        let i = r.get(t);
                        void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i))
                    },
                    uniformBlockBinding: function(t, n) {
                        let r = s.get(n).get(t);
                        i.get(n) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), i.set(n, r))
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage3D: function() {
                        try {
                            e.compressedTexSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(t) {
                        !1 === ey.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), ey.copy(t))
                    },
                    viewport: function(t) {
                        !1 === ex.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ex.copy(t))
                    },
                    reset: function() {
                        e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), a = {}, eg = null, eA = {}, o = {}, l = new WeakMap, u = [], c = null, p = !1, g = null, A = null, m = null, v = null, y = null, en = null, er = null, ei = new i_(0, 0, 0), es = 0, ea = !1, eo = null, el = null, eu = null, ec = null, eh = null, ey.set(0, 0, e.canvas.width, e.canvas.height), ex.set(0, 0, e.canvas.width, e.canvas.height), t.reset(), n.reset(), r.reset()
                    }
                }
            }

            function oI(e, t, n, r) {
                let i = function(e) {
                    switch (e) {
                        case eP:
                        case eO:
                            return {
                                byteLength: 1,
                                components: 1
                            };
                        case eU:
                        case eN:
                        case eG:
                            return {
                                byteLength: 2,
                                components: 1
                            };
                        case ez:
                        case eH:
                            return {
                                byteLength: 2,
                                components: 4
                            };
                        case ek:
                        case eF:
                        case eQ:
                            return {
                                byteLength: 4,
                                components: 1
                            };
                        case ej:
                            return {
                                byteLength: 4,
                                components: 3
                            }
                    }
                    throw Error(`Unknown texture type ${e}.`)
                }(r);
                switch (n) {
                    case eW:
                    case eq:
                        return e * t;
                    case eK:
                        return e * t * 2;
                    case e$:
                    case e0:
                        return e * t / i.components * i.byteLength;
                    case e1:
                    case e2:
                        return e * t * 2 / i.components * i.byteLength;
                    case eY:
                        return e * t * 3 / i.components * i.byteLength;
                    case eX:
                    case e4:
                        return e * t * 4 / i.components * i.byteLength;
                    case e5:
                    case e6:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case e8:
                    case e9:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case te:
                    case tn:
                        return Math.max(e, 16) * Math.max(t, 8) / 4;
                    case e7:
                    case tt:
                        return Math.max(e, 8) * Math.max(t, 8) / 2;
                    case tr:
                    case ti:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case ts:
                    case ta:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case to:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
                    case tl:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
                    case tu:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
                    case tc:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
                    case th:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
                    case td:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
                    case tf:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
                    case tp:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
                    case tg:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
                    case tA:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
                    case tm:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
                    case tv:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
                    case ty:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
                    case tx:
                    case tE:
                    case t_:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
                    case tb:
                    case tw:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
                    case tC:
                    case tS:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
                }
                throw Error(`Unable to determine texture byte length for ${n} format.`)
            }
            let oM = {
                contain: function(e, t) {
                    let n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = 1, e.repeat.y = n / t, e.offset.x = 0, e.offset.y = (1 - e.repeat.y) / 2) : (e.repeat.x = t / n, e.repeat.y = 1, e.offset.x = (1 - e.repeat.x) / 2, e.offset.y = 0), e
                },
                cover: function(e, t) {
                    let n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = t / n, e.repeat.y = 1, e.offset.x = (1 - e.repeat.x) / 2, e.offset.y = 0) : (e.repeat.x = 1, e.repeat.y = n / t, e.offset.x = 0, e.offset.y = (1 - e.repeat.y) / 2), e
                },
                fill: function(e) {
                    return e.repeat.x = 1, e.repeat.y = 1, e.offset.x = 0, e.offset.y = 0, e
                },
                getByteLength: oI
            };

            function oT(e, t, n, r, i, s, a) {
                let o;
                let l = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                    u = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                    c = new nG,
                    h = new WeakMap,
                    d = new WeakMap,
                    f = !1;
                try {
                    f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}

                function p(e, t) {
                    return f ? new OffscreenCanvas(e, t) : nY("canvas")
                }

                function g(e, t, n) {
                    let r = 1,
                        i = Q(e);
                    if ((i.width > n || i.height > n) && (r = n / Math.max(i.width, i.height)), r < 1) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                            let n = Math.floor(r * i.width),
                                s = Math.floor(r * i.height);
                            void 0 === o && (o = p(n, s));
                            let a = t ? p(n, s) : o;
                            return a.width = n, a.height = s, a.getContext("2d").drawImage(e, 0, 0, n, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + i.width + "x" + i.height + ") to (" + n + "x" + s + ")."), a
                        }
                        "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + i.width + "x" + i.height + ").")
                    }
                    return e
                }

                function A(e) {
                    return e.generateMipmaps && e.minFilter !== ew && e.minFilter !== eT
                }

                function m(t) {
                    e.generateMipmap(t)
                }

                function v(n, r, i, s, a = !1) {
                    if (null !== n) {
                        if (void 0 !== e[n]) return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let o = r;
                    if (r === e.RED && (i === e.FLOAT && (o = e.R32F), i === e.HALF_FLOAT && (o = e.R16F), i === e.UNSIGNED_BYTE && (o = e.R8)), r === e.RED_INTEGER && (i === e.UNSIGNED_BYTE && (o = e.R8UI), i === e.UNSIGNED_SHORT && (o = e.R16UI), i === e.UNSIGNED_INT && (o = e.R32UI), i === e.BYTE && (o = e.R8I), i === e.SHORT && (o = e.R16I), i === e.INT && (o = e.R32I)), r === e.RG && (i === e.FLOAT && (o = e.RG32F), i === e.HALF_FLOAT && (o = e.RG16F), i === e.UNSIGNED_BYTE && (o = e.RG8)), r === e.RG_INTEGER && (i === e.UNSIGNED_BYTE && (o = e.RG8UI), i === e.UNSIGNED_SHORT && (o = e.RG16UI), i === e.UNSIGNED_INT && (o = e.RG32UI), i === e.BYTE && (o = e.RG8I), i === e.SHORT && (o = e.RG16I), i === e.INT && (o = e.RG32I)), r === e.RGB_INTEGER && (i === e.UNSIGNED_BYTE && (o = e.RGB8UI), i === e.UNSIGNED_SHORT && (o = e.RGB16UI), i === e.UNSIGNED_INT && (o = e.RGB32UI), i === e.BYTE && (o = e.RGB8I), i === e.SHORT && (o = e.RGB16I), i === e.INT && (o = e.RGB32I)), r === e.RGBA_INTEGER && (i === e.UNSIGNED_BYTE && (o = e.RGBA8UI), i === e.UNSIGNED_SHORT && (o = e.RGBA16UI), i === e.UNSIGNED_INT && (o = e.RGBA32UI), i === e.BYTE && (o = e.RGBA8I), i === e.SHORT && (o = e.RGBA16I), i === e.INT && (o = e.RGBA32I)), r === e.RGB && i === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5), r === e.RGBA) {
                        let t = a ? tZ : n1.getTransfer(s);
                        i === e.FLOAT && (o = e.RGBA32F), i === e.HALF_FLOAT && (o = e.RGBA16F), i === e.UNSIGNED_BYTE && (o = t === t$ ? e.SRGB8_ALPHA8 : e.RGBA8), i === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4), i === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1)
                    }
                    return (o === e.R16F || o === e.R32F || o === e.RG16F || o === e.RG32F || o === e.RGBA16F || o === e.RGBA32F) && t.get("EXT_color_buffer_float"), o
                }

                function y(t, n) {
                    let r;
                    return t ? null === n || n === ek || n === eV ? r = e.DEPTH24_STENCIL8 : n === eQ ? r = e.DEPTH32F_STENCIL8 : n === eU && (r = e.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === n || n === ek || n === eV ? r = e.DEPTH_COMPONENT24 : n === eQ ? r = e.DEPTH_COMPONENT32F : n === eU && (r = e.DEPTH_COMPONENT16), r
                }

                function x(e, t) {
                    return !0 === A(e) || e.isFramebufferTexture && e.minFilter !== ew && e.minFilter !== eT ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function E(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", E),
                        function(e) {
                            let t = r.get(e);
                            if (void 0 === t.__webglInit) return;
                            let n = e.source,
                                i = d.get(n);
                            if (i) {
                                let r = i[t.__cacheKey];
                                r.usedTimes--, 0 === r.usedTimes && b(e), 0 === Object.keys(i).length && d.delete(n)
                            }
                            r.remove(e)
                        }(t), t.isVideoTexture && h.delete(t)
                }

                function _(t) {
                    let n = t.target;
                    n.removeEventListener("dispose", _),
                        function(t) {
                            let n = r.get(t);
                            if (t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                                for (let t = 0; t < 6; t++) {
                                    if (Array.isArray(n.__webglFramebuffer[t]))
                                        for (let r = 0; r < n.__webglFramebuffer[t].length; r++) e.deleteFramebuffer(n.__webglFramebuffer[t][r]);
                                    else e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                    n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                                } else {
                                    if (Array.isArray(n.__webglFramebuffer))
                                        for (let t = 0; t < n.__webglFramebuffer.length; t++) e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                    else e.deleteFramebuffer(n.__webglFramebuffer);
                                    if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                                        for (let t = 0; t < n.__webglColorRenderbuffer.length; t++) n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                                    n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                                }
                            let i = t.textures;
                            for (let t = 0, n = i.length; t < n; t++) {
                                let n = r.get(i[t]);
                                n.__webglTexture && (e.deleteTexture(n.__webglTexture), a.memory.textures--), r.remove(i[t])
                            }
                            r.remove(t)
                        }(n)
                }

                function b(t) {
                    let n = r.get(t);
                    e.deleteTexture(n.__webglTexture);
                    let i = t.source,
                        s = d.get(i);
                    delete s[n.__cacheKey], a.memory.textures--
                }
                let w = 0;

                function C(t, i) {
                    let s = r.get(t);
                    if (t.isVideoTexture && function(e) {
                            let t = a.render.frame;
                            h.get(e) !== t && (h.set(e, t), e.update())
                        }(t), !1 === t.isRenderTargetTexture && t.version > 0 && s.__version !== t.version) {
                        let e = t.image;
                        if (null === e) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else if (!1 === e.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                        else {
                            R(s, t, i);
                            return
                        }
                    }
                    n.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + i)
                }
                let S = {
                        [eE]: e.REPEAT,
                        [e_]: e.CLAMP_TO_EDGE,
                        [eb]: e.MIRRORED_REPEAT
                    },
                    I = {
                        [ew]: e.NEAREST,
                        [eC]: e.NEAREST_MIPMAP_NEAREST,
                        [eI]: e.NEAREST_MIPMAP_LINEAR,
                        [eT]: e.LINEAR,
                        [eB]: e.LINEAR_MIPMAP_NEAREST,
                        [eD]: e.LINEAR_MIPMAP_LINEAR
                    },
                    M = {
                        [nl]: e.NEVER,
                        [ng]: e.ALWAYS,
                        [nu]: e.LESS,
                        [nh]: e.LEQUAL,
                        [nc]: e.EQUAL,
                        [np]: e.GEQUAL,
                        [nd]: e.GREATER,
                        [nf]: e.NOTEQUAL
                    };

                function T(n, s) {
                    if (s.type === eQ && !1 === t.has("OES_texture_float_linear") && (s.magFilter === eT || s.magFilter === eB || s.magFilter === eI || s.magFilter === eD || s.minFilter === eT || s.minFilter === eB || s.minFilter === eI || s.minFilter === eD) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), e.texParameteri(n, e.TEXTURE_WRAP_S, S[s.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, S[s.wrapT]), (n === e.TEXTURE_3D || n === e.TEXTURE_2D_ARRAY) && e.texParameteri(n, e.TEXTURE_WRAP_R, S[s.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, I[s.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, I[s.minFilter]), s.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, M[s.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic") && s.magFilter !== ew && (s.minFilter === eI || s.minFilter === eD) && (s.type !== eQ || !1 !== t.has("OES_texture_float_linear")) && (s.anisotropy > 1 || r.get(s).__currentAnisotropy)) {
                        let a = t.get("EXT_texture_filter_anisotropic");
                        e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy
                    }
                }

                function B(t, n) {
                    let r = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", E));
                    let i = n.source,
                        s = d.get(i);
                    void 0 === s && (s = {}, d.set(i, s));
                    let o = function(e) {
                        let t = [];
                        return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join()
                    }(n);
                    if (o !== t.__cacheKey) {
                        void 0 === s[o] && (s[o] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        }, a.memory.textures++, r = !0), s[o].usedTimes++;
                        let i = s[t.__cacheKey];
                        void 0 !== i && (s[t.__cacheKey].usedTimes--, 0 === i.usedTimes && b(n)), t.__cacheKey = o, t.__webglTexture = s[o].texture
                    }
                    return r
                }

                function R(t, a, o) {
                    let l = e.TEXTURE_2D;
                    (a.isDataArrayTexture || a.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY), a.isData3DTexture && (l = e.TEXTURE_3D);
                    let u = B(t, a),
                        c = a.source;
                    n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
                    let h = r.get(c);
                    if (c.version !== h.__version || !0 === u) {
                        let t;
                        n.activeTexture(e.TEXTURE0 + o);
                        let r = n1.getPrimaries(n1.workingColorSpace),
                            d = a.colorSpace === tY ? null : n1.getPrimaries(a.colorSpace),
                            f = a.colorSpace === tY || r === d ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, f);
                        let p = g(a.image, !1, i.maxTextureSize);
                        p = k(a, p);
                        let E = s.convert(a.format, a.colorSpace),
                            _ = s.convert(a.type),
                            b = v(a.internalFormat, E, _, a.colorSpace, a.isVideoTexture);
                        T(l, a);
                        let w = a.mipmaps,
                            C = !0 !== a.isVideoTexture,
                            S = void 0 === h.__version || !0 === u,
                            I = c.dataReady,
                            M = x(a, p);
                        if (a.isDepthTexture) b = y(a.format === eZ, a.type), S && (C ? n.texStorage2D(e.TEXTURE_2D, 1, b, p.width, p.height) : n.texImage2D(e.TEXTURE_2D, 0, b, p.width, p.height, 0, E, _, null));
                        else if (a.isDataTexture) {
                            if (w.length > 0) {
                                C && S && n.texStorage2D(e.TEXTURE_2D, M, b, w[0].width, w[0].height);
                                for (let r = 0, i = w.length; r < i; r++) t = w[r], C ? I && n.texSubImage2D(e.TEXTURE_2D, r, 0, 0, t.width, t.height, E, _, t.data) : n.texImage2D(e.TEXTURE_2D, r, b, t.width, t.height, 0, E, _, t.data);
                                a.generateMipmaps = !1
                            } else C ? (S && n.texStorage2D(e.TEXTURE_2D, M, b, p.width, p.height), I && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p.width, p.height, E, _, p.data)) : n.texImage2D(e.TEXTURE_2D, 0, b, p.width, p.height, 0, E, _, p.data)
                        } else if (a.isCompressedTexture) {
                            if (a.isCompressedArrayTexture) {
                                C && S && n.texStorage3D(e.TEXTURE_2D_ARRAY, M, b, w[0].width, w[0].height, p.depth);
                                for (let r = 0, i = w.length; r < i; r++)
                                    if (t = w[r], a.format !== eX) {
                                        if (null !== E) {
                                            if (C) {
                                                if (I) {
                                                    if (a.layerUpdates.size > 0) {
                                                        let i = oI(t.width, t.height, a.format, a.type);
                                                        for (let s of a.layerUpdates) {
                                                            let a = t.data.subarray(s * i / t.data.BYTES_PER_ELEMENT, (s + 1) * i / t.data.BYTES_PER_ELEMENT);
                                                            n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, r, 0, 0, s, t.width, t.height, 1, E, a, 0, 0)
                                                        }
                                                        a.clearLayerUpdates()
                                                    } else n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, r, 0, 0, 0, t.width, t.height, p.depth, E, t.data, 0, 0)
                                                }
                                            } else n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, r, b, t.width, t.height, p.depth, 0, t.data, 0, 0)
                                        } else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()")
                                    } else C ? I && n.texSubImage3D(e.TEXTURE_2D_ARRAY, r, 0, 0, 0, t.width, t.height, p.depth, E, _, t.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, r, b, t.width, t.height, p.depth, 0, E, _, t.data)
                            } else {
                                C && S && n.texStorage2D(e.TEXTURE_2D, M, b, w[0].width, w[0].height);
                                for (let r = 0, i = w.length; r < i; r++) t = w[r], a.format !== eX ? null !== E ? C ? I && n.compressedTexSubImage2D(e.TEXTURE_2D, r, 0, 0, t.width, t.height, E, t.data) : n.compressedTexImage2D(e.TEXTURE_2D, r, b, t.width, t.height, 0, t.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? I && n.texSubImage2D(e.TEXTURE_2D, r, 0, 0, t.width, t.height, E, _, t.data) : n.texImage2D(e.TEXTURE_2D, r, b, t.width, t.height, 0, E, _, t.data)
                            }
                        } else if (a.isDataArrayTexture) {
                            if (C) {
                                if (S && n.texStorage3D(e.TEXTURE_2D_ARRAY, M, b, p.width, p.height, p.depth), I) {
                                    if (a.layerUpdates.size > 0) {
                                        let t = oI(p.width, p.height, a.format, a.type);
                                        for (let r of a.layerUpdates) {
                                            let i = p.data.subarray(r * t / p.data.BYTES_PER_ELEMENT, (r + 1) * t / p.data.BYTES_PER_ELEMENT);
                                            n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, r, p.width, p.height, 1, E, _, i)
                                        }
                                        a.clearLayerUpdates()
                                    } else n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, E, _, p.data)
                                }
                            } else n.texImage3D(e.TEXTURE_2D_ARRAY, 0, b, p.width, p.height, p.depth, 0, E, _, p.data)
                        } else if (a.isData3DTexture) C ? (S && n.texStorage3D(e.TEXTURE_3D, M, b, p.width, p.height, p.depth), I && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, E, _, p.data)) : n.texImage3D(e.TEXTURE_3D, 0, b, p.width, p.height, p.depth, 0, E, _, p.data);
                        else if (a.isFramebufferTexture) {
                            if (S) {
                                if (C) n.texStorage2D(e.TEXTURE_2D, M, b, p.width, p.height);
                                else {
                                    let t = p.width,
                                        r = p.height;
                                    for (let i = 0; i < M; i++) n.texImage2D(e.TEXTURE_2D, i, b, t, r, 0, E, _, null), t >>= 1, r >>= 1
                                }
                            }
                        } else if (w.length > 0) {
                            if (C && S) {
                                let t = Q(w[0]);
                                n.texStorage2D(e.TEXTURE_2D, M, b, t.width, t.height)
                            }
                            for (let r = 0, i = w.length; r < i; r++) t = w[r], C ? I && n.texSubImage2D(e.TEXTURE_2D, r, 0, 0, E, _, t) : n.texImage2D(e.TEXTURE_2D, r, b, E, _, t);
                            a.generateMipmaps = !1
                        } else if (C) {
                            if (S) {
                                let t = Q(p);
                                n.texStorage2D(e.TEXTURE_2D, M, b, t.width, t.height)
                            }
                            I && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, E, _, p)
                        } else n.texImage2D(e.TEXTURE_2D, 0, b, E, _, p);
                        A(a) && m(l), h.__version = c.version, a.onUpdate && a.onUpdate(a)
                    }
                    t.__version = a.version
                }

                function D(t, i, a, o, u, c) {
                    let h = s.convert(a.format, a.colorSpace),
                        d = s.convert(a.type),
                        f = v(a.internalFormat, h, d, a.colorSpace);
                    if (!r.get(i).__hasExternalTextures) {
                        let t = Math.max(1, i.width >> c),
                            r = Math.max(1, i.height >> c);
                        u === e.TEXTURE_3D || u === e.TEXTURE_2D_ARRAY ? n.texImage3D(u, c, f, t, r, i.depth, 0, h, d, null) : n.texImage2D(u, c, f, t, r, 0, h, d, null)
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, t), F(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, o, u, r.get(a).__webglTexture, 0, U(i)) : (u === e.TEXTURE_2D || u >= e.TEXTURE_CUBE_MAP_POSITIVE_X && u <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, o, u, r.get(a).__webglTexture, c), n.bindFramebuffer(e.FRAMEBUFFER, null)
                }

                function L(t, n, r) {
                    if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer) {
                        let i = n.depthTexture,
                            s = i && i.isDepthTexture ? i.type : null,
                            a = y(n.stencilBuffer, s),
                            o = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            u = U(n);
                        F(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, u, a, n.width, n.height) : r ? e.renderbufferStorageMultisample(e.RENDERBUFFER, u, a, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, a, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, o, e.RENDERBUFFER, t)
                    } else {
                        let t = n.textures;
                        for (let i = 0; i < t.length; i++) {
                            let a = t[i],
                                o = s.convert(a.format, a.colorSpace),
                                u = s.convert(a.type),
                                c = v(a.internalFormat, o, u, a.colorSpace),
                                h = U(n);
                            r && !1 === F(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, h, c, n.width, n.height) : F(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, h, c, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, c, n.width, n.height)
                        }
                    }
                    e.bindRenderbuffer(e.RENDERBUFFER, null)
                }

                function P(t) {
                    let i = r.get(t),
                        s = !0 === t.isWebGLCubeRenderTarget;
                    if (i.__boundDepthTexture !== t.depthTexture) {
                        let e = t.depthTexture;
                        if (i.__depthDisposeCallback && i.__depthDisposeCallback(), e) {
                            let t = () => {
                                delete i.__boundDepthTexture, delete i.__depthDisposeCallback, e.removeEventListener("dispose", t)
                            };
                            e.addEventListener("dispose", t), i.__depthDisposeCallback = t
                        }
                        i.__boundDepthTexture = e
                    }
                    if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                        if (s) throw Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, i) {
                            if (i && i.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(e.FRAMEBUFFER, t), !(i.depthTexture && i.depthTexture.isDepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), C(i.depthTexture, 0);
                            let s = r.get(i.depthTexture).__webglTexture,
                                a = U(i);
                            if (i.depthTexture.format === eJ) F(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0);
                            else if (i.depthTexture.format === eZ) F(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0);
                            else throw Error("Unknown depthTexture format")
                        }(i.__webglFramebuffer, t)
                    } else if (s) {
                        i.__webglDepthbuffer = [];
                        for (let r = 0; r < 6; r++)
                            if (n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[r]), void 0 === i.__webglDepthbuffer[r]) i.__webglDepthbuffer[r] = e.createRenderbuffer(), L(i.__webglDepthbuffer[r], t, !1);
                            else {
                                let n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                                    s = i.__webglDepthbuffer[r];
                                e.bindRenderbuffer(e.RENDERBUFFER, s), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, s)
                            }
                    } else if (n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer), void 0 === i.__webglDepthbuffer) i.__webglDepthbuffer = e.createRenderbuffer(), L(i.__webglDepthbuffer, t, !1);
                    else {
                        let n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            r = i.__webglDepthbuffer;
                        e.bindRenderbuffer(e.RENDERBUFFER, r), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, r)
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                let O = [],
                    N = [];

                function U(e) {
                    return Math.min(i.maxSamples, e.samples)
                }

                function F(e) {
                    let n = r.get(e);
                    return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                }

                function k(e, t) {
                    let n = e.colorSpace,
                        r = e.format,
                        i = e.type;
                    return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== tq && n !== tY && (n1.getTransfer(n) === t$ ? (r !== eX || i !== eP) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)), t
                }

                function Q(e) {
                    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width, c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth, c.height = e.displayHeight) : (c.width = e.width, c.height = e.height), c
                }
                this.allocateTextureUnit = function() {
                    let e = w;
                    return e >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + i.maxTextures), w += 1, e
                }, this.resetTextureUnits = function() {
                    w = 0
                }, this.setTexture2D = C, this.setTexture2DArray = function(t, i) {
                    let s = r.get(t);
                    if (t.version > 0 && s.__version !== t.version) {
                        R(s, t, i);
                        return
                    }
                    n.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture, e.TEXTURE0 + i)
                }, this.setTexture3D = function(t, i) {
                    let s = r.get(t);
                    if (t.version > 0 && s.__version !== t.version) {
                        R(s, t, i);
                        return
                    }
                    n.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + i)
                }, this.setTextureCube = function(t, a) {
                    let o = r.get(t);
                    if (t.version > 0 && o.__version !== t.version) {
                        (function(t, a, o) {
                            if (6 !== a.image.length) return;
                            let l = B(t, a),
                                u = a.source;
                            n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
                            let c = r.get(u);
                            if (u.version !== c.__version || !0 === l) {
                                let t;
                                n.activeTexture(e.TEXTURE0 + o);
                                let r = n1.getPrimaries(n1.workingColorSpace),
                                    h = a.colorSpace === tY ? null : n1.getPrimaries(a.colorSpace),
                                    d = a.colorSpace === tY || r === h ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                                let f = a.isCompressedTexture || a.image[0].isCompressedTexture,
                                    p = a.image[0] && a.image[0].isDataTexture,
                                    y = [];
                                for (let e = 0; e < 6; e++) f || p ? y[e] = p ? a.image[e].image : a.image[e] : y[e] = g(a.image[e], !0, i.maxCubemapSize), y[e] = k(a, y[e]);
                                let E = y[0],
                                    _ = s.convert(a.format, a.colorSpace),
                                    b = s.convert(a.type),
                                    w = v(a.internalFormat, _, b, a.colorSpace),
                                    C = !0 !== a.isVideoTexture,
                                    S = void 0 === c.__version || !0 === l,
                                    I = u.dataReady,
                                    M = x(a, E);
                                if (T(e.TEXTURE_CUBE_MAP, a), f) {
                                    C && S && n.texStorage2D(e.TEXTURE_CUBE_MAP, M, w, E.width, E.height);
                                    for (let r = 0; r < 6; r++) {
                                        t = y[r].mipmaps;
                                        for (let i = 0; i < t.length; i++) {
                                            let s = t[i];
                                            a.format !== eX ? null !== _ ? C ? I && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i, 0, 0, s.width, s.height, _, s.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i, w, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : C ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i, 0, 0, s.width, s.height, _, b, s.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i, w, s.width, s.height, 0, _, b, s.data)
                                        }
                                    }
                                } else {
                                    if (t = a.mipmaps, C && S) {
                                        t.length > 0 && M++;
                                        let r = Q(y[0]);
                                        n.texStorage2D(e.TEXTURE_CUBE_MAP, M, w, r.width, r.height)
                                    }
                                    for (let r = 0; r < 6; r++)
                                        if (p) {
                                            C ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, 0, 0, y[r].width, y[r].height, _, b, y[r].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, w, y[r].width, y[r].height, 0, _, b, y[r].data);
                                            for (let i = 0; i < t.length; i++) {
                                                let s = t[i].image[r].image;
                                                C ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i + 1, 0, 0, s.width, s.height, _, b, s.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i + 1, w, s.width, s.height, 0, _, b, s.data)
                                            }
                                        } else {
                                            C ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, 0, 0, _, b, y[r]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, w, _, b, y[r]);
                                            for (let i = 0; i < t.length; i++) {
                                                let s = t[i];
                                                C ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i + 1, 0, 0, _, b, s.image[r]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i + 1, w, _, b, s.image[r])
                                            }
                                        }
                                }
                                A(a) && m(e.TEXTURE_CUBE_MAP), c.__version = u.version, a.onUpdate && a.onUpdate(a)
                            }
                            t.__version = a.version
                        })(o, t, a);
                        return
                    }
                    n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + a)
                }, this.rebindTextures = function(t, n, i) {
                    let s = r.get(t);
                    void 0 !== n && D(s.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== i && P(t)
                }, this.setupRenderTarget = function(t) {
                    let i = t.texture,
                        o = r.get(t),
                        l = r.get(i);
                    t.addEventListener("dispose", _);
                    let u = t.textures,
                        c = !0 === t.isWebGLCubeRenderTarget,
                        h = u.length > 1;
                    if (!h && (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = i.version, a.memory.textures++), c) {
                        o.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++)
                            if (i.mipmaps && i.mipmaps.length > 0) {
                                o.__webglFramebuffer[t] = [];
                                for (let n = 0; n < i.mipmaps.length; n++) o.__webglFramebuffer[t][n] = e.createFramebuffer()
                            } else o.__webglFramebuffer[t] = e.createFramebuffer()
                    } else {
                        if (i.mipmaps && i.mipmaps.length > 0) {
                            o.__webglFramebuffer = [];
                            for (let t = 0; t < i.mipmaps.length; t++) o.__webglFramebuffer[t] = e.createFramebuffer()
                        } else o.__webglFramebuffer = e.createFramebuffer();
                        if (h)
                            for (let t = 0, n = u.length; t < n; t++) {
                                let n = r.get(u[t]);
                                void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(), a.memory.textures++)
                            }
                        if (t.samples > 0 && !1 === F(t)) {
                            o.__webglMultisampledFramebuffer = e.createFramebuffer(), o.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
                            for (let n = 0; n < u.length; n++) {
                                let r = u[n];
                                o.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[n]);
                                let i = s.convert(r.format, r.colorSpace),
                                    a = s.convert(r.type),
                                    l = v(r.internalFormat, i, a, r.colorSpace, !0 === t.isXRRenderTarget),
                                    c = U(t);
                                e.renderbufferStorageMultisample(e.RENDERBUFFER, c, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, o.__webglColorRenderbuffer[n])
                            }
                            e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(), L(o.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null)
                        }
                    }
                    if (c) {
                        n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture), T(e.TEXTURE_CUBE_MAP, i);
                        for (let n = 0; n < 6; n++)
                            if (i.mipmaps && i.mipmaps.length > 0)
                                for (let r = 0; r < i.mipmaps.length; r++) D(o.__webglFramebuffer[n][r], t, i, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                            else D(o.__webglFramebuffer[n], t, i, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                        A(i) && m(e.TEXTURE_CUBE_MAP), n.unbindTexture()
                    } else if (h) {
                        for (let i = 0, s = u.length; i < s; i++) {
                            let s = u[i],
                                a = r.get(s);
                            n.bindTexture(e.TEXTURE_2D, a.__webglTexture), T(e.TEXTURE_2D, s), D(o.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + i, e.TEXTURE_2D, 0), A(s) && m(e.TEXTURE_2D)
                        }
                        n.unbindTexture()
                    } else {
                        let r = e.TEXTURE_2D;
                        if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (r = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), n.bindTexture(r, l.__webglTexture), T(r, i), i.mipmaps && i.mipmaps.length > 0)
                            for (let n = 0; n < i.mipmaps.length; n++) D(o.__webglFramebuffer[n], t, i, e.COLOR_ATTACHMENT0, r, n);
                        else D(o.__webglFramebuffer, t, i, e.COLOR_ATTACHMENT0, r, 0);
                        A(i) && m(r), n.unbindTexture()
                    }
                    t.depthBuffer && P(t)
                }, this.updateRenderTargetMipmap = function(t) {
                    let i = t.textures;
                    for (let s = 0, a = i.length; s < a; s++) {
                        let a = i[s];
                        if (A(a)) {
                            let i = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
                                s = r.get(a).__webglTexture;
                            n.bindTexture(i, s), m(i), n.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(t) {
                    if (t.samples > 0) {
                        if (!1 === F(t)) {
                            let i = t.textures,
                                s = t.width,
                                a = t.height,
                                o = e.COLOR_BUFFER_BIT,
                                l = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                                c = r.get(t),
                                h = i.length > 1;
                            if (h)
                                for (let t = 0; t < i.length; t++) n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                            n.bindFramebuffer(e.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglFramebuffer);
                            for (let n = 0; n < i.length; n++) {
                                if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)), h) {
                                    e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                                    let t = r.get(i[n]).__webglTexture;
                                    e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                                }
                                e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST), !0 === u && (O.length = 0, N.length = 0, O.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && !1 === t.resolveDepthBuffer && (O.push(l), N.push(l), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, N)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, O))
                            }
                            if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), h)
                                for (let t = 0; t < i.length; t++) {
                                    n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, c.__webglColorRenderbuffer[t]);
                                    let s = r.get(i[t]).__webglTexture;
                                    n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, s, 0)
                                }
                            n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                        } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && u) {
                            let n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                            e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
                        }
                    }
                }, this.setupDepthRenderbuffer = P, this.setupFrameBufferTexture = D, this.useMultisampledRTT = F
            }

            function oB(e, t) {
                return {
                    convert: function(n, r = tY) {
                        let i;
                        let s = n1.getTransfer(r);
                        if (n === eP) return e.UNSIGNED_BYTE;
                        if (n === ez) return e.UNSIGNED_SHORT_4_4_4_4;
                        if (n === eH) return e.UNSIGNED_SHORT_5_5_5_1;
                        if (n === ej) return e.UNSIGNED_INT_5_9_9_9_REV;
                        if (n === eO) return e.BYTE;
                        if (n === eN) return e.SHORT;
                        if (n === eU) return e.UNSIGNED_SHORT;
                        if (n === eF) return e.INT;
                        if (n === ek) return e.UNSIGNED_INT;
                        if (n === eQ) return e.FLOAT;
                        if (n === eG) return e.HALF_FLOAT;
                        if (n === eW) return e.ALPHA;
                        if (n === eY) return e.RGB;
                        if (n === eX) return e.RGBA;
                        if (n === eq) return e.LUMINANCE;
                        if (n === eK) return e.LUMINANCE_ALPHA;
                        if (n === eJ) return e.DEPTH_COMPONENT;
                        if (n === eZ) return e.DEPTH_STENCIL;
                        if (n === e$) return e.RED;
                        if (n === e0) return e.RED_INTEGER;
                        if (n === e1) return e.RG;
                        if (n === e2) return e.RG_INTEGER;
                        if (n === e4) return e.RGBA_INTEGER;
                        if (n === e5 || n === e6 || n === e8 || n === e9) {
                            if (s === t$) {
                                if (null === (i = t.get("WEBGL_compressed_texture_s3tc_srgb"))) return null;
                                if (n === e5) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (n === e6) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (n === e8) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (n === e9) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (null === (i = t.get("WEBGL_compressed_texture_s3tc"))) return null;
                                if (n === e5) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (n === e6) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (n === e8) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (n === e9) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        }
                        if (n === e7 || n === te || n === tt || n === tn) {
                            if (null === (i = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (n === e7) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === te) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === tt) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === tn) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (n === tr || n === ti || n === ts) {
                            if (null === (i = t.get("WEBGL_compressed_texture_etc"))) return null;
                            if (n === tr || n === ti) return s === t$ ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
                            if (n === ts) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (n === ta || n === to || n === tl || n === tu || n === tc || n === th || n === td || n === tf || n === tp || n === tg || n === tA || n === tm || n === tv || n === ty) {
                            if (null === (i = t.get("WEBGL_compressed_texture_astc"))) return null;
                            if (n === ta) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (n === to) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (n === tl) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (n === tu) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (n === tc) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (n === th) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (n === td) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (n === tf) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (n === tp) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (n === tg) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (n === tA) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (n === tm) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (n === tv) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (n === ty) return s === t$ ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (n === tx || n === tE || n === t_) {
                            if (null === (i = t.get("EXT_texture_compression_bptc"))) return null;
                            if (n === tx) return s === t$ ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                            if (n === tE) return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                            if (n === t_) return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                        }
                        if (n === tb || n === tw || n === tC || n === tS) {
                            if (null === (i = t.get("EXT_texture_compression_rgtc"))) return null;
                            if (n === tx) return i.COMPRESSED_RED_RGTC1_EXT;
                            if (n === tw) return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                            if (n === tC) return i.COMPRESSED_RED_GREEN_RGTC2_EXT;
                            if (n === tS) return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                        }
                        return n === eV ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
                    }
                }
            }
            class oR extends sc {
                constructor(e = []) {
                    super(), this.isArrayCamera = !0, this.cameras = e
                }
            }
            class oD extends it {
                constructor() {
                    super(), this.isGroup = !0, this.type = "Group"
                }
            }
            let oL = {
                type: "move"
            };
            class oP {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new oD, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new oD, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new rl, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new rl), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new oD, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new rl, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new rl), this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                }
                connect(e) {
                    if (e && e.hand) {
                        let t = this._hand;
                        if (t)
                            for (let n of e.hand.values()) this._getHandJoint(t, n)
                    }
                    return this.dispatchEvent({
                        type: "connected",
                        data: e
                    }), this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(e, t, n) {
                    let r = null,
                        i = null,
                        s = null,
                        a = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState) {
                        if (l && e.hand) {
                            for (let r of (s = !0, e.hand.values())) {
                                let e = t.getJointPose(r, n),
                                    i = this._getHandJoint(l, r);
                                null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.matrixWorldNeedsUpdate = !0, i.jointRadius = e.radius), i.visible = null !== e
                            }
                            let r = l.joints["index-finger-tip"],
                                i = l.joints["thumb-tip"],
                                a = r.position.distanceTo(i.position);
                            l.inputState.pinching && a > .025 ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && a <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else null !== o && e.gripSpace && null !== (i = t.getPose(e.gripSpace, n)) && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1);
                        null !== a && (null === (r = t.getPose(e.targetRaySpace, n)) && null !== i && (r = i), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(oL)))
                    }
                    return null !== a && (a.visible = null !== r), null !== o && (o.visible = null !== i), null !== l && (l.visible = null !== s), this
                }
                _getHandJoint(e, t) {
                    if (void 0 === e.joints[t.jointName]) {
                        let n = new oD;
                        n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
                    }
                    return e.joints[t.jointName]
                }
            }
            let oO = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
                oN = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
            class oU {
                constructor() {
                    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
                }
                init(e, t, n) {
                    if (null === this.texture) {
                        let r = new n7;
                        e.properties.get(r).__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r
                    }
                }
                getMesh(e) {
                    if (null !== this.texture && null === this.mesh) {
                        let t = e.cameras[0].viewport,
                            n = new ss({
                                vertexShader: oO,
                                fragmentShader: oN,
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: t.z
                                    },
                                    depthHeight: {
                                        value: t.w
                                    }
                                }
                            });
                        this.mesh = new i9(new sb(20, 20), n)
                    }
                    return this.mesh
                }
                reset() {
                    this.texture = null, this.mesh = null
                }
                getDepthTexture() {
                    return this.texture
                }
            }
            class oF extends nT {
                constructor(e, t) {
                    super();
                    let n = this,
                        r = null,
                        i = 1,
                        s = null,
                        a = "local-floor",
                        o = 1,
                        l = null,
                        u = null,
                        c = null,
                        h = null,
                        d = null,
                        f = null,
                        p = new oU,
                        g = t.getContextAttributes(),
                        A = null,
                        m = null,
                        v = [],
                        y = [],
                        x = new nG,
                        E = null,
                        _ = new sc;
                    _.layers.enable(1), _.viewport = new re;
                    let b = new sc;
                    b.layers.enable(2), b.viewport = new re;
                    let w = [_, b],
                        C = new oR;
                    C.layers.enable(1), C.layers.enable(2);
                    let S = null,
                        I = null;

                    function M(e) {
                        let t = y.indexOf(e.inputSource);
                        if (-1 === t) return;
                        let n = v[t];
                        void 0 !== n && (n.update(e.inputSource, e.frame, l || s), n.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        }))
                    }

                    function T() {
                        r.removeEventListener("select", M), r.removeEventListener("selectstart", M), r.removeEventListener("selectend", M), r.removeEventListener("squeeze", M), r.removeEventListener("squeezestart", M), r.removeEventListener("squeezeend", M), r.removeEventListener("end", T), r.removeEventListener("inputsourceschange", B);
                        for (let e = 0; e < v.length; e++) {
                            let t = y[e];
                            null !== t && (y[e] = null, v[e].disconnect(t))
                        }
                        S = null, I = null, p.reset(), e.setRenderTarget(A), d = null, h = null, c = null, r = null, m = null, O.stop(), n.isPresenting = !1, e.setPixelRatio(E), e.setSize(x.width, x.height, !1), n.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function B(e) {
                        for (let t = 0; t < e.removed.length; t++) {
                            let n = e.removed[t],
                                r = y.indexOf(n);
                            r >= 0 && (y[r] = null, v[r].disconnect(n))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            let n = e.added[t],
                                r = y.indexOf(n);
                            if (-1 === r) {
                                for (let e = 0; e < v.length; e++) {
                                    if (e >= y.length) {
                                        y.push(n), r = e;
                                        break
                                    }
                                    if (null === y[e]) {
                                        y[e] = n, r = e;
                                        break
                                    }
                                }
                                if (-1 === r) break
                            }
                            let i = v[r];
                            i && i.connect(n)
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                        let t = v[e];
                        return void 0 === t && (t = new oP, v[e] = t), t.getTargetRaySpace()
                    }, this.getControllerGrip = function(e) {
                        let t = v[e];
                        return void 0 === t && (t = new oP, v[e] = t), t.getGripSpace()
                    }, this.getHand = function(e) {
                        let t = v[e];
                        return void 0 === t && (t = new oP, v[e] = t), t.getHandSpace()
                    }, this.setFramebufferScaleFactor = function(e) {
                        i = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function(e) {
                        a = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function() {
                        return l || s
                    }, this.setReferenceSpace = function(e) {
                        l = e
                    }, this.getBaseLayer = function() {
                        return null !== h ? h : d
                    }, this.getBinding = function() {
                        return c
                    }, this.getFrame = function() {
                        return f
                    }, this.getSession = function() {
                        return r
                    }, this.setSession = async function(u) {
                        if (null !== (r = u)) {
                            if (A = e.getRenderTarget(), r.addEventListener("select", M), r.addEventListener("selectstart", M), r.addEventListener("selectend", M), r.addEventListener("squeeze", M), r.addEventListener("squeezestart", M), r.addEventListener("squeezeend", M), r.addEventListener("end", T), r.addEventListener("inputsourceschange", B), !0 !== g.xrCompatible && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(x), void 0 === r.renderState.layers) {
                                let n = {
                                    antialias: g.antialias,
                                    alpha: !0,
                                    depth: g.depth,
                                    stencil: g.stencil,
                                    framebufferScaleFactor: i
                                };
                                d = new XRWebGLLayer(r, t, n), r.updateRenderState({
                                    baseLayer: d
                                }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, !1), m = new rn(d.framebufferWidth, d.framebufferHeight, {
                                    format: eX,
                                    type: eP,
                                    colorSpace: e.outputColorSpace,
                                    stencilBuffer: g.stencil
                                })
                            } else {
                                let n = null,
                                    s = null,
                                    a = null;
                                g.depth && (a = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = g.stencil ? eZ : eJ, s = g.stencil ? eV : ek);
                                let o = {
                                    colorFormat: t.RGBA8,
                                    depthFormat: a,
                                    scaleFactor: i
                                };
                                h = (c = new XRWebGLBinding(r, t)).createProjectionLayer(o), r.updateRenderState({
                                    layers: [h]
                                }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), m = new rn(h.textureWidth, h.textureHeight, {
                                    format: eX,
                                    type: eP,
                                    depthTexture: new s6(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                    stencilBuffer: g.stencil,
                                    colorSpace: e.outputColorSpace,
                                    samples: g.antialias ? 4 : 0,
                                    resolveDepthBuffer: !1 === h.ignoreDepthValues
                                })
                            }
                            m.isXRRenderTarget = !0, this.setFoveation(o), l = null, s = await r.requestReferenceSpace(a), O.setContext(r), O.start(), n.isPresenting = !0, n.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    }, this.getEnvironmentBlendMode = function() {
                        if (null !== r) return r.environmentBlendMode
                    }, this.getDepthTexture = function() {
                        return p.getDepthTexture()
                    };
                    let R = new rl,
                        D = new rl;

                    function L(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === r) return;
                        let t = e.near,
                            n = e.far;
                        null !== p.texture && (p.depthNear > 0 && (t = p.depthNear), p.depthFar > 0 && (n = p.depthFar)), C.near = b.near = _.near = t, C.far = b.far = _.far = n, (S !== C.near || I !== C.far) && (r.updateRenderState({
                            depthNear: C.near,
                            depthFar: C.far
                        }), S = C.near, I = C.far);
                        let i = e.parent,
                            s = C.cameras;
                        L(C, i);
                        for (let e = 0; e < s.length; e++) L(s[e], i);
                        2 === s.length ? function(e, t, n) {
                            R.setFromMatrixPosition(t.matrixWorld), D.setFromMatrixPosition(n.matrixWorld);
                            let r = R.distanceTo(D),
                                i = t.projectionMatrix.elements,
                                s = n.projectionMatrix.elements,
                                a = i[14] / (i[10] - 1),
                                o = i[14] / (i[10] + 1),
                                l = (i[9] + 1) / i[5],
                                u = (i[9] - 1) / i[5],
                                c = (i[8] - 1) / i[0],
                                h = (s[8] + 1) / s[0],
                                d = r / (-c + h),
                                f = -(d * c);
                            if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(d), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), -1 === i[10]) e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                            else {
                                let t = a + d,
                                    n = o + d;
                                e.projectionMatrix.makePerspective(a * c - f, a * h + (r - f), l * o / n * t, u * o / n * t, t, n), e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                            }
                        }(C, _, b) : C.projectionMatrix.copy(_.projectionMatrix), null === i ? e.matrix.copy(C.matrixWorld) : (e.matrix.copy(i.matrixWorld), e.matrix.invert(), e.matrix.multiply(C.matrixWorld)), e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(C.projectionMatrix), e.projectionMatrixInverse.copy(C.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * nL * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1)
                    }, this.getCamera = function() {
                        return C
                    }, this.getFoveation = function() {
                        if (null !== h || null !== d) return o
                    }, this.setFoveation = function(e) {
                        o = e, null !== h && (h.fixedFoveation = e), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e)
                    }, this.hasDepthSensing = function() {
                        return null !== p.texture
                    }, this.getDepthSensingMesh = function() {
                        return p.getMesh(C)
                    };
                    let P = null,
                        O = new sE;
                    O.setAnimationLoop(function(t, i) {
                        if (u = i.getViewerPose(l || s), f = i, null !== u) {
                            let t = u.views;
                            null !== d && (e.setRenderTargetFramebuffer(m, d.framebuffer), e.setRenderTarget(m));
                            let n = !1;
                            t.length !== C.cameras.length && (C.cameras.length = 0, n = !0);
                            for (let r = 0; r < t.length; r++) {
                                let i = t[r],
                                    s = null;
                                if (null !== d) s = d.getViewport(i);
                                else {
                                    let t = c.getViewSubImage(h, i);
                                    s = t.viewport, 0 === r && (e.setRenderTargetTextures(m, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(m))
                                }
                                let a = w[r];
                                void 0 === a && ((a = new sc).layers.enable(r), a.viewport = new re, w[r] = a), a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.projectionMatrix.fromArray(i.projectionMatrix), a.projectionMatrixInverse.copy(a.projectionMatrix).invert(), a.viewport.set(s.x, s.y, s.width, s.height), 0 === r && (C.matrix.copy(a.matrix), C.matrix.decompose(C.position, C.quaternion, C.scale)), !0 === n && C.cameras.push(a)
                            }
                            let i = r.enabledFeatures;
                            if (i && i.includes("depth-sensing")) {
                                let n = c.getDepthInformation(t[0]);
                                n && n.isValid && n.texture && p.init(e, n, r.renderState)
                            }
                        }
                        for (let e = 0; e < v.length; e++) {
                            let t = y[e],
                                n = v[e];
                            null !== t && void 0 !== n && n.update(t, i, l || s)
                        }
                        P && P(t, i), i.detectedPlanes && n.dispatchEvent({
                            type: "planesdetected",
                            data: i
                        }), f = null
                    }), this.setAnimationLoop = function(e) {
                        P = e
                    }, this.dispose = function() {}
                }
            }
            let ok = new rX,
                oQ = new rF;

            function oG(e, t) {
                function n(e, t) {
                    !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix)
                }

                function r(e, r) {
                    e.opacity.value = r.opacity, r.color && e.diffuse.value.copy(r.color), r.emissive && e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (e.map.value = r.map, n(r.map, e.mapTransform)), r.alphaMap && (e.alphaMap.value = r.alphaMap, n(r.alphaMap, e.alphaMapTransform)), r.bumpMap && (e.bumpMap.value = r.bumpMap, n(r.bumpMap, e.bumpMapTransform), e.bumpScale.value = r.bumpScale, r.side === x && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, n(r.normalMap, e.normalMapTransform), e.normalScale.value.copy(r.normalScale), r.side === x && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, n(r.displacementMap, e.displacementMapTransform), e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, e.emissiveMapTransform)), r.specularMap && (e.specularMap.value = r.specularMap, n(r.specularMap, e.specularMapTransform)), r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest);
                    let i = t.get(r),
                        s = i.envMap,
                        a = i.envMapRotation;
                    s && (e.envMap.value = s, ok.copy(a), ok.x *= -1, ok.y *= -1, ok.z *= -1, s.isCubeTexture && !1 === s.isRenderTargetTexture && (ok.y *= -1, ok.z *= -1), e.envMapRotation.value.setFromMatrix4(oQ.makeRotationFromEuler(ok)), e.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = r.reflectivity, e.ior.value = r.ior, e.refractionRatio.value = r.refractionRatio), r.lightMap && (e.lightMap.value = r.lightMap, e.lightMapIntensity.value = r.lightMapIntensity, n(r.lightMap, e.lightMapTransform)), r.aoMap && (e.aoMap.value = r.aoMap, e.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, e.aoMapTransform))
                }
                return {
                    refreshFogUniforms: function(t, n) {
                        n.color.getRGB(t.fogColor.value, sr(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                    },
                    refreshMaterialUniforms: function(e, i, s, a, o) {
                        i.isMeshBasicMaterial ? r(e, i) : i.isMeshLambertMaterial ? r(e, i) : i.isMeshToonMaterial ? (r(e, i), i.gradientMap && (e.gradientMap.value = i.gradientMap)) : i.isMeshPhongMaterial ? (r(e, i), e.specular.value.copy(i.specular), e.shininess.value = Math.max(i.shininess, 1e-4)) : i.isMeshStandardMaterial ? (r(e, i), e.metalness.value = i.metalness, i.metalnessMap && (e.metalnessMap.value = i.metalnessMap, n(i.metalnessMap, e.metalnessMapTransform)), e.roughness.value = i.roughness, i.roughnessMap && (e.roughnessMap.value = i.roughnessMap, n(i.roughnessMap, e.roughnessMapTransform)), i.envMap && (e.envMapIntensity.value = i.envMapIntensity), i.isMeshPhysicalMaterial && (e.ior.value = i.ior, i.sheen > 0 && (e.sheenColor.value.copy(i.sheenColor).multiplyScalar(i.sheen), e.sheenRoughness.value = i.sheenRoughness, i.sheenColorMap && (e.sheenColorMap.value = i.sheenColorMap, n(i.sheenColorMap, e.sheenColorMapTransform)), i.sheenRoughnessMap && (e.sheenRoughnessMap.value = i.sheenRoughnessMap, n(i.sheenRoughnessMap, e.sheenRoughnessMapTransform))), i.clearcoat > 0 && (e.clearcoat.value = i.clearcoat, e.clearcoatRoughness.value = i.clearcoatRoughness, i.clearcoatMap && (e.clearcoatMap.value = i.clearcoatMap, n(i.clearcoatMap, e.clearcoatMapTransform)), i.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = i.clearcoatRoughnessMap, n(i.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), i.clearcoatNormalMap && (e.clearcoatNormalMap.value = i.clearcoatNormalMap, n(i.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(i.clearcoatNormalScale), i.side === x && e.clearcoatNormalScale.value.negate())), i.dispersion > 0 && (e.dispersion.value = i.dispersion), i.iridescence > 0 && (e.iridescence.value = i.iridescence, e.iridescenceIOR.value = i.iridescenceIOR, e.iridescenceThicknessMinimum.value = i.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = i.iridescenceThicknessRange[1], i.iridescenceMap && (e.iridescenceMap.value = i.iridescenceMap, n(i.iridescenceMap, e.iridescenceMapTransform)), i.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = i.iridescenceThicknessMap, n(i.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))), i.transmission > 0 && (e.transmission.value = i.transmission, e.transmissionSamplerMap.value = o.texture, e.transmissionSamplerSize.value.set(o.width, o.height), i.transmissionMap && (e.transmissionMap.value = i.transmissionMap, n(i.transmissionMap, e.transmissionMapTransform)), e.thickness.value = i.thickness, i.thicknessMap && (e.thicknessMap.value = i.thicknessMap, n(i.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = i.attenuationDistance, e.attenuationColor.value.copy(i.attenuationColor)), i.anisotropy > 0 && (e.anisotropyVector.value.set(i.anisotropy * Math.cos(i.anisotropyRotation), i.anisotropy * Math.sin(i.anisotropyRotation)), i.anisotropyMap && (e.anisotropyMap.value = i.anisotropyMap, n(i.anisotropyMap, e.anisotropyMapTransform))), e.specularIntensity.value = i.specularIntensity, e.specularColor.value.copy(i.specularColor), i.specularColorMap && (e.specularColorMap.value = i.specularColorMap, n(i.specularColorMap, e.specularColorMapTransform)), i.specularIntensityMap && (e.specularIntensityMap.value = i.specularIntensityMap, n(i.specularIntensityMap, e.specularIntensityMapTransform)))) : i.isMeshMatcapMaterial ? (r(e, i), i.matcap && (e.matcap.value = i.matcap)) : i.isMeshDepthMaterial ? r(e, i) : i.isMeshDistanceMaterial ? (r(e, i), function(e, n) {
                            let r = t.get(n).light;
                            e.referencePosition.value.setFromMatrixPosition(r.matrixWorld), e.nearDistance.value = r.shadow.camera.near, e.farDistance.value = r.shadow.camera.far
                        }(e, i)) : i.isMeshNormalMaterial ? r(e, i) : i.isLineBasicMaterial ? (e.diffuse.value.copy(i.color), e.opacity.value = i.opacity, i.map && (e.map.value = i.map, n(i.map, e.mapTransform)), i.isLineDashedMaterial && (e.dashSize.value = i.dashSize, e.totalSize.value = i.dashSize + i.gapSize, e.scale.value = i.scale)) : i.isPointsMaterial ? (e.diffuse.value.copy(i.color), e.opacity.value = i.opacity, e.size.value = i.size * s, e.scale.value = .5 * a, i.map && (e.map.value = i.map, n(i.map, e.uvTransform)), i.alphaMap && (e.alphaMap.value = i.alphaMap, n(i.alphaMap, e.alphaMapTransform)), i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest)) : i.isSpriteMaterial ? (e.diffuse.value.copy(i.color), e.opacity.value = i.opacity, e.rotation.value = i.rotation, i.map && (e.map.value = i.map, n(i.map, e.mapTransform)), i.alphaMap && (e.alphaMap.value = i.alphaMap, n(i.alphaMap, e.alphaMapTransform)), i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest)) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                    }
                }
            }

            function oz(e, t, n, r) {
                let i = {},
                    s = {},
                    a = [],
                    o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);

                function l(e) {
                    let t = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t
                }

                function u(t) {
                    let n = t.target;
                    n.removeEventListener("dispose", u);
                    let r = a.indexOf(n.__bindingPointIndex);
                    a.splice(r, 1), e.deleteBuffer(i[n.id]), delete i[n.id], delete s[n.id]
                }
                return {
                    bind: function(e, t) {
                        let n = t.program;
                        r.uniformBlockBinding(e, n)
                    },
                    update: function(n, c) {
                        let h = i[n.id];
                        void 0 === h && (function(e) {
                            let t = e.uniforms,
                                n = 0;
                            for (let e = 0, r = t.length; e < r; e++) {
                                let r = Array.isArray(t[e]) ? t[e] : [t[e]];
                                for (let e = 0, t = r.length; e < t; e++) {
                                    let t = r[e],
                                        i = Array.isArray(t.value) ? t.value : [t.value];
                                    for (let e = 0, r = i.length; e < r; e++) {
                                        let r = l(i[e]),
                                            s = n % 16,
                                            a = s % r.boundary,
                                            o = s + a;
                                        n += a, 0 !== o && 16 - o < r.storage && (n += 16 - o), t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = n, n += r.storage
                                    }
                                }
                            }
                            let r = n % 16;
                            r > 0 && (n += 16 - r), e.__size = n, e.__cache = {}
                        }(n), h = function(t) {
                            let n = function() {
                                for (let e = 0; e < o; e++)
                                    if (-1 === a.indexOf(e)) return a.push(e), e;
                                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                            }();
                            t.__bindingPointIndex = n;
                            let r = e.createBuffer(),
                                i = t.__size,
                                s = t.usage;
                            return e.bindBuffer(e.UNIFORM_BUFFER, r), e.bufferData(e.UNIFORM_BUFFER, i, s), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, r), r
                        }(n), i[n.id] = h, n.addEventListener("dispose", u));
                        let d = c.program;
                        r.updateUBOMapping(n, d);
                        let f = t.render.frame;
                        s[n.id] !== f && (function(t) {
                            let n = i[t.id],
                                r = t.uniforms,
                                s = t.__cache;
                            e.bindBuffer(e.UNIFORM_BUFFER, n);
                            for (let t = 0, n = r.length; t < n; t++) {
                                let n = Array.isArray(r[t]) ? r[t] : [r[t]];
                                for (let r = 0, i = n.length; r < i; r++) {
                                    let i = n[r];
                                    if (!0 === function(e, t, n, r) {
                                            let i = e.value,
                                                s = t + "_" + n;
                                            if (void 0 === r[s]) return "number" == typeof i || "boolean" == typeof i ? r[s] = i : r[s] = i.clone(), !0; {
                                                let e = r[s];
                                                if ("number" == typeof i || "boolean" == typeof i) {
                                                    if (e !== i) return r[s] = i, !0
                                                } else if (!1 === e.equals(i)) return e.copy(i), !0
                                            }
                                            return !1
                                        }(i, t, r, s)) {
                                        let t = i.__offset,
                                            n = Array.isArray(i.value) ? i.value : [i.value],
                                            r = 0;
                                        for (let s = 0; s < n.length; s++) {
                                            let a = n[s],
                                                o = l(a);
                                            "number" == typeof a || "boolean" == typeof a ? (i.__data[0] = a, e.bufferSubData(e.UNIFORM_BUFFER, t + r, i.__data)) : a.isMatrix3 ? (i.__data[0] = a.elements[0], i.__data[1] = a.elements[1], i.__data[2] = a.elements[2], i.__data[3] = 0, i.__data[4] = a.elements[3], i.__data[5] = a.elements[4], i.__data[6] = a.elements[5], i.__data[7] = 0, i.__data[8] = a.elements[6], i.__data[9] = a.elements[7], i.__data[10] = a.elements[8], i.__data[11] = 0) : (a.toArray(i.__data, r), r += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                        }
                                        e.bufferSubData(e.UNIFORM_BUFFER, t, i.__data)
                                    }
                                }
                            }
                            e.bindBuffer(e.UNIFORM_BUFFER, null)
                        }(n), s[n.id] = f)
                    },
                    dispose: function() {
                        for (let t in i) e.deleteBuffer(i[t]);
                        a = [], i = {}, s = {}
                    }
                }
            }
            class oH {
                constructor(e = {}) {
                    let t, n, r, i, s, a, o, u, c, h, d, f, p, g, A, m, v, _, b, w, C, S, I, M, T;
                    let {
                        canvas: B = nX(),
                        context: R = null,
                        depth: D = !0,
                        stencil: L = !1,
                        alpha: P = !1,
                        antialias: O = !1,
                        premultipliedAlpha: N = !0,
                        preserveDrawingBuffer: U = !1,
                        powerPreference: F = "default",
                        failIfMajorPerformanceCaveat: k = !1
                    } = e;
                    if (this.isWebGLRenderer = !0, null !== R) {
                        if ("undefined" != typeof WebGLRenderingContext && R instanceof WebGLRenderingContext) throw Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                        t = R.getContextAttributes().alpha
                    } else t = P;
                    let Q = new Uint32Array(4),
                        G = new Int32Array(4),
                        z = null,
                        H = null,
                        V = [],
                        j = [];
                    this.domElement = B, this.debug = {
                        checkShaderErrors: !0,
                        onShaderError: null
                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = tX, this.toneMapping = es, this.toneMappingExposure = 1;
                    let W = this,
                        Y = !1,
                        X = 0,
                        q = 0,
                        K = null,
                        J = -1,
                        Z = null,
                        $ = new re,
                        ee = new re,
                        et = null,
                        en = new i_(0),
                        er = 0,
                        ei = B.width,
                        ea = B.height,
                        eo = 1,
                        el = null,
                        eu = null,
                        ec = new re(0, 0, ei, ea),
                        eh = new re(0, 0, ei, ea),
                        ed = !1,
                        ef = new sx,
                        ep = !1,
                        eg = !1,
                        eA = new rF,
                        em = new rF,
                        ev = new rl,
                        ey = new re,
                        ex = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        },
                        eE = !1;

                    function e_() {
                        return null === K ? eo : 1
                    }
                    let eb = R;

                    function ew(e, t) {
                        return B.getContext(e, t)
                    }
                    try {
                        if ("setAttribute" in B && B.setAttribute("data-engine", `three.js r${l}`), B.addEventListener("webglcontextlost", eI, !1), B.addEventListener("webglcontextrestored", eM, !1), B.addEventListener("webglcontextcreationerror", eT, !1), null === eb) {
                            let e = "webgl2";
                            if (eb = ew(e, {
                                    alpha: !0,
                                    depth: D,
                                    stencil: L,
                                    antialias: O,
                                    premultipliedAlpha: N,
                                    preserveDrawingBuffer: U,
                                    powerPreference: F,
                                    failIfMajorPerformanceCaveat: k
                                }), null === eb) {
                                if (ew(e)) throw Error("Error creating WebGL context with your selected attributes.");
                                throw Error("Error creating WebGL context.")
                            }
                        }
                    } catch (e) {
                        throw console.error("THREE.WebGLRenderer: " + e.message), e
                    }

                    function eC() {
                        (n = new s0(eb)).init(), I = new oB(eb, n), r = new sL(eb, n, e, I), i = new oS(eb), r.reverseDepthBuffer && i.buffers.depth.setReversed(!0), s = new s3(eb), a = new oh, o = new oT(eb, n, i, a, r, I, s), u = new sO(W), c = new s$(W), h = new s_(eb), M = new sR(eb, h), d = new s1(eb, h, s, M), f = new s5(eb, d, h, s), w = new s4(eb, r, o), v = new sP(a), p = new oc(W, u, c, n, r, M, v), g = new oG(W, a), A = new og, m = new oE(n), b = new sB(W, u, c, i, f, t, N), _ = new ow(W, f, r), T = new oz(eb, s, r, i), C = new sD(eb, n, s), S = new s2(eb, n, s), s.programs = p.programs, W.capabilities = r, W.extensions = n, W.properties = a, W.renderLists = A, W.shadowMap = _, W.state = i, W.info = s
                    }
                    eC();
                    let eS = new oF(W, eb);

                    function eI(e) {
                        e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), Y = !0
                    }

                    function eM() {
                        console.log("THREE.WebGLRenderer: Context Restored."), Y = !1;
                        let e = s.autoReset,
                            t = _.enabled,
                            n = _.autoUpdate,
                            r = _.needsUpdate,
                            i = _.type;
                        eC(), s.autoReset = e, _.enabled = t, _.autoUpdate = n, _.needsUpdate = r, _.type = i
                    }

                    function eT(e) {
                        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                    }

                    function eB(e) {
                        let t = e.target;
                        t.removeEventListener("dispose", eB),
                            function(e) {
                                let t = a.get(e).programs;
                                void 0 !== t && (t.forEach(function(e) {
                                    p.releaseProgram(e)
                                }), e.isShaderMaterial && p.releaseShaderCache(e))
                            }(t), a.remove(t)
                    }

                    function eR(e, t, n) {
                        !0 === e.transparent && e.side === E && !1 === e.forceSinglePass ? (e.side = x, e.needsUpdate = !0, eq(e, t, n), e.side = y, e.needsUpdate = !0, eq(e, t, n), e.side = E) : eq(e, t, n)
                    }
                    this.xr = eS, this.getContext = function() {
                        return eb
                    }, this.getContextAttributes = function() {
                        return eb.getContextAttributes()
                    }, this.forceContextLoss = function() {
                        let e = n.get("WEBGL_lose_context");
                        e && e.loseContext()
                    }, this.forceContextRestore = function() {
                        let e = n.get("WEBGL_lose_context");
                        e && e.restoreContext()
                    }, this.getPixelRatio = function() {
                        return eo
                    }, this.setPixelRatio = function(e) {
                        void 0 !== e && (eo = e, this.setSize(ei, ea, !1))
                    }, this.getSize = function(e) {
                        return e.set(ei, ea)
                    }, this.setSize = function(e, t, n = !0) {
                        if (eS.isPresenting) {
                            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                            return
                        }
                        ei = e, ea = t, B.width = Math.floor(e * eo), B.height = Math.floor(t * eo), !0 === n && (B.style.width = e + "px", B.style.height = t + "px"), this.setViewport(0, 0, e, t)
                    }, this.getDrawingBufferSize = function(e) {
                        return e.set(ei * eo, ea * eo).floor()
                    }, this.setDrawingBufferSize = function(e, t, n) {
                        ei = e, ea = t, eo = n, B.width = Math.floor(e * n), B.height = Math.floor(t * n), this.setViewport(0, 0, e, t)
                    }, this.getCurrentViewport = function(e) {
                        return e.copy($)
                    }, this.getViewport = function(e) {
                        return e.copy(ec)
                    }, this.setViewport = function(e, t, n, r) {
                        e.isVector4 ? ec.set(e.x, e.y, e.z, e.w) : ec.set(e, t, n, r), i.viewport($.copy(ec).multiplyScalar(eo).round())
                    }, this.getScissor = function(e) {
                        return e.copy(eh)
                    }, this.setScissor = function(e, t, n, r) {
                        e.isVector4 ? eh.set(e.x, e.y, e.z, e.w) : eh.set(e, t, n, r), i.scissor(ee.copy(eh).multiplyScalar(eo).round())
                    }, this.getScissorTest = function() {
                        return ed
                    }, this.setScissorTest = function(e) {
                        i.setScissorTest(ed = e)
                    }, this.setOpaqueSort = function(e) {
                        el = e
                    }, this.setTransparentSort = function(e) {
                        eu = e
                    }, this.getClearColor = function(e) {
                        return e.copy(b.getClearColor())
                    }, this.setClearColor = function() {
                        b.setClearColor.apply(b, arguments)
                    }, this.getClearAlpha = function() {
                        return b.getClearAlpha()
                    }, this.setClearAlpha = function() {
                        b.setClearAlpha.apply(b, arguments)
                    }, this.clear = function(e = !0, t = !0, n = !0) {
                        let r = 0;
                        if (e) {
                            let e = !1;
                            if (null !== K) {
                                let t = K.texture.format;
                                e = t === e4 || t === e2 || t === e0
                            }
                            if (e) {
                                let e = K.texture.type,
                                    t = e === eP || e === ek || e === eU || e === eV || e === ez || e === eH,
                                    n = b.getClearColor(),
                                    r = b.getClearAlpha(),
                                    i = n.r,
                                    s = n.g,
                                    a = n.b;
                                t ? (Q[0] = i, Q[1] = s, Q[2] = a, Q[3] = r, eb.clearBufferuiv(eb.COLOR, 0, Q)) : (G[0] = i, G[1] = s, G[2] = a, G[3] = r, eb.clearBufferiv(eb.COLOR, 0, G))
                            } else r |= eb.COLOR_BUFFER_BIT
                        }
                        t && (r |= eb.DEPTH_BUFFER_BIT, eb.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1)), n && (r |= eb.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), eb.clear(r)
                    }, this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }, this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }, this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }, this.dispose = function() {
                        B.removeEventListener("webglcontextlost", eI, !1), B.removeEventListener("webglcontextrestored", eM, !1), B.removeEventListener("webglcontextcreationerror", eT, !1), A.dispose(), m.dispose(), a.dispose(), u.dispose(), c.dispose(), f.dispose(), M.dispose(), T.dispose(), p.dispose(), eS.dispose(), eS.removeEventListener("sessionstart", eO), eS.removeEventListener("sessionend", eN), eF.stop()
                    }, this.renderBufferDirect = function(e, t, s, l, f, p) {
                        let A;
                        null === t && (t = ex);
                        let m = f.isMesh && 0 > f.matrixWorld.determinant(),
                            y = function(e, t, n, s, l) {
                                var h;
                                !0 !== t.isScene && (t = ex), o.resetTextureUnits();
                                let d = t.fog,
                                    f = s.isMeshStandardMaterial ? t.environment : null,
                                    p = null === K ? W.outputColorSpace : !0 === K.isXRRenderTarget ? K.texture.colorSpace : tq,
                                    A = (s.isMeshStandardMaterial ? c : u).get(s.envMap || f),
                                    m = !0 === s.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                    y = !!n.attributes.tangent && (!!s.normalMap || s.anisotropy > 0),
                                    x = !!n.morphAttributes.position,
                                    E = !!n.morphAttributes.normal,
                                    _ = !!n.morphAttributes.color,
                                    b = es;
                                s.toneMapped && (null === K || !0 === K.isXRRenderTarget) && (b = W.toneMapping);
                                let C = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                    S = void 0 !== C ? C.length : 0,
                                    I = a.get(s),
                                    M = H.state.lights;
                                if (!0 === ep && (!0 === eg || e !== Z)) {
                                    let t = e === Z && s.id === J;
                                    v.setState(s, e, t)
                                }
                                let B = !1;
                                s.version === I.__version ? I.needsLights && I.lightsStateVersion !== M.state.version ? B = !0 : I.outputColorSpace !== p ? B = !0 : l.isBatchedMesh && !1 === I.batching ? B = !0 : l.isBatchedMesh || !0 !== I.batching ? l.isBatchedMesh && !0 === I.batchingColor && null === l.colorTexture ? B = !0 : l.isBatchedMesh && !1 === I.batchingColor && null !== l.colorTexture ? B = !0 : l.isInstancedMesh && !1 === I.instancing ? B = !0 : l.isInstancedMesh || !0 !== I.instancing ? l.isSkinnedMesh && !1 === I.skinning ? B = !0 : l.isSkinnedMesh || !0 !== I.skinning ? l.isInstancedMesh && !0 === I.instancingColor && null === l.instanceColor ? B = !0 : l.isInstancedMesh && !1 === I.instancingColor && null !== l.instanceColor ? B = !0 : l.isInstancedMesh && !0 === I.instancingMorph && null === l.morphTexture ? B = !0 : l.isInstancedMesh && !1 === I.instancingMorph && null !== l.morphTexture ? B = !0 : I.envMap !== A ? B = !0 : !0 === s.fog && I.fog !== d ? B = !0 : void 0 !== I.numClippingPlanes && (I.numClippingPlanes !== v.numPlanes || I.numIntersection !== v.numIntersection) ? B = !0 : I.vertexAlphas !== m ? B = !0 : I.vertexTangents !== y ? B = !0 : I.morphTargets !== x ? B = !0 : I.morphNormals !== E ? B = !0 : I.morphColors !== _ ? B = !0 : I.toneMapping !== b ? B = !0 : I.morphTargetsCount !== S && (B = !0) : B = !0 : B = !0 : B = !0 : (B = !0, I.__version = s.version);
                                let R = I.currentProgram;
                                !0 === B && (R = eq(s, t, l));
                                let D = !1,
                                    L = !1,
                                    P = !1,
                                    O = R.getUniforms(),
                                    N = I.uniforms;
                                if (i.useProgram(R.program) && (D = !0, L = !0, P = !0), s.id !== J && (J = s.id, L = !0), D || Z !== e) {
                                    r.reverseDepthBuffer ? (eA.copy(e.projectionMatrix), function(e) {
                                        let t = e.elements;
                                        t[2] = .5 * t[2] + .5 * t[3], t[6] = .5 * t[6] + .5 * t[7], t[10] = .5 * t[10] + .5 * t[11], t[14] = .5 * t[14] + .5 * t[15]
                                    }(eA), function(e) {
                                        let t = e.elements; - 1 === t[11] ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = -t[14] + 1)
                                    }(eA), O.setValue(eb, "projectionMatrix", eA)) : O.setValue(eb, "projectionMatrix", e.projectionMatrix), O.setValue(eb, "viewMatrix", e.matrixWorldInverse);
                                    let t = O.map.cameraPosition;
                                    void 0 !== t && t.setValue(eb, ev.setFromMatrixPosition(e.matrixWorld)), r.logarithmicDepthBuffer && O.setValue(eb, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (s.isMeshPhongMaterial || s.isMeshToonMaterial || s.isMeshLambertMaterial || s.isMeshBasicMaterial || s.isMeshStandardMaterial || s.isShaderMaterial) && O.setValue(eb, "isOrthographic", !0 === e.isOrthographicCamera), Z !== e && (Z = e, L = !0, P = !0)
                                }
                                if (l.isSkinnedMesh) {
                                    O.setOptional(eb, l, "bindMatrix"), O.setOptional(eb, l, "bindMatrixInverse");
                                    let e = l.skeleton;
                                    e && (null === e.boneTexture && e.computeBoneTexture(), O.setValue(eb, "boneTexture", e.boneTexture, o))
                                }
                                l.isBatchedMesh && (O.setOptional(eb, l, "batchingTexture"), O.setValue(eb, "batchingTexture", l._matricesTexture, o), O.setOptional(eb, l, "batchingIdTexture"), O.setValue(eb, "batchingIdTexture", l._indirectTexture, o), O.setOptional(eb, l, "batchingColorTexture"), null !== l._colorsTexture && O.setValue(eb, "batchingColorTexture", l._colorsTexture, o));
                                let U = n.morphAttributes;
                                if ((void 0 !== U.position || void 0 !== U.normal || void 0 !== U.color) && w.update(l, n, R), (L || I.receiveShadow !== l.receiveShadow) && (I.receiveShadow = l.receiveShadow, O.setValue(eb, "receiveShadow", l.receiveShadow)), s.isMeshGouraudMaterial && null !== s.envMap && (N.envMap.value = A, N.flipEnvMap.value = A.isCubeTexture && !1 === A.isRenderTargetTexture ? -1 : 1), s.isMeshStandardMaterial && null === s.envMap && null !== t.environment && (N.envMapIntensity.value = t.environmentIntensity), L && (O.setValue(eb, "toneMappingExposure", W.toneMappingExposure), I.needsLights && (h = P, N.ambientLightColor.needsUpdate = h, N.lightProbe.needsUpdate = h, N.directionalLights.needsUpdate = h, N.directionalLightShadows.needsUpdate = h, N.pointLights.needsUpdate = h, N.pointLightShadows.needsUpdate = h, N.spotLights.needsUpdate = h, N.spotLightShadows.needsUpdate = h, N.rectAreaLights.needsUpdate = h, N.hemisphereLights.needsUpdate = h), d && !0 === s.fog && g.refreshFogUniforms(N, d), g.refreshMaterialUniforms(N, s, eo, ea, H.state.transmissionRenderTarget[e.id]), a0.upload(eb, eK(I), N, o)), s.isShaderMaterial && !0 === s.uniformsNeedUpdate && (a0.upload(eb, eK(I), N, o), s.uniformsNeedUpdate = !1), s.isSpriteMaterial && O.setValue(eb, "center", l.center), O.setValue(eb, "modelViewMatrix", l.modelViewMatrix), O.setValue(eb, "normalMatrix", l.normalMatrix), O.setValue(eb, "modelMatrix", l.matrixWorld), s.isShaderMaterial || s.isRawShaderMaterial) {
                                    let e = s.uniformsGroups;
                                    for (let t = 0, n = e.length; t < n; t++) {
                                        let n = e[t];
                                        T.update(n, R), T.bind(n, R)
                                    }
                                }
                                return R
                            }(e, t, s, l, f);
                        i.setMaterial(l, m);
                        let x = s.index,
                            E = 1;
                        if (!0 === l.wireframe) {
                            if (void 0 === (x = d.getWireframeAttribute(s))) return;
                            E = 2
                        }
                        let _ = s.drawRange,
                            b = s.attributes.position,
                            I = _.start * E,
                            B = (_.start + _.count) * E;
                        null !== p && (I = Math.max(I, p.start * E), B = Math.min(B, (p.start + p.count) * E)), null !== x ? (I = Math.max(I, 0), B = Math.min(B, x.count)) : null != b && (I = Math.max(I, 0), B = Math.min(B, b.count));
                        let R = B - I;
                        if (R < 0 || R === 1 / 0) return;
                        M.setup(f, l, y, s, x);
                        let D = C;
                        if (null !== x && (A = h.get(x), (D = S).setIndex(A)), f.isMesh) !0 === l.wireframe ? (i.setLineWidth(l.wireframeLinewidth * e_()), D.setMode(eb.LINES)) : D.setMode(eb.TRIANGLES);
                        else if (f.isLine) {
                            let e = l.linewidth;
                            void 0 === e && (e = 1), i.setLineWidth(e * e_()), f.isLineSegments ? D.setMode(eb.LINES) : f.isLineLoop ? D.setMode(eb.LINE_LOOP) : D.setMode(eb.LINE_STRIP)
                        } else f.isPoints ? D.setMode(eb.POINTS) : f.isSprite && D.setMode(eb.TRIANGLES);
                        if (f.isBatchedMesh) {
                            if (null !== f._multiDrawInstances) D.renderMultiDrawInstances(f._multiDrawStarts, f._multiDrawCounts, f._multiDrawCount, f._multiDrawInstances);
                            else if (n.get("WEBGL_multi_draw")) D.renderMultiDraw(f._multiDrawStarts, f._multiDrawCounts, f._multiDrawCount);
                            else {
                                let e = f._multiDrawStarts,
                                    t = f._multiDrawCounts,
                                    n = f._multiDrawCount,
                                    r = x ? h.get(x).bytesPerElement : 1,
                                    i = a.get(l).currentProgram.getUniforms();
                                for (let s = 0; s < n; s++) i.setValue(eb, "_gl_DrawID", s), D.render(e[s] / r, t[s])
                            }
                        } else if (f.isInstancedMesh) D.renderInstances(I, R, f.count);
                        else if (s.isInstancedBufferGeometry) {
                            let e = void 0 !== s._maxInstanceCount ? s._maxInstanceCount : 1 / 0,
                                t = Math.min(s.instanceCount, e);
                            D.renderInstances(I, R, t)
                        } else D.render(I, R)
                    }, this.compile = function(e, t, n = null) {
                        null === n && (n = e), (H = m.get(n)).init(t), j.push(H), n.traverseVisible(function(e) {
                            e.isLight && e.layers.test(t.layers) && (H.pushLight(e), e.castShadow && H.pushShadow(e))
                        }), e !== n && e.traverseVisible(function(e) {
                            e.isLight && e.layers.test(t.layers) && (H.pushLight(e), e.castShadow && H.pushShadow(e))
                        }), H.setupLights();
                        let r = new Set;
                        return e.traverse(function(e) {
                            if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite)) return;
                            let t = e.material;
                            if (t) {
                                if (Array.isArray(t))
                                    for (let i = 0; i < t.length; i++) {
                                        let s = t[i];
                                        eR(s, n, e), r.add(s)
                                    } else eR(t, n, e), r.add(t)
                            }
                        }), j.pop(), H = null, r
                    }, this.compileAsync = function(e, t, r = null) {
                        let i = this.compile(e, t, r);
                        return new Promise(t => {
                            function r() {
                                if (i.forEach(function(e) {
                                        a.get(e).currentProgram.isReady() && i.delete(e)
                                    }), 0 === i.size) {
                                    t(e);
                                    return
                                }
                                setTimeout(r, 10)
                            }
                            null !== n.get("KHR_parallel_shader_compile") ? r() : setTimeout(r, 10)
                        })
                    };
                    let eL = null;

                    function eO() {
                        eF.stop()
                    }

                    function eN() {
                        eF.start()
                    }
                    let eF = new sE;

                    function eQ(e, t, n, r) {
                        if (!1 === e.visible) return;
                        if (e.layers.test(t.layers)) {
                            if (e.isGroup) n = e.renderOrder;
                            else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                            else if (e.isLight) H.pushLight(e), e.castShadow && H.pushShadow(e);
                            else if (e.isSprite) {
                                if (!e.frustumCulled || ef.intersectsSprite(e)) {
                                    r && ey.setFromMatrixPosition(e.matrixWorld).applyMatrix4(em);
                                    let t = f.update(e),
                                        i = e.material;
                                    i.visible && z.push(e, t, i, n, ey.z, null)
                                }
                            } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || ef.intersectsObject(e))) {
                                let t = f.update(e),
                                    i = e.material;
                                if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), ey.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), ey.copy(t.boundingSphere.center)), ey.applyMatrix4(e.matrixWorld).applyMatrix4(em)), Array.isArray(i)) {
                                    let r = t.groups;
                                    for (let s = 0, a = r.length; s < a; s++) {
                                        let a = r[s],
                                            o = i[a.materialIndex];
                                        o && o.visible && z.push(e, t, o, n, ey.z, a)
                                    }
                                } else i.visible && z.push(e, t, i, n, ey.z, null)
                            }
                        }
                        let i = e.children;
                        for (let e = 0, s = i.length; e < s; e++) eQ(i[e], t, n, r)
                    }

                    function ej(e, t, n, r) {
                        let s = e.opaque,
                            a = e.transmissive,
                            o = e.transparent;
                        H.setupLightsView(n), !0 === ep && v.setGlobalState(W.clippingPlanes, n), r && i.viewport($.copy(r)), s.length > 0 && eY(s, t, n), a.length > 0 && eY(a, t, n), o.length > 0 && eY(o, t, n), i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), i.setPolygonOffset(!1)
                    }

                    function eW(e, t, r, i) {
                        if (null !== (!0 === r.isScene ? r.overrideMaterial : null)) return;
                        void 0 === H.state.transmissionRenderTarget[i.id] && (H.state.transmissionRenderTarget[i.id] = new rn(1, 1, {
                            generateMipmaps: !0,
                            type: n.has("EXT_color_buffer_half_float") || n.has("EXT_color_buffer_float") ? eG : eP,
                            minFilter: eD,
                            samples: 4,
                            stencilBuffer: L,
                            resolveDepthBuffer: !1,
                            resolveStencilBuffer: !1,
                            colorSpace: n1.workingColorSpace
                        }));
                        let s = H.state.transmissionRenderTarget[i.id],
                            a = i.viewport || $;
                        s.setSize(a.z, a.w);
                        let l = W.getRenderTarget();
                        W.setRenderTarget(s), W.getClearColor(en), (er = W.getClearAlpha()) < 1 && W.setClearColor(16777215, .5), W.clear(), eE && b.render(r);
                        let u = W.toneMapping;
                        W.toneMapping = es;
                        let c = i.viewport;
                        if (void 0 !== i.viewport && (i.viewport = void 0), H.setupLightsView(i), !0 === ep && v.setGlobalState(W.clippingPlanes, i), eY(e, r, i), o.updateMultisampleRenderTarget(s), o.updateRenderTargetMipmap(s), !1 === n.has("WEBGL_multisampled_render_to_texture")) {
                            let e = !1;
                            for (let n = 0, s = t.length; n < s; n++) {
                                let s = t[n],
                                    a = s.object,
                                    o = s.geometry,
                                    l = s.material,
                                    u = s.group;
                                if (l.side === E && a.layers.test(i.layers)) {
                                    let t = l.side;
                                    l.side = x, l.needsUpdate = !0, eX(a, r, i, o, l, u), l.side = t, l.needsUpdate = !0, e = !0
                                }
                            }!0 === e && (o.updateMultisampleRenderTarget(s), o.updateRenderTargetMipmap(s))
                        }
                        W.setRenderTarget(l), W.setClearColor(en, er), void 0 !== c && (i.viewport = c), W.toneMapping = u
                    }

                    function eY(e, t, n) {
                        let r = !0 === t.isScene ? t.overrideMaterial : null;
                        for (let i = 0, s = e.length; i < s; i++) {
                            let s = e[i],
                                a = s.object,
                                o = s.geometry,
                                l = null === r ? s.material : r,
                                u = s.group;
                            a.layers.test(n.layers) && eX(a, t, n, o, l, u)
                        }
                    }

                    function eX(e, t, n, r, i, s) {
                        e.onBeforeRender(W, t, n, r, i, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(W, t, n, r, e, s), !0 === i.transparent && i.side === E && !1 === i.forceSinglePass ? (i.side = x, i.needsUpdate = !0, W.renderBufferDirect(n, t, r, i, e, s), i.side = y, i.needsUpdate = !0, W.renderBufferDirect(n, t, r, i, e, s), i.side = E) : W.renderBufferDirect(n, t, r, i, e, s), e.onAfterRender(W, t, n, r, i, s)
                    }

                    function eq(e, t, n) {
                        !0 !== t.isScene && (t = ex);
                        let r = a.get(e),
                            i = H.state.lights,
                            s = H.state.shadowsArray,
                            o = i.state.version,
                            l = p.getParameters(e, i.state, s, t, n),
                            h = p.getProgramCacheKey(l),
                            d = r.programs;
                        r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? c : u).get(e.envMap || r.environment), r.envMapRotation = null !== r.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === d && (e.addEventListener("dispose", eB), d = new Map, r.programs = d);
                        let f = d.get(h);
                        if (void 0 !== f) {
                            if (r.currentProgram === f && r.lightsStateVersion === o) return eJ(e, l), f
                        } else l.uniforms = p.getUniforms(e), e.onBeforeCompile(l, W), f = p.acquireProgram(l, h), d.set(h, f), r.uniforms = l.uniforms;
                        let g = r.uniforms;
                        return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (g.clippingPlanes = v.uniform), eJ(e, l), r.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, r.lightsStateVersion = o, r.needsLights && (g.ambientLightColor.value = i.state.ambient, g.lightProbe.value = i.state.probe, g.directionalLights.value = i.state.directional, g.directionalLightShadows.value = i.state.directionalShadow, g.spotLights.value = i.state.spot, g.spotLightShadows.value = i.state.spotShadow, g.rectAreaLights.value = i.state.rectArea, g.ltc_1.value = i.state.rectAreaLTC1, g.ltc_2.value = i.state.rectAreaLTC2, g.pointLights.value = i.state.point, g.pointLightShadows.value = i.state.pointShadow, g.hemisphereLights.value = i.state.hemi, g.directionalShadowMap.value = i.state.directionalShadowMap, g.directionalShadowMatrix.value = i.state.directionalShadowMatrix, g.spotShadowMap.value = i.state.spotShadowMap, g.spotLightMatrix.value = i.state.spotLightMatrix, g.spotLightMap.value = i.state.spotLightMap, g.pointShadowMap.value = i.state.pointShadowMap, g.pointShadowMatrix.value = i.state.pointShadowMatrix), r.currentProgram = f, r.uniformsList = null, f
                    }

                    function eK(e) {
                        if (null === e.uniformsList) {
                            let t = e.currentProgram.getUniforms();
                            e.uniformsList = a0.seqWithValue(t.seq, e.uniforms)
                        }
                        return e.uniformsList
                    }

                    function eJ(e, t) {
                        let n = a.get(e);
                        n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.batchingColor = t.batchingColor, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.instancingMorph = t.instancingMorph, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
                    }
                    eF.setAnimationLoop(function(e) {
                        eL && eL(e)
                    }), "undefined" != typeof self && eF.setContext(self), this.setAnimationLoop = function(e) {
                        eL = e, eS.setAnimationLoop(e), null === e ? eF.stop() : eF.start()
                    }, eS.addEventListener("sessionstart", eO), eS.addEventListener("sessionend", eN), this.render = function(e, t) {
                        if (void 0 !== t && !0 !== t.isCamera) {
                            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                            return
                        }
                        if (!0 === Y) return;
                        if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === eS.enabled && !0 === eS.isPresenting && (!0 === eS.cameraAutoUpdate && eS.updateCamera(t), t = eS.getCamera()), !0 === e.isScene && e.onBeforeRender(W, e, t, K), (H = m.get(e, j.length)).init(t), j.push(H), em.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ef.setFromProjectionMatrix(em), eg = this.localClippingEnabled, ep = v.init(this.clippingPlanes, eg), (z = A.get(e, V.length)).init(), V.push(z), !0 === eS.enabled && !0 === eS.isPresenting) {
                            let e = W.xr.getDepthSensingMesh();
                            null !== e && eQ(e, t, -1 / 0, W.sortObjects)
                        }
                        eQ(e, t, 0, W.sortObjects), z.finish(), !0 === W.sortObjects && z.sort(el, eu), (eE = !1 === eS.enabled || !1 === eS.isPresenting || !1 === eS.hasDepthSensing()) && b.addToRenderList(z, e), this.info.render.frame++, !0 === ep && v.beginShadows();
                        let n = H.state.shadowsArray;
                        _.render(n, e, t), !0 === ep && v.endShadows(), !0 === this.info.autoReset && this.info.reset();
                        let r = z.opaque,
                            i = z.transmissive;
                        if (H.setupLights(), t.isArrayCamera) {
                            let n = t.cameras;
                            if (i.length > 0)
                                for (let t = 0, s = n.length; t < s; t++) eW(r, i, e, n[t]);
                            eE && b.render(e);
                            for (let t = 0, r = n.length; t < r; t++) {
                                let r = n[t];
                                ej(z, e, r, r.viewport)
                            }
                        } else i.length > 0 && eW(r, i, e, t), eE && b.render(e), ej(z, e, t);
                        null !== K && (o.updateMultisampleRenderTarget(K), o.updateRenderTargetMipmap(K)), !0 === e.isScene && e.onAfterRender(W, e, t), M.resetDefaultState(), J = -1, Z = null, j.pop(), j.length > 0 ? (H = j[j.length - 1], !0 === ep && v.setGlobalState(W.clippingPlanes, H.state.camera)) : H = null, V.pop(), z = V.length > 0 ? V[V.length - 1] : null
                    }, this.getActiveCubeFace = function() {
                        return X
                    }, this.getActiveMipmapLevel = function() {
                        return q
                    }, this.getRenderTarget = function() {
                        return K
                    }, this.setRenderTargetTextures = function(e, t, r) {
                        a.get(e.texture).__webglTexture = t, a.get(e.depthTexture).__webglTexture = r;
                        let i = a.get(e);
                        i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === r, i.__autoAllocateDepthBuffer || !0 !== n.has("WEBGL_multisampled_render_to_texture") || (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1)
                    }, this.setRenderTargetFramebuffer = function(e, t) {
                        let n = a.get(e);
                        n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                    }, this.setRenderTarget = function(e, t = 0, n = 0) {
                        K = e, X = t, q = n;
                        let r = !0,
                            s = null,
                            l = !1,
                            u = !1;
                        if (e) {
                            let c = a.get(e);
                            if (void 0 !== c.__useDefaultFramebuffer) i.bindFramebuffer(eb.FRAMEBUFFER, null), r = !1;
                            else if (void 0 === c.__webglFramebuffer) o.setupRenderTarget(e);
                            else if (c.__hasExternalTextures) o.rebindTextures(e, a.get(e.texture).__webglTexture, a.get(e.depthTexture).__webglTexture);
                            else if (e.depthBuffer) {
                                let t = e.depthTexture;
                                if (c.__boundDepthTexture !== t) {
                                    if (null !== t && a.has(t) && (e.width !== t.image.width || e.height !== t.image.height)) throw Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                    o.setupDepthRenderbuffer(e)
                                }
                            }
                            let h = e.texture;
                            (h.isData3DTexture || h.isDataArrayTexture || h.isCompressedArrayTexture) && (u = !0);
                            let d = a.get(e).__webglFramebuffer;
                            e.isWebGLCubeRenderTarget ? (s = Array.isArray(d[t]) ? d[t][n] : d[t], l = !0) : s = e.samples > 0 && !1 === o.useMultisampledRTT(e) ? a.get(e).__webglMultisampledFramebuffer : Array.isArray(d) ? d[n] : d, $.copy(e.viewport), ee.copy(e.scissor), et = e.scissorTest
                        } else $.copy(ec).multiplyScalar(eo).floor(), ee.copy(eh).multiplyScalar(eo).floor(), et = ed;
                        if (i.bindFramebuffer(eb.FRAMEBUFFER, s) && r && i.drawBuffers(e, s), i.viewport($), i.scissor(ee), i.setScissorTest(et), l) {
                            let r = a.get(e.texture);
                            eb.framebufferTexture2D(eb.FRAMEBUFFER, eb.COLOR_ATTACHMENT0, eb.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, n)
                        } else if (u) {
                            let r = a.get(e.texture);
                            eb.framebufferTextureLayer(eb.FRAMEBUFFER, eb.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, t || 0)
                        }
                        J = -1
                    }, this.readRenderTargetPixels = function(e, t, n, s, o, l, u) {
                        if (!(e && e.isWebGLRenderTarget)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                            return
                        }
                        let c = a.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== u && (c = c[u]), c) {
                            i.bindFramebuffer(eb.FRAMEBUFFER, c);
                            try {
                                let i = e.texture,
                                    a = i.format,
                                    u = i.type;
                                if (!r.textureFormatReadable(a)) {
                                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                    return
                                }
                                if (!r.textureTypeReadable(u)) {
                                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                    return
                                }
                                t >= 0 && t <= e.width - s && n >= 0 && n <= e.height - o && eb.readPixels(t, n, s, o, I.convert(a), I.convert(u), l)
                            } finally {
                                let e = null !== K ? a.get(K).__webglFramebuffer : null;
                                i.bindFramebuffer(eb.FRAMEBUFFER, e)
                            }
                        }
                    }, this.readRenderTargetPixelsAsync = async function(e, t, n, s, o, l, u) {
                        if (!(e && e.isWebGLRenderTarget)) throw Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let c = a.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== u && (c = c[u]), c) {
                            let u = e.texture,
                                d = u.format,
                                f = u.type;
                            if (!r.textureFormatReadable(d)) throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                            if (!r.textureTypeReadable(f)) throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                            if (t >= 0 && t <= e.width - s && n >= 0 && n <= e.height - o) {
                                var h;
                                i.bindFramebuffer(eb.FRAMEBUFFER, c);
                                let e = eb.createBuffer();
                                eb.bindBuffer(eb.PIXEL_PACK_BUFFER, e), eb.bufferData(eb.PIXEL_PACK_BUFFER, l.byteLength, eb.STREAM_READ), eb.readPixels(t, n, s, o, I.convert(d), I.convert(f), 0);
                                let r = null !== K ? a.get(K).__webglFramebuffer : null;
                                i.bindFramebuffer(eb.FRAMEBUFFER, r);
                                let u = eb.fenceSync(eb.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                return eb.flush(), await (h = eb, new Promise(function(e, t) {
                                    setTimeout(function n() {
                                        switch (h.clientWaitSync(u, h.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                            case h.WAIT_FAILED:
                                                t();
                                                break;
                                            case h.TIMEOUT_EXPIRED:
                                                setTimeout(n, 4);
                                                break;
                                            default:
                                                e()
                                        }
                                    }, 4)
                                })), eb.bindBuffer(eb.PIXEL_PACK_BUFFER, e), eb.getBufferSubData(eb.PIXEL_PACK_BUFFER, 0, l), eb.deleteBuffer(e), eb.deleteSync(u), l
                            }
                            throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                        }
                    }, this.copyFramebufferToTexture = function(e, t = null, n = 0) {
                        !0 !== e.isTexture && (nK("WebGLRenderer: copyFramebufferToTexture function signature has changed."), t = arguments[0] || null, e = arguments[1]);
                        let r = Math.pow(2, -n),
                            s = Math.floor(e.image.width * r),
                            a = Math.floor(e.image.height * r),
                            l = null !== t ? t.x : 0,
                            u = null !== t ? t.y : 0;
                        o.setTexture2D(e, 0), eb.copyTexSubImage2D(eb.TEXTURE_2D, n, 0, 0, l, u, s, a), i.unbindTexture()
                    }, this.copyTextureToTexture = function(e, t, n = null, r = null, s = 0) {
                        let a, l, u, c, h, d;
                        !0 !== e.isTexture && (nK("WebGLRenderer: copyTextureToTexture function signature has changed."), r = arguments[0] || null, e = arguments[1], t = arguments[2], s = arguments[3] || 0, n = null), null !== n ? (a = n.max.x - n.min.x, l = n.max.y - n.min.y, u = n.min.x, c = n.min.y) : (a = e.image.width, l = e.image.height, u = 0, c = 0), null !== r ? (h = r.x, d = r.y) : (h = 0, d = 0);
                        let f = I.convert(t.format),
                            p = I.convert(t.type);
                        o.setTexture2D(t, 0), eb.pixelStorei(eb.UNPACK_FLIP_Y_WEBGL, t.flipY), eb.pixelStorei(eb.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), eb.pixelStorei(eb.UNPACK_ALIGNMENT, t.unpackAlignment);
                        let g = eb.getParameter(eb.UNPACK_ROW_LENGTH),
                            A = eb.getParameter(eb.UNPACK_IMAGE_HEIGHT),
                            m = eb.getParameter(eb.UNPACK_SKIP_PIXELS),
                            v = eb.getParameter(eb.UNPACK_SKIP_ROWS),
                            y = eb.getParameter(eb.UNPACK_SKIP_IMAGES),
                            x = e.isCompressedTexture ? e.mipmaps[s] : e.image;
                        eb.pixelStorei(eb.UNPACK_ROW_LENGTH, x.width), eb.pixelStorei(eb.UNPACK_IMAGE_HEIGHT, x.height), eb.pixelStorei(eb.UNPACK_SKIP_PIXELS, u), eb.pixelStorei(eb.UNPACK_SKIP_ROWS, c), e.isDataTexture ? eb.texSubImage2D(eb.TEXTURE_2D, s, h, d, a, l, f, p, x.data) : e.isCompressedTexture ? eb.compressedTexSubImage2D(eb.TEXTURE_2D, s, h, d, x.width, x.height, f, x.data) : eb.texSubImage2D(eb.TEXTURE_2D, s, h, d, a, l, f, p, x), eb.pixelStorei(eb.UNPACK_ROW_LENGTH, g), eb.pixelStorei(eb.UNPACK_IMAGE_HEIGHT, A), eb.pixelStorei(eb.UNPACK_SKIP_PIXELS, m), eb.pixelStorei(eb.UNPACK_SKIP_ROWS, v), eb.pixelStorei(eb.UNPACK_SKIP_IMAGES, y), 0 === s && t.generateMipmaps && eb.generateMipmap(eb.TEXTURE_2D), i.unbindTexture()
                    }, this.copyTextureToTexture3D = function(e, t, n = null, r = null, s = 0) {
                        let a, l, u, c, h, d, f, p, g, A;
                        !0 !== e.isTexture && (nK("WebGLRenderer: copyTextureToTexture3D function signature has changed."), n = arguments[0] || null, r = arguments[1] || null, e = arguments[2], t = arguments[3], s = arguments[4] || 0);
                        let m = e.isCompressedTexture ? e.mipmaps[s] : e.image;
                        null !== n ? (a = n.max.x - n.min.x, l = n.max.y - n.min.y, u = n.max.z - n.min.z, c = n.min.x, h = n.min.y, d = n.min.z) : (a = m.width, l = m.height, u = m.depth, c = 0, h = 0, d = 0), null !== r ? (f = r.x, p = r.y, g = r.z) : (f = 0, p = 0, g = 0);
                        let v = I.convert(t.format),
                            y = I.convert(t.type);
                        if (t.isData3DTexture) o.setTexture3D(t, 0), A = eb.TEXTURE_3D;
                        else if (t.isDataArrayTexture || t.isCompressedArrayTexture) o.setTexture2DArray(t, 0), A = eb.TEXTURE_2D_ARRAY;
                        else {
                            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                            return
                        }
                        eb.pixelStorei(eb.UNPACK_FLIP_Y_WEBGL, t.flipY), eb.pixelStorei(eb.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), eb.pixelStorei(eb.UNPACK_ALIGNMENT, t.unpackAlignment);
                        let x = eb.getParameter(eb.UNPACK_ROW_LENGTH),
                            E = eb.getParameter(eb.UNPACK_IMAGE_HEIGHT),
                            _ = eb.getParameter(eb.UNPACK_SKIP_PIXELS),
                            b = eb.getParameter(eb.UNPACK_SKIP_ROWS),
                            w = eb.getParameter(eb.UNPACK_SKIP_IMAGES);
                        eb.pixelStorei(eb.UNPACK_ROW_LENGTH, m.width), eb.pixelStorei(eb.UNPACK_IMAGE_HEIGHT, m.height), eb.pixelStorei(eb.UNPACK_SKIP_PIXELS, c), eb.pixelStorei(eb.UNPACK_SKIP_ROWS, h), eb.pixelStorei(eb.UNPACK_SKIP_IMAGES, d), e.isDataTexture || e.isData3DTexture ? eb.texSubImage3D(A, s, f, p, g, a, l, u, v, y, m.data) : t.isCompressedArrayTexture ? eb.compressedTexSubImage3D(A, s, f, p, g, a, l, u, v, m.data) : eb.texSubImage3D(A, s, f, p, g, a, l, u, v, y, m), eb.pixelStorei(eb.UNPACK_ROW_LENGTH, x), eb.pixelStorei(eb.UNPACK_IMAGE_HEIGHT, E), eb.pixelStorei(eb.UNPACK_SKIP_PIXELS, _), eb.pixelStorei(eb.UNPACK_SKIP_ROWS, b), eb.pixelStorei(eb.UNPACK_SKIP_IMAGES, w), 0 === s && t.generateMipmaps && eb.generateMipmap(A), i.unbindTexture()
                    }, this.initRenderTarget = function(e) {
                        void 0 === a.get(e).__webglFramebuffer && o.setupRenderTarget(e)
                    }, this.initTexture = function(e) {
                        e.isCubeTexture ? o.setTextureCube(e, 0) : e.isData3DTexture ? o.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? o.setTexture2DArray(e, 0) : o.setTexture2D(e, 0), i.unbindTexture()
                    }, this.resetState = function() {
                        X = 0, q = 0, K = null, i.reset(), M.reset()
                    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                get coordinateSystem() {
                    return nI
                }
                get outputColorSpace() {
                    return this._outputColorSpace
                }
                set outputColorSpace(e) {
                    this._outputColorSpace = e;
                    let t = this.getContext();
                    t.drawingBufferColorSpace = e === tK ? "display-p3" : "srgb", t.unpackColorSpace = n1.workingColorSpace === tJ ? "display-p3" : "srgb"
                }
            }
            class oV {
                constructor(e, t = 25e-5) {
                    this.isFogExp2 = !0, this.name = "", this.color = new i_(e), this.density = t
                }
                clone() {
                    return new oV(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        name: this.name,
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            class oj {
                constructor(e, t = 1, n = 1e3) {
                    this.isFog = !0, this.name = "", this.color = new i_(e), this.near = t, this.far = n
                }
                clone() {
                    return new oj(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        name: this.name,
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            class oW extends it {
                constructor() {
                    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new rX, this.environmentIntensity = 1, this.environmentRotation = new rX, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
                }
            }
            class oY {
                constructor(e, t) {
                    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = nA, this.updateRanges = [], this.version = 0, this.uuid = nP()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (let r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nP()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    let t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                        n = new this.constructor(t, this.stride);
                    return n.setUsage(this.usage), n
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nP()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            let oX = new rl;
            class oq {
                constructor(e, t, n, r = !1) {
                    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.data.count; t < n; t++) oX.fromBufferAttribute(this, t), oX.applyMatrix4(e), this.setXYZ(t, oX.x, oX.y, oX.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) oX.fromBufferAttribute(this, t), oX.applyNormalMatrix(e), this.setXYZ(t, oX.x, oX.y, oX.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) oX.fromBufferAttribute(this, t), oX.transformDirection(e), this.setXYZ(t, oX.x, oX.y, oX.z);
                    return this
                }
                getComponent(e, t) {
                    let n = this.array[e * this.data.stride + this.offset + t];
                    return this.normalized && (n = nF(n, this.array)), n
                }
                setComponent(e, t, n) {
                    return this.normalized && (n = nk(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
                }
                setX(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
                }
                setY(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
                }
                setZ(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
                }
                setW(e, t) {
                    return this.normalized && (t = nk(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
                }
                getX(e) {
                    let t = this.data.array[e * this.data.stride + this.offset];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                getY(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 1];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                getZ(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 2];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                getW(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 3];
                    return this.normalized && (t = nF(t, this.array)), t
                }
                setXY(e, t, n) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = nk(t, this.array), n = nk(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                }
                setXYZ(e, t, n, r) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = nk(t, this.array), n = nk(n, this.array), r = nk(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
                }
                setXYZW(e, t, n, r, i) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = nk(t, this.array), n = nk(n, this.array), r = nk(r, this.array), i = nk(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
                }
                clone(e) {
                    if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new oq(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                        let e = [];
                        for (let t = 0; t < this.count; t++) {
                            let n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return new iL(new this.array.constructor(e), this.itemSize, this.normalized)
                    }
                }
                toJSON(e) {
                    if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }; {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                        let e = [];
                        for (let t = 0; t < this.count; t++) {
                            let n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: e,
                            normalized: this.normalized
                        }
                    }
                }
            }
            class oK extends iC {
                constructor(e) {
                    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new i_(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            let oJ = new rl,
                oZ = new rl,
                o$ = new rl,
                o0 = new nG,
                o1 = new nG,
                o2 = new rF,
                o3 = new rl,
                o4 = new rl,
                o5 = new rl,
                o6 = new nG,
                o8 = new nG,
                o9 = new nG;
            class o7 extends it {
                constructor(e = new oK) {
                    if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === i) {
                        i = new iK;
                        let e = new oY(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                        i.setIndex([0, 1, 2, 0, 2, 3]), i.setAttribute("position", new oq(e, 3, 0, !1)), i.setAttribute("uv", new oq(e, 2, 3, !1))
                    }
                    this.geometry = i, this.material = e, this.center = new nG(.5, .5)
                }
                raycast(e, t) {
                    let n, r;
                    null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), oZ.setFromMatrixScale(this.matrixWorld), o2.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), o$.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && oZ.multiplyScalar(-o$.z);
                    let i = this.material.rotation;
                    0 !== i && (r = Math.cos(i), n = Math.sin(i));
                    let s = this.center;
                    le(o3.set(-.5, -.5, 0), o$, s, oZ, n, r), le(o4.set(.5, -.5, 0), o$, s, oZ, n, r), le(o5.set(.5, .5, 0), o$, s, oZ, n, r), o6.set(0, 0), o8.set(1, 0), o9.set(1, 1);
                    let a = e.ray.intersectTriangle(o3, o4, o5, !1, oJ);
                    if (null === a && (le(o4.set(-.5, .5, 0), o$, s, oZ, n, r), o8.set(0, 1), null === (a = e.ray.intersectTriangle(o3, o5, o4, !1, oJ)))) return;
                    let o = e.ray.origin.distanceTo(oJ);
                    o < e.near || o > e.far || t.push({
                        distance: o,
                        point: oJ.clone(),
                        uv: im.getInterpolation(oJ, o3, o4, o5, o6, o8, o9, new nG),
                        face: null,
                        object: this
                    })
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
                }
            }

            function le(e, t, n, r, i, s) {
                o0.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (o1.x = s * o0.x - i * o0.y, o1.y = i * o0.x + s * o0.y) : o1.copy(o0), e.copy(t), e.x += o1.x, e.y += o1.y, e.applyMatrix4(o2)
            }
            let lt = new rl,
                ln = new rl;
            class lr extends it {
                constructor() {
                    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                        levels: {
                            enumerable: !0,
                            value: []
                        },
                        isLOD: {
                            value: !0
                        }
                    }), this.autoUpdate = !0
                }
                copy(e) {
                    super.copy(e, !1);
                    let t = e.levels;
                    for (let e = 0, n = t.length; e < n; e++) {
                        let n = t[e];
                        this.addLevel(n.object.clone(), n.distance, n.hysteresis)
                    }
                    return this.autoUpdate = e.autoUpdate, this
                }
                addLevel(e, t = 0, n = 0) {
                    let r;
                    t = Math.abs(t);
                    let i = this.levels;
                    for (r = 0; r < i.length && !(t < i[r].distance); r++);
                    return i.splice(r, 0, {
                        distance: t,
                        hysteresis: n,
                        object: e
                    }), this.add(e), this
                }
                removeLevel(e) {
                    let t = this.levels;
                    for (let n = 0; n < t.length; n++)
                        if (t[n].distance === e) {
                            let e = t.splice(n, 1);
                            return this.remove(e[0].object), !0
                        }
                    return !1
                }
                getCurrentLevel() {
                    return this._currentLevel
                }
                getObjectForDistance(e) {
                    let t = this.levels;
                    if (t.length > 0) {
                        let n, r;
                        for (n = 1, r = t.length; n < r; n++) {
                            let r = t[n].distance;
                            if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r) break
                        }
                        return t[n - 1].object
                    }
                    return null
                }
                raycast(e, t) {
                    if (this.levels.length > 0) {
                        lt.setFromMatrixPosition(this.matrixWorld);
                        let n = e.ray.origin.distanceTo(lt);
                        this.getObjectForDistance(n).raycast(e, t)
                    }
                }
                update(e) {
                    let t = this.levels;
                    if (t.length > 1) {
                        let n, r;
                        lt.setFromMatrixPosition(e.matrixWorld), ln.setFromMatrixPosition(this.matrixWorld);
                        let i = lt.distanceTo(ln) / e.zoom;
                        for (n = 1, t[0].object.visible = !0, r = t.length; n < r; n++) {
                            let e = t[n].distance;
                            if (t[n].object.visible && (e -= e * t[n].hysteresis), i >= e) t[n - 1].object.visible = !1, t[n].object.visible = !0;
                            else break
                        }
                        for (this._currentLevel = n - 1; n < r; n++) t[n].object.visible = !1
                    }
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                    let n = this.levels;
                    for (let e = 0, r = n.length; e < r; e++) {
                        let r = n[e];
                        t.object.levels.push({
                            object: r.object.uuid,
                            distance: r.distance,
                            hysteresis: r.hysteresis
                        })
                    }
                    return t
                }
            }
            let li = new rl,
                ls = new re,
                la = new re,
                lo = new rl,
                ll = new rF,
                lu = new rl,
                lc = new rT,
                lh = new rF,
                ld = new rU;
            class lf extends i9 {
                constructor(e, t) {
                    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = ef, this.bindMatrix = new rF, this.bindMatrixInverse = new rF, this.boundingBox = null, this.boundingSphere = null
                }
                computeBoundingBox() {
                    let e = this.geometry;
                    null === this.boundingBox && (this.boundingBox = new rh), this.boundingBox.makeEmpty();
                    let t = e.getAttribute("position");
                    for (let e = 0; e < t.count; e++) this.getVertexPosition(e, lu), this.boundingBox.expandByPoint(lu)
                }
                computeBoundingSphere() {
                    let e = this.geometry;
                    null === this.boundingSphere && (this.boundingSphere = new rT), this.boundingSphere.makeEmpty();
                    let t = e.getAttribute("position");
                    for (let e = 0; e < t.count; e++) this.getVertexPosition(e, lu), this.boundingSphere.expandByPoint(lu)
                }
                copy(e, t) {
                    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                }
                raycast(e, t) {
                    let n = this.material,
                        r = this.matrixWorld;
                    if (void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), lc.copy(this.boundingSphere), lc.applyMatrix4(r), !1 !== e.ray.intersectsSphere(lc))) {
                        if (lh.copy(r).invert(), ld.copy(e.ray).applyMatrix4(lh), null !== this.boundingBox && !1 === ld.intersectsBox(this.boundingBox)) return;
                        this._computeIntersections(e, t, ld)
                    }
                }
                getVertexPosition(e, t) {
                    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
                }
                bind(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    let e = new re,
                        t = this.geometry.attributes.skinWeight;
                    for (let n = 0, r = t.count; n < r; n++) {
                        e.fromBufferAttribute(t, n);
                        let r = 1 / e.manhattanLength();
                        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.bindMode === ef ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === ep ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                applyBoneTransform(e, t) {
                    let n = this.skeleton,
                        r = this.geometry;
                    ls.fromBufferAttribute(r.attributes.skinIndex, e), la.fromBufferAttribute(r.attributes.skinWeight, e), li.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let e = 0; e < 4; e++) {
                        let r = la.getComponent(e);
                        if (0 !== r) {
                            let i = ls.getComponent(e);
                            ll.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(lo.copy(li).applyMatrix4(ll), r)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            class lp extends it {
                constructor() {
                    super(), this.isBone = !0, this.type = "Bone"
                }
            }
            class lg extends n7 {
                constructor(e = null, t = 1, n = 1, r, i, s, a, o, l = ew, u = ew, c, h) {
                    super(null, s, a, o, l, u, r, i, c, h), this.isDataTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n
                    }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            let lA = new rF,
                lm = new rF;
            class lv {
                constructor(e = [], t = []) {
                    this.uuid = nP(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
                }
                init() {
                    let e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new rF)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        let t = new rF;
                        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        let t = this.bones[e];
                        t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        let t = this.bones[e];
                        t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                    }
                }
                update() {
                    let e = this.bones,
                        t = this.boneInverses,
                        n = this.boneMatrices,
                        r = this.boneTexture;
                    for (let r = 0, i = e.length; r < i; r++) {
                        let i = e[r] ? e[r].matrixWorld : lm;
                        lA.multiplyMatrices(i, t[r]), lA.toArray(n, 16 * r)
                    }
                    null !== r && (r.needsUpdate = !0)
                }
                clone() {
                    return new lv(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length),
                        t = new Float32Array((e = Math.max(e = 4 * Math.ceil(e / 4), 4)) * e * 4);
                    t.set(this.boneMatrices);
                    let n = new lg(t, e, e, eX, eQ);
                    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
                }
                getBoneByName(e) {
                    for (let t = 0, n = this.bones.length; t < n; t++) {
                        let n = this.bones[t];
                        if (n.name === e) return n
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let n = 0, r = e.bones.length; n < r; n++) {
                        let r = e.bones[n],
                            i = t[r];
                        void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new lp), this.bones.push(i), this.boneInverses.push(new rF().fromArray(e.boneInverses[n]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.6,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    let t = this.bones,
                        n = this.boneInverses;
                    for (let r = 0, i = t.length; r < i; r++) {
                        let i = t[r];
                        e.bones.push(i.uuid);
                        let s = n[r];
                        e.boneInverses.push(s.toArray())
                    }
                    return e
                }
            }
            class ly extends iL {
                constructor(e, t, n, r = 1) {
                    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }
            let lx = new rF,
                lE = new rF,
                l_ = [],
                lb = new rh,
                lw = new rF,
                lC = new i9,
                lS = new rT;
            class lI extends i9 {
                constructor(e, t, n) {
                    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new ly(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                    for (let e = 0; e < n; e++) this.setMatrixAt(e, lw)
                }
                computeBoundingBox() {
                    let e = this.geometry,
                        t = this.count;
                    null === this.boundingBox && (this.boundingBox = new rh), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, lx), lb.copy(e.boundingBox).applyMatrix4(lx), this.boundingBox.union(lb)
                }
                computeBoundingSphere() {
                    let e = this.geometry,
                        t = this.count;
                    null === this.boundingSphere && (this.boundingSphere = new rT), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, lx), lS.copy(e.boundingSphere).applyMatrix4(lx), this.boundingSphere.union(lS)
                }
                copy(e, t) {
                    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                getMorphAt(e, t) {
                    let n = t.morphTargetInfluences,
                        r = this.morphTexture.source.data.data,
                        i = e * (n.length + 1) + 1;
                    for (let e = 0; e < n.length; e++) n[e] = r[i + e]
                }
                raycast(e, t) {
                    let n = this.matrixWorld,
                        r = this.count;
                    if (lC.geometry = this.geometry, lC.material = this.material, void 0 !== lC.material && (null === this.boundingSphere && this.computeBoundingSphere(), lS.copy(this.boundingSphere), lS.applyMatrix4(n), !1 !== e.ray.intersectsSphere(lS)))
                        for (let i = 0; i < r; i++) {
                            this.getMatrixAt(i, lx), lE.multiplyMatrices(n, lx), lC.matrixWorld = lE, lC.raycast(e, l_);
                            for (let e = 0, n = l_.length; e < n; e++) {
                                let n = l_[e];
                                n.instanceId = i, n.object = this, t.push(n)
                            }
                            l_.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new ly(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                setMorphAt(e, t) {
                    let n = t.morphTargetInfluences,
                        r = n.length + 1;
                    null === this.morphTexture && (this.morphTexture = new lg(new Float32Array(r * this.count), r, this.count, e$, eQ));
                    let i = this.morphTexture.source.data.data,
                        s = 0;
                    for (let e = 0; e < n.length; e++) s += n[e];
                    let a = this.geometry.morphTargetsRelative ? 1 : 1 - s,
                        o = r * e;
                    i[o] = a, i.set(n, o + 1)
                }
                updateMorphTargets() {}
                dispose() {
                    return this.dispatchEvent({
                        type: "dispose"
                    }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null), this
                }
            }

            function lM(e, t) {
                return e.z - t.z
            }

            function lT(e, t) {
                return t.z - e.z
            }
            class lB {
                constructor() {
                    this.index = 0, this.pool = [], this.list = []
                }
                push(e, t, n) {
                    let r = this.pool,
                        i = this.list;
                    this.index >= r.length && r.push({
                        start: -1,
                        count: -1,
                        z: -1,
                        index: -1
                    });
                    let s = r[this.index];
                    i.push(s), this.index++, s.start = e.start, s.count = e.count, s.z = t, s.index = n
                }
                reset() {
                    this.list.length = 0, this.index = 0
                }
            }
            let lR = new rF,
                lD = new rF,
                lL = new rF,
                lP = new i_(1, 1, 1),
                lO = new rF,
                lN = new sx,
                lU = new rh,
                lF = new rT,
                lk = new rl,
                lQ = new rl,
                lG = new rl,
                lz = new lB,
                lH = new i9,
                lV = [];
            class lj extends i9 {
                get maxInstanceCount() {
                    return this._maxInstanceCount
                }
                constructor(e, t, n = 2 * t, r) {
                    super(new iK, r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawInfo = [], this._availableInstanceIds = [], this._drawRanges = [], this._reservedRanges = [], this._bounds = [], this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture()
                }
                _initMatricesTexture() {
                    let e = Math.sqrt(4 * this._maxInstanceCount),
                        t = new lg(new Float32Array((e = Math.max(e = 4 * Math.ceil(e / 4), 4)) * e * 4), e, e, eX, eQ);
                    this._matricesTexture = t
                }
                _initIndirectTexture() {
                    let e = Math.sqrt(this._maxInstanceCount),
                        t = new lg(new Uint32Array((e = Math.ceil(e)) * e), e, e, e0, ek);
                    this._indirectTexture = t
                }
                _initColorsTexture() {
                    let e = Math.sqrt(this._maxInstanceCount),
                        t = new lg(new Float32Array((e = Math.ceil(e)) * e * 4).fill(1), e, e, eX, eQ);
                    t.colorSpace = n1.workingColorSpace, this._colorsTexture = t
                }
                _initializeGeometry(e) {
                    let t = this.geometry,
                        n = this._maxVertexCount,
                        r = this._maxIndexCount;
                    if (!1 === this._geometryInitialized) {
                        for (let r in e.attributes) {
                            let {
                                array: i,
                                itemSize: s,
                                normalized: a
                            } = e.getAttribute(r), o = new iL(new i.constructor(n * s), s, a);
                            t.setAttribute(r, o)
                        }
                        if (null !== e.getIndex()) {
                            let e = n > 65535 ? new Uint32Array(r) : new Uint16Array(r);
                            t.setIndex(new iL(e, 1))
                        }
                        this._geometryInitialized = !0
                    }
                }
                _validateGeometry(e) {
                    let t = this.geometry;
                    if (!!e.getIndex() != !!t.getIndex()) throw Error('BatchedMesh: All geometries must consistently have "index".');
                    for (let n in t.attributes) {
                        if (!e.hasAttribute(n)) throw Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                        let r = e.getAttribute(n),
                            i = t.getAttribute(n);
                        if (r.itemSize !== i.itemSize || r.normalized !== i.normalized) throw Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                    }
                }
                setCustomSort(e) {
                    return this.customSort = e, this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new rh);
                    let e = this.boundingBox,
                        t = this._drawInfo;
                    e.makeEmpty();
                    for (let n = 0, r = t.length; n < r; n++) {
                        if (!1 === t[n].active) continue;
                        let r = t[n].geometryIndex;
                        this.getMatrixAt(n, lR), this.getBoundingBoxAt(r, lU).applyMatrix4(lR), e.union(lU)
                    }
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new rT);
                    let e = this.boundingSphere,
                        t = this._drawInfo;
                    e.makeEmpty();
                    for (let n = 0, r = t.length; n < r; n++) {
                        if (!1 === t[n].active) continue;
                        let r = t[n].geometryIndex;
                        this.getMatrixAt(n, lR), this.getBoundingSphereAt(r, lF).applyMatrix4(lR), e.union(lF)
                    }
                }
                addInstance(e) {
                    if (this._drawInfo.length >= this.maxInstanceCount && 0 === this._availableInstanceIds.length) throw Error("BatchedMesh: Maximum item count reached.");
                    let t = {
                            visible: !0,
                            active: !0,
                            geometryIndex: e
                        },
                        n = null;
                    this._availableInstanceIds.length > 0 ? (n = this._availableInstanceIds.pop(), this._drawInfo[n] = t) : (n = this._drawInfo.length, this._drawInfo.push(t));
                    let r = this._matricesTexture,
                        i = r.image.data;
                    lL.toArray(i, 16 * n), r.needsUpdate = !0;
                    let s = this._colorsTexture;
                    return s && (lP.toArray(s.image.data, 4 * n), s.needsUpdate = !0), n
                }
                addGeometry(e, t = -1, n = -1) {
                    if (this._initializeGeometry(e), this._validateGeometry(e), this._drawInfo.length >= this._maxInstanceCount) throw Error("BatchedMesh: Maximum item count reached.");
                    let r = {
                            vertexStart: -1,
                            vertexCount: -1,
                            indexStart: -1,
                            indexCount: -1
                        },
                        i = null,
                        s = this._reservedRanges,
                        a = this._drawRanges,
                        o = this._bounds;
                    0 !== this._geometryCount && (i = s[s.length - 1]), -1 === t ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t, null === i ? r.vertexStart = 0 : r.vertexStart = i.vertexStart + i.vertexCount;
                    let l = e.getIndex(),
                        u = null !== l;
                    if (u && (-1 === n ? r.indexCount = l.count : r.indexCount = n, null === i ? r.indexStart = 0 : r.indexStart = i.indexStart + i.indexCount), -1 !== r.indexStart && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount) throw Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                    let c = this._geometryCount;
                    return this._geometryCount++, s.push(r), a.push({
                        start: u ? r.indexStart : r.vertexStart,
                        count: -1
                    }), o.push({
                        boxInitialized: !1,
                        box: new rh,
                        sphereInitialized: !1,
                        sphere: new rT
                    }), this.setGeometryAt(c, e), c
                }
                setGeometryAt(e, t) {
                    if (e >= this._geometryCount) throw Error("BatchedMesh: Maximum geometry count reached.");
                    this._validateGeometry(t);
                    let n = this.geometry,
                        r = null !== n.getIndex(),
                        i = n.getIndex(),
                        s = t.getIndex(),
                        a = this._reservedRanges[e];
                    if (r && s.count > a.indexCount || t.attributes.position.count > a.vertexCount) throw Error("BatchedMesh: Reserved space not large enough for provided geometry.");
                    let o = a.vertexStart,
                        l = a.vertexCount;
                    for (let e in n.attributes) {
                        let r = t.getAttribute(e),
                            i = n.getAttribute(e);
                        ! function(e, t, n = 0) {
                            let r = t.itemSize;
                            if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) {
                                let i = e.count;
                                for (let s = 0; s < i; s++)
                                    for (let i = 0; i < r; i++) t.setComponent(s + n, i, e.getComponent(s, i))
                            } else t.array.set(e.array, n * r);
                            t.needsUpdate = !0
                        }(r, i, o);
                        let s = r.itemSize;
                        for (let e = r.count; e < l; e++) {
                            let t = o + e;
                            for (let e = 0; e < s; e++) i.setComponent(t, e, 0)
                        }
                        i.needsUpdate = !0, i.addUpdateRange(o * s, l * s)
                    }
                    if (r) {
                        let e = a.indexStart;
                        for (let t = 0; t < s.count; t++) i.setX(e + t, o + s.getX(t));
                        for (let t = s.count, n = a.indexCount; t < n; t++) i.setX(e + t, o);
                        i.needsUpdate = !0, i.addUpdateRange(e, a.indexCount)
                    }
                    let u = this._bounds[e];
                    null !== t.boundingBox ? (u.box.copy(t.boundingBox), u.boxInitialized = !0) : u.boxInitialized = !1, null !== t.boundingSphere ? (u.sphere.copy(t.boundingSphere), u.sphereInitialized = !0) : u.sphereInitialized = !1;
                    let c = this._drawRanges[e],
                        h = t.getAttribute("position");
                    return c.count = r ? s.count : h.count, this._visibilityChanged = !0, e
                }
                deleteInstance(e) {
                    let t = this._drawInfo;
                    return e >= t.length || !1 === t[e].active || (t[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0), this
                }
                getBoundingBoxAt(e, t) {
                    if (e >= this._geometryCount) return null;
                    let n = this._bounds[e],
                        r = n.box,
                        i = this.geometry;
                    if (!1 === n.boxInitialized) {
                        r.makeEmpty();
                        let t = i.index,
                            s = i.attributes.position,
                            a = this._drawRanges[e];
                        for (let e = a.start, n = a.start + a.count; e < n; e++) {
                            let n = e;
                            t && (n = t.getX(n)), r.expandByPoint(lk.fromBufferAttribute(s, n))
                        }
                        n.boxInitialized = !0
                    }
                    return t.copy(r), t
                }
                getBoundingSphereAt(e, t) {
                    if (e >= this._geometryCount) return null;
                    let n = this._bounds[e],
                        r = n.sphere,
                        i = this.geometry;
                    if (!1 === n.sphereInitialized) {
                        r.makeEmpty(), this.getBoundingBoxAt(e, lU), lU.getCenter(r.center);
                        let t = i.index,
                            s = i.attributes.position,
                            a = this._drawRanges[e],
                            o = 0;
                        for (let e = a.start, n = a.start + a.count; e < n; e++) {
                            let n = e;
                            t && (n = t.getX(n)), lk.fromBufferAttribute(s, n), o = Math.max(o, r.center.distanceToSquared(lk))
                        }
                        r.radius = Math.sqrt(o), n.sphereInitialized = !0
                    }
                    return t.copy(r), t
                }
                setMatrixAt(e, t) {
                    let n = this._drawInfo,
                        r = this._matricesTexture,
                        i = this._matricesTexture.image.data;
                    return e >= n.length || !1 === n[e].active || (t.toArray(i, 16 * e), r.needsUpdate = !0), this
                }
                getMatrixAt(e, t) {
                    let n = this._drawInfo,
                        r = this._matricesTexture.image.data;
                    return e >= n.length || !1 === n[e].active ? null : t.fromArray(r, 16 * e)
                }
                setColorAt(e, t) {
                    null === this._colorsTexture && this._initColorsTexture();
                    let n = this._colorsTexture,
                        r = this._colorsTexture.image.data,
                        i = this._drawInfo;
                    return e >= i.length || !1 === i[e].active || (t.toArray(r, 4 * e), n.needsUpdate = !0), this
                }
                getColorAt(e, t) {
                    let n = this._colorsTexture.image.data,
                        r = this._drawInfo;
                    return e >= r.length || !1 === r[e].active ? null : t.fromArray(n, 4 * e)
                }
                setVisibleAt(e, t) {
                    let n = this._drawInfo;
                    return e >= n.length || !1 === n[e].active || n[e].visible === t || (n[e].visible = t, this._visibilityChanged = !0), this
                }
                getVisibleAt(e) {
                    let t = this._drawInfo;
                    return !(e >= t.length) && !1 !== t[e].active && t[e].visible
                }
                setGeometryIdAt(e, t) {
                    let n = this._drawInfo;
                    return e >= n.length || !1 === n[e].active || t < 0 || t >= this._geometryCount ? null : (n[e].geometryIndex = t, this)
                }
                getGeometryIdAt(e) {
                    let t = this._drawInfo;
                    return e >= t.length || !1 === t[e].active ? -1 : t[e].geometryIndex
                }
                getGeometryRangeAt(e, t = {}) {
                    if (e < 0 || e >= this._geometryCount) return null;
                    let n = this._drawRanges[e];
                    return t.start = n.start, t.count = n.count, t
                }
                raycast(e, t) {
                    let n = this._drawInfo,
                        r = this._drawRanges,
                        i = this.matrixWorld,
                        s = this.geometry;
                    lH.material = this.material, lH.geometry.index = s.index, lH.geometry.attributes = s.attributes, null === lH.geometry.boundingBox && (lH.geometry.boundingBox = new rh), null === lH.geometry.boundingSphere && (lH.geometry.boundingSphere = new rT);
                    for (let s = 0, a = n.length; s < a; s++) {
                        if (!n[s].visible || !n[s].active) continue;
                        let a = n[s].geometryIndex,
                            o = r[a];
                        lH.geometry.setDrawRange(o.start, o.count), this.getMatrixAt(s, lH.matrixWorld).premultiply(i), this.getBoundingBoxAt(a, lH.geometry.boundingBox), this.getBoundingSphereAt(a, lH.geometry.boundingSphere), lH.raycast(e, lV);
                        for (let e = 0, n = lV.length; e < n; e++) {
                            let n = lV[e];
                            n.object = this, n.batchId = s, t.push(n)
                        }
                        lV.length = 0
                    }
                    lH.material = null, lH.geometry.index = null, lH.geometry.attributes = {}, lH.geometry.setDrawRange(0, 1 / 0)
                }
                copy(e) {
                    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = null !== e.boundingBox ? e.boundingBox.clone() : null, this.boundingSphere = null !== e.boundingSphere ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map(e => ({ ...e
                    })), this._reservedRanges = e._reservedRanges.map(e => ({ ...e
                    })), this._drawInfo = e._drawInfo.map(e => ({ ...e
                    })), this._bounds = e._bounds.map(e => ({
                        boxInitialized: e.boxInitialized,
                        box: e.box.clone(),
                        sphereInitialized: e.sphereInitialized,
                        sphere: e.sphere.clone()
                    })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), null !== this._colorsTexture && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this
                }
                dispose() {
                    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, null !== this._colorsTexture && (this._colorsTexture.dispose(), this._colorsTexture = null), this
                }
                onBeforeRender(e, t, n, r, i) {
                    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
                    let s = r.getIndex(),
                        a = null === s ? 1 : s.array.BYTES_PER_ELEMENT,
                        o = this._drawInfo,
                        l = this._multiDrawStarts,
                        u = this._multiDrawCounts,
                        c = this._drawRanges,
                        h = this.perObjectFrustumCulled,
                        d = this._indirectTexture,
                        f = d.image.data;
                    h && (lO.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), lN.setFromProjectionMatrix(lO, e.coordinateSystem));
                    let p = 0;
                    if (this.sortObjects) {
                        lD.copy(this.matrixWorld).invert(), lk.setFromMatrixPosition(n.matrixWorld).applyMatrix4(lD), lQ.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(lD);
                        for (let e = 0, t = o.length; e < t; e++)
                            if (o[e].visible && o[e].active) {
                                let t = o[e].geometryIndex;
                                this.getMatrixAt(e, lR), this.getBoundingSphereAt(t, lF).applyMatrix4(lR);
                                let n = !1;
                                if (h && (n = !lN.intersectsSphere(lF)), !n) {
                                    let n = lG.subVectors(lF.center, lk).dot(lQ);
                                    lz.push(c[t], n, e)
                                }
                            }
                        let e = lz.list,
                            t = this.customSort;
                        null === t ? e.sort(i.transparent ? lT : lM) : t.call(this, e, n);
                        for (let t = 0, n = e.length; t < n; t++) {
                            let n = e[t];
                            l[p] = n.start * a, u[p] = n.count, f[p] = n.index, p++
                        }
                        lz.reset()
                    } else
                        for (let e = 0, t = o.length; e < t; e++)
                            if (o[e].visible && o[e].active) {
                                let t = o[e].geometryIndex,
                                    n = !1;
                                if (h && (this.getMatrixAt(e, lR), this.getBoundingSphereAt(t, lF).applyMatrix4(lR), n = !lN.intersectsSphere(lF)), !n) {
                                    let n = c[t];
                                    l[p] = n.start * a, u[p] = n.count, f[p] = e, p++
                                }
                            }
                    d.needsUpdate = !0, this._multiDrawCount = p, this._visibilityChanged = !1
                }
                onBeforeShadow(e, t, n, r, i, s) {
                    this.onBeforeRender(e, null, r, i, s)
                }
            }
            class lW extends iC {
                constructor(e) {
                    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new i_(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
                }
            }
            let lY = new rl,
                lX = new rl,
                lq = new rF,
                lK = new rU,
                lJ = new rT,
                lZ = new rl,
                l$ = new rl;
            class l0 extends it {
                constructor(e = new iK, t = new lW) {
                    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                }
                computeLineDistances() {
                    let e = this.geometry;
                    if (null === e.index) {
                        let t = e.attributes.position,
                            n = [0];
                        for (let e = 1, r = t.count; e < r; e++) lY.fromBufferAttribute(t, e - 1), lX.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += lY.distanceTo(lX);
                        e.setAttribute("lineDistance", new iz(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
                raycast(e, t) {
                    let n = this.geometry,
                        r = this.matrixWorld,
                        i = e.params.Line.threshold,
                        s = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), lJ.copy(n.boundingSphere), lJ.applyMatrix4(r), lJ.radius += i, !1 === e.ray.intersectsSphere(lJ)) return;
                    lq.copy(r).invert(), lK.copy(e.ray).applyMatrix4(lq);
                    let a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        l = this.isLineSegments ? 2 : 1,
                        u = n.index,
                        c = n.attributes.position;
                    if (null !== u) {
                        let n = Math.max(0, s.start),
                            r = Math.min(u.count, s.start + s.count);
                        for (let i = n, s = r - 1; i < s; i += l) {
                            let n = l1(this, e, lK, o, u.getX(i), u.getX(i + 1));
                            n && t.push(n)
                        }
                        if (this.isLineLoop) {
                            let i = l1(this, e, lK, o, u.getX(r - 1), u.getX(n));
                            i && t.push(i)
                        }
                    } else {
                        let n = Math.max(0, s.start),
                            r = Math.min(c.count, s.start + s.count);
                        for (let i = n, s = r - 1; i < s; i += l) {
                            let n = l1(this, e, lK, o, i, i + 1);
                            n && t.push(n)
                        }
                        if (this.isLineLoop) {
                            let i = l1(this, e, lK, o, r - 1, n);
                            i && t.push(i)
                        }
                    }
                }
                updateMorphTargets() {
                    let e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        let n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                let t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }

            function l1(e, t, n, r, i, s) {
                let a = e.geometry.attributes.position;
                if (lY.fromBufferAttribute(a, i), lX.fromBufferAttribute(a, s), n.distanceSqToSegment(lY, lX, lZ, l$) > r) return;
                lZ.applyMatrix4(e.matrixWorld);
                let o = t.ray.origin.distanceTo(lZ);
                if (!(o < t.near) && !(o > t.far)) return {
                    distance: o,
                    point: l$.clone().applyMatrix4(e.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    barycoord: null,
                    object: e
                }
            }
            let l2 = new rl,
                l3 = new rl;
            class l4 extends l0 {
                constructor(e, t) {
                    super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
                }
                computeLineDistances() {
                    let e = this.geometry;
                    if (null === e.index) {
                        let t = e.attributes.position,
                            n = [];
                        for (let e = 0, r = t.count; e < r; e += 2) l2.fromBufferAttribute(t, e), l3.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + l2.distanceTo(l3);
                        e.setAttribute("lineDistance", new iz(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
            }
            class l5 extends l0 {
                constructor(e, t) {
                    super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
                }
            }
            class l6 extends iC {
                constructor(e) {
                    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new i_(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            let l8 = new rF,
                l9 = new rU,
                l7 = new rT,
                ue = new rl;
            class ut extends it {
                constructor(e = new iK, t = new l6) {
                    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                }
                raycast(e, t) {
                    let n = this.geometry,
                        r = this.matrixWorld,
                        i = e.params.Points.threshold,
                        s = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), l7.copy(n.boundingSphere), l7.applyMatrix4(r), l7.radius += i, !1 === e.ray.intersectsSphere(l7)) return;
                    l8.copy(r).invert(), l9.copy(e.ray).applyMatrix4(l8);
                    let a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        l = n.index,
                        u = n.attributes.position;
                    if (null !== l) {
                        let n = Math.max(0, s.start),
                            i = Math.min(l.count, s.start + s.count);
                        for (let s = n; s < i; s++) {
                            let n = l.getX(s);
                            ue.fromBufferAttribute(u, n), un(ue, n, o, r, e, t, this)
                        }
                    } else {
                        let n = Math.max(0, s.start),
                            i = Math.min(u.count, s.start + s.count);
                        for (let s = n; s < i; s++) ue.fromBufferAttribute(u, s), un(ue, s, o, r, e, t, this)
                    }
                }
                updateMorphTargets() {
                    let e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        let n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                let t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }

            function un(e, t, n, r, i, s, a) {
                let o = l9.distanceSqToPoint(e);
                if (o < n) {
                    let n = new rl;
                    l9.closestPointToPoint(e, n), n.applyMatrix4(r);
                    let l = i.ray.origin.distanceTo(n);
                    if (l < i.near || l > i.far) return;
                    s.push({
                        distance: l,
                        distanceToRay: Math.sqrt(o),
                        point: n,
                        index: t,
                        face: null,
                        faceIndex: null,
                        barycoord: null,
                        object: a
                    })
                }
            }
            class ur extends n7 {
                constructor(e, t, n, r, i, s, a, o, l) {
                    super(e, t, n, r, i, s, a, o, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : eT, this.magFilter = void 0 !== i ? i : eT, this.generateMipmaps = !1;
                    let u = this;
                    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
                        u.needsUpdate = !0, e.requestVideoFrameCallback(t)
                    })
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    let e = this.image;
                    !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }
            class ui extends n7 {
                constructor(e, t) {
                    super({
                        width: e,
                        height: t
                    }), this.isFramebufferTexture = !0, this.magFilter = ew, this.minFilter = ew, this.generateMipmaps = !1, this.needsUpdate = !0
                }
            }
            class us extends n7 {
                constructor(e, t, n, r, i, s, a, o, l, u, c, h) {
                    super(null, s, a, o, l, u, r, i, c, h), this.isCompressedTexture = !0, this.image = {
                        width: t,
                        height: n
                    }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            class ua extends us {
                constructor(e, t, n, r, i, s) {
                    super(e, t, n, i, s), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = e_, this.layerUpdates = new Set
                }
                addLayerUpdate(e) {
                    this.layerUpdates.add(e)
                }
                clearLayerUpdates() {
                    this.layerUpdates.clear()
                }
            }
            class uo extends us {
                constructor(e, t, n) {
                    super(void 0, e[0].width, e[0].height, t, n, eA), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
                }
            }
            class ul extends n7 {
                constructor(e, t, n, r, i, s, a, o, l) {
                    super(e, t, n, r, i, s, a, o, l), this.isCanvasTexture = !0, this.needsUpdate = !0
                }
            }
            class uu {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(e, t) {
                    let n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                }
                getPoints(e = 5) {
                    let t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                }
                getSpacedPoints(e = 5) {
                    let t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                }
                getLength() {
                    let e = this.getLengths();
                    return e[e.length - 1]
                }
                getLengths(e = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    let t = [],
                        n, r = this.getPoint(0),
                        i = 0;
                    t.push(0);
                    for (let s = 1; s <= e; s++) t.push(i += (n = this.getPoint(s / e)).distanceTo(r)), r = n;
                    return this.cacheArcLengths = t, t
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(e, t) {
                    let n;
                    let r = this.getLengths(),
                        i = 0,
                        s = r.length;
                    n = t || e * r[s - 1];
                    let a = 0,
                        o = s - 1,
                        l;
                    for (; a <= o;)
                        if ((l = r[i = Math.floor(a + (o - a) / 2)] - n) < 0) a = i + 1;
                        else if (l > 0) o = i - 1;
                    else {
                        o = i;
                        break
                    }
                    if (r[i = o] === n) return i / (s - 1);
                    let u = r[i],
                        c = r[i + 1];
                    return (i + (n - u) / (c - u)) / (s - 1)
                }
                getTangent(e, t) {
                    let n = e - 1e-4,
                        r = e + 1e-4;
                    n < 0 && (n = 0), r > 1 && (r = 1);
                    let i = this.getPoint(n),
                        s = this.getPoint(r),
                        a = t || (i.isVector2 ? new nG : new rl);
                    return a.copy(s).sub(i).normalize(), a
                }
                getTangentAt(e, t) {
                    let n = this.getUtoTmapping(e);
                    return this.getTangent(n, t)
                }
                computeFrenetFrames(e, t) {
                    let n = new rl,
                        r = [],
                        i = [],
                        s = [],
                        a = new rl,
                        o = new rF;
                    for (let t = 0; t <= e; t++) {
                        let n = t / e;
                        r[t] = this.getTangentAt(n, new rl)
                    }
                    i[0] = new rl, s[0] = new rl;
                    let l = Number.MAX_VALUE,
                        u = Math.abs(r[0].x),
                        c = Math.abs(r[0].y),
                        h = Math.abs(r[0].z);
                    u <= l && (l = u, n.set(1, 0, 0)), c <= l && (l = c, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], a), s[0].crossVectors(r[0], i[0]);
                    for (let t = 1; t <= e; t++) {
                        if (i[t] = i[t - 1].clone(), s[t] = s[t - 1].clone(), a.crossVectors(r[t - 1], r[t]), a.length() > Number.EPSILON) {
                            a.normalize();
                            let e = Math.acos(nO(r[t - 1].dot(r[t]), -1, 1));
                            i[t].applyMatrix4(o.makeRotationAxis(a, e))
                        }
                        s[t].crossVectors(r[t], i[t])
                    }
                    if (!0 === t) {
                        let t = Math.acos(nO(i[0].dot(i[e]), -1, 1));
                        t /= e, r[0].dot(a.crossVectors(i[0], i[e])) > 0 && (t = -t);
                        for (let n = 1; n <= e; n++) i[n].applyMatrix4(o.makeRotationAxis(r[n], t * n)), s[n].crossVectors(r[n], i[n])
                    }
                    return {
                        tangents: r,
                        normals: i,
                        binormals: s
                    }
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.6,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                }
                fromJSON(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }
            class uc extends uu {
                constructor(e = 0, t = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, a = !1, o = 0) {
                    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                }
                getPoint(e, t = new nG) {
                    let n = 2 * Math.PI,
                        r = this.aEndAngle - this.aStartAngle,
                        i = Math.abs(r) < Number.EPSILON;
                    for (; r < 0;) r += n;
                    for (; r > n;) r -= n;
                    r < Number.EPSILON && (r = i ? 0 : n), !0 !== this.aClockwise || i || (r === n ? r = -n : r -= n);
                    let s = this.aStartAngle + e * r,
                        a = this.aX + this.xRadius * Math.cos(s),
                        o = this.aY + this.yRadius * Math.sin(s);
                    if (0 !== this.aRotation) {
                        let e = Math.cos(this.aRotation),
                            t = Math.sin(this.aRotation),
                            n = a - this.aX,
                            r = o - this.aY;
                        a = n * e - r * t + this.aX, o = n * t + r * e + this.aY
                    }
                    return t.set(a, o)
                }
                copy(e) {
                    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
            }
            class uh extends uc {
                constructor(e, t, n, r, i, s) {
                    super(e, t, n, n, r, i, s), this.isArcCurve = !0, this.type = "ArcCurve"
                }
            }

            function ud() {
                let e = 0,
                    t = 0,
                    n = 0,
                    r = 0;

                function i(i, s, a, o) {
                    e = i, t = a, n = -3 * i + 3 * s - 2 * a - o, r = 2 * i - 2 * s + a + o
                }
                return {
                    initCatmullRom: function(e, t, n, r, s) {
                        i(t, n, s * (n - e), s * (r - t))
                    },
                    initNonuniformCatmullRom: function(e, t, n, r, s, a, o) {
                        let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a,
                            u = (n - t) / a - (r - t) / (a + o) + (r - n) / o;
                        i(t, n, l *= a, u *= a)
                    },
                    calc: function(i) {
                        let s = i * i;
                        return e + t * i + n * s + s * i * r
                    }
                }
            }
            let uf = new rl,
                up = new ud,
                ug = new ud,
                uA = new ud;
            class um extends uu {
                constructor(e = [], t = !1, n = "centripetal", r = .5) {
                    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r
                }
                getPoint(e, t = new rl) {
                    let n, r;
                    let i = this.points,
                        s = i.length,
                        a = (s - (this.closed ? 0 : 1)) * e,
                        o = Math.floor(a),
                        l = a - o;
                    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s : 0 === l && o === s - 1 && (o = s - 2, l = 1), this.closed || o > 0 ? n = i[(o - 1) % s] : (uf.subVectors(i[0], i[1]).add(i[0]), n = uf);
                    let u = i[o % s],
                        c = i[(o + 1) % s];
                    if (this.closed || o + 2 < s ? r = i[(o + 2) % s] : (uf.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), r = uf), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        let e = "chordal" === this.curveType ? .5 : .25,
                            t = Math.pow(n.distanceToSquared(u), e),
                            i = Math.pow(u.distanceToSquared(c), e),
                            s = Math.pow(c.distanceToSquared(r), e);
                        i < 1e-4 && (i = 1), t < 1e-4 && (t = i), s < 1e-4 && (s = i), up.initNonuniformCatmullRom(n.x, u.x, c.x, r.x, t, i, s), ug.initNonuniformCatmullRom(n.y, u.y, c.y, r.y, t, i, s), uA.initNonuniformCatmullRom(n.z, u.z, c.z, r.z, t, i, s)
                    } else "catmullrom" === this.curveType && (up.initCatmullRom(n.x, u.x, c.x, r.x, this.tension), ug.initCatmullRom(n.y, u.y, c.y, r.y, this.tension), uA.initCatmullRom(n.z, u.z, c.z, r.z, this.tension));
                    return t.set(up.calc(l), ug.calc(l), uA.calc(l)), t
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        let n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let n = e.points[t];
                        this.points.push(new rl().fromArray(n))
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
            }

            function uv(e, t, n, r, i) {
                let s = (r - t) * .5,
                    a = (i - n) * .5,
                    o = e * e;
                return e * o * (2 * n - 2 * r + s + a) + (-3 * n + 3 * r - 2 * s - a) * o + s * e + n
            }

            function uy(e, t, n, r) {
                return function(e, t) {
                    let n = 1 - e;
                    return n * n * t
                }(e, t) + 2 * (1 - e) * e * n + e * e * r
            }

            function ux(e, t, n, r, i) {
                return function(e, t) {
                    let n = 1 - e;
                    return n * n * n * t
                }(e, t) + function(e, t) {
                    let n = 1 - e;
                    return 3 * n * n * e * t
                }(e, n) + 3 * (1 - e) * e * e * r + e * e * e * i
            }
            class uE extends uu {
                constructor(e = new nG, t = new nG, n = new nG, r = new nG) {
                    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
                }
                getPoint(e, t = new nG) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2,
                        s = this.v3;
                    return t.set(ux(e, n.x, r.x, i.x, s.x), ux(e, n.y, r.y, i.y, s.y)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            class u_ extends uu {
                constructor(e = new rl, t = new rl, n = new rl, r = new rl) {
                    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
                }
                getPoint(e, t = new rl) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2,
                        s = this.v3;
                    return t.set(ux(e, n.x, r.x, i.x, s.x), ux(e, n.y, r.y, i.y, s.y), ux(e, n.z, r.z, i.z, s.z)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            class ub extends uu {
                constructor(e = new nG, t = new nG) {
                    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new nG) {
                    return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t = new nG) {
                    return t.subVectors(this.v2, this.v1).normalize()
                }
                getTangentAt(e, t) {
                    return this.getTangent(e, t)
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class uw extends uu {
                constructor(e = new rl, t = new rl) {
                    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new rl) {
                    return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t = new rl) {
                    return t.subVectors(this.v2, this.v1).normalize()
                }
                getTangentAt(e, t) {
                    return this.getTangent(e, t)
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class uC extends uu {
                constructor(e = new nG, t = new nG, n = new nG) {
                    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new nG) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2;
                    return t.set(uy(e, n.x, r.x, i.x), uy(e, n.y, r.y, i.y)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class uS extends uu {
                constructor(e = new rl, t = new rl, n = new rl) {
                    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new rl) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2;
                    return t.set(uy(e, n.x, r.x, i.x), uy(e, n.y, r.y, i.y), uy(e, n.z, r.z, i.z)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class uI extends uu {
                constructor(e = []) {
                    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
                }
                getPoint(e, t = new nG) {
                    let n = this.points,
                        r = (n.length - 1) * e,
                        i = Math.floor(r),
                        s = r - i,
                        a = n[0 === i ? i : i - 1],
                        o = n[i],
                        l = n[i > n.length - 2 ? n.length - 1 : i + 1],
                        u = n[i > n.length - 3 ? n.length - 1 : i + 2];
                    return t.set(uv(s, a.x, o.x, l.x, u.x), uv(s, a.y, o.y, l.y, u.y)), t
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        let n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let n = e.points[t];
                        this.points.push(new nG().fromArray(n))
                    }
                    return this
                }
            }
            var uM = Object.freeze({
                __proto__: null,
                ArcCurve: uh,
                CatmullRomCurve3: um,
                CubicBezierCurve: uE,
                CubicBezierCurve3: u_,
                EllipseCurve: uc,
                LineCurve: ub,
                LineCurve3: uw,
                QuadraticBezierCurve: uC,
                QuadraticBezierCurve3: uS,
                SplineCurve: uI
            });
            class uT extends uu {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(e) {
                    this.curves.push(e)
                }
                closePath() {
                    let e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    if (!e.equals(t)) {
                        let n = !0 === e.isVector2 ? "LineCurve" : "LineCurve3";
                        this.curves.push(new uM[n](t, e))
                    }
                    return this
                }
                getPoint(e, t) {
                    let n = e * this.getLength(),
                        r = this.getCurveLengths(),
                        i = 0;
                    for (; i < r.length;) {
                        if (r[i] >= n) {
                            let e = r[i] - n,
                                s = this.curves[i],
                                a = s.getLength(),
                                o = 0 === a ? 0 : 1 - e / a;
                            return s.getPointAt(o, t)
                        }
                        i++
                    }
                    return null
                }
                getLength() {
                    let e = this.getCurveLengths();
                    return e[e.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    let e = [],
                        t = 0;
                    for (let n = 0, r = this.curves.length; n < r; n++) e.push(t += this.curves[n].getLength());
                    return this.cacheLengths = e, e
                }
                getSpacedPoints(e = 40) {
                    let t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                }
                getPoints(e = 12) {
                    let t;
                    let n = [];
                    for (let r = 0, i = this.curves; r < i.length; r++) {
                        let s = i[r],
                            a = s.isEllipseCurve ? 2 * e : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e,
                            o = s.getPoints(a);
                        for (let e = 0; e < o.length; e++) {
                            let r = o[e];
                            t && t.equals(r) || (n.push(r), t = r)
                        }
                    }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                }
                copy(e) {
                    super.copy(e), this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        let n = e.curves[t];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = e.autoClose, this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.autoClose = this.autoClose, e.curves = [];
                    for (let t = 0, n = this.curves.length; t < n; t++) {
                        let n = this.curves[t];
                        e.curves.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        let n = e.curves[t];
                        this.curves.push(new uM[n.type]().fromJSON(n))
                    }
                    return this
                }
            }
            class uB extends uT {
                constructor(e) {
                    super(), this.type = "Path", this.currentPoint = new nG, e && this.setFromPoints(e)
                }
                setFromPoints(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                }
                moveTo(e, t) {
                    return this.currentPoint.set(e, t), this
                }
                lineTo(e, t) {
                    let n = new ub(this.currentPoint.clone(), new nG(e, t));
                    return this.curves.push(n), this.currentPoint.set(e, t), this
                }
                quadraticCurveTo(e, t, n, r) {
                    let i = new uC(this.currentPoint.clone(), new nG(e, t), new nG(n, r));
                    return this.curves.push(i), this.currentPoint.set(n, r), this
                }
                bezierCurveTo(e, t, n, r, i, s) {
                    let a = new uE(this.currentPoint.clone(), new nG(e, t), new nG(n, r), new nG(i, s));
                    return this.curves.push(a), this.currentPoint.set(i, s), this
                }
                splineThru(e) {
                    let t = new uI([this.currentPoint.clone()].concat(e));
                    return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
                }
                arc(e, t, n, r, i, s) {
                    let a = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(e + a, t + o, n, r, i, s), this
                }
                absarc(e, t, n, r, i, s) {
                    return this.absellipse(e, t, n, n, r, i, s), this
                }
                ellipse(e, t, n, r, i, s, a, o) {
                    let l = this.currentPoint.x,
                        u = this.currentPoint.y;
                    return this.absellipse(e + l, t + u, n, r, i, s, a, o), this
                }
                absellipse(e, t, n, r, i, s, a, o) {
                    let l = new uc(e, t, n, r, i, s, a, o);
                    if (this.curves.length > 0) {
                        let e = l.getPoint(0);
                        e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                    }
                    this.curves.push(l);
                    let u = l.getPoint(1);
                    return this.currentPoint.copy(u), this
                }
                copy(e) {
                    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.currentPoint = this.currentPoint.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }
            class uR extends iK {
                constructor(e = [new nG(0, -.5), new nG(.5, 0), new nG(0, .5)], t = 12, n = 0, r = 2 * Math.PI) {
                    super(), this.type = "LatheGeometry", this.parameters = {
                        points: e,
                        segments: t,
                        phiStart: n,
                        phiLength: r
                    }, t = Math.floor(t), r = nO(r, 0, 2 * Math.PI);
                    let i = [],
                        s = [],
                        a = [],
                        o = [],
                        l = [],
                        u = 1 / t,
                        c = new rl,
                        h = new nG,
                        d = new rl,
                        f = new rl,
                        p = new rl,
                        g = 0,
                        A = 0;
                    for (let t = 0; t <= e.length - 1; t++) switch (t) {
                        case 0:
                            g = e[t + 1].x - e[t].x, A = e[t + 1].y - e[t].y, d.x = 1 * A, d.y = -g, d.z = 0 * A, p.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
                            break;
                        case e.length - 1:
                            o.push(p.x, p.y, p.z);
                            break;
                        default:
                            g = e[t + 1].x - e[t].x, A = e[t + 1].y - e[t].y, d.x = 1 * A, d.y = -g, d.z = 0 * A, f.copy(d), d.x += p.x, d.y += p.y, d.z += p.z, d.normalize(), o.push(d.x, d.y, d.z), p.copy(f)
                    }
                    for (let i = 0; i <= t; i++) {
                        let d = n + i * u * r,
                            f = Math.sin(d),
                            p = Math.cos(d);
                        for (let n = 0; n <= e.length - 1; n++) {
                            c.x = e[n].x * f, c.y = e[n].y, c.z = e[n].x * p, s.push(c.x, c.y, c.z), h.x = i / t, h.y = n / (e.length - 1), a.push(h.x, h.y);
                            let r = o[3 * n + 0] * f,
                                u = o[3 * n + 1],
                                d = o[3 * n + 0] * p;
                            l.push(r, u, d)
                        }
                    }
                    for (let n = 0; n < t; n++)
                        for (let t = 0; t < e.length - 1; t++) {
                            let r = t + n * e.length,
                                s = r + e.length,
                                a = r + e.length + 1,
                                o = r + 1;
                            i.push(r, s, o), i.push(a, o, s)
                        }
                    this.setIndex(i), this.setAttribute("position", new iz(s, 3)), this.setAttribute("uv", new iz(a, 2)), this.setAttribute("normal", new iz(l, 3))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new uR(e.points, e.segments, e.phiStart, e.phiLength)
                }
            }
            class uD extends uR {
                constructor(e = 1, t = 1, n = 4, r = 8) {
                    let i = new uB;
                    i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), i.absarc(0, t / 2, e, 0, .5 * Math.PI), super(i.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
                        radius: e,
                        length: t,
                        capSegments: n,
                        radialSegments: r
                    }
                }
                static fromJSON(e) {
                    return new uD(e.radius, e.length, e.capSegments, e.radialSegments)
                }
            }
            class uL extends iK {
                constructor(e = 1, t = 32, n = 0, r = 2 * Math.PI) {
                    super(), this.type = "CircleGeometry", this.parameters = {
                        radius: e,
                        segments: t,
                        thetaStart: n,
                        thetaLength: r
                    }, t = Math.max(3, t);
                    let i = [],
                        s = [],
                        a = [],
                        o = [],
                        l = new rl,
                        u = new nG;
                    s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
                    for (let i = 0, c = 3; i <= t; i++, c += 3) {
                        let h = n + i / t * r;
                        l.x = e * Math.cos(h), l.y = e * Math.sin(h), s.push(l.x, l.y, l.z), a.push(0, 0, 1), u.x = (s[c] / e + 1) / 2, u.y = (s[c + 1] / e + 1) / 2, o.push(u.x, u.y)
                    }
                    for (let e = 1; e <= t; e++) i.push(e, e + 1, 0);
                    this.setIndex(i), this.setAttribute("position", new iz(s, 3)), this.setAttribute("normal", new iz(a, 3)), this.setAttribute("uv", new iz(o, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new uL(e.radius, e.segments, e.thetaStart, e.thetaLength)
                }
            }
            class uP extends iK {
                constructor(e = 1, t = 1, n = 1, r = 32, i = 1, s = !1, a = 0, o = 2 * Math.PI) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: e,
                        radiusBottom: t,
                        height: n,
                        radialSegments: r,
                        heightSegments: i,
                        openEnded: s,
                        thetaStart: a,
                        thetaLength: o
                    };
                    let l = this;
                    r = Math.floor(r), i = Math.floor(i);
                    let u = [],
                        c = [],
                        h = [],
                        d = [],
                        f = 0,
                        p = [],
                        g = n / 2,
                        A = 0;

                    function m(n) {
                        let i = f,
                            s = new nG,
                            p = new rl,
                            m = 0,
                            v = !0 === n ? e : t,
                            y = !0 === n ? 1 : -1;
                        for (let e = 1; e <= r; e++) c.push(0, g * y, 0), h.push(0, y, 0), d.push(.5, .5), f++;
                        let x = f;
                        for (let e = 0; e <= r; e++) {
                            let t = e / r * o + a,
                                n = Math.cos(t),
                                i = Math.sin(t);
                            p.x = v * i, p.y = g * y, p.z = v * n, c.push(p.x, p.y, p.z), h.push(0, y, 0), s.x = .5 * n + .5, s.y = .5 * i * y + .5, d.push(s.x, s.y), f++
                        }
                        for (let e = 0; e < r; e++) {
                            let t = i + e,
                                r = x + e;
                            !0 === n ? u.push(r, r + 1, t) : u.push(r + 1, r, t), m += 3
                        }
                        l.addGroup(A, m, !0 === n ? 1 : 2), A += m
                    }(function() {
                        let s = new rl,
                            m = new rl,
                            v = 0,
                            y = (t - e) / n;
                        for (let l = 0; l <= i; l++) {
                            let u = [],
                                A = l / i,
                                v = A * (t - e) + e;
                            for (let e = 0; e <= r; e++) {
                                let t = e / r,
                                    i = t * o + a,
                                    l = Math.sin(i),
                                    p = Math.cos(i);
                                m.x = v * l, m.y = -A * n + g, m.z = v * p, c.push(m.x, m.y, m.z), s.set(l, y, p).normalize(), h.push(s.x, s.y, s.z), d.push(t, 1 - A), u.push(f++)
                            }
                            p.push(u)
                        }
                        for (let n = 0; n < r; n++)
                            for (let r = 0; r < i; r++) {
                                let i = p[r][n],
                                    s = p[r + 1][n],
                                    a = p[r + 1][n + 1],
                                    o = p[r][n + 1];
                                e > 0 && (u.push(i, s, o), v += 3), t > 0 && (u.push(s, a, o), v += 3)
                            }
                        l.addGroup(A, v, 0), A += v
                    })(), !1 === s && (e > 0 && m(!0), t > 0 && m(!1)), this.setIndex(u), this.setAttribute("position", new iz(c, 3)), this.setAttribute("normal", new iz(h, 3)), this.setAttribute("uv", new iz(d, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new uP(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class uO extends uP {
                constructor(e = 1, t = 1, n = 32, r = 1, i = !1, s = 0, a = 2 * Math.PI) {
                    super(0, e, t, n, r, i, s, a), this.type = "ConeGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        radialSegments: n,
                        heightSegments: r,
                        openEnded: i,
                        thetaStart: s,
                        thetaLength: a
                    }
                }
                static fromJSON(e) {
                    return new uO(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class uN extends iK {
                constructor(e = [], t = [], n = 1, r = 0) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: e,
                        indices: t,
                        radius: n,
                        detail: r
                    };
                    let i = [],
                        s = [];

                    function a(e) {
                        i.push(e.x, e.y, e.z)
                    }

                    function o(t, n) {
                        let r = 3 * t;
                        n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
                    }

                    function l(e, t, n, r) {
                        r < 0 && 1 === e.x && (s[t] = e.x - 1), 0 === n.x && 0 === n.z && (s[t] = r / 2 / Math.PI + .5)
                    }

                    function u(e) {
                        return Math.atan2(e.z, -e.x)
                    }(function(e) {
                        let n = new rl,
                            r = new rl,
                            i = new rl;
                        for (let s = 0; s < t.length; s += 3) o(t[s + 0], n), o(t[s + 1], r), o(t[s + 2], i),
                            function(e, t, n, r) {
                                let i = r + 1,
                                    s = [];
                                for (let r = 0; r <= i; r++) {
                                    s[r] = [];
                                    let a = e.clone().lerp(n, r / i),
                                        o = t.clone().lerp(n, r / i),
                                        l = i - r;
                                    for (let e = 0; e <= l; e++) 0 === e && r === i ? s[r][e] = a : s[r][e] = a.clone().lerp(o, e / l)
                                }
                                for (let e = 0; e < i; e++)
                                    for (let t = 0; t < 2 * (i - e) - 1; t++) {
                                        let n = Math.floor(t / 2);
                                        t % 2 == 0 ? (a(s[e][n + 1]), a(s[e + 1][n]), a(s[e][n])) : (a(s[e][n + 1]), a(s[e + 1][n + 1]), a(s[e + 1][n]))
                                    }
                            }(n, r, i, e)
                    })(r),
                    function(e) {
                        let t = new rl;
                        for (let n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z
                    }(n),
                    function() {
                        let e = new rl;
                        for (let t = 0; t < i.length; t += 3) {
                            e.x = i[t + 0], e.y = i[t + 1], e.z = i[t + 2];
                            let n = u(e) / 2 / Math.PI + .5,
                                r = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5;
                            s.push(n, 1 - r)
                        }(function() {
                            let e = new rl,
                                t = new rl,
                                n = new rl,
                                r = new rl,
                                a = new nG,
                                o = new nG,
                                c = new nG;
                            for (let h = 0, d = 0; h < i.length; h += 9, d += 6) {
                                e.set(i[h + 0], i[h + 1], i[h + 2]), t.set(i[h + 3], i[h + 4], i[h + 5]), n.set(i[h + 6], i[h + 7], i[h + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), c.set(s[d + 4], s[d + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                                let f = u(r);
                                l(a, d + 0, e, f), l(o, d + 2, t, f), l(c, d + 4, n, f)
                            }
                        })(),
                        function() {
                            for (let e = 0; e < s.length; e += 6) {
                                let t = s[e + 0],
                                    n = s[e + 2],
                                    r = s[e + 4],
                                    i = Math.max(t, n, r),
                                    a = Math.min(t, n, r);
                                i > .9 && a < .1 && (t < .2 && (s[e + 0] += 1), n < .2 && (s[e + 2] += 1), r < .2 && (s[e + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new iz(i, 3)), this.setAttribute("normal", new iz(i.slice(), 3)), this.setAttribute("uv", new iz(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new uN(e.vertices, e.indices, e.radius, e.details)
                }
            }
            class uU extends uN {
                constructor(e = 1, t = 0) {
                    let n = (1 + Math.sqrt(5)) / 2,
                        r = 1 / n;
                    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new uU(e.radius, e.detail)
                }
            }
            let uF = new rl,
                uk = new rl,
                uQ = new rl,
                uG = new im;
            class uz extends iK {
                constructor(e = null, t = 1) {
                    if (super(), this.type = "EdgesGeometry", this.parameters = {
                            geometry: e,
                            thresholdAngle: t
                        }, null !== e) {
                        let n = Math.cos(nD * t),
                            r = e.getIndex(),
                            i = e.getAttribute("position"),
                            s = r ? r.count : i.count,
                            a = [0, 0, 0],
                            o = ["a", "b", "c"],
                            l = [, , , ],
                            u = {},
                            c = [];
                        for (let e = 0; e < s; e += 3) {
                            r ? (a[0] = r.getX(e), a[1] = r.getX(e + 1), a[2] = r.getX(e + 2)) : (a[0] = e, a[1] = e + 1, a[2] = e + 2);
                            let {
                                a: t,
                                b: s,
                                c: h
                            } = uG;
                            if (t.fromBufferAttribute(i, a[0]), s.fromBufferAttribute(i, a[1]), h.fromBufferAttribute(i, a[2]), uG.getNormal(uQ), l[0] = `${Math.round(1e4*t.x)},${Math.round(1e4*t.y)},${Math.round(1e4*t.z)}`, l[1] = `${Math.round(1e4*s.x)},${Math.round(1e4*s.y)},${Math.round(1e4*s.z)}`, l[2] = `${Math.round(1e4*h.x)},${Math.round(1e4*h.y)},${Math.round(1e4*h.z)}`, l[0] !== l[1] && l[1] !== l[2] && l[2] !== l[0])
                                for (let e = 0; e < 3; e++) {
                                    let t = (e + 1) % 3,
                                        r = l[e],
                                        i = l[t],
                                        s = uG[o[e]],
                                        h = uG[o[t]],
                                        d = `${r}_${i}`,
                                        f = `${i}_${r}`;
                                    f in u && u[f] ? (uQ.dot(u[f].normal) <= n && (c.push(s.x, s.y, s.z), c.push(h.x, h.y, h.z)), u[f] = null) : d in u || (u[d] = {
                                        index0: a[e],
                                        index1: a[t],
                                        normal: uQ.clone()
                                    })
                                }
                        }
                        for (let e in u)
                            if (u[e]) {
                                let {
                                    index0: t,
                                    index1: n
                                } = u[e];
                                uF.fromBufferAttribute(i, t), uk.fromBufferAttribute(i, n), c.push(uF.x, uF.y, uF.z), c.push(uk.x, uk.y, uk.z)
                            }
                        this.setAttribute("position", new iz(c, 3))
                    }
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
            }
            class uH extends uB {
                constructor(e) {
                    super(e), this.uuid = nP(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(e) {
                    let t = [];
                    for (let n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                }
                extractPoints(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                }
                copy(e) {
                    super.copy(e), this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        let n = e.holes[t];
                        this.holes.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.uuid = this.uuid, e.holes = [];
                    for (let t = 0, n = this.holes.length; t < n; t++) {
                        let n = this.holes[t];
                        e.holes.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        let n = e.holes[t];
                        this.holes.push(new uB().fromJSON(n))
                    }
                    return this
                }
            }
            let uV = function(e, t, n = 2) {
                let r, i, s, a, o, l, u;
                let c = t && t.length,
                    h = c ? t[0] * n : e.length,
                    d = uj(e, 0, h, n, !0),
                    f = [];
                if (!d || d.next === d.prev) return f;
                if (c && (d = function(e, t, n, r) {
                        let i, s, a, o, l;
                        let u = [];
                        for (i = 0, s = t.length; i < s; i++) a = t[i] * r, o = i < s - 1 ? t[i + 1] * r : e.length, (l = uj(e, a, o, r, !1)) === l.next && (l.steiner = !0), u.push(function(e) {
                            let t = e,
                                n = e;
                            do(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== e);
                            return n
                        }(l));
                        for (u.sort(uY), i = 0; i < u.length; i++) n = function(e, t) {
                            let n = function(e, t) {
                                let n = t,
                                    r = -1 / 0,
                                    i, s = e.x,
                                    a = e.y;
                                do {
                                    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                                        let e = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                        if (e <= s && e > r && (r = e, i = n.x < n.next.x ? n : n.next, e === s)) return i
                                    }
                                    n = n.next
                                } while (n !== t);
                                if (!i) return null;
                                let o = i,
                                    l = i.x,
                                    u = i.y,
                                    c = 1 / 0,
                                    h;
                                n = i;
                                do {
                                    var d, f;
                                    s >= n.x && n.x >= l && s !== n.x && uq(a < u ? s : r, a, l, u, a < u ? r : s, a, n.x, n.y) && (h = Math.abs(a - n.y) / (s - n.x), u1(n, e) && (h < c || h === c && (n.x > i.x || n.x === i.x && (d = i, f = n, 0 > uK(d.prev, d, f.prev) && 0 > uK(f.next, d, d.next)))) && (i = n, c = h)), n = n.next
                                } while (n !== o);
                                return i
                            }(e, t);
                            if (!n) return t;
                            let r = u2(n, e);
                            return uW(r, r.next), uW(n, n.next)
                        }(u[i], n);
                        return n
                    }(e, t, d, n)), e.length > 80 * n) {
                    r = s = e[0], i = a = e[1];
                    for (let t = n; t < h; t += n) o = e[t], l = e[t + 1], o < r && (r = o), l < i && (i = l), o > s && (s = o), l > a && (a = l);
                    u = 0 !== (u = Math.max(s - r, a - i)) ? 32767 / u : 0
                }
                return function e(t, n, r, i, s, a, o) {
                    if (!t) return;
                    !o && a && function(e, t, n, r) {
                        let i = e;
                        do 0 === i.z && (i.z = uX(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== e);
                        i.prevZ.nextZ = null, i.prevZ = null,
                            function(e) {
                                let t, n, r, i, s, a, o, l, u = 1;
                                do {
                                    for (n = e, e = null, s = null, a = 0; n;) {
                                        for (a++, r = n, o = 0, t = 0; t < u && (o++, r = r.nextZ); t++);
                                        for (l = u; o > 0 || l > 0 && r;) 0 !== o && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, o--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : e = i, i.prevZ = s, s = i;
                                        n = r
                                    }
                                    s.nextZ = null, u *= 2
                                } while (a > 1)
                            }(i)
                    }(t, i, s, a);
                    let l = t,
                        u, c;
                    for (; t.prev !== t.next;) {
                        if (u = t.prev, c = t.next, a ? function(e, t, n, r) {
                                let i = e.prev,
                                    s = e.next;
                                if (uK(i, e, s) >= 0) return !1;
                                let a = i.x,
                                    o = e.x,
                                    l = s.x,
                                    u = i.y,
                                    c = e.y,
                                    h = s.y,
                                    d = a < o ? a < l ? a : l : o < l ? o : l,
                                    f = u < c ? u < h ? u : h : c < h ? c : h,
                                    p = a > o ? a > l ? a : l : o > l ? o : l,
                                    g = u > c ? u > h ? u : h : c > h ? c : h,
                                    A = uX(d, f, t, n, r),
                                    m = uX(p, g, t, n, r),
                                    v = e.prevZ,
                                    y = e.nextZ;
                                for (; v && v.z >= A && y && y.z <= m;) {
                                    if (v.x >= d && v.x <= p && v.y >= f && v.y <= g && v !== i && v !== s && uq(a, u, o, c, l, h, v.x, v.y) && uK(v.prev, v, v.next) >= 0 || (v = v.prevZ, y.x >= d && y.x <= p && y.y >= f && y.y <= g && y !== i && y !== s && uq(a, u, o, c, l, h, y.x, y.y) && uK(y.prev, y, y.next) >= 0)) return !1;
                                    y = y.nextZ
                                }
                                for (; v && v.z >= A;) {
                                    if (v.x >= d && v.x <= p && v.y >= f && v.y <= g && v !== i && v !== s && uq(a, u, o, c, l, h, v.x, v.y) && uK(v.prev, v, v.next) >= 0) return !1;
                                    v = v.prevZ
                                }
                                for (; y && y.z <= m;) {
                                    if (y.x >= d && y.x <= p && y.y >= f && y.y <= g && y !== i && y !== s && uq(a, u, o, c, l, h, y.x, y.y) && uK(y.prev, y, y.next) >= 0) return !1;
                                    y = y.nextZ
                                }
                                return !0
                            }(t, i, s, a) : function(e) {
                                let t = e.prev,
                                    n = e.next;
                                if (uK(t, e, n) >= 0) return !1;
                                let r = t.x,
                                    i = e.x,
                                    s = n.x,
                                    a = t.y,
                                    o = e.y,
                                    l = n.y,
                                    u = r < i ? r < s ? r : s : i < s ? i : s,
                                    c = a < o ? a < l ? a : l : o < l ? o : l,
                                    h = r > i ? r > s ? r : s : i > s ? i : s,
                                    d = a > o ? a > l ? a : l : o > l ? o : l,
                                    f = n.next;
                                for (; f !== t;) {
                                    if (f.x >= u && f.x <= h && f.y >= c && f.y <= d && uq(r, a, i, o, s, l, f.x, f.y) && uK(f.prev, f, f.next) >= 0) return !1;
                                    f = f.next
                                }
                                return !0
                            }(t)) {
                            n.push(u.i / r | 0), n.push(t.i / r | 0), n.push(c.i / r | 0), u4(t), t = c.next, l = c.next;
                            continue
                        }
                        if ((t = c) === l) {
                            o ? 1 === o ? e(t = function(e, t, n) {
                                let r = e;
                                do {
                                    let i = r.prev,
                                        s = r.next.next;
                                    !uJ(i, s) && uZ(i, r, r.next, s) && u1(i, s) && u1(s, i) && (t.push(i.i / n | 0), t.push(r.i / n | 0), t.push(s.i / n | 0), u4(r), u4(r.next), r = e = s), r = r.next
                                } while (r !== e);
                                return uW(r)
                            }(uW(t), n, r), n, r, i, s, a, 2) : 2 === o && function(t, n, r, i, s, a) {
                                let o = t;
                                do {
                                    let t = o.next.next;
                                    for (; t !== o.prev;) {
                                        var l, u;
                                        if (o.i !== t.i && (l = o, u = t, l.next.i !== u.i && l.prev.i !== u.i && ! function(e, t) {
                                                let n = e;
                                                do {
                                                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && uZ(n, n.next, e, t)) return !0;
                                                    n = n.next
                                                } while (n !== e);
                                                return !1
                                            }(l, u) && (u1(l, u) && u1(u, l) && function(e, t) {
                                                let n = e,
                                                    r = !1,
                                                    i = (e.x + t.x) / 2,
                                                    s = (e.y + t.y) / 2;
                                                do n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== e);
                                                return r
                                            }(l, u) && (uK(l.prev, l, u.prev) || uK(l, u.prev, u)) || uJ(l, u) && uK(l.prev, l, l.next) > 0 && uK(u.prev, u, u.next) > 0))) {
                                            let l = u2(o, t);
                                            o = uW(o, o.next), l = uW(l, l.next), e(o, n, r, i, s, a, 0), e(l, n, r, i, s, a, 0);
                                            return
                                        }
                                        t = t.next
                                    }
                                    o = o.next
                                } while (o !== t)
                            }(t, n, r, i, s, a) : e(uW(t), n, r, i, s, a, 1);
                            break
                        }
                    }
                }(d, f, n, r, i, u, 0), f
            };

            function uj(e, t, n, r, i) {
                let s, a;
                if (i === function(e, t, n, r) {
                        let i = 0;
                        for (let s = t, a = n - r; s < n; s += r) i += (e[a] - e[s]) * (e[s + 1] + e[a + 1]), a = s;
                        return i
                    }(e, t, n, r) > 0)
                    for (s = t; s < n; s += r) a = u3(s, e[s], e[s + 1], a);
                else
                    for (s = n - r; s >= t; s -= r) a = u3(s, e[s], e[s + 1], a);
                return a && uJ(a, a.next) && (u4(a), a = a.next), a
            }

            function uW(e, t) {
                if (!e) return e;
                t || (t = e);
                let n = e,
                    r;
                do
                    if (r = !1, !n.steiner && (uJ(n, n.next) || 0 === uK(n.prev, n, n.next))) {
                        if (u4(n), (n = t = n.prev) === n.next) break;
                        r = !0
                    } else n = n.next; while (r || n !== t);
                return t
            }

            function uY(e, t) {
                return e.x - t.x
            }

            function uX(e, t, n, r, i) {
                return (e = ((e = ((e = ((e = ((e = (e - n) * i | 0) | e << 8) & 16711935) | e << 4) & 252645135) | e << 2) & 858993459) | e << 1) & 1431655765) | (t = ((t = ((t = ((t = ((t = (t - r) * i | 0) | t << 8) & 16711935) | t << 4) & 252645135) | t << 2) & 858993459) | t << 1) & 1431655765) << 1
            }

            function uq(e, t, n, r, i, s, a, o) {
                return (i - a) * (t - o) >= (e - a) * (s - o) && (e - a) * (r - o) >= (n - a) * (t - o) && (n - a) * (s - o) >= (i - a) * (r - o)
            }

            function uK(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function uJ(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function uZ(e, t, n, r) {
                let i = u0(uK(e, t, n)),
                    s = u0(uK(e, t, r)),
                    a = u0(uK(n, r, e)),
                    o = u0(uK(n, r, t));
                return !!(i !== s && a !== o || 0 === i && u$(e, n, t) || 0 === s && u$(e, r, t) || 0 === a && u$(n, e, r) || 0 === o && u$(n, t, r))
            }

            function u$(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }

            function u0(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function u1(e, t) {
                return 0 > uK(e.prev, e, e.next) ? uK(e, t, e.next) >= 0 && uK(e, e.prev, t) >= 0 : 0 > uK(e, t, e.prev) || 0 > uK(e, e.next, t)
            }

            function u2(e, t) {
                let n = new u5(e.i, e.x, e.y),
                    r = new u5(t.i, t.x, t.y),
                    i = e.next,
                    s = t.prev;
                return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
            }

            function u3(e, t, n, r) {
                let i = new u5(e, t, n);
                return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
            }

            function u4(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function u5(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            class u6 {
                static area(e) {
                    let t = e.length,
                        n = 0;
                    for (let r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                    return .5 * n
                }
                static isClockWise(e) {
                    return 0 > u6.area(e)
                }
                static triangulateShape(e, t) {
                    let n = [],
                        r = [],
                        i = [];
                    u8(e), u9(n, e);
                    let s = e.length;
                    t.forEach(u8);
                    for (let e = 0; e < t.length; e++) r.push(s), s += t[e].length, u9(n, t[e]);
                    let a = uV(n, r);
                    for (let e = 0; e < a.length; e += 3) i.push(a.slice(e, e + 3));
                    return i
                }
            }

            function u8(e) {
                let t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function u9(e, t) {
                for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }
            class u7 extends iK {
                constructor(e = new uH([new nG(.5, .5), new nG(-.5, .5), new nG(-.5, -.5), new nG(.5, -.5)]), t = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    }, e = Array.isArray(e) ? e : [e];
                    let n = this,
                        r = [],
                        i = [];
                    for (let s = 0, a = e.length; s < a; s++) ! function(e) {
                        let s, a, o, l;
                        let u = [],
                            c = void 0 !== t.curveSegments ? t.curveSegments : 12,
                            h = void 0 !== t.steps ? t.steps : 1,
                            d = void 0 !== t.depth ? t.depth : 1,
                            f = void 0 === t.bevelEnabled || t.bevelEnabled,
                            p = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                            g = void 0 !== t.bevelSize ? t.bevelSize : p - .1,
                            A = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                            m = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                            v = t.extrudePath,
                            y = void 0 !== t.UVGenerator ? t.UVGenerator : ce,
                            x, E = !1;
                        v && (x = v.getSpacedPoints(h), E = !0, f = !1, s = v.computeFrenetFrames(h, !1), a = new rl, o = new rl, l = new rl), f || (m = 0, p = 0, g = 0, A = 0);
                        let _ = e.extractPoints(c),
                            b = _.shape,
                            w = _.holes;
                        if (!u6.isClockWise(b)) {
                            b = b.reverse();
                            for (let e = 0, t = w.length; e < t; e++) {
                                let t = w[e];
                                u6.isClockWise(t) && (w[e] = t.reverse())
                            }
                        }
                        let C = u6.triangulateShape(b, w),
                            S = b;
                        for (let e = 0, t = w.length; e < t; e++) {
                            let t = w[e];
                            b = b.concat(t)
                        }

                        function I(e, t, n) {
                            return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().addScaledVector(t, n)
                        }
                        let M = b.length,
                            T = C.length;

                        function B(e, t, n) {
                            let r, i, s;
                            let a = e.x - t.x,
                                o = e.y - t.y,
                                l = n.x - e.x,
                                u = n.y - e.y,
                                c = a * a + o * o;
                            if (Math.abs(a * u - o * l) > Number.EPSILON) {
                                let h = Math.sqrt(c),
                                    d = Math.sqrt(l * l + u * u),
                                    f = t.x - o / h,
                                    p = t.y + a / h,
                                    g = ((n.x - u / d - f) * u - (n.y + l / d - p) * l) / (a * u - o * l),
                                    A = (r = f + a * g - e.x) * r + (i = p + o * g - e.y) * i;
                                if (A <= 2) return new nG(r, i);
                                s = Math.sqrt(A / 2)
                            } else {
                                let e = !1;
                                a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(u) && (e = !0), e ? (r = -o, i = a, s = Math.sqrt(c)) : (r = a, i = o, s = Math.sqrt(c / 2))
                            }
                            return new nG(r / s, i / s)
                        }
                        let R = [];
                        for (let e = 0, t = S.length, n = t - 1, r = e + 1; e < t; e++, n++, r++) n === t && (n = 0), r === t && (r = 0), R[e] = B(S[e], S[n], S[r]);
                        let D = [],
                            L, P = R.concat();
                        for (let e = 0, t = w.length; e < t; e++) {
                            let t = w[e];
                            L = [];
                            for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), L[e] = B(t[e], t[r], t[i]);
                            D.push(L), P = P.concat(L)
                        }
                        for (let e = 0; e < m; e++) {
                            let t = e / m,
                                n = p * Math.cos(t * Math.PI / 2),
                                r = g * Math.sin(t * Math.PI / 2) + A;
                            for (let e = 0, t = S.length; e < t; e++) {
                                let t = I(S[e], R[e], r);
                                U(t.x, t.y, -n)
                            }
                            for (let e = 0, t = w.length; e < t; e++) {
                                let t = w[e];
                                L = D[e];
                                for (let e = 0, i = t.length; e < i; e++) {
                                    let i = I(t[e], L[e], r);
                                    U(i.x, i.y, -n)
                                }
                            }
                        }
                        let O = g + A;
                        for (let e = 0; e < M; e++) {
                            let t = f ? I(b[e], P[e], O) : b[e];
                            E ? (o.copy(s.normals[0]).multiplyScalar(t.x), a.copy(s.binormals[0]).multiplyScalar(t.y), l.copy(x[0]).add(o).add(a), U(l.x, l.y, l.z)) : U(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= h; e++)
                            for (let t = 0; t < M; t++) {
                                let n = f ? I(b[t], P[t], O) : b[t];
                                E ? (o.copy(s.normals[e]).multiplyScalar(n.x), a.copy(s.binormals[e]).multiplyScalar(n.y), l.copy(x[e]).add(o).add(a), U(l.x, l.y, l.z)) : U(n.x, n.y, d / h * e)
                            }
                        for (let e = m - 1; e >= 0; e--) {
                            let t = e / m,
                                n = p * Math.cos(t * Math.PI / 2),
                                r = g * Math.sin(t * Math.PI / 2) + A;
                            for (let e = 0, t = S.length; e < t; e++) {
                                let t = I(S[e], R[e], r);
                                U(t.x, t.y, d + n)
                            }
                            for (let e = 0, t = w.length; e < t; e++) {
                                let t = w[e];
                                L = D[e];
                                for (let e = 0, i = t.length; e < i; e++) {
                                    let i = I(t[e], L[e], r);
                                    E ? U(i.x, i.y + x[h - 1].y, x[h - 1].x + n) : U(i.x, i.y, d + n)
                                }
                            }
                        }

                        function N(e, t) {
                            let i = e.length;
                            for (; --i >= 0;) {
                                let s = i,
                                    a = i - 1;
                                a < 0 && (a = e.length - 1);
                                for (let e = 0, i = h + 2 * m; e < i; e++) {
                                    let i = M * e,
                                        o = M * (e + 1);
                                    ! function(e, t, i, s) {
                                        k(e), k(t), k(s), k(t), k(i), k(s);
                                        let a = r.length / 3,
                                            o = y.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                                        Q(o[0]), Q(o[1]), Q(o[3]), Q(o[1]), Q(o[2]), Q(o[3])
                                    }(t + s + i, t + a + i, t + a + o, t + s + o)
                                }
                            }
                        }

                        function U(e, t, n) {
                            u.push(e), u.push(t), u.push(n)
                        }

                        function F(e, t, i) {
                            k(e), k(t), k(i);
                            let s = r.length / 3,
                                a = y.generateTopUV(n, r, s - 3, s - 2, s - 1);
                            Q(a[0]), Q(a[1]), Q(a[2])
                        }

                        function k(e) {
                            r.push(u[3 * e + 0]), r.push(u[3 * e + 1]), r.push(u[3 * e + 2])
                        }

                        function Q(e) {
                            i.push(e.x), i.push(e.y)
                        }(function() {
                            let e = r.length / 3;
                            if (f) {
                                let e = 0 * M;
                                for (let t = 0; t < T; t++) {
                                    let n = C[t];
                                    F(n[2] + e, n[1] + e, n[0] + e)
                                }
                                e = M * (h + 2 * m);
                                for (let t = 0; t < T; t++) {
                                    let n = C[t];
                                    F(n[0] + e, n[1] + e, n[2] + e)
                                }
                            } else {
                                for (let e = 0; e < T; e++) {
                                    let t = C[e];
                                    F(t[2], t[1], t[0])
                                }
                                for (let e = 0; e < T; e++) {
                                    let t = C[e];
                                    F(t[0] + M * h, t[1] + M * h, t[2] + M * h)
                                }
                            }
                            n.addGroup(e, r.length / 3 - e, 0)
                        })(),
                        function() {
                            let e = r.length / 3,
                                t = 0;
                            N(S, 0), t += S.length;
                            for (let e = 0, n = w.length; e < n; e++) {
                                let n = w[e];
                                N(n, t), t += n.length
                            }
                            n.addGroup(e, r.length / 3 - e, 1)
                        }()
                    }(e[s]);
                    this.setAttribute("position", new iz(r, 3)), this.setAttribute("uv", new iz(i, 2)), this.computeVertexNormals()
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return function(e, t, n) {
                        if (n.shapes = [], Array.isArray(e))
                            for (let t = 0, r = e.length; t < r; t++) {
                                let r = e[t];
                                n.shapes.push(r.uuid)
                            } else n.shapes.push(e.uuid);
                        return n.options = Object.assign({}, t), void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
                    }(this.parameters.shapes, this.parameters.options, e)
                }
                static fromJSON(e, t) {
                    let n = [];
                    for (let r = 0, i = e.shapes.length; r < i; r++) {
                        let i = t[e.shapes[r]];
                        n.push(i)
                    }
                    let r = e.options.extrudePath;
                    return void 0 !== r && (e.options.extrudePath = new uM[r.type]().fromJSON(r)), new u7(n, e.options)
                }
            }
            let ce = {
                generateTopUV: function(e, t, n, r, i) {
                    let s = t[3 * n],
                        a = t[3 * n + 1],
                        o = t[3 * r],
                        l = t[3 * r + 1],
                        u = t[3 * i],
                        c = t[3 * i + 1];
                    return [new nG(s, a), new nG(o, l), new nG(u, c)]
                },
                generateSideWallUV: function(e, t, n, r, i, s) {
                    let a = t[3 * n],
                        o = t[3 * n + 1],
                        l = t[3 * n + 2],
                        u = t[3 * r],
                        c = t[3 * r + 1],
                        h = t[3 * r + 2],
                        d = t[3 * i],
                        f = t[3 * i + 1],
                        p = t[3 * i + 2],
                        g = t[3 * s],
                        A = t[3 * s + 1],
                        m = t[3 * s + 2];
                    return Math.abs(o - c) < Math.abs(a - u) ? [new nG(a, 1 - l), new nG(u, 1 - h), new nG(d, 1 - p), new nG(g, 1 - m)] : [new nG(o, 1 - l), new nG(c, 1 - h), new nG(f, 1 - p), new nG(A, 1 - m)]
                }
            };
            class ct extends uN {
                constructor(e = 1, t = 0) {
                    let n = (1 + Math.sqrt(5)) / 2;
                    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new ct(e.radius, e.detail)
                }
            }
            class cn extends uN {
                constructor(e = 1, t = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new cn(e.radius, e.detail)
                }
            }
            class cr extends iK {
                constructor(e = .5, t = 1, n = 32, r = 1, i = 0, s = 2 * Math.PI) {
                    super(), this.type = "RingGeometry", this.parameters = {
                        innerRadius: e,
                        outerRadius: t,
                        thetaSegments: n,
                        phiSegments: r,
                        thetaStart: i,
                        thetaLength: s
                    }, n = Math.max(3, n);
                    let a = [],
                        o = [],
                        l = [],
                        u = [],
                        c = e,
                        h = (t - e) / (r = Math.max(1, r)),
                        d = new rl,
                        f = new nG;
                    for (let e = 0; e <= r; e++) {
                        for (let e = 0; e <= n; e++) {
                            let r = i + e / n * s;
                            d.x = c * Math.cos(r), d.y = c * Math.sin(r), o.push(d.x, d.y, d.z), l.push(0, 0, 1), f.x = (d.x / t + 1) / 2, f.y = (d.y / t + 1) / 2, u.push(f.x, f.y)
                        }
                        c += h
                    }
                    for (let e = 0; e < r; e++) {
                        let t = e * (n + 1);
                        for (let e = 0; e < n; e++) {
                            let r = e + t,
                                i = r + n + 1,
                                s = r + n + 2,
                                o = r + 1;
                            a.push(r, i, o), a.push(i, s, o)
                        }
                    }
                    this.setIndex(a), this.setAttribute("position", new iz(o, 3)), this.setAttribute("normal", new iz(l, 3)), this.setAttribute("uv", new iz(u, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new cr(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
                }
            }
            class ci extends iK {
                constructor(e = new uH([new nG(0, .5), new nG(-.5, -.5), new nG(.5, -.5)]), t = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    let n = [],
                        r = [],
                        i = [],
                        s = [],
                        a = 0,
                        o = 0;
                    if (!1 === Array.isArray(e)) l(e);
                    else
                        for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(a, o, t), a += o, o = 0;

                    function l(e) {
                        let a = r.length / 3,
                            l = e.extractPoints(t),
                            u = l.shape,
                            c = l.holes;
                        !1 === u6.isClockWise(u) && (u = u.reverse());
                        for (let e = 0, t = c.length; e < t; e++) {
                            let t = c[e];
                            !0 === u6.isClockWise(t) && (c[e] = t.reverse())
                        }
                        let h = u6.triangulateShape(u, c);
                        for (let e = 0, t = c.length; e < t; e++) {
                            let t = c[e];
                            u = u.concat(t)
                        }
                        for (let e = 0, t = u.length; e < t; e++) {
                            let t = u[e];
                            r.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y)
                        }
                        for (let e = 0, t = h.length; e < t; e++) {
                            let t = h[e],
                                r = t[0] + a,
                                i = t[1] + a,
                                s = t[2] + a;
                            n.push(r, i, s), o += 3
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new iz(r, 3)), this.setAttribute("normal", new iz(i, 3)), this.setAttribute("uv", new iz(s, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return function(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let n = 0, r = e.length; n < r; n++) {
                                let r = e[n];
                                t.shapes.push(r.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
                static fromJSON(e, t) {
                    let n = [];
                    for (let r = 0, i = e.shapes.length; r < i; r++) {
                        let i = t[e.shapes[r]];
                        n.push(i)
                    }
                    return new ci(n, e.curveSegments)
                }
            }
            class cs extends iK {
                constructor(e = 1, t = 32, n = 16, r = 0, i = 2 * Math.PI, s = 0, a = Math.PI) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: r,
                        phiLength: i,
                        thetaStart: s,
                        thetaLength: a
                    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                    let o = Math.min(s + a, Math.PI),
                        l = 0,
                        u = [],
                        c = new rl,
                        h = new rl,
                        d = [],
                        f = [],
                        p = [],
                        g = [];
                    for (let d = 0; d <= n; d++) {
                        let A = [],
                            m = d / n,
                            v = 0;
                        0 === d && 0 === s ? v = .5 / t : d === n && o === Math.PI && (v = -.5 / t);
                        for (let n = 0; n <= t; n++) {
                            let o = n / t;
                            c.x = -e * Math.cos(r + o * i) * Math.sin(s + m * a), c.y = e * Math.cos(s + m * a), c.z = e * Math.sin(r + o * i) * Math.sin(s + m * a), f.push(c.x, c.y, c.z), h.copy(c).normalize(), p.push(h.x, h.y, h.z), g.push(o + v, 1 - m), A.push(l++)
                        }
                        u.push(A)
                    }
                    for (let e = 0; e < n; e++)
                        for (let r = 0; r < t; r++) {
                            let t = u[e][r + 1],
                                i = u[e][r],
                                a = u[e + 1][r],
                                l = u[e + 1][r + 1];
                            (0 !== e || s > 0) && d.push(t, i, l), (e !== n - 1 || o < Math.PI) && d.push(i, a, l)
                        }
                    this.setIndex(d), this.setAttribute("position", new iz(f, 3)), this.setAttribute("normal", new iz(p, 3)), this.setAttribute("uv", new iz(g, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new cs(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
                }
            }
            class ca extends uN {
                constructor(e = 1, t = 0) {
                    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new ca(e.radius, e.detail)
                }
            }
            class co extends iK {
                constructor(e = 1, t = .4, n = 12, r = 48, i = 2 * Math.PI) {
                    super(), this.type = "TorusGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        radialSegments: n,
                        tubularSegments: r,
                        arc: i
                    }, n = Math.floor(n), r = Math.floor(r);
                    let s = [],
                        a = [],
                        o = [],
                        l = [],
                        u = new rl,
                        c = new rl,
                        h = new rl;
                    for (let s = 0; s <= n; s++)
                        for (let d = 0; d <= r; d++) {
                            let f = d / r * i,
                                p = s / n * Math.PI * 2;
                            c.x = (e + t * Math.cos(p)) * Math.cos(f), c.y = (e + t * Math.cos(p)) * Math.sin(f), c.z = t * Math.sin(p), a.push(c.x, c.y, c.z), u.x = e * Math.cos(f), u.y = e * Math.sin(f), h.subVectors(c, u).normalize(), o.push(h.x, h.y, h.z), l.push(d / r), l.push(s / n)
                        }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= r; t++) {
                            let n = (r + 1) * e + t - 1,
                                i = (r + 1) * (e - 1) + t - 1,
                                a = (r + 1) * (e - 1) + t,
                                o = (r + 1) * e + t;
                            s.push(n, i, o), s.push(i, a, o)
                        }
                    this.setIndex(s), this.setAttribute("position", new iz(a, 3)), this.setAttribute("normal", new iz(o, 3)), this.setAttribute("uv", new iz(l, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new co(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
                }
            }
            class cl extends iK {
                constructor(e = 1, t = .4, n = 64, r = 8, i = 2, s = 3) {
                    super(), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        tubularSegments: n,
                        radialSegments: r,
                        p: i,
                        q: s
                    }, n = Math.floor(n), r = Math.floor(r);
                    let a = [],
                        o = [],
                        l = [],
                        u = [],
                        c = new rl,
                        h = new rl,
                        d = new rl,
                        f = new rl,
                        p = new rl,
                        g = new rl,
                        A = new rl;
                    for (let a = 0; a <= n; ++a) {
                        let v = a / n * i * Math.PI * 2;
                        m(v, i, s, e, d), m(v + .01, i, s, e, f), g.subVectors(f, d), A.addVectors(f, d), p.crossVectors(g, A), A.crossVectors(p, g), p.normalize(), A.normalize();
                        for (let e = 0; e <= r; ++e) {
                            let i = e / r * Math.PI * 2,
                                s = -t * Math.cos(i),
                                f = t * Math.sin(i);
                            c.x = d.x + (s * A.x + f * p.x), c.y = d.y + (s * A.y + f * p.y), c.z = d.z + (s * A.z + f * p.z), o.push(c.x, c.y, c.z), h.subVectors(c, d).normalize(), l.push(h.x, h.y, h.z), u.push(a / n), u.push(e / r)
                        }
                    }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= r; t++) {
                            let n = (r + 1) * (e - 1) + (t - 1),
                                i = (r + 1) * e + (t - 1),
                                s = (r + 1) * e + t,
                                o = (r + 1) * (e - 1) + t;
                            a.push(n, i, o), a.push(i, s, o)
                        }

                    function m(e, t, n, r, i) {
                        let s = Math.cos(e),
                            a = Math.sin(e),
                            o = n / t * e,
                            l = Math.cos(o);
                        i.x = r * (2 + l) * .5 * s, i.y = r * (2 + l) * a * .5, i.z = r * Math.sin(o) * .5
                    }
                    this.setIndex(a), this.setAttribute("position", new iz(o, 3)), this.setAttribute("normal", new iz(l, 3)), this.setAttribute("uv", new iz(u, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                static fromJSON(e) {
                    return new cl(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
                }
            }
            class cu extends iK {
                constructor(e = new uS(new rl(-1, -1, 0), new rl(-1, 1, 0), new rl(1, 1, 0)), t = 64, n = 1, r = 8, i = !1) {
                    super(), this.type = "TubeGeometry", this.parameters = {
                        path: e,
                        tubularSegments: t,
                        radius: n,
                        radialSegments: r,
                        closed: i
                    };
                    let s = e.computeFrenetFrames(t, i);
                    this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
                    let a = new rl,
                        o = new rl,
                        l = new nG,
                        u = new rl,
                        c = [],
                        h = [],
                        d = [],
                        f = [];

                    function p(i) {
                        u = e.getPointAt(i / t, u);
                        let l = s.normals[i],
                            d = s.binormals[i];
                        for (let e = 0; e <= r; e++) {
                            let t = e / r * Math.PI * 2,
                                i = Math.sin(t),
                                s = -Math.cos(t);
                            o.x = s * l.x + i * d.x, o.y = s * l.y + i * d.y, o.z = s * l.z + i * d.z, o.normalize(), h.push(o.x, o.y, o.z), a.x = u.x + n * o.x, a.y = u.y + n * o.y, a.z = u.z + n * o.z, c.push(a.x, a.y, a.z)
                        }
                    }(function() {
                        for (let e = 0; e < t; e++) p(e);
                        p(!1 === i ? t : 0),
                            function() {
                                for (let e = 0; e <= t; e++)
                                    for (let n = 0; n <= r; n++) l.x = e / t, l.y = n / r, d.push(l.x, l.y)
                            }(),
                            function() {
                                for (let e = 1; e <= t; e++)
                                    for (let t = 1; t <= r; t++) {
                                        let n = (r + 1) * (e - 1) + (t - 1),
                                            i = (r + 1) * e + (t - 1),
                                            s = (r + 1) * e + t,
                                            a = (r + 1) * (e - 1) + t;
                                        f.push(n, i, a), f.push(i, s, a)
                                    }
                            }()
                    })(), this.setIndex(f), this.setAttribute("position", new iz(c, 3)), this.setAttribute("normal", new iz(h, 3)), this.setAttribute("uv", new iz(d, 2))
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.path = this.parameters.path.toJSON(), e
                }
                static fromJSON(e) {
                    return new cu(new uM[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
                }
            }
            class cc extends iK {
                constructor(e = null) {
                    if (super(), this.type = "WireframeGeometry", this.parameters = {
                            geometry: e
                        }, null !== e) {
                        let t = [],
                            n = new Set,
                            r = new rl,
                            i = new rl;
                        if (null !== e.index) {
                            let s = e.attributes.position,
                                a = e.index,
                                o = e.groups;
                            0 === o.length && (o = [{
                                start: 0,
                                count: a.count,
                                materialIndex: 0
                            }]);
                            for (let e = 0, l = o.length; e < l; ++e) {
                                let l = o[e],
                                    u = l.start,
                                    c = l.count;
                                for (let e = u, o = u + c; e < o; e += 3)
                                    for (let o = 0; o < 3; o++) {
                                        let l = a.getX(e + o),
                                            u = a.getX(e + (o + 1) % 3);
                                        r.fromBufferAttribute(s, l), i.fromBufferAttribute(s, u), !0 === ch(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                                    }
                            }
                        } else {
                            let s = e.attributes.position;
                            for (let e = 0, a = s.count / 3; e < a; e++)
                                for (let a = 0; a < 3; a++) {
                                    let o = 3 * e + a,
                                        l = 3 * e + (a + 1) % 3;
                                    r.fromBufferAttribute(s, o), i.fromBufferAttribute(s, l), !0 === ch(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                                }
                        }
                        this.setAttribute("position", new iz(t, 3))
                    }
                }
                copy(e) {
                    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                }
            }

            function ch(e, t, n) {
                let r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
                    i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
                return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0)
            }
            var cd = Object.freeze({
                __proto__: null,
                BoxGeometry: se,
                CapsuleGeometry: uD,
                CircleGeometry: uL,
                ConeGeometry: uO,
                CylinderGeometry: uP,
                DodecahedronGeometry: uU,
                EdgesGeometry: uz,
                ExtrudeGeometry: u7,
                IcosahedronGeometry: ct,
                LatheGeometry: uR,
                OctahedronGeometry: cn,
                PlaneGeometry: sb,
                PolyhedronGeometry: uN,
                RingGeometry: cr,
                ShapeGeometry: ci,
                SphereGeometry: cs,
                TetrahedronGeometry: ca,
                TorusGeometry: co,
                TorusKnotGeometry: cl,
                TubeGeometry: cu,
                WireframeGeometry: cc
            });
            class cf extends iC {
                constructor(e) {
                    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new i_(0), this.transparent = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
                }
            }
            class cp extends ss {
                constructor(e) {
                    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
                }
            }
            class cg extends iC {
                constructor(e) {
                    super(), this.isMeshStandardMaterial = !0, this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new i_(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new i_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new nG(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rX, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class cA extends cg {
                constructor(e) {
                    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new nG(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return nO(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new i_(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new i_(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new i_(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
                }
                get anisotropy() {
                    return this._anisotropy
                }
                set anisotropy(e) {
                    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                }
                get iridescence() {
                    return this._iridescence
                }
                set iridescence(e) {
                    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
                }
                get dispersion() {
                    return this._dispersion
                }
                set dispersion(e) {
                    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                }
            }
            class cm extends iC {
                constructor(e) {
                    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new i_(16777215), this.specular = new i_(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new i_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new nG(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rX, this.combine = en, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class cv extends iC {
                constructor(e) {
                    super(), this.isMeshToonMaterial = !0, this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new i_(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new i_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new nG(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            class cy extends iC {
                constructor(e) {
                    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new nG(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                }
            }
            class cx extends iC {
                constructor(e) {
                    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new i_(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new i_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new nG(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rX, this.combine = en, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class cE extends iC {
                constructor(e) {
                    super(), this.isMeshMatcapMaterial = !0, this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new i_(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new nG(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class c_ extends lW {
                constructor(e) {
                    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
                }
            }

            function cb(e, t, n) {
                return e && (n || e.constructor !== t) ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e
            }

            function cw(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            }

            function cC(e) {
                let t = e.length,
                    n = Array(t);
                for (let e = 0; e !== t; ++e) n[e] = e;
                return n.sort(function(t, n) {
                    return e[t] - e[n]
                }), n
            }

            function cS(e, t, n) {
                let r = e.length,
                    i = new e.constructor(r);
                for (let s = 0, a = 0; a !== r; ++s) {
                    let r = n[s] * t;
                    for (let n = 0; n !== t; ++n) i[a++] = e[r + n]
                }
                return i
            }

            function cI(e, t, n, r) {
                let i = 1,
                    s = e[0];
                for (; void 0 !== s && void 0 === s[r];) s = e[i++];
                if (void 0 === s) return;
                let a = s[r];
                if (void 0 !== a) {
                    if (Array.isArray(a))
                        do void 0 !== (a = s[r]) && (t.push(s.time), n.push.apply(n, a)), s = e[i++]; while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                        do void 0 !== (a = s[r]) && (t.push(s.time), a.toArray(n, n.length)), s = e[i++]; while (void 0 !== s);
                    else
                        do void 0 !== (a = s[r]) && (t.push(s.time), n.push(a)), s = e[i++]; while (void 0 !== s)
                }
            }
            let cM = {
                convertArray: cb,
                isTypedArray: cw,
                getKeyframeOrder: cC,
                sortedArray: cS,
                flattenJSON: cI,
                subclip: function(e, t, n, r, i = 30) {
                    let s = e.clone();
                    s.name = t;
                    let a = [];
                    for (let e = 0; e < s.tracks.length; ++e) {
                        let t = s.tracks[e],
                            o = t.getValueSize(),
                            l = [],
                            u = [];
                        for (let e = 0; e < t.times.length; ++e) {
                            let s = t.times[e] * i;
                            if (!(s < n) && !(s >= r)) {
                                l.push(t.times[e]);
                                for (let n = 0; n < o; ++n) u.push(t.values[e * o + n])
                            }
                        }
                        0 !== l.length && (t.times = cb(l, t.times.constructor), t.values = cb(u, t.values.constructor), a.push(t))
                    }
                    s.tracks = a;
                    let o = 1 / 0;
                    for (let e = 0; e < s.tracks.length; ++e) o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
                    for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * o);
                    return s.resetDuration(), s
                },
                makeClipAdditive: function(e, t = 0, n = e, r = 30) {
                    r <= 0 && (r = 30);
                    let i = n.tracks.length,
                        s = t / r;
                    for (let t = 0; t < i; ++t) {
                        let r;
                        let i = n.tracks[t],
                            a = i.ValueTypeName;
                        if ("bool" === a || "string" === a) continue;
                        let o = e.tracks.find(function(e) {
                            return e.name === i.name && e.ValueTypeName === a
                        });
                        if (void 0 === o) continue;
                        let l = 0,
                            u = i.getValueSize();
                        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = u / 3);
                        let c = 0,
                            h = o.getValueSize();
                        o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                        let d = i.times.length - 1;
                        if (s <= i.times[0]) {
                            let e = l,
                                t = u - l;
                            r = i.values.slice(e, t)
                        } else if (s >= i.times[d]) {
                            let e = d * u + l,
                                t = e + u - l;
                            r = i.values.slice(e, t)
                        } else {
                            let e = i.createInterpolant(),
                                t = l,
                                n = u - l;
                            e.evaluate(s), r = e.resultBuffer.slice(t, n)
                        }
                        "quaternion" === a && new ro().fromArray(r).normalize().conjugate().toArray(r);
                        let f = o.times.length;
                        for (let e = 0; e < f; ++e) {
                            let t = e * h + c;
                            if ("quaternion" === a) ro.multiplyQuaternionsFlat(o.values, t, r, 0, o.values, t);
                            else {
                                let e = h - 2 * c;
                                for (let n = 0; n < e; ++n) o.values[t + n] -= r[n]
                            }
                        }
                    }
                    return e.blendMode = tU, e
                }
            };
            class cT {
                constructor(e, t, n, r) {
                    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    let t = this.parameterPositions,
                        n = this._cachedIndex,
                        r = t[n],
                        i = t[n - 1];
                    e: {
                        t: {
                            let s;n: {
                                r: if (!(e < r)) {
                                    for (let s = n + 2;;) {
                                        if (void 0 === r) {
                                            if (e < i) break r;
                                            return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                        }
                                        if (n === s) break;
                                        if (i = r, e < (r = t[++n])) break t
                                    }
                                    s = t.length;
                                    break n
                                }if (!(e >= i)) {
                                    let a = t[1];
                                    e < a && (n = 2, i = a);
                                    for (let s = n - 2;;) {
                                        if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                                        if (n === s) break;
                                        if (r = i, e >= (i = t[--n - 1])) break t
                                    }
                                    s = n, n = 0;
                                    break n
                                }
                                break e
                            }
                            for (; n < s;) {
                                let r = n + s >>> 1;
                                e < t[r] ? s = r : n = r + 1
                            }
                            if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (void 0 === r) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, e, r)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    let t = this.resultBuffer,
                        n = this.sampleValues,
                        r = this.valueSize,
                        i = e * r;
                    for (let e = 0; e !== r; ++e) t[e] = n[i + e];
                    return t
                }
                interpolate_() {
                    throw Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class cB extends cT {
                constructor(e, t, n, r) {
                    super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: tL,
                        endingEnd: tL
                    }
                }
                intervalChanged_(e, t, n) {
                    let r = this.parameterPositions,
                        i = e - 2,
                        s = e + 1,
                        a = r[i],
                        o = r[s];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case tP:
                            i = e, a = 2 * t - n;
                            break;
                        case tO:
                            i = r.length - 2, a = t + r[i] - r[i + 1];
                            break;
                        default:
                            i = e, a = n
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                        case tP:
                            s = e, o = 2 * n - t;
                            break;
                        case tO:
                            s = 1, o = n + r[1] - r[0];
                            break;
                        default:
                            s = e - 1, o = t
                    }
                    let l = (n - t) * .5,
                        u = this.valueSize;
                    this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = i * u, this._offsetNext = s * u
                }
                interpolate_(e, t, n, r) {
                    let i = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = e * a,
                        l = o - a,
                        u = this._offsetPrev,
                        c = this._offsetNext,
                        h = this._weightPrev,
                        d = this._weightNext,
                        f = (n - t) / (r - t),
                        p = f * f,
                        g = p * f,
                        A = -h * g + 2 * h * p - h * f,
                        m = (1 + h) * g + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1,
                        v = (-1 - d) * g + (1.5 + d) * p + .5 * f,
                        y = d * g - d * p;
                    for (let e = 0; e !== a; ++e) i[e] = A * s[u + e] + m * s[l + e] + v * s[o + e] + y * s[c + e];
                    return i
                }
            }
            class cR extends cT {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    let i = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = e * a,
                        l = o - a,
                        u = (n - t) / (r - t),
                        c = 1 - u;
                    for (let e = 0; e !== a; ++e) i[e] = s[l + e] * c + s[o + e] * u;
                    return i
                }
            }
            class cD extends cT {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class cL {
                constructor(e, t, n, r) {
                    if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e, this.times = cb(t, this.TimeBufferType), this.values = cb(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    let t;
                    let n = e.constructor;
                    if (n.toJSON !== this.toJSON) t = n.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: cb(e.times, Array),
                            values: cb(e.values, Array)
                        };
                        let n = e.getInterpolation();
                        n !== e.DefaultInterpolation && (t.interpolation = n)
                    }
                    return t.type = e.ValueTypeName, t
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new cD(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new cR(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new cB(this.times, this.values, this.getValueSize(), e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                        case tB:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case tR:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case tD:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        let t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                            else throw Error(t)
                        }
                        return console.warn("THREE.KeyframeTrack:", t), this
                    }
                    return this.createInterpolant = t, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return tB;
                        case this.InterpolantFactoryMethodLinear:
                            return tR;
                        case this.InterpolantFactoryMethodSmooth:
                            return tD
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        let t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n) t[n] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        let t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e
                    }
                    return this
                }
                trim(e, t) {
                    let n = this.times,
                        r = n.length,
                        i = 0,
                        s = r - 1;
                    for (; i !== r && n[i] < e;) ++i;
                    for (; - 1 !== s && n[s] > t;) --s;
                    if (++s, 0 !== i || s !== r) {
                        i >= s && (i = (s = Math.max(s, 1)) - 1);
                        let e = this.getValueSize();
                        this.times = n.slice(i, s), this.values = this.values.slice(i * e, s * e)
                    }
                    return this
                }
                validate() {
                    let e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    let n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    let s = null;
                    for (let t = 0; t !== i; t++) {
                        let r = n[t];
                        if ("number" == typeof r && isNaN(r)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r), e = !1;
                            break
                        }
                        if (null !== s && s > r) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, s), e = !1;
                            break
                        }
                        s = r
                    }
                    if (void 0 !== r && cw(r))
                        for (let t = 0, n = r.length; t !== n; ++t) {
                            let n = r[t];
                            if (isNaN(n)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    let e = this.times.slice(),
                        t = this.values.slice(),
                        n = this.getValueSize(),
                        r = this.getInterpolation() === tD,
                        i = e.length - 1,
                        s = 1;
                    for (let a = 1; a < i; ++a) {
                        let i = !1,
                            o = e[a];
                        if (o !== e[a + 1] && (1 !== a || o !== e[0])) {
                            if (r) i = !0;
                            else {
                                let e = a * n,
                                    r = e - n,
                                    s = e + n;
                                for (let a = 0; a !== n; ++a) {
                                    let n = t[e + a];
                                    if (n !== t[r + a] || n !== t[s + a]) {
                                        i = !0;
                                        break
                                    }
                                }
                            }
                        }
                        if (i) {
                            if (a !== s) {
                                e[s] = e[a];
                                let r = a * n,
                                    i = s * n;
                                for (let e = 0; e !== n; ++e) t[i + e] = t[r + e]
                            }++s
                        }
                    }
                    if (i > 0) {
                        e[s] = e[i];
                        for (let e = i * n, r = s * n, a = 0; a !== n; ++a) t[r + a] = t[e + a];
                        ++s
                    }
                    return s !== e.length ? (this.times = e.slice(0, s), this.values = t.slice(0, s * n)) : (this.times = e, this.values = t), this
                }
                clone() {
                    let e = this.times.slice(),
                        t = this.values.slice(),
                        n = new this.constructor(this.name, e, t);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }
            cL.prototype.TimeBufferType = Float32Array, cL.prototype.ValueBufferType = Float32Array, cL.prototype.DefaultInterpolation = tR;
            class cP extends cL {
                constructor(e, t, n) {
                    super(e, t, n)
                }
            }
            cP.prototype.ValueTypeName = "bool", cP.prototype.ValueBufferType = Array, cP.prototype.DefaultInterpolation = tB, cP.prototype.InterpolantFactoryMethodLinear = void 0, cP.prototype.InterpolantFactoryMethodSmooth = void 0;
            class cO extends cL {}
            cO.prototype.ValueTypeName = "color";
            class cN extends cL {}
            cN.prototype.ValueTypeName = "number";
            class cU extends cT {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    let i = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = (n - t) / (r - t),
                        l = e * a;
                    for (let e = l + a; l !== e; l += 4) ro.slerpFlat(i, 0, s, l - a, s, l, o);
                    return i
                }
            }
            class cF extends cL {
                InterpolantFactoryMethodLinear(e) {
                    return new cU(this.times, this.values, this.getValueSize(), e)
                }
            }
            cF.prototype.ValueTypeName = "quaternion", cF.prototype.InterpolantFactoryMethodSmooth = void 0;
            class ck extends cL {
                constructor(e, t, n) {
                    super(e, t, n)
                }
            }
            ck.prototype.ValueTypeName = "string", ck.prototype.ValueBufferType = Array, ck.prototype.DefaultInterpolation = tB, ck.prototype.InterpolantFactoryMethodLinear = void 0, ck.prototype.InterpolantFactoryMethodSmooth = void 0;
            class cQ extends cL {}
            cQ.prototype.ValueTypeName = "vector";
            class cG {
                constructor(e = "", t = -1, n = [], r = tN) {
                    this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = nP(), this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    let t = [],
                        n = e.tracks,
                        r = 1 / (e.fps || 1);
                    for (let e = 0, i = n.length; e !== i; ++e) t.push((function(e) {
                        if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        let t = function(e) {
                            switch (e.toLowerCase()) {
                                case "scalar":
                                case "double":
                                case "float":
                                case "number":
                                case "integer":
                                    return cN;
                                case "vector":
                                case "vector2":
                                case "vector3":
                                case "vector4":
                                    return cQ;
                                case "color":
                                    return cO;
                                case "quaternion":
                                    return cF;
                                case "bool":
                                case "boolean":
                                    return cP;
                                case "string":
                                    return ck
                            }
                            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                        }(e.type);
                        if (void 0 === e.times) {
                            let t = [],
                                n = [];
                            cI(e.keys, t, n, "value"), e.times = t, e.values = n
                        }
                        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
                    })(n[e]).scale(r));
                    let i = new this(e.name, e.duration, t, e.blendMode);
                    return i.uuid = e.uuid, i
                }
                static toJSON(e) {
                    let t = [],
                        n = e.tracks,
                        r = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let e = 0, r = n.length; e !== r; ++e) t.push(cL.toJSON(n[e]));
                    return r
                }
                static CreateFromMorphTargetSequence(e, t, n, r) {
                    let i = t.length,
                        s = [];
                    for (let e = 0; e < i; e++) {
                        let a = [],
                            o = [];
                        a.push((e + i - 1) % i, e, (e + 1) % i), o.push(0, 1, 0);
                        let l = cC(a);
                        a = cS(a, 1, l), o = cS(o, 1, l), r || 0 !== a[0] || (a.push(i), o.push(o[0])), s.push(new cN(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / n))
                    }
                    return new this(e, -1, s)
                }
                static findByName(e, t) {
                    let n = e;
                    Array.isArray(e) || (n = e.geometry && e.geometry.animations || e.animations);
                    for (let e = 0; e < n.length; e++)
                        if (n[e].name === t) return n[e];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, n) {
                    let r = {},
                        i = /^([\w-]*?)([\d]+)$/;
                    for (let t = 0, n = e.length; t < n; t++) {
                        let n = e[t],
                            s = n.name.match(i);
                        if (s && s.length > 1) {
                            let e = s[1],
                                t = r[e];
                            t || (r[e] = t = []), t.push(n)
                        }
                    }
                    let s = [];
                    for (let e in r) s.push(this.CreateFromMorphTargetSequence(e, r[e], t, n));
                    return s
                }
                static parseAnimation(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    let n = function(e, t, n, r, i) {
                            if (0 !== n.length) {
                                let s = [],
                                    a = [];
                                cI(n, s, a, r), 0 !== s.length && i.push(new e(t, s, a))
                            }
                        },
                        r = [],
                        i = e.name || "default",
                        s = e.fps || 30,
                        a = e.blendMode,
                        o = e.length || -1,
                        l = e.hierarchy || [];
                    for (let e = 0; e < l.length; e++) {
                        let i = l[e].keys;
                        if (i && 0 !== i.length) {
                            if (i[0].morphTargets) {
                                let e;
                                let t = {};
                                for (e = 0; e < i.length; e++)
                                    if (i[e].morphTargets)
                                        for (let n = 0; n < i[e].morphTargets.length; n++) t[i[e].morphTargets[n]] = -1;
                                for (let n in t) {
                                    let t = [],
                                        s = [];
                                    for (let r = 0; r !== i[e].morphTargets.length; ++r) {
                                        let r = i[e];
                                        t.push(r.time), s.push(r.morphTarget === n ? 1 : 0)
                                    }
                                    r.push(new cN(".morphTargetInfluence[" + n + "]", t, s))
                                }
                                o = t.length * s
                            } else {
                                let s = ".bones[" + t[e].name + "]";
                                n(cQ, s + ".position", i, "pos", r), n(cF, s + ".quaternion", i, "rot", r), n(cQ, s + ".scale", i, "scl", r)
                            }
                        }
                    }
                    return 0 === r.length ? null : new this(i, o, r, a)
                }
                resetDuration() {
                    let e = this.tracks,
                        t = 0;
                    for (let n = 0, r = e.length; n !== r; ++n) {
                        let e = this.tracks[n];
                        t = Math.max(t, e.times[e.times.length - 1])
                    }
                    return this.duration = t, this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
                clone() {
                    let e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new this.constructor(this.name, this.duration, e, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }
            let cz = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e) {
                    if (!1 !== this.enabled) return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class cH {
                constructor(e, t, n) {
                    let r;
                    let i = this,
                        s = !1,
                        a = 0,
                        o = 0,
                        l = [];
                    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                        o++, !1 === s && void 0 !== i.onStart && i.onStart(e, a, o), s = !0
                    }, this.itemEnd = function(e) {
                        a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad())
                    }, this.itemError = function(e) {
                        void 0 !== i.onError && i.onError(e)
                    }, this.resolveURL = function(e) {
                        return r ? r(e) : e
                    }, this.setURLModifier = function(e) {
                        return r = e, this
                    }, this.addHandler = function(e, t) {
                        return l.push(e, t), this
                    }, this.removeHandler = function(e) {
                        let t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2), this
                    }, this.getHandler = function(e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            let n = l[t],
                                r = l[t + 1];
                            if (n.global && (n.lastIndex = 0), n.test(e)) return r
                        }
                        return null
                    }
                }
            }
            let cV = new cH;
            class cj {
                constructor(e) {
                    this.manager = void 0 !== e ? e : cV, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    let n = this;
                    return new Promise(function(r, i) {
                        n.load(e, r, t, i)
                    })
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e, this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e, this
                }
                setPath(e) {
                    return this.path = e, this
                }
                setResourcePath(e) {
                    return this.resourcePath = e, this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e, this
                }
            }
            cj.DEFAULT_MATERIAL_NAME = "__DEFAULT";
            let cW = {};
            class cY extends Error {
                constructor(e, t) {
                    super(e), this.response = t
                }
            }
            class cX extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let i = cz.get(e);
                    if (void 0 !== i) return this.manager.itemStart(e), setTimeout(() => {
                        t && t(i), this.manager.itemEnd(e)
                    }, 0), i;
                    if (void 0 !== cW[e]) {
                        cW[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: r
                        });
                        return
                    }
                    cW[e] = [], cW[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: r
                    });
                    let s = new Request(e, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin"
                        }),
                        a = this.mimeType,
                        o = this.responseType;
                    fetch(s).then(t => {
                        if (200 === t.status || 0 === t.status) {
                            if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                            let n = cW[e],
                                r = t.body.getReader(),
                                i = t.headers.get("X-File-Size") || t.headers.get("Content-Length"),
                                s = i ? parseInt(i) : 0,
                                a = 0 !== s,
                                o = 0;
                            return new Response(new ReadableStream({
                                start(e) {
                                    (function t() {
                                        r.read().then(({
                                            done: r,
                                            value: i
                                        }) => {
                                            if (r) e.close();
                                            else {
                                                let r = new ProgressEvent("progress", {
                                                    lengthComputable: a,
                                                    loaded: o += i.byteLength,
                                                    total: s
                                                });
                                                for (let e = 0, t = n.length; e < t; e++) {
                                                    let t = n[e];
                                                    t.onProgress && t.onProgress(r)
                                                }
                                                e.enqueue(i), t()
                                            }
                                        }, t => {
                                            e.error(t)
                                        })
                                    })()
                                }
                            }))
                        }
                        throw new cY(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t)
                    }).then(e => {
                        switch (o) {
                            case "arraybuffer":
                                return e.arrayBuffer();
                            case "blob":
                                return e.blob();
                            case "document":
                                return e.text().then(e => new DOMParser().parseFromString(e, a));
                            case "json":
                                return e.json();
                            default:
                                if (void 0 === a) return e.text(); {
                                    let t = /charset="?([^;"\s]*)"?/i.exec(a),
                                        n = new TextDecoder(t && t[1] ? t[1].toLowerCase() : void 0);
                                    return e.arrayBuffer().then(e => n.decode(e))
                                }
                        }
                    }).then(t => {
                        cz.add(e, t);
                        let n = cW[e];
                        delete cW[e];
                        for (let e = 0, r = n.length; e < r; e++) {
                            let r = n[e];
                            r.onLoad && r.onLoad(t)
                        }
                    }).catch(t => {
                        let n = cW[e];
                        if (void 0 === n) throw this.manager.itemError(e), t;
                        delete cW[e];
                        for (let e = 0, r = n.length; e < r; e++) {
                            let r = n[e];
                            r.onError && r.onError(t)
                        }
                        this.manager.itemError(e)
                    }).finally(() => {
                        this.manager.itemEnd(e)
                    }), this.manager.itemStart(e)
                }
                setResponseType(e) {
                    return this.responseType = e, this
                }
                setMimeType(e) {
                    return this.mimeType = e, this
                }
            }
            class cq extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        s = new cX(this.manager);
                    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                        }
                    }, n, r)
                }
                parse(e) {
                    let t = [];
                    for (let n = 0; n < e.length; n++) {
                        let r = cG.parse(e[n]);
                        t.push(r)
                    }
                    return t
                }
            }
            class cK extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        s = [],
                        a = new us,
                        o = new cX(this.manager);
                    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(i.withCredentials);
                    let l = 0;
                    if (Array.isArray(e))
                        for (let u = 0, c = e.length; u < c; ++u) ! function(u) {
                            o.load(e[u], function(e) {
                                let n = i.parse(e, !0);
                                s[u] = {
                                    width: n.width,
                                    height: n.height,
                                    format: n.format,
                                    mipmaps: n.mipmaps
                                }, 6 === (l += 1) && (1 === n.mipmapCount && (a.minFilter = eT), a.image = s, a.format = n.format, a.needsUpdate = !0, t && t(a))
                            }, n, r)
                        }(u);
                    else o.load(e, function(e) {
                        let n = i.parse(e, !0);
                        if (n.isCubemap) {
                            let e = n.mipmaps.length / n.mipmapCount;
                            for (let t = 0; t < e; t++) {
                                s[t] = {
                                    mipmaps: []
                                };
                                for (let e = 0; e < n.mipmapCount; e++) s[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), s[t].format = n.format, s[t].width = n.width, s[t].height = n.height
                            }
                            a.image = s
                        } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = eT), a.format = n.format, a.needsUpdate = !0, t && t(a)
                    }, n, r);
                    return a
                }
            }
            class cJ extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let i = this,
                        s = cz.get(e);
                    if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function() {
                        t && t(s), i.manager.itemEnd(e)
                    }, 0), s;
                    let a = nY("img");

                    function o() {
                        u(), cz.add(e, this), t && t(this), i.manager.itemEnd(e)
                    }

                    function l(t) {
                        u(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    }

                    function u() {
                        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                    }
                    return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a
                }
            }
            class cZ extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = new sd;
                    i.colorSpace = tX;
                    let s = new cJ(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    let a = 0;
                    for (let n = 0; n < e.length; ++n) ! function(n) {
                        s.load(e[n], function(e) {
                            i.images[n] = e, 6 == ++a && (i.needsUpdate = !0, t && t(i))
                        }, void 0, r)
                    }(n);
                    return i
                }
            }
            class c$ extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        s = new lg,
                        a = new cX(this.manager);
                    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(i.withCredentials), a.load(e, function(e) {
                        let n;
                        try {
                            n = i.parse(e)
                        } catch (e) {
                            if (void 0 !== r) r(e);
                            else {
                                console.error(e);
                                return
                            }
                        }
                        void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : e_, s.wrapT = void 0 !== n.wrapT ? n.wrapT : e_, s.magFilter = void 0 !== n.magFilter ? n.magFilter : eT, s.minFilter = void 0 !== n.minFilter ? n.minFilter : eT, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace && (s.colorSpace = n.colorSpace), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = eD), 1 === n.mipmapCount && (s.minFilter = eT), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, t && t(s, n)
                    }, n, r), s
                }
            }
            class c0 extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = new n7,
                        s = new cJ(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function(e) {
                        i.image = e, i.needsUpdate = !0, void 0 !== t && t(i)
                    }, n, r), i
                }
            }
            class c1 extends it {
                constructor(e, t = 1) {
                    super(), this.isLight = !0, this.type = "Light", this.color = new i_(e), this.intensity = t
                }
                dispose() {}
                copy(e, t) {
                    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t
                }
            }
            class c2 extends c1 {
                constructor(e, t, n) {
                    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(it.DEFAULT_UP), this.updateMatrix(), this.groundColor = new i_(t)
                }
                copy(e, t) {
                    return super.copy(e, t), this.groundColor.copy(e.groundColor), this
                }
            }
            let c3 = new rF,
                c4 = new rl,
                c5 = new rl;
            class c6 {
                constructor(e) {
                    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new nG(512, 512), this.map = null, this.mapPass = null, this.matrix = new rF, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new sx, this._frameExtents = new nG(1, 1), this._viewportCount = 1, this._viewports = [new re(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    let t = this.camera,
                        n = this.matrix;
                    c4.setFromMatrixPosition(e.matrixWorld), t.position.copy(c4), c5.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(c5), t.updateMatrixWorld(), c3.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(c3), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(c3)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                toJSON() {
                    let e = {};
                    return 1 !== this.intensity && (e.intensity = this.intensity), 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }
            class c8 extends c6 {
                constructor() {
                    super(new sc(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                }
                updateMatrices(e) {
                    let t = this.camera,
                        n = 2 * nL * e.angle * this.focus,
                        r = this.mapSize.width / this.mapSize.height,
                        i = e.distance || t.far;
                    (n !== t.fov || r !== t.aspect || i !== t.far) && (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e), this.focus = e.focus, this
                }
            }
            class c9 extends c1 {
                constructor(e, t, n = 0, r = Math.PI / 3, i = 0, s = 2) {
                    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(it.DEFAULT_UP), this.updateMatrix(), this.target = new it, this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.map = null, this.shadow = new c8
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            let c7 = new rF,
                he = new rl,
                ht = new rl;
            class hn extends c6 {
                constructor() {
                    super(new sc(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new nG(4, 2), this._viewportCount = 6, this._viewports = [new re(2, 1, 1, 1), new re(0, 1, 1, 1), new re(3, 1, 1, 1), new re(1, 1, 1, 1), new re(3, 0, 1, 1), new re(1, 0, 1, 1)], this._cubeDirections = [new rl(1, 0, 0), new rl(-1, 0, 0), new rl(0, 0, 1), new rl(0, 0, -1), new rl(0, 1, 0), new rl(0, -1, 0)], this._cubeUps = [new rl(0, 1, 0), new rl(0, 1, 0), new rl(0, 1, 0), new rl(0, 1, 0), new rl(0, 0, 1), new rl(0, 0, -1)]
                }
                updateMatrices(e, t = 0) {
                    let n = this.camera,
                        r = this.matrix,
                        i = e.distance || n.far;
                    i !== n.far && (n.far = i, n.updateProjectionMatrix()), he.setFromMatrixPosition(e.matrixWorld), n.position.copy(he), ht.copy(n.position), ht.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(ht), n.updateMatrixWorld(), r.makeTranslation(-he.x, -he.y, -he.z), c7.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(c7)
                }
            }
            class hr extends c1 {
                constructor(e, t, n = 0, r = 2) {
                    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new hn
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }
            class hi extends c6 {
                constructor() {
                    super(new sN(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                }
            }
            class hs extends c1 {
                constructor(e, t) {
                    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(it.DEFAULT_UP), this.updateMatrix(), this.target = new it, this.shadow = new hi
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            class ha extends c1 {
                constructor(e, t) {
                    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
                }
            }
            class ho extends c1 {
                constructor(e, t, n = 10, r = 10) {
                    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r
                }
                get power() {
                    return this.intensity * this.width * this.height * Math.PI
                }
                set power(e) {
                    this.intensity = e / (this.width * this.height * Math.PI)
                }
                copy(e) {
                    return super.copy(e), this.width = e.width, this.height = e.height, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }
            class hl {
                constructor() {
                    this.isSphericalHarmonics3 = !0, this.coefficients = [];
                    for (let e = 0; e < 9; e++) this.coefficients.push(new rl)
                }
                set(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this
                }
                zero() {
                    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this
                }
                getAt(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z,
                        s = this.coefficients;
                    return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * r), t.addScaledVector(s[2], .488603 * i), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * r * 1.092548), t.addScaledVector(s[5], r * i * 1.092548), t.addScaledVector(s[6], .315392 * (3 * i * i - 1)), t.addScaledVector(s[7], n * i * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - r * r)), t
                }
                getIrradianceAt(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z,
                        s = this.coefficients;
                    return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * r), t.addScaledVector(s[2], 1.023328 * i), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * r), t.addScaledVector(s[5], .858086 * r * i), t.addScaledVector(s[6], .743125 * i * i - .247708), t.addScaledVector(s[7], .858086 * n * i), t.addScaledVector(s[8], .429043 * (n * n - r * r)), t
                }
                add(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this
                }
                addScaledSH(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                    return this
                }
                scale(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this
                }
                lerp(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                    return this
                }
                equals(e) {
                    for (let t = 0; t < 9; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                    return !0
                }
                copy(e) {
                    return this.set(e.coefficients)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                fromArray(e, t = 0) {
                    let n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                    return this
                }
                toArray(e = [], t = 0) {
                    let n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                    return e
                }
                static getBasisAt(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z;
                    t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
                }
            }
            class hu extends c1 {
                constructor(e = new hl, t = 1) {
                    super(void 0, t), this.isLightProbe = !0, this.sh = e
                }
                copy(e) {
                    return super.copy(e), this.sh.copy(e.sh), this
                }
                fromJSON(e) {
                    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.sh = this.sh.toArray(), t
                }
            }
            class hc extends cj {
                constructor(e) {
                    super(e), this.textures = {}
                }
                load(e, t, n, r) {
                    let i = this,
                        s = new cX(i.manager);
                    s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                        }
                    }, n, r)
                }
                parse(e) {
                    let t = this.textures;

                    function n(e) {
                        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                    }
                    let r = this.createMaterialFromType(e.type);
                    if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = new i_().setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.dispersion && (r.dispersion = e.dispersion), void 0 !== e.iridescence && (r.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.anisotropy && (r.anisotropy = e.anisotropy), void 0 !== e.anisotropyRotation && (r.anisotropyRotation = e.anisotropyRotation), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.alphaHash && (r.alphaHash = e.alphaHash), void 0 !== e.depthFunc && (r.depthFunc = e.depthFunc), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.blendSrc && (r.blendSrc = e.blendSrc), void 0 !== e.blendDst && (r.blendDst = e.blendDst), void 0 !== e.blendEquation && (r.blendEquation = e.blendEquation), void 0 !== e.blendSrcAlpha && (r.blendSrcAlpha = e.blendSrcAlpha), void 0 !== e.blendDstAlpha && (r.blendDstAlpha = e.blendDstAlpha), void 0 !== e.blendEquationAlpha && (r.blendEquationAlpha = e.blendEquationAlpha), void 0 !== e.blendColor && void 0 !== r.blendColor && r.blendColor.setHex(e.blendColor), void 0 !== e.blendAlpha && (r.blendAlpha = e.blendAlpha), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), void 0 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.forceSinglePass && (r.forceSinglePass = e.forceSinglePass), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                        for (let t in e.uniforms) {
                            let i = e.uniforms[t];
                            switch (r.uniforms[t] = {}, i.type) {
                                case "t":
                                    r.uniforms[t].value = n(i.value);
                                    break;
                                case "c":
                                    r.uniforms[t].value = new i_().setHex(i.value);
                                    break;
                                case "v2":
                                    r.uniforms[t].value = new nG().fromArray(i.value);
                                    break;
                                case "v3":
                                    r.uniforms[t].value = new rl().fromArray(i.value);
                                    break;
                                case "v4":
                                    r.uniforms[t].value = new re().fromArray(i.value);
                                    break;
                                case "m3":
                                    r.uniforms[t].value = new nz().fromArray(i.value);
                                    break;
                                case "m4":
                                    r.uniforms[t].value = new rF().fromArray(i.value);
                                    break;
                                default:
                                    r.uniforms[t].value = i.value
                            }
                        }
                    if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.glslVersion && (r.glslVersion = e.glslVersion), void 0 !== e.extensions)
                        for (let t in e.extensions) r.extensions[t] = e.extensions[t];
                    if (void 0 !== e.lights && (r.lights = e.lights), void 0 !== e.clipping && (r.clipping = e.clipping), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        let t = e.normalScale;
                        !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = new nG().fromArray(t)
                    }
                    return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapRotation && r.envMapRotation.fromArray(e.envMapRotation), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = new nG().fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (r.iridescenceMap = n(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), void 0 !== e.anisotropyMap && (r.anisotropyMap = n(e.anisotropyMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r
                }
                setTextures(e) {
                    return this.textures = e, this
                }
                createMaterialFromType(e) {
                    return hc.createMaterialFromType(e)
                }
                static createMaterialFromType(e) {
                    return new({
                        ShadowMaterial: cf,
                        SpriteMaterial: oK,
                        RawShaderMaterial: cp,
                        ShaderMaterial: ss,
                        PointsMaterial: l6,
                        MeshPhysicalMaterial: cA,
                        MeshStandardMaterial: cg,
                        MeshPhongMaterial: cm,
                        MeshToonMaterial: cv,
                        MeshNormalMaterial: cy,
                        MeshLambertMaterial: cx,
                        MeshDepthMaterial: o_,
                        MeshDistanceMaterial: ob,
                        MeshBasicMaterial: iS,
                        MeshMatcapMaterial: cE,
                        LineDashedMaterial: c_,
                        LineBasicMaterial: lW,
                        Material: iC
                    })[e]
                }
            }
            class hh {
                static decodeText(e) {
                    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), "undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
                    let t = "";
                    for (let n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (e) {
                        return t
                    }
                }
                static extractUrlBase(e) {
                    let t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.slice(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e)) ? e : t + e
                }
            }
            class hd extends iK {
                constructor() {
                    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(e) {
                    return super.copy(e), this.instanceCount = e.instanceCount, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                }
            }
            class hf extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        s = new cX(i.manager);
                    s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                        }
                    }, n, r)
                }
                parse(e) {
                    let t = {},
                        n = {};

                    function r(e, r) {
                        if (void 0 !== t[r]) return t[r];
                        let i = e.interleavedBuffers[r],
                            s = function(e, t) {
                                if (void 0 !== n[t]) return n[t];
                                let r = new Uint32Array(e.arrayBuffers[t]).buffer;
                                return n[t] = r, r
                            }(e, i.buffer),
                            a = new oY(nW(i.type, s), i.stride);
                        return a.uuid = i.uuid, t[r] = a, a
                    }
                    let i = e.isInstancedBufferGeometry ? new hd : new iK,
                        s = e.data.index;
                    if (void 0 !== s) {
                        let e = nW(s.type, s.array);
                        i.setIndex(new iL(e, 1))
                    }
                    let a = e.data.attributes;
                    for (let t in a) {
                        let n;
                        let s = a[t];
                        if (s.isInterleavedBufferAttribute) n = new oq(r(e.data, s.data), s.itemSize, s.offset, s.normalized);
                        else {
                            let e = nW(s.type, s.array);
                            n = new(s.isInstancedBufferAttribute ? ly : iL)(e, s.itemSize, s.normalized)
                        }
                        void 0 !== s.name && (n.name = s.name), void 0 !== s.usage && n.setUsage(s.usage), i.setAttribute(t, n)
                    }
                    let o = e.data.morphAttributes;
                    if (o)
                        for (let t in o) {
                            let n = o[t],
                                s = [];
                            for (let t = 0, i = n.length; t < i; t++) {
                                let i;
                                let a = n[t];
                                i = a.isInterleavedBufferAttribute ? new oq(r(e.data, a.data), a.itemSize, a.offset, a.normalized) : new iL(nW(a.type, a.array), a.itemSize, a.normalized), void 0 !== a.name && (i.name = a.name), s.push(i)
                            }
                            i.morphAttributes[t] = s
                        }
                    e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
                    let l = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== l)
                        for (let e = 0, t = l.length; e !== t; ++e) {
                            let t = l[e];
                            i.addGroup(t.start, t.count, t.materialIndex)
                        }
                    let u = e.data.boundingSphere;
                    if (void 0 !== u) {
                        let e = new rl;
                        void 0 !== u.center && e.fromArray(u.center), i.boundingSphere = new rT(e, u.radius)
                    }
                    return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i
                }
            }
            class hp extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        s = "" === this.path ? hh.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || s;
                    let a = new cX(this.manager);
                    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(n) {
                        let s = null;
                        try {
                            s = JSON.parse(n)
                        } catch (t) {
                            void 0 !== r && r(t), console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message);
                            return
                        }
                        let a = s.metadata;
                        if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) {
                            void 0 !== r && r(Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                            return
                        }
                        i.parse(s, t)
                    }, n, r)
                }
                async loadAsync(e, t) {
                    let n = "" === this.path ? hh.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || n;
                    let r = new cX(this.manager);
                    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
                    let i = JSON.parse(await r.loadAsync(e, t)),
                        s = i.metadata;
                    if (void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase()) throw Error("THREE.ObjectLoader: Can't load " + e);
                    return await this.parseAsync(i)
                }
                parse(e, t) {
                    let n = this.parseAnimations(e.animations),
                        r = this.parseShapes(e.shapes),
                        i = this.parseGeometries(e.geometries, r),
                        s = this.parseImages(e.images, function() {
                            void 0 !== t && t(l)
                        }),
                        a = this.parseTextures(e.textures, s),
                        o = this.parseMaterials(e.materials, a),
                        l = this.parseObject(e.object, i, o, a, n),
                        u = this.parseSkeletons(e.skeletons, l);
                    if (this.bindSkeletons(l, u), this.bindLightTargets(l), void 0 !== t) {
                        let e = !1;
                        for (let t in s)
                            if (s[t].data instanceof HTMLImageElement) {
                                e = !0;
                                break
                            }!1 === e && t(l)
                    }
                    return l
                }
                async parseAsync(e) {
                    let t = this.parseAnimations(e.animations),
                        n = this.parseShapes(e.shapes),
                        r = this.parseGeometries(e.geometries, n),
                        i = await this.parseImagesAsync(e.images),
                        s = this.parseTextures(e.textures, i),
                        a = this.parseMaterials(e.materials, s),
                        o = this.parseObject(e.object, r, a, s, t),
                        l = this.parseSkeletons(e.skeletons, o);
                    return this.bindSkeletons(o, l), this.bindLightTargets(o), o
                }
                parseShapes(e) {
                    let t = {};
                    if (void 0 !== e)
                        for (let n = 0, r = e.length; n < r; n++) {
                            let r = new uH().fromJSON(e[n]);
                            t[r.uuid] = r
                        }
                    return t
                }
                parseSkeletons(e, t) {
                    let n = {},
                        r = {};
                    if (t.traverse(function(e) {
                            e.isBone && (r[e.uuid] = e)
                        }), void 0 !== e)
                        for (let t = 0, i = e.length; t < i; t++) {
                            let i = new lv().fromJSON(e[t], r);
                            n[i.uuid] = i
                        }
                    return n
                }
                parseGeometries(e, t) {
                    let n = {};
                    if (void 0 !== e) {
                        let r = new hf;
                        for (let i = 0, s = e.length; i < s; i++) {
                            let s;
                            let a = e[i];
                            switch (a.type) {
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    s = r.parse(a);
                                    break;
                                default:
                                    a.type in cd ? s = cd[a.type].fromJSON(a, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
                            }
                            s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s
                        }
                    }
                    return n
                }
                parseMaterials(e, t) {
                    let n = {},
                        r = {};
                    if (void 0 !== e) {
                        let i = new hc;
                        i.setTextures(t);
                        for (let t = 0, s = e.length; t < s; t++) {
                            let s = e[t];
                            void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                        }
                    }
                    return r
                }
                parseAnimations(e) {
                    let t = {};
                    if (void 0 !== e)
                        for (let n = 0; n < e.length; n++) {
                            let r = e[n],
                                i = cG.parse(r);
                            t[i.uuid] = i
                        }
                    return t
                }
                parseImages(e, t) {
                    let n;
                    let r = this,
                        i = {};

                    function s(e) {
                        if ("string" == typeof e) {
                            var t;
                            return t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : r.resourcePath + e, r.manager.itemStart(t), n.load(t, function() {
                                r.manager.itemEnd(t)
                            }, void 0, function() {
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            })
                        }
                        return e.data ? {
                            data: nW(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        (n = new cJ(new cH(t))).setCrossOrigin(this.crossOrigin);
                        for (let t = 0, n = e.length; t < n; t++) {
                            let n = e[t],
                                r = n.url;
                            if (Array.isArray(r)) {
                                let e = [];
                                for (let t = 0, n = r.length; t < n; t++) {
                                    let n = s(r[t]);
                                    null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new lg(n.data, n.width, n.height)))
                                }
                                i[n.uuid] = new n6(e)
                            } else {
                                let e = s(n.url);
                                i[n.uuid] = new n6(e)
                            }
                        }
                    }
                    return i
                }
                async parseImagesAsync(e) {
                    let t;
                    let n = this,
                        r = {};
                    async function i(e) {
                        if ("string" == typeof e) {
                            let r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e;
                            return await t.loadAsync(r)
                        }
                        return e.data ? {
                            data: nW(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        (t = new cJ(this.manager)).setCrossOrigin(this.crossOrigin);
                        for (let t = 0, n = e.length; t < n; t++) {
                            let n = e[t],
                                s = n.url;
                            if (Array.isArray(s)) {
                                let e = [];
                                for (let t = 0, n = s.length; t < n; t++) {
                                    let n = s[t],
                                        r = await i(n);
                                    null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new lg(r.data, r.width, r.height)))
                                }
                                r[n.uuid] = new n6(e)
                            } else {
                                let e = await i(n.url);
                                r[n.uuid] = new n6(e)
                            }
                        }
                    }
                    return r
                }
                parseTextures(e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    let r = {};
                    if (void 0 !== e)
                        for (let i = 0, s = e.length; i < s; i++) {
                            let s;
                            let a = e[i];
                            void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                            let o = t[a.image],
                                l = o.data;
                            Array.isArray(l) ? (s = new sd, 6 === l.length && (s.needsUpdate = !0)) : (s = l && l.data ? new lg : new n7, l && (s.needsUpdate = !0)), s.source = o, s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.mapping && (s.mapping = n(a.mapping, hg)), void 0 !== a.channel && (s.channel = a.channel), void 0 !== a.offset && s.offset.fromArray(a.offset), void 0 !== a.repeat && s.repeat.fromArray(a.repeat), void 0 !== a.center && s.center.fromArray(a.center), void 0 !== a.rotation && (s.rotation = a.rotation), void 0 !== a.wrap && (s.wrapS = n(a.wrap[0], hA), s.wrapT = n(a.wrap[1], hA)), void 0 !== a.format && (s.format = a.format), void 0 !== a.internalFormat && (s.internalFormat = a.internalFormat), void 0 !== a.type && (s.type = a.type), void 0 !== a.colorSpace && (s.colorSpace = a.colorSpace), void 0 !== a.minFilter && (s.minFilter = n(a.minFilter, hm)), void 0 !== a.magFilter && (s.magFilter = n(a.magFilter, hm)), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), void 0 !== a.flipY && (s.flipY = a.flipY), void 0 !== a.generateMipmaps && (s.generateMipmaps = a.generateMipmaps), void 0 !== a.premultiplyAlpha && (s.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (s.unpackAlignment = a.unpackAlignment), void 0 !== a.compareFunction && (s.compareFunction = a.compareFunction), void 0 !== a.userData && (s.userData = a.userData), r[a.uuid] = s
                        }
                    return r
                }
                parseObject(e, t, n, r, i) {
                    let s, a, o;

                    function l(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function u(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                let t = [];
                                for (let r = 0, i = e.length; r < i; r++) {
                                    let i = e[r];
                                    void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(n[i])
                                }
                                return t
                            }
                            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                        }
                    }

                    function c(e) {
                        return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e]
                    }
                    switch (e.type) {
                        case "Scene":
                            s = new oW, void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new i_(e.background) : s.background = c(e.background)), void 0 !== e.environment && (s.environment = c(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new oj(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new oV(e.fog.color, e.fog.density)), "" !== e.fog.name && (s.fog.name = e.fog.name)), void 0 !== e.backgroundBlurriness && (s.backgroundBlurriness = e.backgroundBlurriness), void 0 !== e.backgroundIntensity && (s.backgroundIntensity = e.backgroundIntensity), void 0 !== e.backgroundRotation && s.backgroundRotation.fromArray(e.backgroundRotation), void 0 !== e.environmentIntensity && (s.environmentIntensity = e.environmentIntensity), void 0 !== e.environmentRotation && s.environmentRotation.fromArray(e.environmentRotation);
                            break;
                        case "PerspectiveCamera":
                            s = new sc(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (s.focus = e.focus), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset), void 0 !== e.view && (s.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            s = new sN(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.view && (s.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            s = new ha(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            (s = new hs(e.color, e.intensity)).target = e.target || "";
                            break;
                        case "PointLight":
                            s = new hr(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            s = new ho(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            (s = new c9(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay)).target = e.target || "";
                            break;
                        case "HemisphereLight":
                            s = new c2(e.color, e.groundColor, e.intensity);
                            break;
                        case "LightProbe":
                            s = new hu().fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            s = new lf(a = l(e.geometry), o = u(e.material)), void 0 !== e.bindMode && (s.bindMode = e.bindMode), void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (s.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            s = new i9(a = l(e.geometry), o = u(e.material));
                            break;
                        case "InstancedMesh":
                            a = l(e.geometry), o = u(e.material);
                            let h = e.count,
                                d = e.instanceMatrix,
                                f = e.instanceColor;
                            (s = new lI(a, o, h)).instanceMatrix = new ly(new Float32Array(d.array), 16), void 0 !== f && (s.instanceColor = new ly(new Float32Array(f.array), f.itemSize));
                            break;
                        case "BatchedMesh":
                            a = l(e.geometry), o = u(e.material), (s = new lj(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, o)).geometry = a, s.perObjectFrustumCulled = e.perObjectFrustumCulled, s.sortObjects = e.sortObjects, s._drawRanges = e.drawRanges, s._reservedRanges = e.reservedRanges, s._visibility = e.visibility, s._active = e.active, s._bounds = e.bounds.map(e => {
                                let t = new rh;
                                t.min.fromArray(e.boxMin), t.max.fromArray(e.boxMax);
                                let n = new rT;
                                return n.radius = e.sphereRadius, n.center.fromArray(e.sphereCenter), {
                                    boxInitialized: e.boxInitialized,
                                    box: t,
                                    sphereInitialized: e.sphereInitialized,
                                    sphere: n
                                }
                            }), s._maxInstanceCount = e.maxInstanceCount, s._maxVertexCount = e.maxVertexCount, s._maxIndexCount = e.maxIndexCount, s._geometryInitialized = e.geometryInitialized, s._geometryCount = e.geometryCount, s._matricesTexture = c(e.matricesTexture.uuid), void 0 !== e.colorsTexture && (s._colorsTexture = c(e.colorsTexture.uuid));
                            break;
                        case "LOD":
                            s = new lr;
                            break;
                        case "Line":
                            s = new l0(l(e.geometry), u(e.material));
                            break;
                        case "LineLoop":
                            s = new l5(l(e.geometry), u(e.material));
                            break;
                        case "LineSegments":
                            s = new l4(l(e.geometry), u(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            s = new ut(l(e.geometry), u(e.material));
                            break;
                        case "Sprite":
                            s = new o7(u(e.material));
                            break;
                        case "Group":
                            s = new oD;
                            break;
                        case "Bone":
                            s = new lp;
                            break;
                        default:
                            s = new it
                    }
                    if (s.uuid = e.uuid, void 0 !== e.name && (s.name = e.name), void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position), void 0 !== e.rotation && s.rotation.fromArray(e.rotation), void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion), void 0 !== e.scale && s.scale.fromArray(e.scale)), void 0 !== e.up && s.up.fromArray(e.up), void 0 !== e.castShadow && (s.castShadow = e.castShadow), void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.intensity && (s.shadow.intensity = e.shadow.intensity), void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.layers && (s.layers.mask = e.layers), void 0 !== e.children) {
                        let a = e.children;
                        for (let e = 0; e < a.length; e++) s.add(this.parseObject(a[e], t, n, r, i))
                    }
                    if (void 0 !== e.animations) {
                        let t = e.animations;
                        for (let e = 0; e < t.length; e++) {
                            let n = t[e];
                            s.animations.push(i[n])
                        }
                    }
                    if ("LOD" === e.type) {
                        void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate);
                        let t = e.levels;
                        for (let e = 0; e < t.length; e++) {
                            let n = t[e],
                                r = s.getObjectByProperty("uuid", n.object);
                            void 0 !== r && s.addLevel(r, n.distance, n.hysteresis)
                        }
                    }
                    return s
                }
                bindSkeletons(e, t) {
                    0 !== Object.keys(t).length && e.traverse(function(e) {
                        if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                            let n = t[e.skeleton];
                            void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                        }
                    })
                }
                bindLightTargets(e) {
                    e.traverse(function(t) {
                        if (t.isDirectionalLight || t.isSpotLight) {
                            let n = t.target,
                                r = e.getObjectByProperty("uuid", n);
                            void 0 !== r ? t.target = r : t.target = new it
                        }
                    })
                }
            }
            let hg = {
                    UVMapping: eg,
                    CubeReflectionMapping: eA,
                    CubeRefractionMapping: em,
                    EquirectangularReflectionMapping: ev,
                    EquirectangularRefractionMapping: ey,
                    CubeUVReflectionMapping: ex
                },
                hA = {
                    RepeatWrapping: eE,
                    ClampToEdgeWrapping: e_,
                    MirroredRepeatWrapping: eb
                },
                hm = {
                    NearestFilter: ew,
                    NearestMipmapNearestFilter: eC,
                    NearestMipmapLinearFilter: eI,
                    LinearFilter: eT,
                    LinearMipmapNearestFilter: eB,
                    LinearMipmapLinearFilter: eD
                };
            class hv extends cj {
                constructor(e) {
                    super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(e) {
                    return this.options = e, this
                }
                load(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let i = this,
                        s = cz.get(e);
                    if (void 0 !== s) {
                        if (i.manager.itemStart(e), s.then) {
                            s.then(n => {
                                t && t(n), i.manager.itemEnd(e)
                            }).catch(e => {
                                r && r(e)
                            });
                            return
                        }
                        return setTimeout(function() {
                            t && t(s), i.manager.itemEnd(e)
                        }, 0), s
                    }
                    let a = {};
                    a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader;
                    let o = fetch(e, a).then(function(e) {
                        return e.blob()
                    }).then(function(e) {
                        return createImageBitmap(e, Object.assign(i.options, {
                            colorSpaceConversion: "none"
                        }))
                    }).then(function(n) {
                        return cz.add(e, n), t && t(n), i.manager.itemEnd(e), n
                    }).catch(function(t) {
                        r && r(t), cz.remove(e), i.manager.itemError(e), i.manager.itemEnd(e)
                    });
                    cz.add(e, o), i.manager.itemStart(e)
                }
            }
            class hy {
                static getContext() {
                    return void 0 === s && (s = new(window.AudioContext || window.webkitAudioContext)), s
                }
                static setContext(e) {
                    s = e
                }
            }
            class hx extends cj {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        s = new cX(this.manager);

                    function a(t) {
                        r ? r(t) : console.error(t), i.manager.itemError(e)
                    }
                    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(e) {
                        try {
                            let n = e.slice(0);
                            hy.getContext().decodeAudioData(n, function(e) {
                                t(e)
                            }).catch(a)
                        } catch (e) {
                            a(e)
                        }
                    }, n, r)
                }
            }
            let hE = new rF,
                h_ = new rF,
                hb = new rF;
            class hw {
                constructor() {
                    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new sc, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new sc, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                        focus: null,
                        fov: null,
                        aspect: null,
                        near: null,
                        far: null,
                        zoom: null,
                        eyeSep: null
                    }
                }
                update(e) {
                    let t = this._cache;
                    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                        let n, r;
                        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, hb.copy(e.projectionMatrix);
                        let i = t.eyeSep / 2,
                            s = i * t.near / t.focus,
                            a = t.near * Math.tan(nD * t.fov * .5) / t.zoom;
                        h_.elements[12] = -i, hE.elements[12] = i, n = -a * t.aspect + s, r = a * t.aspect + s, hb.elements[0] = 2 * t.near / (r - n), hb.elements[8] = (r + n) / (r - n), this.cameraL.projectionMatrix.copy(hb), n = -a * t.aspect - s, r = a * t.aspect - s, hb.elements[0] = 2 * t.near / (r - n), hb.elements[8] = (r + n) / (r - n), this.cameraR.projectionMatrix.copy(hb)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(h_), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(hE)
                }
            }
            class hC {
                constructor(e = !0) {
                    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = hS(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        let t = hS();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }

            function hS() {
                return performance.now()
            }
            let hI = new rl,
                hM = new ro,
                hT = new rl,
                hB = new rl;
            class hR extends it {
                constructor() {
                    super(), this.type = "AudioListener", this.context = hy.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new hC
                }
                getInput() {
                    return this.gain
                }
                removeFilter() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                }
                getFilter() {
                    return this.filter
                }
                setFilter(e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                }
                getMasterVolume() {
                    return this.gain.gain.value
                }
                setMasterVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e);
                    let t = this.context.listener,
                        n = this.up;
                    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(hI, hM, hT), hB.set(0, 0, -1).applyQuaternion(hM), t.positionX) {
                        let e = this.context.currentTime + this.timeDelta;
                        t.positionX.linearRampToValueAtTime(hI.x, e), t.positionY.linearRampToValueAtTime(hI.y, e), t.positionZ.linearRampToValueAtTime(hI.z, e), t.forwardX.linearRampToValueAtTime(hB.x, e), t.forwardY.linearRampToValueAtTime(hB.y, e), t.forwardZ.linearRampToValueAtTime(hB.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)
                    } else t.setPosition(hI.x, hI.y, hI.z), t.setOrientation(hB.x, hB.y, hB.z, n.x, n.y, n.z)
                }
            }
            class hD extends it {
                constructor(e) {
                    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                }
                setMediaElementSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                }
                setMediaStreamSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                }
                setBuffer(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(e = 0) {
                    if (!0 === this.isPlaying) {
                        console.warn("THREE.Audio: Audio is already playing.");
                        return
                    }
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    this._startedAt = this.context.currentTime + e;
                    let t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
                }
                stop(e = 0) {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return this._progress = 0, null !== this.source && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (!1 !== this._connected) {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this._connected = !1, this
                    }
                }
                getFilters() {
                    return this.filters
                }
                setFilters(e) {
                    return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                }
                setDetune(e) {
                    return this.detune = e, !0 === this.isPlaying && void 0 !== this.source.detune && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(e) {
                    return this.setFilters(e ? [e] : [])
                }
                setPlaybackRate(e) {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(e) {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this
                }
                setLoopStart(e) {
                    return this.loopStart = e, this
                }
                setLoopEnd(e) {
                    return this.loopEnd = e, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }
            let hL = new rl,
                hP = new ro,
                hO = new rl,
                hN = new rl;
            class hU extends hD {
                constructor(e) {
                    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                }
                connect() {
                    super.connect(), this.panner.connect(this.gain)
                }
                disconnect() {
                    super.disconnect(), this.panner.disconnect(this.gain)
                }
                getOutput() {
                    return this.panner
                }
                getRefDistance() {
                    return this.panner.refDistance
                }
                setRefDistance(e) {
                    return this.panner.refDistance = e, this
                }
                getRolloffFactor() {
                    return this.panner.rolloffFactor
                }
                setRolloffFactor(e) {
                    return this.panner.rolloffFactor = e, this
                }
                getDistanceModel() {
                    return this.panner.distanceModel
                }
                setDistanceModel(e) {
                    return this.panner.distanceModel = e, this
                }
                getMaxDistance() {
                    return this.panner.maxDistance
                }
                setMaxDistance(e) {
                    return this.panner.maxDistance = e, this
                }
                setDirectionalCone(e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                }
                updateMatrixWorld(e) {
                    if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                    this.matrixWorld.decompose(hL, hP, hO), hN.set(0, 0, 1).applyQuaternion(hP);
                    let t = this.panner;
                    if (t.positionX) {
                        let e = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(hL.x, e), t.positionY.linearRampToValueAtTime(hL.y, e), t.positionZ.linearRampToValueAtTime(hL.z, e), t.orientationX.linearRampToValueAtTime(hN.x, e), t.orientationY.linearRampToValueAtTime(hN.y, e), t.orientationZ.linearRampToValueAtTime(hN.z, e)
                    } else t.setPosition(hL.x, hL.y, hL.z), t.setOrientation(hN.x, hN.y, hN.z)
                }
            }
            class hF {
                constructor(e, t = 2048) {
                    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
                }
                getFrequencyData() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
                getAverageFrequency() {
                    let e = 0,
                        t = this.getFrequencyData();
                    for (let n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }
            class hk {
                constructor(e, t, n) {
                    let r, i, s;
                    switch (this.binding = e, this.valueSize = n, t) {
                        case "quaternion":
                            r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = Array(5 * n);
                            break;
                        default:
                            r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                    }
                    this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(e, t) {
                    let n = this.buffer,
                        r = this.valueSize,
                        i = e * r + r,
                        s = this.cumulativeWeight;
                    if (0 === s) {
                        for (let e = 0; e !== r; ++e) n[i + e] = n[e];
                        s = t
                    } else {
                        s += t;
                        let e = t / s;
                        this._mixBufferRegion(n, i, 0, e, r)
                    }
                    this.cumulativeWeight = s
                }
                accumulateAdditive(e) {
                    let t = this.buffer,
                        n = this.valueSize,
                        r = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e
                }
                apply(e) {
                    let t = this.valueSize,
                        n = this.buffer,
                        r = e * t + t,
                        i = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                        let e = t * this._origIndex;
                        this._mixBufferRegion(n, r, e, 1 - i, t)
                    }
                    s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
                    for (let e = t, i = t + t; e !== i; ++e)
                        if (n[e] !== n[e + t]) {
                            a.setValue(n, r);
                            break
                        }
                }
                saveOriginalState() {
                    let e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        r = n * this._origIndex;
                    e.getValue(t, r);
                    for (let e = n; e !== r; ++e) t[e] = t[r + e % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    let e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                }
                _setAdditiveIdentityNumeric() {
                    let e = this._addIndex * this.valueSize,
                        t = e + this.valueSize;
                    for (let n = e; n < t; n++) this.buffer[n] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    let e = this._origIndex * this.valueSize,
                        t = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
                }
                _select(e, t, n, r, i) {
                    if (r >= .5)
                        for (let r = 0; r !== i; ++r) e[t + r] = e[n + r]
                }
                _slerp(e, t, n, r) {
                    ro.slerpFlat(e, t, e, t, e, n, r)
                }
                _slerpAdditive(e, t, n, r, i) {
                    let s = this._workIndex * i;
                    ro.multiplyQuaternionsFlat(e, s, e, t, e, n), ro.slerpFlat(e, t, e, t, e, s, r)
                }
                _lerp(e, t, n, r, i) {
                    let s = 1 - r;
                    for (let a = 0; a !== i; ++a) {
                        let i = t + a;
                        e[i] = e[i] * s + e[n + a] * r
                    }
                }
                _lerpAdditive(e, t, n, r, i) {
                    for (let s = 0; s !== i; ++s) {
                        let i = t + s;
                        e[i] = e[i] + e[n + s] * r
                    }
                }
            }
            let hQ = "\\[\\]\\.:\\/",
                hG = RegExp("[" + hQ + "]", "g"),
                hz = "[^" + hQ + "]",
                hH = "[^" + hQ.replace("\\.", "") + "]",
                hV = /((?:WC+[\/:])*)/.source.replace("WC", hz),
                hj = RegExp("^" + hV + /(WCOD+)?/.source.replace("WCOD", hH) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", hz) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", hz) + "$"),
                hW = ["material", "materials", "bones", "map"];
            class hY {
                constructor(e, t, n) {
                    let r = n || hX.parseTrackName(t);
                    this._targetGroup = e, this._bindings = e.subscribe_(t, r)
                }
                getValue(e, t) {
                    this.bind();
                    let n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(e, t)
                }
                setValue(e, t) {
                    let n = this._bindings;
                    for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
                }
                bind() {
                    let e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                }
                unbind() {
                    let e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }
            class hX {
                constructor(e, t, n) {
                    this.path = t, this.parsedPath = n || hX.parseTrackName(t), this.node = hX.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new hX.Composite(e, t, n) : new hX(e, t, n)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(hG, "")
                }
                static parseTrackName(e) {
                    let t = hj.exec(e);
                    if (null === t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                    let n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        let e = n.nodeName.substring(r + 1); - 1 !== hW.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
                static findNode(e, t) {
                    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        let n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        let n = function(e) {
                                for (let r = 0; r < e.length; r++) {
                                    let i = e[r];
                                    if (i.name === t || i.uuid === t) return i;
                                    let s = n(i.children);
                                    if (s) return s
                                }
                                return null
                            },
                            r = n(e.children);
                        if (r) return r
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                }
                bind() {
                    let e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        r = t.propertyName,
                        i = t.propertyIndex;
                    if (e || (e = hX.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                        console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                        return
                    }
                    if (n) {
                        let r = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.materials) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) {
                                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                e = e.skeleton.bones;
                                for (let t = 0; t < e.length; t++)
                                    if (e[t].name === r) {
                                        r = t;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map" in e) {
                                    e = e.map;
                                    break
                                }
                                if (!e.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.map) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                e = e.material.map;
                                break;
                            default:
                                if (void 0 === e[n]) {
                                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                e = e[n]
                        }
                        if (void 0 !== r) {
                            if (void 0 === e[r]) {
                                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                return
                            }
                            e = e[r]
                        }
                    }
                    let s = e[r];
                    if (void 0 === s) {
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + r + " but it wasn't found.", e);
                        return
                    }
                    let a = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!e.geometry) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                return
                            }
                            if (!e.geometry.morphAttributes) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                return
                            }
                            void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                        }
                        o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            hX.Composite = hY, hX.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, hX.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, hX.prototype.GetterByBindingType = [hX.prototype._getValue_direct, hX.prototype._getValue_array, hX.prototype._getValue_arrayElement, hX.prototype._getValue_toArray], hX.prototype.SetterByBindingTypeAndVersioning = [
                [hX.prototype._setValue_direct, hX.prototype._setValue_direct_setNeedsUpdate, hX.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [hX.prototype._setValue_array, hX.prototype._setValue_array_setNeedsUpdate, hX.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [hX.prototype._setValue_arrayElement, hX.prototype._setValue_arrayElement_setNeedsUpdate, hX.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [hX.prototype._setValue_fromArray, hX.prototype._setValue_fromArray_setNeedsUpdate, hX.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class hq {
                constructor() {
                    this.isAnimationObjectGroup = !0, this.uuid = nP(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                    let e = {};
                    this._indicesByUUID = e;
                    for (let t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                    let t = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return t._objects.length
                            },
                            get inUse() {
                                return this.total - t.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return t._bindings.length
                        }
                    }
                }
                add() {
                    let e = this._objects,
                        t = this._indicesByUUID,
                        n = this._paths,
                        r = this._parsedPaths,
                        i = this._bindings,
                        s = i.length,
                        a, o = e.length,
                        l = this.nCachedObjects_;
                    for (let u = 0, c = arguments.length; u !== c; ++u) {
                        let c = arguments[u],
                            h = c.uuid,
                            d = t[h];
                        if (void 0 === d) {
                            d = o++, t[h] = d, e.push(c);
                            for (let e = 0; e !== s; ++e) i[e].push(new hX(c, n[e], r[e]))
                        } else if (d < l) {
                            a = e[d];
                            let o = --l,
                                u = e[o];
                            t[u.uuid] = d, e[d] = u, t[h] = o, e[o] = c;
                            for (let e = 0; e !== s; ++e) {
                                let t = i[e],
                                    s = t[o],
                                    a = t[d];
                                t[d] = s, void 0 === a && (a = new hX(c, n[e], r[e])), t[o] = a
                            }
                        } else e[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = l
                }
                remove() {
                    let e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length,
                        i = this.nCachedObjects_;
                    for (let s = 0, a = arguments.length; s !== a; ++s) {
                        let a = arguments[s],
                            o = a.uuid,
                            l = t[o];
                        if (void 0 !== l && l >= i) {
                            let s = i++,
                                u = e[s];
                            t[u.uuid] = l, e[l] = u, t[o] = s, e[s] = a;
                            for (let e = 0; e !== r; ++e) {
                                let t = n[e],
                                    r = t[s],
                                    i = t[l];
                                t[l] = r, t[s] = i
                            }
                        }
                    }
                    this.nCachedObjects_ = i
                }
                uncache() {
                    let e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length,
                        i = this.nCachedObjects_,
                        s = e.length;
                    for (let a = 0, o = arguments.length; a !== o; ++a) {
                        let o = arguments[a],
                            l = o.uuid,
                            u = t[l];
                        if (void 0 !== u) {
                            if (delete t[l], u < i) {
                                let a = --i,
                                    o = e[a],
                                    l = --s,
                                    c = e[l];
                                t[o.uuid] = u, e[u] = o, t[c.uuid] = a, e[a] = c, e.pop();
                                for (let e = 0; e !== r; ++e) {
                                    let t = n[e],
                                        r = t[a],
                                        i = t[l];
                                    t[u] = r, t[a] = i, t.pop()
                                }
                            } else {
                                let i = --s,
                                    a = e[i];
                                i > 0 && (t[a.uuid] = u), e[u] = a, e.pop();
                                for (let e = 0; e !== r; ++e) {
                                    let t = n[e];
                                    t[u] = t[i], t.pop()
                                }
                            }
                        }
                    }
                    this.nCachedObjects_ = i
                }
                subscribe_(e, t) {
                    let n = this._bindingsIndicesByPath,
                        r = n[e],
                        i = this._bindings;
                    if (void 0 !== r) return i[r];
                    let s = this._paths,
                        a = this._parsedPaths,
                        o = this._objects,
                        l = o.length,
                        u = this.nCachedObjects_,
                        c = Array(l);
                    r = i.length, n[e] = r, s.push(e), a.push(t), i.push(c);
                    for (let n = u, r = o.length; n !== r; ++n) {
                        let r = o[n];
                        c[n] = new hX(r, e, t)
                    }
                    return c
                }
                unsubscribe_(e) {
                    let t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        let r = this._paths,
                            i = this._parsedPaths,
                            s = this._bindings,
                            a = s.length - 1,
                            o = s[a];
                        t[e[a]] = n, s[n] = o, s.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                    }
                }
            }
            class hK {
                constructor(e, t, n = null, r = t.blendMode) {
                    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
                    let i = t.tracks,
                        s = i.length,
                        a = Array(s),
                        o = {
                            endingStart: tL,
                            endingEnd: tL
                        };
                    for (let e = 0; e !== s; ++e) {
                        let t = i[e].createInterpolant(null);
                        a[e] = t, t.settings = o
                    }
                    this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = tM, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(e) {
                    return this._startTime = e, this
                }
                setLoop(e, t) {
                    return this.loop = e, this.repetitions = t, this
                }
                setEffectiveWeight(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(e) {
                    return this._scheduleFading(e, 0, 1)
                }
                fadeOut(e) {
                    return this._scheduleFading(e, 1, 0)
                }
                crossFadeFrom(e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        let n = this._clip.duration,
                            r = e._clip.duration;
                        e.warp(1, r / n, t), this.warp(n / r, 1, t)
                    }
                    return this
                }
                crossFadeTo(e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                }
                stopFading() {
                    let e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                setEffectiveTimeScale(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                }
                syncWith(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                }
                halt(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                }
                warp(e, t, n) {
                    let r = this._mixer,
                        i = r.time,
                        s = this.timeScale,
                        a = this._timeScaleInterpolant;
                    null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
                    let o = a.parameterPositions,
                        l = a.sampleValues;
                    return o[0] = i, o[1] = i + n, l[0] = e / s, l[1] = t / s, this
                }
                stopWarping() {
                    let e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(e, t, n, r) {
                    if (!this.enabled) {
                        this._updateWeight(e);
                        return
                    }
                    let i = this._startTime;
                    if (null !== i) {
                        let r = (e - i) * n;
                        r < 0 || 0 === n ? t = 0 : (this._startTime = null, t = n * r)
                    }
                    t *= this._updateTimeScale(e);
                    let s = this._updateTime(t),
                        a = this._updateWeight(e);
                    if (a > 0) {
                        let e = this._interpolants,
                            t = this._propertyBindings;
                        if (this.blendMode === tU)
                            for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(s), t[n].accumulateAdditive(a);
                        else
                            for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(s), t[n].accumulate(r, a)
                    }
                }
                _updateWeight(e) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        let n = this._weightInterpolant;
                        if (null !== n) {
                            let r = n.evaluate(e)[0];
                            t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(e) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        let n = this._timeScaleInterpolant;
                        null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t))
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(e) {
                    let t = this._clip.duration,
                        n = this.loop,
                        r = this.time + e,
                        i = this._loopCount,
                        s = n === tT;
                    if (0 === e) return -1 === i ? r : s && (1 & i) == 1 ? t - r : r;
                    if (n === tI) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        i: {
                            if (r >= t) r = t;
                            else if (r < 0) r = 0;
                            else {
                                this.time = r;
                                break i
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = r,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= t || r < 0) {
                            let n = Math.floor(r / t);
                            r -= t * n, i += Math.abs(n);
                            let a = this.repetitions - i;
                            if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === a) {
                                    let t = e < 0;
                                    this._setEndings(t, !t, s)
                                } else this._setEndings(!1, !1, s);
                                this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                            }
                        } else this.time = r;
                        if (s && (1 & i) == 1) return t - r
                    }
                    return r
                }
                _setEndings(e, t, n) {
                    let r = this._interpolantSettings;
                    n ? (r.endingStart = tP, r.endingEnd = tP) : (e ? r.endingStart = this.zeroSlopeAtStart ? tP : tL : r.endingStart = tO, t ? r.endingEnd = this.zeroSlopeAtEnd ? tP : tL : r.endingEnd = tO)
                }
                _scheduleFading(e, t, n) {
                    let r = this._mixer,
                        i = r.time,
                        s = this._weightInterpolant;
                    null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s);
                    let a = s.parameterPositions,
                        o = s.sampleValues;
                    return a[0] = i, o[0] = t, a[1] = i + e, o[1] = n, this
                }
            }
            let hJ = new Float32Array(1);
            class hZ extends nT {
                constructor(e) {
                    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(e, t) {
                    let n = e._localRoot || this._root,
                        r = e._clip.tracks,
                        i = r.length,
                        s = e._propertyBindings,
                        a = e._interpolants,
                        o = n.uuid,
                        l = this._bindingsByRootAndName,
                        u = l[o];
                    void 0 === u && (u = {}, l[o] = u);
                    for (let e = 0; e !== i; ++e) {
                        let i = r[e],
                            l = i.name,
                            c = u[l];
                        if (void 0 !== c) ++c.referenceCount, s[e] = c;
                        else {
                            if (void 0 !== (c = s[e])) {
                                null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, o, l));
                                continue
                            }
                            let r = t && t._propertyBindings[e].binding.parsedPath;
                            c = new hk(hX.create(n, l, r), i.ValueTypeName, i.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, o, l), s[e] = c
                        }
                        a[e].resultBuffer = c.buffer
                    }
                }
                _activateAction(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            let t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        let t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            let n = t[e];
                            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                }
                _deactivateAction(e) {
                    if (this._isActiveAction(e)) {
                        let t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            let n = t[e];
                            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(e)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    let e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(e) {
                    let t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                }
                _addInactiveAction(e, t, n) {
                    let r = this._actions,
                        i = this._actionsByClip,
                        s = i[t];
                    if (void 0 === s) s = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, i[t] = s;
                    else {
                        let t = s.knownActions;
                        e._byClipCacheIndex = t.length, t.push(e)
                    }
                    e._cacheIndex = r.length, r.push(e), s.actionByRoot[n] = e
                }
                _removeInactiveAction(e) {
                    let t = this._actions,
                        n = t[t.length - 1],
                        r = e._cacheIndex;
                    n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                    let i = e._clip.uuid,
                        s = this._actionsByClip,
                        a = s[i],
                        o = a.knownActions,
                        l = o[o.length - 1],
                        u = e._byClipCacheIndex;
                    l._byClipCacheIndex = u, o[u] = l, o.pop(), e._byClipCacheIndex = null;
                    let c = a.actionByRoot,
                        h = (e._localRoot || this._root).uuid;
                    delete c[h], 0 === o.length && delete s[i], this._removeInactiveBindingsForAction(e)
                }
                _removeInactiveBindingsForAction(e) {
                    let t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        let n = t[e];
                        0 == --n.referenceCount && this._removeInactiveBinding(n)
                    }
                }
                _lendAction(e) {
                    let t = this._actions,
                        n = e._cacheIndex,
                        r = this._nActiveActions++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _takeBackAction(e) {
                    let t = this._actions,
                        n = e._cacheIndex,
                        r = --this._nActiveActions,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _addInactiveBinding(e, t, n) {
                    let r = this._bindingsByRootAndName,
                        i = this._bindings,
                        s = r[t];
                    void 0 === s && (s = {}, r[t] = s), s[n] = e, e._cacheIndex = i.length, i.push(e)
                }
                _removeInactiveBinding(e) {
                    let t = this._bindings,
                        n = e.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        s = this._bindingsByRootAndName,
                        a = s[r],
                        o = t[t.length - 1],
                        l = e._cacheIndex;
                    o._cacheIndex = l, t[l] = o, t.pop(), delete a[i], 0 === Object.keys(a).length && delete s[r]
                }
                _lendBinding(e) {
                    let t = this._bindings,
                        n = e._cacheIndex,
                        r = this._nActiveBindings++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _takeBackBinding(e) {
                    let t = this._bindings,
                        n = e._cacheIndex,
                        r = --this._nActiveBindings,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _lendControlInterpolant() {
                    let e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && ((n = new cR(new Float32Array(2), new Float32Array(2), 1, hJ)).__cacheIndex = t, e[t] = n), n
                }
                _takeBackControlInterpolant(e) {
                    let t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = t[r];
                    e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
                }
                clipAction(e, t, n) {
                    let r = t || this._root,
                        i = r.uuid,
                        s = "string" == typeof e ? cG.findByName(r, e) : e,
                        a = null !== s ? s.uuid : e,
                        o = this._actionsByClip[a],
                        l = null;
                    if (void 0 === n && (n = null !== s ? s.blendMode : tN), void 0 !== o) {
                        let e = o.actionByRoot[i];
                        if (void 0 !== e && e.blendMode === n) return e;
                        l = o.knownActions[0], null === s && (s = l._clip)
                    }
                    if (null === s) return null;
                    let u = new hK(this, s, t, n);
                    return this._bindAction(u, l), this._addInactiveAction(u, a, i), u
                }
                existingAction(e, t) {
                    let n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? cG.findByName(n, e) : e,
                        s = i ? i.uuid : e,
                        a = this._actionsByClip[s];
                    return void 0 !== a && a.actionByRoot[r] || null
                }
                stopAllAction() {
                    let e = this._actions,
                        t = this._nActiveActions;
                    for (let n = t - 1; n >= 0; --n) e[n].stop();
                    return this
                }
                update(e) {
                    e *= this.timeScale;
                    let t = this._actions,
                        n = this._nActiveActions,
                        r = this.time += e,
                        i = Math.sign(e),
                        s = this._accuIndex ^= 1;
                    for (let a = 0; a !== n; ++a) t[a]._update(r, e, i, s);
                    let a = this._bindings,
                        o = this._nActiveBindings;
                    for (let e = 0; e !== o; ++e) a[e].apply(s);
                    return this
                }
                setTime(e) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(e)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(e) {
                    let t = this._actions,
                        n = e.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        let e = i.knownActions;
                        for (let n = 0, r = e.length; n !== r; ++n) {
                            let r = e[n];
                            this._deactivateAction(r);
                            let i = r._cacheIndex,
                                s = t[t.length - 1];
                            r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, t[i] = s, t.pop(), this._removeInactiveBindingsForAction(r)
                        }
                        delete r[n]
                    }
                }
                uncacheRoot(e) {
                    let t = e.uuid,
                        n = this._actionsByClip;
                    for (let e in n) {
                        let r = n[e].actionByRoot[t];
                        void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                    }
                    let r = this._bindingsByRootAndName[t];
                    if (void 0 !== r)
                        for (let e in r) {
                            let t = r[e];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                }
                uncacheAction(e, t) {
                    let n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }
            class h$ {
                constructor(e) {
                    this.value = e
                }
                clone() {
                    return new h$(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }
            let h0 = 0;
            class h1 extends nT {
                constructor() {
                    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
                        value: h0++
                    }), this.name = "", this.usage = nA, this.uniforms = []
                }
                add(e) {
                    return this.uniforms.push(e), this
                }
                remove(e) {
                    let t = this.uniforms.indexOf(e);
                    return -1 !== t && this.uniforms.splice(t, 1), this
                }
                setName(e) {
                    return this.name = e, this
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                dispose() {
                    return this.dispatchEvent({
                        type: "dispose"
                    }), this
                }
                copy(e) {
                    this.name = e.name, this.usage = e.usage;
                    let t = e.uniforms;
                    this.uniforms.length = 0;
                    for (let e = 0, n = t.length; e < n; e++) {
                        let n = Array.isArray(t[e]) ? t[e] : [t[e]];
                        for (let e = 0; e < n.length; e++) this.uniforms.push(n[e].clone())
                    }
                    return this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class h2 extends oY {
                constructor(e, t, n = 1) {
                    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                clone(e) {
                    let t = super.clone(e);
                    return t.meshPerAttribute = this.meshPerAttribute, t
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
                }
            }
            class h3 {
                constructor(e, t, n, r, i) {
                    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setBuffer(e) {
                    return this.buffer = e, this
                }
                setType(e, t) {
                    return this.type = e, this.elementSize = t, this
                }
                setItemSize(e) {
                    return this.itemSize = e, this
                }
                setCount(e) {
                    return this.count = e, this
                }
            }
            let h4 = new rF;
            class h5 {
                constructor(e, t, n = 0, r = 1 / 0) {
                    this.ray = new rU(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new rq, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                }
                setFromXRController(e) {
                    return h4.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(h4), this
                }
                intersectObject(e, t = !0, n = []) {
                    return h8(e, this, n, t), n.sort(h6), n
                }
                intersectObjects(e, t = !0, n = []) {
                    for (let r = 0, i = e.length; r < i; r++) h8(e[r], this, n, t);
                    return n.sort(h6), n
                }
            }

            function h6(e, t) {
                return e.distance - t.distance
            }

            function h8(e, t, n, r) {
                let i = !0;
                if (e.layers.test(t.layers) && !1 === e.raycast(t, n) && (i = !1), !0 === i && !0 === r) {
                    let r = e.children;
                    for (let e = 0, i = r.length; e < i; e++) h8(r[e], t, n, !0)
                }
            }
            class h9 {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
                makeSafe() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(nO(t / this.radius, -1, 1))), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class h7 {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class de {
                constructor(e, t, n, r) {
                    de.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], void 0 !== e && this.set(e, t, n, r)
                }
                identity() {
                    return this.set(1, 0, 0, 1), this
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 4; n++) this.elements[n] = e[n + t];
                    return this
                }
                set(e, t, n, r) {
                    let i = this.elements;
                    return i[0] = e, i[2] = t, i[1] = n, i[3] = r, this
                }
            }
            let dt = new nG;
            class dn {
                constructor(e = new nG(Infinity, Infinity), t = new nG(-1 / 0, -1 / 0)) {
                    this.isBox2 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    let n = dt.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                containsPoint(e) {
                    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(e) {
                    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return this.clampPoint(e, dt).distanceTo(e)
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            let dr = new rl,
                di = new rl;
            class ds {
                constructor(e = new rl, t = new rl) {
                    this.start = e, this.end = t
                }
                set(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                }
                copy(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                }
                getCenter(e) {
                    return e.addVectors(this.start, this.end).multiplyScalar(.5)
                }
                delta(e) {
                    return e.subVectors(this.end, this.start)
                }
                distanceSq() {
                    return this.start.distanceToSquared(this.end)
                }
                distance() {
                    return this.start.distanceTo(this.end)
                }
                at(e, t) {
                    return this.delta(t).multiplyScalar(e).add(this.start)
                }
                closestPointToPointParameter(e, t) {
                    dr.subVectors(e, this.start), di.subVectors(this.end, this.start);
                    let n = di.dot(di),
                        r = di.dot(dr) / n;
                    return t && (r = nO(r, 0, 1)), r
                }
                closestPointToPoint(e, t, n) {
                    let r = this.closestPointToPointParameter(e, t);
                    return this.delta(n).multiplyScalar(r).add(this.start)
                }
                applyMatrix4(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                }
                equals(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let da = new rl;
            class dl extends it {
                constructor(e, t) {
                    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
                    let n = new iK,
                        r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                    for (let e = 0, t = 1; e < 32; e++, t++) {
                        let n = e / 32 * Math.PI * 2,
                            i = t / 32 * Math.PI * 2;
                        r.push(Math.cos(n), Math.sin(n), 1, Math.cos(i), Math.sin(i), 1)
                    }
                    n.setAttribute("position", new iz(r, 3));
                    let i = new lW({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.cone = new l4(n, i), this.add(this.cone), this.update()
                }
                dispose() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }
                update() {
                    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
                    let e = this.light.distance ? this.light.distance : 1e3,
                        t = e * Math.tan(this.light.angle);
                    this.cone.scale.set(t, t, e), da.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(da), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }
            let du = new rl,
                dc = new rF,
                dh = new rF;
            class dd extends l4 {
                constructor(e) {
                    let t = function e(t) {
                            let n = [];
                            !0 === t.isBone && n.push(t);
                            for (let r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                            return n
                        }(e),
                        n = new iK,
                        r = [],
                        i = [],
                        s = new i_(0, 0, 1),
                        a = new i_(0, 1, 0);
                    for (let e = 0; e < t.length; e++) {
                        let n = t[e];
                        n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(a.r, a.g, a.b))
                    }
                    n.setAttribute("position", new iz(r, 3)), n.setAttribute("color", new iz(i, 3)), super(n, new lW({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(e) {
                    let t = this.bones,
                        n = this.geometry,
                        r = n.getAttribute("position");
                    dh.copy(this.root.matrixWorld).invert();
                    for (let e = 0, n = 0; e < t.length; e++) {
                        let i = t[e];
                        i.parent && i.parent.isBone && (dc.multiplyMatrices(dh, i.matrixWorld), du.setFromMatrixPosition(dc), r.setXYZ(n, du.x, du.y, du.z), dc.multiplyMatrices(dh, i.parent.matrixWorld), du.setFromMatrixPosition(dc), r.setXYZ(n + 1, du.x, du.y, du.z), n += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class df extends i9 {
                constructor(e, t, n) {
                    super(new cs(t, 4, 2), new iS({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    })), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
                update() {
                    this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }
            }
            let dp = new rl,
                dg = new i_,
                dA = new i_;
            class dm extends it {
                constructor(e, t, n) {
                    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
                    let r = new cn(t);
                    r.rotateY(.5 * Math.PI), this.material = new iS({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    }), void 0 === this.color && (this.material.vertexColors = !0);
                    let i = new Float32Array(3 * r.getAttribute("position").count);
                    r.setAttribute("color", new iL(i, 3)), this.add(new i9(r, this.material)), this.update()
                }
                dispose() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
                update() {
                    let e = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        let t = e.geometry.getAttribute("color");
                        dg.copy(this.light.color), dA.copy(this.light.groundColor);
                        for (let e = 0, n = t.count; e < n; e++) {
                            let r = e < n / 2 ? dg : dA;
                            t.setXYZ(e, r.r, r.g, r.b)
                        }
                        t.needsUpdate = !0
                    }
                    this.light.updateWorldMatrix(!0, !1), e.lookAt(dp.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }
            class dv extends l4 {
                constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
                    n = new i_(n), r = new i_(r);
                    let i = t / 2,
                        s = e / t,
                        a = e / 2,
                        o = [],
                        l = [];
                    for (let e = 0, u = 0, c = -a; e <= t; e++, c += s) {
                        o.push(-a, 0, c, a, 0, c), o.push(c, 0, -a, c, 0, a);
                        let t = e === i ? n : r;
                        t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3
                    }
                    let u = new iK;
                    u.setAttribute("position", new iz(o, 3)), u.setAttribute("color", new iz(l, 3)), super(u, new lW({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "GridHelper"
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class dy extends l4 {
                constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, s = 8947848) {
                    i = new i_(i), s = new i_(s);
                    let a = [],
                        o = [];
                    if (t > 1)
                        for (let n = 0; n < t; n++) {
                            let r = n / t * (2 * Math.PI),
                                l = Math.sin(r) * e,
                                u = Math.cos(r) * e;
                            a.push(0, 0, 0), a.push(l, 0, u);
                            let c = 1 & n ? i : s;
                            o.push(c.r, c.g, c.b), o.push(c.r, c.g, c.b)
                        }
                    for (let t = 0; t < n; t++) {
                        let l = 1 & t ? i : s,
                            u = e - e / n * t;
                        for (let e = 0; e < r; e++) {
                            let t = e / r * (2 * Math.PI),
                                n = Math.sin(t) * u,
                                i = Math.cos(t) * u;
                            a.push(n, 0, i), o.push(l.r, l.g, l.b), n = Math.sin(t = (e + 1) / r * (2 * Math.PI)) * u, i = Math.cos(t) * u, a.push(n, 0, i), o.push(l.r, l.g, l.b)
                        }
                    }
                    let l = new iK;
                    l.setAttribute("position", new iz(a, 3)), l.setAttribute("color", new iz(o, 3)), super(l, new lW({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "PolarGridHelper"
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            let dx = new rl,
                dE = new rl,
                d_ = new rl;
            class db extends it {
                constructor(e, t, n) {
                    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", void 0 === t && (t = 1);
                    let r = new iK;
                    r.setAttribute("position", new iz([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                    let i = new lW({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.lightPlane = new l0(r, i), this.add(this.lightPlane), (r = new iK).setAttribute("position", new iz([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new l0(r, i), this.add(this.targetLine), this.update()
                }
                dispose() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }
                update() {
                    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), dx.setFromMatrixPosition(this.light.matrixWorld), dE.setFromMatrixPosition(this.light.target.matrixWorld), d_.subVectors(dE, dx), this.lightPlane.lookAt(dE), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(dE), this.targetLine.scale.z = d_.length()
                }
            }
            let dw = new rl,
                dC = new sa;
            class dS extends l4 {
                constructor(e) {
                    let t = new iK,
                        n = new lW({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        }),
                        r = [],
                        i = [],
                        s = {};

                    function a(e, t) {
                        o(e), o(t)
                    }

                    function o(e) {
                        r.push(0, 0, 0), i.push(0, 0, 0), void 0 === s[e] && (s[e] = []), s[e].push(r.length / 3 - 1)
                    }
                    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), t.setAttribute("position", new iz(r, 3)), t.setAttribute("color", new iz(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
                    let l = new i_(16755200),
                        u = new i_(16711680),
                        c = new i_(43775),
                        h = new i_(16777215),
                        d = new i_(3355443);
                    this.setColors(l, u, c, h, d)
                }
                setColors(e, t, n, r, i) {
                    let s = this.geometry.getAttribute("color");
                    s.setXYZ(0, e.r, e.g, e.b), s.setXYZ(1, e.r, e.g, e.b), s.setXYZ(2, e.r, e.g, e.b), s.setXYZ(3, e.r, e.g, e.b), s.setXYZ(4, e.r, e.g, e.b), s.setXYZ(5, e.r, e.g, e.b), s.setXYZ(6, e.r, e.g, e.b), s.setXYZ(7, e.r, e.g, e.b), s.setXYZ(8, e.r, e.g, e.b), s.setXYZ(9, e.r, e.g, e.b), s.setXYZ(10, e.r, e.g, e.b), s.setXYZ(11, e.r, e.g, e.b), s.setXYZ(12, e.r, e.g, e.b), s.setXYZ(13, e.r, e.g, e.b), s.setXYZ(14, e.r, e.g, e.b), s.setXYZ(15, e.r, e.g, e.b), s.setXYZ(16, e.r, e.g, e.b), s.setXYZ(17, e.r, e.g, e.b), s.setXYZ(18, e.r, e.g, e.b), s.setXYZ(19, e.r, e.g, e.b), s.setXYZ(20, e.r, e.g, e.b), s.setXYZ(21, e.r, e.g, e.b), s.setXYZ(22, e.r, e.g, e.b), s.setXYZ(23, e.r, e.g, e.b), s.setXYZ(24, t.r, t.g, t.b), s.setXYZ(25, t.r, t.g, t.b), s.setXYZ(26, t.r, t.g, t.b), s.setXYZ(27, t.r, t.g, t.b), s.setXYZ(28, t.r, t.g, t.b), s.setXYZ(29, t.r, t.g, t.b), s.setXYZ(30, t.r, t.g, t.b), s.setXYZ(31, t.r, t.g, t.b), s.setXYZ(32, n.r, n.g, n.b), s.setXYZ(33, n.r, n.g, n.b), s.setXYZ(34, n.r, n.g, n.b), s.setXYZ(35, n.r, n.g, n.b), s.setXYZ(36, n.r, n.g, n.b), s.setXYZ(37, n.r, n.g, n.b), s.setXYZ(38, r.r, r.g, r.b), s.setXYZ(39, r.r, r.g, r.b), s.setXYZ(40, i.r, i.g, i.b), s.setXYZ(41, i.r, i.g, i.b), s.setXYZ(42, i.r, i.g, i.b), s.setXYZ(43, i.r, i.g, i.b), s.setXYZ(44, i.r, i.g, i.b), s.setXYZ(45, i.r, i.g, i.b), s.setXYZ(46, i.r, i.g, i.b), s.setXYZ(47, i.r, i.g, i.b), s.setXYZ(48, i.r, i.g, i.b), s.setXYZ(49, i.r, i.g, i.b), s.needsUpdate = !0
                }
                update() {
                    let e = this.geometry,
                        t = this.pointMap;
                    dC.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), dI("c", t, e, dC, 0, 0, -1), dI("t", t, e, dC, 0, 0, 1), dI("n1", t, e, dC, -1, -1, -1), dI("n2", t, e, dC, 1, -1, -1), dI("n3", t, e, dC, -1, 1, -1), dI("n4", t, e, dC, 1, 1, -1), dI("f1", t, e, dC, -1, -1, 1), dI("f2", t, e, dC, 1, -1, 1), dI("f3", t, e, dC, -1, 1, 1), dI("f4", t, e, dC, 1, 1, 1), dI("u1", t, e, dC, .7, 1.1, -1), dI("u2", t, e, dC, -.7, 1.1, -1), dI("u3", t, e, dC, 0, 2, -1), dI("cf1", t, e, dC, -1, 0, 1), dI("cf2", t, e, dC, 1, 0, 1), dI("cf3", t, e, dC, 0, -1, 1), dI("cf4", t, e, dC, 0, 1, 1), dI("cn1", t, e, dC, -1, 0, -1), dI("cn2", t, e, dC, 1, 0, -1), dI("cn3", t, e, dC, 0, -1, -1), dI("cn4", t, e, dC, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }

            function dI(e, t, n, r, i, s, a) {
                dw.set(i, s, a).unproject(r);
                let o = t[e];
                if (void 0 !== o) {
                    let e = n.getAttribute("position");
                    for (let t = 0, n = o.length; t < n; t++) e.setXYZ(o[t], dw.x, dw.y, dw.z)
                }
            }
            let dM = new rh;
            class dT extends l4 {
                constructor(e, t = 16776960) {
                    let n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        r = new Float32Array(24),
                        i = new iK;
                    i.setIndex(new iL(n, 1)), i.setAttribute("position", new iL(r, 3)), super(i, new lW({
                        color: t,
                        toneMapped: !1
                    })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                }
                update(e) {
                    if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && dM.setFromObject(this.object), dM.isEmpty()) return;
                    let t = dM.min,
                        n = dM.max,
                        r = this.geometry.attributes.position,
                        i = r.array;
                    i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
                setFromObject(e) {
                    return this.object = e, this.update(), this
                }
                copy(e, t) {
                    return super.copy(e, t), this.object = e.object, this
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class dB extends l4 {
                constructor(e, t = 16776960) {
                    let n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        r = new iK;
                    r.setIndex(new iL(n, 1)), r.setAttribute("position", new iz([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new lW({
                        color: t,
                        toneMapped: !1
                    })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                }
                updateMatrixWorld(e) {
                    let t = this.box;
                    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class dR extends l0 {
                constructor(e, t = 1, n = 16776960) {
                    let r = new iK;
                    r.setAttribute("position", new iz([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new lW({
                        color: n,
                        toneMapped: !1
                    })), this.type = "PlaneHelper", this.plane = e, this.size = t;
                    let i = new iK;
                    i.setAttribute("position", new iz([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i.computeBoundingSphere(), this.add(new i9(i, new iS({
                        color: n,
                        opacity: .2,
                        transparent: !0,
                        depthWrite: !1,
                        toneMapped: !1
                    })))
                }
                updateMatrixWorld(e) {
                    this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
            }
            let dD = new rl;
            class dL extends it {
                constructor(e = new rl(0, 0, 1), t = new rl(0, 0, 0), n = 1, r = 16776960, i = .2 * n, s = .2 * i) {
                    super(), this.type = "ArrowHelper", void 0 === a && ((a = new iK).setAttribute("position", new iz([0, 0, 0, 0, 1, 0], 3)), (o = new uP(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new l0(a, new lW({
                        color: r,
                        toneMapped: !1
                    })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new i9(o, new iS({
                        color: r,
                        toneMapped: !1
                    })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, s)
                }
                setDirection(e) {
                    if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
                    else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                    else {
                        dD.set(e.z, 0, -e.x).normalize();
                        let t = Math.acos(e.y);
                        this.quaternion.setFromAxisAngle(dD, t)
                    }
                }
                setLength(e, t = .2 * e, n = .2 * t) {
                    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
                }
                setColor(e) {
                    this.line.material.color.set(e), this.cone.material.color.set(e)
                }
                copy(e) {
                    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
                }
                dispose() {
                    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
                }
            }
            class dP extends l4 {
                constructor(e = 1) {
                    let t = new iK;
                    t.setAttribute("position", new iz([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], 3)), t.setAttribute("color", new iz([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(t, new lW({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "AxesHelper"
                }
                setColors(e, t, n) {
                    let r = new i_,
                        i = this.geometry.attributes.color.array;
                    return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class dO {
                constructor() {
                    this.type = "ShapePath", this.color = new i_, this.subPaths = [], this.currentPath = null
                }
                moveTo(e, t) {
                    return this.currentPath = new uB, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
                }
                lineTo(e, t) {
                    return this.currentPath.lineTo(e, t), this
                }
                quadraticCurveTo(e, t, n, r) {
                    return this.currentPath.quadraticCurveTo(e, t, n, r), this
                }
                bezierCurveTo(e, t, n, r, i, s) {
                    return this.currentPath.bezierCurveTo(e, t, n, r, i, s), this
                }
                splineThru(e) {
                    return this.currentPath.splineThru(e), this
                }
                toShapes(e) {
                    let t, n, r, i, s;
                    let a = u6.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    let l = [];
                    if (1 === o.length) return n = o[0], (r = new uH).curves = n.curves, l.push(r), l;
                    let u = !a(o[0].getPoints());
                    u = e ? !u : u;
                    let c = [],
                        h = [],
                        d = [],
                        f = 0;
                    h[0] = void 0, d[f] = [];
                    for (let r = 0, s = o.length; r < s; r++) t = a(i = (n = o[r]).getPoints()), (t = e ? !t : t) ? (!u && h[f] && f++, h[f] = {
                        s: new uH,
                        p: i
                    }, h[f].s.curves = n.curves, u && f++, d[f] = []) : d[f].push({
                        h: n,
                        p: i[0]
                    });
                    if (!h[0]) return function(e) {
                        let t = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            let r = e[n],
                                i = new uH;
                            i.curves = r.curves, t.push(i)
                        }
                        return t
                    }(o);
                    if (h.length > 1) {
                        let e = !1,
                            t = 0;
                        for (let e = 0, t = h.length; e < t; e++) c[e] = [];
                        for (let n = 0, r = h.length; n < r; n++) {
                            let r = d[n];
                            for (let i = 0; i < r.length; i++) {
                                let s = r[i],
                                    a = !0;
                                for (let r = 0; r < h.length; r++)(function(e, t) {
                                    let n = t.length,
                                        r = !1;
                                    for (let i = n - 1, s = 0; s < n; i = s++) {
                                        let n = t[i],
                                            a = t[s],
                                            o = a.x - n.x,
                                            l = a.y - n.y;
                                        if (Math.abs(l) > Number.EPSILON) {
                                            if (l < 0 && (n = t[s], o = -o, a = t[i], l = -l), e.y < n.y || e.y > a.y) continue;
                                            if (e.y === n.y) {
                                                if (e.x === n.x) return !0
                                            } else {
                                                let t = l * (e.x - n.x) - o * (e.y - n.y);
                                                if (0 === t) return !0;
                                                if (t < 0) continue;
                                                r = !r
                                            }
                                        } else {
                                            if (e.y !== n.y) continue;
                                            if (a.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= a.x) return !0
                                        }
                                    }
                                    return r
                                })(s.p, h[r].p) && (n !== r && t++, a ? (a = !1, c[r].push(s)) : e = !0);
                                a && c[n].push(s)
                            }
                        }
                        t > 0 && !1 === e && (d = c)
                    }
                    for (let e = 0, t = h.length; e < t; e++) {
                        r = h[e].s, l.push(r), s = d[e];
                        for (let e = 0, t = s.length; e < t; e++) r.holes.push(s[e].h)
                    }
                    return l
                }
            }
            class dN extends nT {
                constructor(e, t = null) {
                    super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = {
                        LEFT: null,
                        MIDDLE: null,
                        RIGHT: null
                    }, this.touches = {
                        ONE: null,
                        TWO: null
                    }
                }
                connect() {}
                disconnect() {}
                dispose() {}
                update() {}
            }
            class dU extends rn {
                constructor(e = 1, t = 1, n = 1, r = {}) {
                    console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...r,
                        count: n
                    }), this.isWebGLMultipleRenderTargets = !0
                }
                get texture() {
                    return this.textures
                }
            }
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: l
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = l)
        },
        6871: function(e, t, n) {
            "use strict";
            n.d(t, {
                Jh: function() {
                    return a
                },
                _T: function() {
                    return i
                },
                ev: function() {
                    return l
                },
                fl: function() {
                    return o
                },
                mG: function() {
                    return s
                },
                pi: function() {
                    return r
                }
            });
            var r = function() {
                return (r = Object.assign || function(e) {
                    for (var t, n = 1, r = arguments.length; n < r; n++)
                        for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                    return e
                }).apply(this, arguments)
            };

            function i(e, t) {
                var n = {};
                for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && 0 > t.indexOf(r) && (n[r] = e[r]);
                if (null != e && "function" == typeof Object.getOwnPropertySymbols)
                    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++) 0 > t.indexOf(r[i]) && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
                return n
            }

            function s(e, t, n, r) {
                return new(n || (n = Promise))(function(i, s) {
                    function a(e) {
                        try {
                            l(r.next(e))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function o(e) {
                        try {
                            l(r.throw(e))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function l(e) {
                        var t;
                        e.done ? i(e.value) : ((t = e.value) instanceof n ? t : new n(function(e) {
                            e(t)
                        })).then(a, o)
                    }
                    l((r = r.apply(e, t || [])).next())
                })
            }

            function a(e, t) {
                var n, r, i, s = {
                        label: 0,
                        sent: function() {
                            if (1 & i[0]) throw i[1];
                            return i[1]
                        },
                        trys: [],
                        ops: []
                    },
                    a = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype);
                return a.next = o(0), a.throw = o(1), a.return = o(2), "function" == typeof Symbol && (a[Symbol.iterator] = function() {
                    return this
                }), a;

                function o(o) {
                    return function(l) {
                        return function(o) {
                            if (n) throw TypeError("Generator is already executing.");
                            for (; a && (a = 0, o[0] && (s = 0)), s;) try {
                                if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                                switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                    case 0:
                                    case 1:
                                        i = o;
                                        break;
                                    case 4:
                                        return s.label++, {
                                            value: o[1],
                                            done: !1
                                        };
                                    case 5:
                                        s.label++, r = o[1], o = [0];
                                        continue;
                                    case 7:
                                        o = s.ops.pop(), s.trys.pop();
                                        continue;
                                    default:
                                        if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                                            s = 0;
                                            continue
                                        }
                                        if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                            s.label = o[1];
                                            break
                                        }
                                        if (6 === o[0] && s.label < i[1]) {
                                            s.label = i[1], i = o;
                                            break
                                        }
                                        if (i && s.label < i[2]) {
                                            s.label = i[2], s.ops.push(o);
                                            break
                                        }
                                        i[2] && s.ops.pop(), s.trys.pop();
                                        continue
                                }
                                o = t.call(e, s)
                            } catch (e) {
                                o = [6, e], r = 0
                            } finally {
                                n = i = 0
                            }
                            if (5 & o[0]) throw o[1];
                            return {
                                value: o[0] ? o[1] : void 0,
                                done: !0
                            }
                        }([o, l])
                    }
                }
            }

            function o() {
                for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(function(e, t) {
                    var n = "function" == typeof Symbol && e[Symbol.iterator];
                    if (!n) return e;
                    var r, i, s = n.call(e),
                        a = [];
                    try {
                        for (;
                            (void 0 === t || t-- > 0) && !(r = s.next()).done;) a.push(r.value)
                    } catch (e) {
                        i = {
                            error: e
                        }
                    } finally {
                        try {
                            r && !r.done && (n = s.return) && n.call(s)
                        } finally {
                            if (i) throw i.error
                        }
                    }
                    return a
                }(arguments[t]));
                return e
            }

            function l(e, t, n) {
                if (n || 2 == arguments.length)
                    for (var r, i = 0, s = t.length; i < s; i++) !r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]);
                return e.concat(r || Array.prototype.slice.call(t))
            }
            "function" == typeof SuppressedError && SuppressedError
        },
        9749: function(e, t, n) {
            "use strict";
            n.d(t, {
                Ue: function() {
                    return d
                },
                oR: function() {
                    return c
                }
            });
            var r = n(9795),
                i = n(959),
                s = n(9714);
            let {
                useDebugValue: a
            } = i, {
                useSyncExternalStoreWithSelector: o
            } = s, l = !1, u = e => e;

            function c(e, t = u, n) {
                n && !l && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), l = !0);
                let r = o(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n);
                return a(r), r
            }
            let h = e => {
                    "function" != typeof e && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
                    let t = "function" == typeof e ? (0, r.M)(e) : e,
                        n = (e, n) => c(t, e, n);
                    return Object.assign(n, t), n
                },
                d = e => e ? h(e) : h
        },
        2125: function(e, t, n) {
            "use strict";
            n.d(t, {
                FL: function() {
                    return u
                },
                XR: function() {
                    return l
                },
                mW: function() {
                    return a
                },
                tJ: function() {
                    return f
                }
            });
            let r = new Map,
                i = e => {
                    let t = r.get(e);
                    return t ? Object.fromEntries(Object.entries(t.stores).map(([e, t]) => [e, t.getState()])) : {}
                },
                s = (e, t, n) => {
                    if (void 0 === e) return {
                        type: "untracked",
                        connection: t.connect(n)
                    };
                    let i = r.get(n.name);
                    if (i) return {
                        type: "tracked",
                        store: e,
                        ...i
                    };
                    let s = {
                        connection: t.connect(n),
                        stores: {}
                    };
                    return r.set(n.name, s), {
                        type: "tracked",
                        store: e,
                        ...s
                    }
                },
                a = (e, t = {}) => (n, r, a) => {
                    let l;
                    let {
                        enabled: u,
                        anonymousActionType: c,
                        store: h,
                        ...d
                    } = t;
                    try {
                        l = (null == u || u) && window.__REDUX_DEVTOOLS_EXTENSION__
                    } catch (e) {}
                    if (!l) return u && console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"), e(n, r, a);
                    let {
                        connection: f,
                        ...p
                    } = s(h, l, d), g = !0;
                    a.setState = (e, t, s) => {
                        let o = n(e, t);
                        if (!g) return o;
                        let l = void 0 === s ? {
                            type: c || "anonymous"
                        } : "string" == typeof s ? {
                            type: s
                        } : s;
                        return void 0 === h ? null == f || f.send(l, r()) : null == f || f.send({ ...l,
                            type: `${h}/${l.type}`
                        }, { ...i(d.name),
                            [h]: a.getState()
                        }), o
                    };
                    let A = (...e) => {
                            let t = g;
                            g = !1, n(...e), g = t
                        },
                        m = e(a.setState, r, a);
                    if ("untracked" === p.type ? null == f || f.init(m) : (p.stores[p.store] = a, null == f || f.init(Object.fromEntries(Object.entries(p.stores).map(([e, t]) => [e, e === p.store ? m : t.getState()])))), a.dispatchFromDevtools && "function" == typeof a.dispatch) {
                        let e = !1,
                            t = a.dispatch;
                        a.dispatch = (...n) => {
                            "__setState" !== n[0].type || e || (console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'), e = !0), t(...n)
                        }
                    }
                    return f.subscribe(e => {
                        var t;
                        switch (e.type) {
                            case "ACTION":
                                if ("string" != typeof e.payload) {
                                    console.error("[zustand devtools middleware] Unsupported action format");
                                    return
                                }
                                return o(e.payload, e => {
                                    if ("__setState" === e.type) {
                                        if (void 0 === h) {
                                            A(e.state);
                                            return
                                        }
                                        1 !== Object.keys(e.state).length && console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);
                                        let t = e.state[h];
                                        if (null == t) return;
                                        JSON.stringify(a.getState()) !== JSON.stringify(t) && A(t);
                                        return
                                    }
                                    a.dispatchFromDevtools && "function" == typeof a.dispatch && a.dispatch(e)
                                });
                            case "DISPATCH":
                                switch (e.payload.type) {
                                    case "RESET":
                                        if (A(m), void 0 === h) return null == f ? void 0 : f.init(a.getState());
                                        return null == f ? void 0 : f.init(i(d.name));
                                    case "COMMIT":
                                        if (void 0 === h) {
                                            null == f || f.init(a.getState());
                                            break
                                        }
                                        return null == f ? void 0 : f.init(i(d.name));
                                    case "ROLLBACK":
                                        return o(e.state, e => {
                                            if (void 0 === h) {
                                                A(e), null == f || f.init(a.getState());
                                                return
                                            }
                                            A(e[h]), null == f || f.init(i(d.name))
                                        });
                                    case "JUMP_TO_STATE":
                                    case "JUMP_TO_ACTION":
                                        return o(e.state, e => {
                                            if (void 0 === h) {
                                                A(e);
                                                return
                                            }
                                            JSON.stringify(a.getState()) !== JSON.stringify(e[h]) && A(e[h])
                                        });
                                    case "IMPORT_STATE":
                                        {
                                            let {
                                                nextLiftedState: n
                                            } = e.payload,
                                            r = null == (t = n.computedStates.slice(-1)[0]) ? void 0 : t.state;
                                            if (!r) return;void 0 === h ? A(r) : A(r[h]),
                                            null == f || f.send(null, n);
                                            break
                                        }
                                    case "PAUSE_RECORDING":
                                        return g = !g
                                }
                                return
                        }
                    }), m
                },
                o = (e, t) => {
                    let n;
                    try {
                        n = JSON.parse(e)
                    } catch (e) {
                        console.error("[zustand devtools middleware] Could not parse the received json", e)
                    }
                    void 0 !== n && t(n)
                },
                l = e => (t, n, r) => {
                    let i = r.subscribe;
                    return r.subscribe = (e, t, n) => {
                        let s = e;
                        if (t) {
                            let i = (null == n ? void 0 : n.equalityFn) || Object.is,
                                a = e(r.getState());
                            s = n => {
                                let r = e(n);
                                if (!i(a, r)) {
                                    let e = a;
                                    t(a = r, e)
                                }
                            }, (null == n ? void 0 : n.fireImmediately) && t(a, a)
                        }
                        return i(s)
                    }, e(t, n, r)
                };

            function u(e, t) {
                let n;
                try {
                    n = e()
                } catch (e) {
                    return
                }
                return {
                    getItem: e => {
                        var r;
                        let i = e => null === e ? null : JSON.parse(e, null == t ? void 0 : t.reviver),
                            s = null != (r = n.getItem(e)) ? r : null;
                        return s instanceof Promise ? s.then(i) : i(s)
                    },
                    setItem: (e, r) => n.setItem(e, JSON.stringify(r, null == t ? void 0 : t.replacer)),
                    removeItem: e => n.removeItem(e)
                }
            }
            let c = e => t => {
                    try {
                        let n = e(t);
                        if (n instanceof Promise) return n;
                        return {
                            then: e => c(e)(n),
                            catch (e) {
                                return this
                            }
                        }
                    } catch (e) {
                        return {
                            then(e) {
                                return this
                            },
                            catch: t => c(t)(e)
                        }
                    }
                },
                h = (e, t) => (n, r, i) => {
                    let s, a, o = {
                            getStorage: () => localStorage,
                            serialize: JSON.stringify,
                            deserialize: JSON.parse,
                            partialize: e => e,
                            version: 0,
                            merge: (e, t) => ({ ...t,
                                ...e
                            }),
                            ...t
                        },
                        l = !1,
                        u = new Set,
                        h = new Set;
                    try {
                        s = o.getStorage()
                    } catch (e) {}
                    if (!s) return e((...e) => {
                        console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`), n(...e)
                    }, r, i);
                    let d = c(o.serialize),
                        f = () => {
                            let e;
                            let t = d({
                                state: o.partialize({ ...r()
                                }),
                                version: o.version
                            }).then(e => s.setItem(o.name, e)).catch(t => {
                                e = t
                            });
                            if (e) throw e;
                            return t
                        },
                        p = i.setState;
                    i.setState = (e, t) => {
                        p(e, t), f()
                    };
                    let g = e((...e) => {
                            n(...e), f()
                        }, r, i),
                        A = () => {
                            var e;
                            if (!s) return;
                            l = !1, u.forEach(e => e(r()));
                            let t = (null == (e = o.onRehydrateStorage) ? void 0 : e.call(o, r())) || void 0;
                            return c(s.getItem.bind(s))(o.name).then(e => {
                                if (e) return o.deserialize(e)
                            }).then(e => {
                                if (e) {
                                    if ("number" != typeof e.version || e.version === o.version) return e.state;
                                    if (o.migrate) return o.migrate(e.state, e.version);
                                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                                }
                            }).then(e => {
                                var t;
                                return n(a = o.merge(e, null != (t = r()) ? t : g), !0), f()
                            }).then(() => {
                                null == t || t(a, void 0), l = !0, h.forEach(e => e(a))
                            }).catch(e => {
                                null == t || t(void 0, e)
                            })
                        };
                    return i.persist = {
                        setOptions: e => {
                            o = { ...o,
                                ...e
                            }, e.getStorage && (s = e.getStorage())
                        },
                        clearStorage: () => {
                            null == s || s.removeItem(o.name)
                        },
                        getOptions: () => o,
                        rehydrate: () => A(),
                        hasHydrated: () => l,
                        onHydrate: e => (u.add(e), () => {
                            u.delete(e)
                        }),
                        onFinishHydration: e => (h.add(e), () => {
                            h.delete(e)
                        })
                    }, A(), a || g
                },
                d = (e, t) => (n, r, i) => {
                    let s, a = {
                            storage: u(() => localStorage),
                            partialize: e => e,
                            version: 0,
                            merge: (e, t) => ({ ...t,
                                ...e
                            }),
                            ...t
                        },
                        o = !1,
                        l = new Set,
                        h = new Set,
                        d = a.storage;
                    if (!d) return e((...e) => {
                        console.warn(`[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`), n(...e)
                    }, r, i);
                    let f = () => {
                            let e = a.partialize({ ...r()
                            });
                            return d.setItem(a.name, {
                                state: e,
                                version: a.version
                            })
                        },
                        p = i.setState;
                    i.setState = (e, t) => {
                        p(e, t), f()
                    };
                    let g = e((...e) => {
                        n(...e), f()
                    }, r, i);
                    i.getInitialState = () => g;
                    let A = () => {
                        var e, t;
                        if (!d) return;
                        o = !1, l.forEach(e => {
                            var t;
                            return e(null != (t = r()) ? t : g)
                        });
                        let i = (null == (t = a.onRehydrateStorage) ? void 0 : t.call(a, null != (e = r()) ? e : g)) || void 0;
                        return c(d.getItem.bind(d))(a.name).then(e => {
                            if (e) {
                                if ("number" != typeof e.version || e.version === a.version) return [!1, e.state];
                                if (a.migrate) return [!0, a.migrate(e.state, e.version)];
                                console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                            }
                            return [!1, void 0]
                        }).then(e => {
                            var t;
                            let [i, o] = e;
                            if (n(s = a.merge(o, null != (t = r()) ? t : g), !0), i) return f()
                        }).then(() => {
                            null == i || i(s, void 0), s = r(), o = !0, h.forEach(e => e(s))
                        }).catch(e => {
                            null == i || i(void 0, e)
                        })
                    };
                    return i.persist = {
                        setOptions: e => {
                            a = { ...a,
                                ...e
                            }, e.storage && (d = e.storage)
                        },
                        clearStorage: () => {
                            null == d || d.removeItem(a.name)
                        },
                        getOptions: () => a,
                        rehydrate: () => A(),
                        hasHydrated: () => o,
                        onHydrate: e => (l.add(e), () => {
                            l.delete(e)
                        }),
                        onFinishHydration: e => (h.add(e), () => {
                            h.delete(e)
                        })
                    }, a.skipHydration || A(), s || g
                },
                f = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? (console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."), h(e, t)) : d(e, t)
        },
        4753: function(e, t, n) {
            "use strict";
            n.d(t, {
                n: function() {
                    return V
                }
            });
            var r, i = Symbol.for("immer-nothing"),
                s = Symbol.for("immer-draftable"),
                a = Symbol.for("immer-state");

            function o(e, ...t) {
                throw Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)
            }
            var l = Object.getPrototypeOf;

            function u(e) {
                return !!e && !!e[a]
            }

            function c(e) {
                return !!e && (d(e) || Array.isArray(e) || !!e[s] || !!e.constructor ? .[s] || m(e) || v(e))
            }
            var h = Object.prototype.constructor.toString();

            function d(e) {
                if (!e || "object" != typeof e) return !1;
                let t = l(e);
                if (null === t) return !0;
                let n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
                return n === Object || "function" == typeof n && Function.toString.call(n) === h
            }

            function f(e, t) {
                0 === p(e) ? Reflect.ownKeys(e).forEach(n => {
                    t(n, e[n], e)
                }) : e.forEach((n, r) => t(r, n, e))
            }

            function p(e) {
                let t = e[a];
                return t ? t.type_ : Array.isArray(e) ? 1 : m(e) ? 2 : v(e) ? 3 : 0
            }

            function g(e, t) {
                return 2 === p(e) ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
            }

            function A(e, t, n) {
                let r = p(e);
                2 === r ? e.set(t, n) : 3 === r ? e.add(n) : e[t] = n
            }

            function m(e) {
                return e instanceof Map
            }

            function v(e) {
                return e instanceof Set
            }

            function y(e) {
                return e.copy_ || e.base_
            }

            function x(e, t) {
                if (m(e)) return new Map(e);
                if (v(e)) return new Set(e);
                if (Array.isArray(e)) return Array.prototype.slice.call(e);
                let n = d(e);
                if (!0 !== t && ("class_only" !== t || n)) {
                    let t = l(e);
                    return null !== t && n ? { ...e
                    } : Object.assign(Object.create(t), e)
                } {
                    let t = Object.getOwnPropertyDescriptors(e);
                    delete t[a];
                    let n = Reflect.ownKeys(t);
                    for (let r = 0; r < n.length; r++) {
                        let i = n[r],
                            s = t[i];
                        !1 === s.writable && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (t[i] = {
                            configurable: !0,
                            writable: !0,
                            enumerable: s.enumerable,
                            value: e[i]
                        })
                    }
                    return Object.create(l(e), t)
                }
            }

            function E(e, t = !1) {
                return b(e) || u(e) || !c(e) || (p(e) > 1 && (e.set = e.add = e.clear = e.delete = _), Object.freeze(e), t && Object.entries(e).forEach(([e, t]) => E(t, !0))), e
            }

            function _() {
                o(2)
            }

            function b(e) {
                return Object.isFrozen(e)
            }
            var w = {};

            function C(e) {
                let t = w[e];
                return t || o(0, e), t
            }

            function S(e, t) {
                t && (C("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t)
            }

            function I(e) {
                M(e), e.drafts_.forEach(B), e.drafts_ = null
            }

            function M(e) {
                e === r && (r = e.parent_)
            }

            function T(e) {
                return r = {
                    drafts_: [],
                    parent_: r,
                    immer_: e,
                    canAutoFreeze_: !0,
                    unfinalizedDrafts_: 0
                }
            }

            function B(e) {
                let t = e[a];
                0 === t.type_ || 1 === t.type_ ? t.revoke_() : t.revoked_ = !0
            }

            function R(e, t) {
                t.unfinalizedDrafts_ = t.drafts_.length;
                let n = t.drafts_[0];
                return void 0 !== e && e !== n ? (n[a].modified_ && (I(t), o(4)), c(e) && (e = D(t, e), t.parent_ || P(t, e)), t.patches_ && C("Patches").generateReplacementPatches_(n[a].base_, e, t.patches_, t.inversePatches_)) : e = D(t, n, []), I(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== i ? e : void 0
            }

            function D(e, t, n) {
                if (b(t)) return t;
                let r = t[a];
                if (!r) return f(t, (i, s) => L(e, r, t, i, s, n)), t;
                if (r.scope_ !== e) return t;
                if (!r.modified_) return P(e, r.base_, !0), r.base_;
                if (!r.finalized_) {
                    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
                    let t = r.copy_,
                        i = t,
                        s = !1;
                    3 === r.type_ && (i = new Set(t), t.clear(), s = !0), f(i, (i, a) => L(e, r, t, i, a, n, s)), P(e, t, !1), n && e.patches_ && C("Patches").generatePatches_(r, n, e.patches_, e.inversePatches_)
                }
                return r.copy_
            }

            function L(e, t, n, r, i, s, a) {
                if (u(i)) {
                    let a = D(e, i, s && t && 3 !== t.type_ && !g(t.assigned_, r) ? s.concat(r) : void 0);
                    if (A(n, r, a), !u(a)) return;
                    e.canAutoFreeze_ = !1
                } else a && n.add(i);
                if (c(i) && !b(i)) {
                    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return;
                    D(e, i), (!t || !t.scope_.parent_) && "symbol" != typeof r && Object.prototype.propertyIsEnumerable.call(n, r) && P(e, i)
                }
            }

            function P(e, t, n = !1) {
                !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && E(t, n)
            }
            var O = {
                    get(e, t) {
                        if (t === a) return e;
                        let n = y(e);
                        if (!g(n, t)) return function(e, t, n) {
                            let r = F(t, n);
                            return r ? "value" in r ? r.value : r.get ? .call(e.draft_) : void 0
                        }(e, n, t);
                        let r = n[t];
                        return e.finalized_ || !c(r) ? r : r === U(e.base_, t) ? (Q(e), e.copy_[t] = G(r, e)) : r
                    },
                    has: (e, t) => t in y(e),
                    ownKeys: e => Reflect.ownKeys(y(e)),
                    set(e, t, n) {
                        let r = F(y(e), t);
                        if (r ? .set) return r.set.call(e.draft_, n), !0;
                        if (!e.modified_) {
                            let r = U(y(e), t),
                                i = r ? .[a];
                            if (i && i.base_ === n) return e.copy_[t] = n, e.assigned_[t] = !1, !0;
                            if ((n === r ? 0 !== n || 1 / n == 1 / r : n != n && r != r) && (void 0 !== n || g(e.base_, t))) return !0;
                            Q(e), k(e)
                        }
                        return !!(e.copy_[t] === n && (void 0 !== n || t in e.copy_) || Number.isNaN(n) && Number.isNaN(e.copy_[t])) || (e.copy_[t] = n, e.assigned_[t] = !0, !0)
                    },
                    deleteProperty: (e, t) => (void 0 !== U(e.base_, t) || t in e.base_ ? (e.assigned_[t] = !1, Q(e), k(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0),
                    getOwnPropertyDescriptor(e, t) {
                        let n = y(e),
                            r = Reflect.getOwnPropertyDescriptor(n, t);
                        return r ? {
                            writable: !0,
                            configurable: 1 !== e.type_ || "length" !== t,
                            enumerable: r.enumerable,
                            value: n[t]
                        } : r
                    },
                    defineProperty() {
                        o(11)
                    },
                    getPrototypeOf: e => l(e.base_),
                    setPrototypeOf() {
                        o(12)
                    }
                },
                N = {};

            function U(e, t) {
                let n = e[a];
                return (n ? y(n) : e)[t]
            }

            function F(e, t) {
                if (!(t in e)) return;
                let n = l(e);
                for (; n;) {
                    let e = Object.getOwnPropertyDescriptor(n, t);
                    if (e) return e;
                    n = l(n)
                }
            }

            function k(e) {
                !e.modified_ && (e.modified_ = !0, e.parent_ && k(e.parent_))
            }

            function Q(e) {
                e.copy_ || (e.copy_ = x(e.base_, e.scope_.immer_.useStrictShallowCopy_))
            }

            function G(e, t) {
                let n = m(e) ? C("MapSet").proxyMap_(e, t) : v(e) ? C("MapSet").proxySet_(e, t) : function(e, t) {
                    let n = Array.isArray(e),
                        i = {
                            type_: n ? 1 : 0,
                            scope_: t ? t.scope_ : r,
                            modified_: !1,
                            finalized_: !1,
                            assigned_: {},
                            parent_: t,
                            base_: e,
                            draft_: null,
                            copy_: null,
                            revoke_: null,
                            isManual_: !1
                        },
                        s = i,
                        a = O;
                    n && (s = [i], a = N);
                    let {
                        revoke: o,
                        proxy: l
                    } = Proxy.revocable(s, a);
                    return i.draft_ = l, i.revoke_ = o, l
                }(e, t);
                return (t ? t.scope_ : r).drafts_.push(n), n
            }
            f(O, (e, t) => {
                N[e] = function() {
                    return arguments[0] = arguments[0][0], t.apply(this, arguments)
                }
            }), N.deleteProperty = function(e, t) {
                return N.set.call(this, e, t, void 0)
            }, N.set = function(e, t, n) {
                return O.set.call(this, e[0], t, n, e[0])
            };
            var z = new class {
                    constructor(e) {
                        this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, t, n) => {
                            let r;
                            if ("function" == typeof e && "function" != typeof t) {
                                let n = t;
                                t = e;
                                let r = this;
                                return function(e = n, ...i) {
                                    return r.produce(e, e => t.call(this, e, ...i))
                                }
                            }
                            if ("function" != typeof t && o(6), void 0 !== n && "function" != typeof n && o(7), c(e)) {
                                let i = T(this),
                                    s = G(e, void 0),
                                    a = !0;
                                try {
                                    r = t(s), a = !1
                                } finally {
                                    a ? I(i) : M(i)
                                }
                                return S(i, n), R(r, i)
                            }
                            if (e && "object" == typeof e) o(1, e);
                            else {
                                if (void 0 === (r = t(e)) && (r = e), r === i && (r = void 0), this.autoFreeze_ && E(r, !0), n) {
                                    let t = [],
                                        i = [];
                                    C("Patches").generateReplacementPatches_(e, r, t, i), n(t, i)
                                }
                                return r
                            }
                        }, this.produceWithPatches = (e, t) => {
                            let n, r;
                            return "function" == typeof e ? (t, ...n) => this.produceWithPatches(t, t => e(t, ...n)) : [this.produce(e, t, (e, t) => {
                                n = e, r = t
                            }), n, r]
                        }, "boolean" == typeof e ? .autoFreeze && this.setAutoFreeze(e.autoFreeze), "boolean" == typeof e ? .useStrictShallowCopy && this.setUseStrictShallowCopy(e.useStrictShallowCopy)
                    }
                    createDraft(e) {
                        var t;
                        c(e) || o(8), u(e) && (u(t = e) || o(10, t), e = function e(t) {
                            let n;
                            if (!c(t) || b(t)) return t;
                            let r = t[a];
                            if (r) {
                                if (!r.modified_) return r.base_;
                                r.finalized_ = !0, n = x(t, r.scope_.immer_.useStrictShallowCopy_)
                            } else n = x(t, !0);
                            return f(n, (t, r) => {
                                A(n, t, e(r))
                            }), r && (r.finalized_ = !1), n
                        }(t));
                        let n = T(this),
                            r = G(e, void 0);
                        return r[a].isManual_ = !0, M(n), r
                    }
                    finishDraft(e, t) {
                        let n = e && e[a];
                        n && n.isManual_ || o(9);
                        let {
                            scope_: r
                        } = n;
                        return S(r, t), R(void 0, r)
                    }
                    setAutoFreeze(e) {
                        this.autoFreeze_ = e
                    }
                    setUseStrictShallowCopy(e) {
                        this.useStrictShallowCopy_ = e
                    }
                    applyPatches(e, t) {
                        let n;
                        for (n = t.length - 1; n >= 0; n--) {
                            let r = t[n];
                            if (0 === r.path.length && "replace" === r.op) {
                                e = r.value;
                                break
                            }
                        }
                        n > -1 && (t = t.slice(n + 1));
                        let r = C("Patches").applyPatches_;
                        return u(e) ? r(e, t) : this.produce(e, e => r(e, t))
                    }
                },
                H = z.produce;
            z.produceWithPatches.bind(z), z.setAutoFreeze.bind(z), z.setUseStrictShallowCopy.bind(z), z.applyPatches.bind(z), z.createDraft.bind(z), z.finishDraft.bind(z);
            let V = e => (t, n, r) => (r.setState = (e, n, ...r) => t("function" == typeof e ? H(e) : e, n, ...r), e(r.setState, n, r))
        },
        9795: function(e, t, n) {
            "use strict";
            n.d(t, {
                M: function() {
                    return i
                }
            });
            let r = e => {
                    let t;
                    let n = new Set,
                        r = (e, r) => {
                            let i = "function" == typeof e ? e(t) : e;
                            if (!Object.is(i, t)) {
                                let e = t;
                                t = (null != r ? r : "object" != typeof i || null === i) ? i : Object.assign({}, t, i), n.forEach(n => n(t, e))
                            }
                        },
                        i = () => t,
                        s = {
                            setState: r,
                            getState: i,
                            getInitialState: () => a,
                            subscribe: e => (n.add(e), () => n.delete(e)),
                            destroy: () => {
                                console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear()
                            }
                        },
                        a = t = e(r, i, s);
                    return s
                },
                i = e => e ? r(e) : r
        },
        1129: function(e) {
            "use strict";
            e.exports = JSON.parse('{"fields":[{"type":"hidden","id":12,"formId":2,"label":"form_url","adminLabel":"","isRequired":false,"size":"large","errorMessage":"","visibility":"visible","inputs":null,"description":"","allowsPrepopulate":false,"inputMask":false,"inputMaskValue":"","inputMaskIsCustom":false,"maxLength":"","inputType":"hidden","labelPlacement":"","descriptionPlacement":"","subLabelPlacement":"","placeholder":"","cssClass":"","inputName":"","noDuplicates":false,"defaultValue":"","enableAutocomplete":false,"autocompleteAttribute":"","choices":"","conditionalLogic":"","productField":"","layoutGridColumnSpan":12,"enableEnhancedUI":0,"layoutGroupId":"e145da76","multipleFiles":false,"maxFiles":"","calculationFormula":"","calculationRounding":"","enableCalculation":"","disableQuantity":false,"displayAllCategories":false,"useRichTextEditor":false,"errors":[],"pageNumber":1,"fields":"","displayOnly":""},{"type":"email","id":2,"formId":2,"label":"Email","adminLabel":"","isRequired":true,"size":"large","errorMessage":"","visibility":"visible","inputs":null,"autocompleteAttribute":"email","description":"","allowsPrepopulate":false,"inputMask":false,"inputMaskValue":"","inputMaskIsCustom":false,"maxLength":"","labelPlacement":"","descriptionPlacement":"","subLabelPlacement":"","placeholder":"Email","cssClass":"","inputName":"","noDuplicates":false,"defaultValue":"","enableAutocomplete":false,"choices":"","conditionalLogic":"","productField":"","layoutGridColumnSpan":"","emailConfirmEnabled":"","enableEnhancedUI":0,"layoutGroupId":"eae61ddf","multipleFiles":false,"maxFiles":"","calculationFormula":"","calculationRounding":"","enableCalculation":"","disableQuantity":false,"displayAllCategories":false,"useRichTextEditor":false,"fields":"","displayOnly":"","pageNumber":1,"inputType":"email"},{"type":"consent","checked_indicator_url":"/wp-content/plugins/gravityforms/images/tick.png","checked_indicator_markup":"<img src=\\"/wp-content/plugins/gravityforms/images/tick.png\\" />","id":7,"formId":2,"label":"Privacy","adminLabel":"","isRequired":true,"size":"large","errorMessage":"","visibility":"visible","inputs":[{"id":"8.1","label":"Consenso","name":""},{"id":"8.2","label":"Testo","name":"","isHidden":true},{"id":"8.3","label":"Descrizione","name":"","isHidden":true}],"checkboxLabel":"I have reviewed the <a href=\'/privacy-policy\' target=\'_blank\'>privacy policy</a> and give my consent to the sending of messages.<br/><span id=required-data>* mandatory data</span>","descriptionPlaceholder":"Inserisci il testo dell&#039;accordo di consenso qui. Il Campo Consenso registrer\xe0 questo testo con la registrazione del modulo per poter tracciare ci\xf2 a cui l&#039;utente ha dato il proprio consenso.","inputType":"consent","choices":[{"text":"Verificato","value":"1","isSelected":false,"price":""}],"description":"","allowsPrepopulate":false,"inputMask":false,"inputMaskValue":"","inputMaskIsCustom":false,"maxLength":"","labelPlacement":"","descriptionPlacement":"","subLabelPlacement":"","placeholder":"","cssClass":"","inputName":"","noDuplicates":false,"defaultValue":"","enableAutocomplete":false,"autocompleteAttribute":"","conditionalLogic":"","productField":"","layoutGridColumnSpan":"","enableEnhancedUI":0,"layoutGroupId":"8780b68c","multipleFiles":false,"maxFiles":"","calculationFormula":"","calculationRounding":"","enableCalculation":"","disableQuantity":false,"displayAllCategories":false,"useRichTextEditor":false,"errors":[],"pageNumber":1,"fields":"","validateState":true,"displayOnly":""}],"button":{"type":"text","text":"Subscribe","imageUrl":"","width":"auto","location":"bottom","layoutGridColumnSpan":12,"id":"submit"},"title":"Contatti","description":"","version":"2.8.17","id":2,"markupVersion":2,"nextFieldId":13,"useCurrentUserAsAuthor":true,"postContentTemplateEnabled":false,"postTitleTemplateEnabled":false,"postTitleTemplate":"","postContentTemplate":"","lastPageButton":null,"pagination":null,"firstPageCssClass":null,"labelPlacement":"top_label","descriptionPlacement":"below","validationPlacement":"below","subLabelPlacement":"below","requiredIndicator":"asterisk","customRequiredIndicator":"(Obbligatorio)","cssClass":"","saveButtonText":"Salva e continua","limitEntries":false,"limitEntriesCount":"","limitEntriesPeriod":"","limitEntriesMessage":"","scheduleForm":false,"scheduleStart":"","scheduleEnd":"","schedulePendingMessage":"","scheduleMessage":"","requireLogin":false,"requireLoginMessage":"","honeypotAction":"abort","validationSummary":false,"deprecated":"","saveEnabled":"","enableHoneypot":false,"enableAnimation":false,"save":{"enabled":false,"button":{"type":"link","text":"Salva e continua"}},"scheduleStartHour":"","scheduleStartMinute":"","scheduleStartAmpm":"","scheduleEndHour":"","scheduleEndMinute":"","scheduleEndAmpm":"","notifications":{"669f6366602ad":{"id":"669f6366602ad","isActive":true,"to":"{admin_email}","name":"Notifica amministratore","event":"form_submission","toType":"email","subject":"Un nuovo invio da {form_title}","message":"{all_fields}"}},"confirmations":{"669f63666057c":{"id":"669f63666057c","name":"Conferma predefinita","isDefault":true,"type":"message","message":"Grazie per averci contattato! Risponderemo il prima possibile.","url":"","pageId":"","queryString":""}},"is_active":"1","date_created":"2024-09-16 12:19:22","is_trash":"0"}')
        },
        4749: function(e) {
            "use strict";
            e.exports = JSON.parse('{"main_menu_01":{"menu":[{"title":"Accelerated Cloud","url":"/accelerated-cloud"},{"title":"Neutrino<sup></sup>","url":"/neutrino"},{"title":"White Glove Services","url":"/white-glove-services"},{"title":"AI as a service","url":"/ai-as-a-service"}]},"main_menu_02":{"menu":[{"title":"Case Studies","url":"/case-studies"},{"title":"About Us","url":"/about-us"}]},"main_menu_03":{"menu":[{"title":"Newsletter","url":"#newsletter"},{"title":"Contacts","url":"/contacts"}]},"legals_menu":{"menu":[{"title":"Cookie Policy","url":"/cookie-policy"},{"title":"Privacy Policy","url":"/privacy-policy"},{"title":"Terms & Conditions","url":"/terms-and-conditions"}]},"social_menu":{"menu":[{"title":"Linkedin","url":"https://www.linkedin.com/company/8bit-ai/","classes":"linkedin","target":"_blank"},{"title":"Twitter","url":"https://x.com/8bitai_Inc","classes":"twitter","target":"_blank"},{"title":"Instagram","url":"https://www.instagram.com/8bit_ai_inc/","classes":"instagram","target":"_blank"},{"title":"Youtube","url":"https://www.youtube.com/channel/UC6WeV10lszMB51_bx_eztlw","classes":"youtube","target":"_blank"}]},"solution_menu":{"menu":[{"title":"Sales","url":"","target":"_blank"},{"title":"Marketing","url":"","target":"_blank"}]},"resources_menu":{"menu":[{"title":"Research","url":"","target":"_blank"},{"title":"Blog","url":"","target":"_blank"},{"title":"Videos","url":"","target":"_blank"},{"title":"Open-source","url":"","target":"_blank"},{"title":"Age of Agents","url":"","target":"_blank"},{"title":"Find Contacts","url":"","target":"_blank"},{"title":"Find Companies","url":"","target":"_blank"}]},"important_links_menu":{"menu":[{"title":"Get a Demo","url":"","target":"_blank"},{"title":"Community","url":"","target":"_blank"},{"title":"MCP","url":"","target":"_blank"}]}}')
        },
        1625: function(e) {
            "use strict";
            e.exports = JSON.parse('{"brand":"8Bit.ai","home":"Home","services":"Services","contacts":"Contacts","discover":"Discover More","scroll":"Scroll Down To Continue","copyright":"[YEAR] \xa9 Copyright 8bit.ai Inc. All Rights Reserved","newsletter":{"title":"Join Our Newsletter","description":"Repellat asperiores nostrum soluta eveniet repellendus illo. Ab ut aut voluptates occaecati animi corporis aspernatur.","form_id":"1"},"footer":{"description":"Accelerating Enterprise Superintelligence","solutions":"Solutions","resources":"Resources","links":"Important Links"}}')
        },
        6124: function(e) {
            "use strict";
            e.exports = JSON.parse('{"required":"The field is required","tel":"The phone number is invalid","email":"The email is not valid","date":"The date is not valid","password":"The password field must be at least ${min} characters long","checkbox":"The field must be accept","confirm_password":"The password does not match"}')
        },
        8267: function(e) {
            "use strict";
            e.exports = JSON.parse('{"required":"Il campo \xe8 richiesto","tel":"Il numero di telefono non \xe8 valido","email":"L\'email non \xe8 valida","date":"La data non \xe8 valida","password":"Il campo password deve essere lungo ${min} caratteri","checkbox":"Il campo deve essere accettato","confirm_password":"La password non corrisponde","codice_fiscale":"Il codice fiscale non \xe8 valido"}')
        }
    },
    function(e) {
        var t = function(t) {
            return e(e.s = t)
        };
        e.O(0, [774, 179], function() {
            return t(7466), t(9153)
        }), _N_E = e.O()
    }
]);
//# sourceMappingURL=_app-db73e48274836115.js.map