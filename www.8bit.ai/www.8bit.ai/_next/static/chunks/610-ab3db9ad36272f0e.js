(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [610], {
        8422: function(t, e, n) {
            "use strict";
            var r = n(959),
                i = n(1519),
                o = n(5700),
                u = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0
                };
            e.Z = o.jU && void 0 !== window.ResizeObserver ? function() {
                var t = (0, r.useState)(null),
                    e = t[0],
                    n = t[1],
                    o = (0, r.useState)(u),
                    c = o[0],
                    a = o[1],
                    s = (0, r.useMemo)(function() {
                        return new window.ResizeObserver(function(t) {
                            if (t[0]) {
                                var e = t[0].contentRect;
                                a({
                                    x: e.x,
                                    y: e.y,
                                    width: e.width,
                                    height: e.height,
                                    top: e.top,
                                    left: e.left,
                                    bottom: e.bottom,
                                    right: e.right
                                })
                            }
                        })
                    }, []);
                return (0, i.Z)(function() {
                    if (e) return s.observe(e),
                        function() {
                            s.disconnect()
                        }
                }, [e]), [n, c]
            } : function() {
                return [o.ZT, u]
            }
        },
        2822: function(t, e, n) {
            "use strict";
            var r = n(959),
                i = n(5700);
            e.Z = function(t, e) {
                var n = (0, r.useState)(void 0 !== e ? e : !!i.jU && window.matchMedia(t).matches),
                    o = n[0],
                    u = n[1];
                return (0, r.useEffect)(function() {
                    var e = !0,
                        n = window.matchMedia(t),
                        r = function() {
                            e && u(!!n.matches)
                        };
                    return n.addEventListener("change", r), u(n.matches),
                        function() {
                            e = !1, n.removeEventListener("change", r)
                        }
                }, [t]), o
            }
        },
        9080: function() {},
        7917: function(t, e, n) {
            t.exports = n(1829)
        },
        8335: function(t, e, n) {
            "use strict";
            n.d(e, {
                Z: function() {
                    return k
                }
            });
            var r = n(959);

            function i(t) {
                return "[object Object]" === Object.prototype.toString.call(t) || Array.isArray(t)
            }

            function o(t, e) {
                let n = Object.keys(t),
                    r = Object.keys(e);
                return n.length === r.length && JSON.stringify(Object.keys(t.breakpoints || {})) === JSON.stringify(Object.keys(e.breakpoints || {})) && n.every(n => {
                    let r = t[n],
                        u = e[n];
                    return "function" == typeof r ? `${r}` == `${u}` : i(r) && i(u) ? o(r, u) : r === u
                })
            }

            function u(t) {
                return t.concat().sort((t, e) => t.name > e.name ? 1 : -1).map(t => t.options)
            }

            function c(t) {
                return "number" == typeof t
            }

            function a(t) {
                return "string" == typeof t
            }

            function s(t) {
                return "boolean" == typeof t
            }

            function l(t) {
                return "[object Object]" === Object.prototype.toString.call(t)
            }

            function f(t) {
                return Math.abs(t)
            }

            function d(t) {
                return Math.sign(t)
            }

            function p(t) {
                return v(t).map(Number)
            }

            function m(t) {
                return t[g(t)]
            }

            function g(t) {
                return Math.max(0, t.length - 1)
            }

            function h(t, e = 0) {
                return Array.from(Array(t), (t, n) => e + n)
            }

            function v(t) {
                return Object.keys(t)
            }

            function y(t, e) {
                return void 0 !== e.MouseEvent && t instanceof e.MouseEvent
            }

            function b() {
                let t = [],
                    e = {
                        add: function(n, r, i, o = {
                            passive: !0
                        }) {
                            let u;
                            return "addEventListener" in n ? (n.addEventListener(r, i, o), u = () => n.removeEventListener(r, i, o)) : (n.addListener(i), u = () => n.removeListener(i)), t.push(u), e
                        },
                        clear: function() {
                            t = t.filter(t => t())
                        }
                    };
                return e
            }

            function w(t = 0, e = 0) {
                let n = f(t - e);

                function r(n) {
                    return n < t || n > e
                }
                return {
                    length: n,
                    max: e,
                    min: t,
                    constrain: function(n) {
                        return r(n) ? n < t ? t : e : n
                    },
                    reachedAny: r,
                    reachedMax: function(t) {
                        return t > e
                    },
                    reachedMin: function(e) {
                        return e < t
                    },
                    removeOffset: function(t) {
                        return n ? t - n * Math.ceil((t - e) / n) : t
                    }
                }
            }

            function x(t) {
                let e = t;

                function n(t) {
                    return c(t) ? t : t.get()
                }
                return {
                    get: function() {
                        return e
                    },
                    set: function(t) {
                        e = n(t)
                    },
                    add: function(t) {
                        e += n(t)
                    },
                    subtract: function(t) {
                        e -= n(t)
                    }
                }
            }

            function S(t, e) {
                let n = "x" === t.scroll ? function(t) {
                        return `translate3d(${t}px,0px,0px)`
                    } : function(t) {
                        return `translate3d(0px,${t}px,0px)`
                    },
                    r = e.style,
                    i = null,
                    o = !1;
                return {
                    clear: function() {
                        o || (r.transform = "", e.getAttribute("style") || e.removeAttribute("style"))
                    },
                    to: function(e) {
                        if (o) return;
                        let u = Math.round(100 * t.direction(e)) / 100;
                        u !== i && (r.transform = n(u), i = u)
                    },
                    toggleActive: function(t) {
                        o = !t
                    }
                }
            }
            let E = {
                align: "center",
                axis: "x",
                container: null,
                slides: null,
                containScroll: "trimSnaps",
                direction: "ltr",
                slidesToScroll: 1,
                inViewThreshold: 0,
                breakpoints: {},
                dragFree: !1,
                dragThreshold: 10,
                loop: !1,
                skipSnaps: !1,
                duration: 25,
                startIndex: 0,
                active: !0,
                watchDrag: !0,
                watchResize: !0,
                watchSlides: !0,
                watchFocus: !0
            };

            function O(t, e, n) {
                let r, i, o, u, k;
                let D = t.ownerDocument,
                    L = D.defaultView,
                    M = function(t) {
                        function e(t, e) {
                            return function t(e, n) {
                                return [e, n].reduce((e, n) => (v(n).forEach(r => {
                                    let i = e[r],
                                        o = n[r],
                                        u = l(i) && l(o);
                                    e[r] = u ? t(i, o) : o
                                }), e), {})
                            }(t, e || {})
                        }
                        return {
                            mergeOptions: e,
                            optionsAtMedia: function(n) {
                                let r = n.breakpoints || {},
                                    i = v(r).filter(e => t.matchMedia(e).matches).map(t => r[t]).reduce((t, n) => e(t, n), {});
                                return e(n, i)
                            },
                            optionsMediaQueries: function(e) {
                                return e.map(t => v(t.breakpoints || {})).reduce((t, e) => t.concat(e), []).map(t.matchMedia)
                            }
                        }
                    }(L),
                    I = (k = [], {
                        init: function(t, e) {
                            return (k = e.filter(({
                                options: t
                            }) => !1 !== M.optionsAtMedia(t).active)).forEach(e => e.init(t, M)), e.reduce((t, e) => Object.assign(t, {
                                [e.name]: e
                            }), {})
                        },
                        destroy: function() {
                            k = k.filter(t => t.destroy())
                        }
                    }),
                    A = b(),
                    F = function() {
                        let t, e = {},
                            n = {
                                init: function(e) {
                                    t = e
                                },
                                emit: function(r) {
                                    return (e[r] || []).forEach(e => e(t, r)), n
                                },
                                off: function(t, r) {
                                    return e[t] = (e[t] || []).filter(t => t !== r), n
                                },
                                on: function(t, r) {
                                    return e[t] = (e[t] || []).concat([r]), n
                                },
                                clear: function() {
                                    e = {}
                                }
                            };
                        return n
                    }(),
                    {
                        mergeOptions: j,
                        optionsAtMedia: T,
                        optionsMediaQueries: N
                    } = M,
                    {
                        on: P,
                        off: z,
                        emit: H
                    } = F,
                    V = !1,
                    R = j(E, O.globalOptions),
                    C = j(R),
                    B = [];

                function U(e, n) {
                    !V && (C = T(R = j(R, e)), B = n || B, function() {
                        let {
                            container: e,
                            slides: n
                        } = C;
                        o = (a(e) ? t.querySelector(e) : e) || t.children[0];
                        let r = a(n) ? o.querySelectorAll(n) : n;
                        u = [].slice.call(r || o.children)
                    }(), r = function e(n) {
                        let r = function(t, e, n, r, i, o, u) {
                            let l, E;
                            let {
                                align: O,
                                axis: k,
                                direction: D,
                                startIndex: L,
                                loop: M,
                                duration: I,
                                dragFree: A,
                                dragThreshold: F,
                                inViewThreshold: j,
                                slidesToScroll: T,
                                skipSnaps: N,
                                containScroll: P,
                                watchResize: z,
                                watchSlides: H,
                                watchDrag: V,
                                watchFocus: R
                            } = o, C = {
                                measure: function(t) {
                                    let {
                                        offsetTop: e,
                                        offsetLeft: n,
                                        offsetWidth: r,
                                        offsetHeight: i
                                    } = t;
                                    return {
                                        top: e,
                                        right: n + r,
                                        bottom: e + i,
                                        left: n,
                                        width: r,
                                        height: i
                                    }
                                }
                            }, B = C.measure(e), U = n.map(C.measure), $ = function(t, e) {
                                let n = "rtl" === e,
                                    r = "y" === t,
                                    i = !r && n ? -1 : 1;
                                return {
                                    scroll: r ? "y" : "x",
                                    cross: r ? "x" : "y",
                                    startEdge: r ? "top" : n ? "right" : "left",
                                    endEdge: r ? "bottom" : n ? "left" : "right",
                                    measureSize: function(t) {
                                        let {
                                            height: e,
                                            width: n
                                        } = t;
                                        return r ? e : n
                                    },
                                    direction: function(t) {
                                        return t * i
                                    }
                                }
                            }(k, D), q = $.measureSize(B), Z = {
                                measure: function(t) {
                                    return t / 100 * q
                                }
                            }, _ = function(t, e) {
                                let n = {
                                    start: function() {
                                        return 0
                                    },
                                    center: function(t) {
                                        return (e - t) / 2
                                    },
                                    end: function(t) {
                                        return e - t
                                    }
                                };
                                return {
                                    measure: function(r, i) {
                                        return a(t) ? n[t](r) : t(e, r, i)
                                    }
                                }
                            }(O, q), J = !M && !!P, {
                                slideSizes: X,
                                slideSizesWithGaps: Q,
                                startGap: Y,
                                endGap: G
                            } = function(t, e, n, r, i, o) {
                                let {
                                    measureSize: u,
                                    startEdge: c,
                                    endEdge: a
                                } = t, s = n[0] && i, l = function() {
                                    if (!s) return 0;
                                    let t = n[0];
                                    return f(e[c] - t[c])
                                }(), d = s ? parseFloat(o.getComputedStyle(m(r)).getPropertyValue(`margin-${a}`)) : 0, p = n.map(u), h = n.map((t, e, n) => {
                                    let r = e === g(n);
                                    return e ? r ? p[e] + d : n[e + 1][c] - t[c] : p[e] + l
                                }).map(f);
                                return {
                                    slideSizes: p,
                                    slideSizesWithGaps: h,
                                    startGap: l,
                                    endGap: d
                                }
                            }($, B, U, n, M || !!P, i), K = function(t, e, n, r, i, o, u, a, s) {
                                let {
                                    startEdge: l,
                                    endEdge: d,
                                    direction: h
                                } = t, v = c(n);
                                return {
                                    groupSlides: function(t) {
                                        return v ? p(t).filter(t => t % n == 0).map(e => t.slice(e, e + n)) : t.length ? p(t).reduce((n, c, s) => {
                                            let p = m(n) || 0,
                                                v = c === g(t),
                                                y = i[l] - o[p][l],
                                                b = i[l] - o[c][d],
                                                w = r || 0 !== p ? 0 : h(u),
                                                x = f(b - (!r && v ? h(a) : 0) - (y + w));
                                            return s && x > e + 2 && n.push(c), v && n.push(t.length), n
                                        }, []).map((e, n, r) => {
                                            let i = Math.max(r[n - 1] || 0);
                                            return t.slice(i, e)
                                        }) : []
                                    }
                                }
                            }($, q, T, M, B, U, Y, G, 0), {
                                snaps: W,
                                snapsAligned: tt
                            } = function(t, e, n, r, i) {
                                let {
                                    startEdge: o,
                                    endEdge: u
                                } = t, {
                                    groupSlides: c
                                } = i, a = c(r).map(t => m(t)[u] - t[0][o]).map(f).map(e.measure), s = r.map(t => n[o] - t[o]).map(t => -f(t)), l = c(s).map(t => t[0]).map((t, e) => t + a[e]);
                                return {
                                    snaps: s,
                                    snapsAligned: l
                                }
                            }($, _, B, U, K), te = -m(W) + m(Q), {
                                snapsContained: tn,
                                scrollContainLimit: tr
                            } = function(t, e, n, r, i) {
                                let o = w(-e + t, 0),
                                    u = n.map((t, e) => {
                                        let {
                                            min: r,
                                            max: i
                                        } = o, u = o.constrain(t), c = e === g(n);
                                        return e ? c || 1 > f(r - u) ? r : 1 > f(i - u) ? i : u : i
                                    }).map(t => parseFloat(t.toFixed(3))),
                                    c = function() {
                                        let t = u[0],
                                            e = m(u);
                                        return w(u.lastIndexOf(t), u.indexOf(e) + 1)
                                    }();
                                return {
                                    snapsContained: function() {
                                        if (e <= t + 2) return [o.max];
                                        if ("keepSnaps" === r) return u;
                                        let {
                                            min: n,
                                            max: i
                                        } = c;
                                        return u.slice(n, i)
                                    }(),
                                    scrollContainLimit: c
                                }
                            }(q, te, tt, P, 0), ti = J ? tn : tt, {
                                limit: to
                            } = function(t, e, n) {
                                let r = e[0];
                                return {
                                    limit: w(n ? r - t : m(e), r)
                                }
                            }(te, ti, M), tu = function t(e, n, r) {
                                let {
                                    constrain: i
                                } = w(0, e), o = e + 1, u = c(n);

                                function c(t) {
                                    return r ? f((o + t) % o) : i(t)
                                }

                                function a() {
                                    return t(e, u, r)
                                }
                                let s = {
                                    get: function() {
                                        return u
                                    },
                                    set: function(t) {
                                        return u = c(t), s
                                    },
                                    add: function(t) {
                                        return a().set(u + t)
                                    },
                                    clone: a
                                };
                                return s
                            }(g(ti), L, M), tc = tu.clone(), ta = p(n), ts = ({
                                dragHandler: t,
                                scrollBody: e,
                                scrollBounds: n,
                                options: {
                                    loop: r
                                }
                            }) => {
                                r || n.constrain(t.pointerDown()), e.seek()
                            }, tl = ({
                                scrollBody: t,
                                translate: e,
                                location: n,
                                offsetLocation: r,
                                previousLocation: i,
                                scrollLooper: o,
                                slideLooper: u,
                                dragHandler: c,
                                animation: a,
                                eventHandler: s,
                                scrollBounds: l,
                                options: {
                                    loop: f
                                }
                            }, d) => {
                                let p = t.settled(),
                                    m = !l.shouldConstrain(),
                                    g = f ? p : p && m;
                                g && !c.pointerDown() && (a.stop(), s.emit("settle")), g || s.emit("scroll");
                                let h = n.get() * d + i.get() * (1 - d);
                                r.set(h), f && (o.loop(t.direction()), u.loop()), e.to(r.get())
                            }, tf = function(t, e, n, r) {
                                let i = b(),
                                    o = 1e3 / 60,
                                    u = null,
                                    c = 0,
                                    a = 0;

                                function s(t) {
                                    if (!a) return;
                                    u || (u = t);
                                    let i = t - u;
                                    for (u = t, c += i; c >= o;) n(), c -= o;
                                    r(c / o), a && (a = e.requestAnimationFrame(s))
                                }

                                function l() {
                                    e.cancelAnimationFrame(a), u = null, c = 0, a = 0
                                }
                                return {
                                    init: function() {
                                        i.add(t, "visibilitychange", () => {
                                            t.hidden && (u = null, c = 0)
                                        })
                                    },
                                    destroy: function() {
                                        l(), i.clear()
                                    },
                                    start: function() {
                                        a || (a = e.requestAnimationFrame(s))
                                    },
                                    stop: l,
                                    update: n,
                                    render: r
                                }
                            }(r, i, () => ts(tk), t => tl(tk, t)), td = ti[tu.get()], tp = x(td), tm = x(td), tg = x(td), th = x(td), tv = function(t, e, n, r, i, o) {
                                let u = 0,
                                    c = 0,
                                    a = i,
                                    s = .68,
                                    l = t.get(),
                                    p = 0;

                                function m(t) {
                                    return a = t, h
                                }

                                function g(t) {
                                    return s = t, h
                                }
                                let h = {
                                    direction: function() {
                                        return c
                                    },
                                    duration: function() {
                                        return a
                                    },
                                    velocity: function() {
                                        return u
                                    },
                                    seek: function() {
                                        let e = r.get() - t.get(),
                                            i = 0;
                                        return a ? (n.set(t), u += e / a, u *= s, l += u, t.add(u), i = l - p) : (u = 0, n.set(r), t.set(r), i = e), c = d(i), p = l, h
                                    },
                                    settled: function() {
                                        return .001 > f(r.get() - e.get())
                                    },
                                    useBaseFriction: function() {
                                        return g(.68)
                                    },
                                    useBaseDuration: function() {
                                        return m(i)
                                    },
                                    useFriction: g,
                                    useDuration: m
                                };
                                return h
                            }(tp, tg, tm, th, I, 0), ty = function(t, e, n, r, i) {
                                let {
                                    reachedAny: o,
                                    removeOffset: u,
                                    constrain: c
                                } = r;

                                function a(t) {
                                    return t.concat().sort((t, e) => f(t) - f(e))[0]
                                }

                                function s(e, r) {
                                    let i = [e, e + n, e - n];
                                    if (!t) return e;
                                    if (!r) return a(i);
                                    let o = i.filter(t => d(t) === r);
                                    return o.length ? a(o) : m(i) - n
                                }
                                return {
                                    byDistance: function(n, r) {
                                        let a = i.get() + n,
                                            {
                                                index: l,
                                                distance: d
                                            } = function(n) {
                                                let r = t ? u(n) : c(n),
                                                    {
                                                        index: i
                                                    } = e.map((t, e) => ({
                                                        diff: s(t - r, 0),
                                                        index: e
                                                    })).sort((t, e) => f(t.diff) - f(e.diff))[0];
                                                return {
                                                    index: i,
                                                    distance: r
                                                }
                                            }(a),
                                            p = !t && o(a);
                                        if (!r || p) return {
                                            index: l,
                                            distance: n
                                        };
                                        let m = n + s(e[l] - d, 0);
                                        return {
                                            index: l,
                                            distance: m
                                        }
                                    },
                                    byIndex: function(t, n) {
                                        let r = s(e[t] - i.get(), n);
                                        return {
                                            index: t,
                                            distance: r
                                        }
                                    },
                                    shortcut: s
                                }
                            }(M, ti, te, to, th), tb = function(t, e, n, r, i, o, u) {
                                function c(i) {
                                    let c = i.distance,
                                        a = i.index !== e.get();
                                    o.add(c), c && (r.duration() ? t.start() : (t.update(), t.render(1), t.update())), a && (n.set(e.get()), e.set(i.index), u.emit("select"))
                                }
                                return {
                                    distance: function(t, e) {
                                        c(i.byDistance(t, e))
                                    },
                                    index: function(t, n) {
                                        let r = e.clone().set(t);
                                        c(i.byIndex(r.get(), n))
                                    }
                                }
                            }(tf, tu, tc, tv, ty, th, u), tw = function(t) {
                                let {
                                    max: e,
                                    length: n
                                } = t;
                                return {
                                    get: function(t) {
                                        return n ? -((t - e) / n) : 0
                                    }
                                }
                            }(to), tx = b(), tS = function(t, e, n, r) {
                                let i;
                                let o = {},
                                    u = null,
                                    c = null,
                                    a = !1;
                                return {
                                    init: function() {
                                        i = new IntersectionObserver(t => {
                                            a || (t.forEach(t => {
                                                o[e.indexOf(t.target)] = t
                                            }), u = null, c = null, n.emit("slidesInView"))
                                        }, {
                                            root: t.parentElement,
                                            threshold: r
                                        }), e.forEach(t => i.observe(t))
                                    },
                                    destroy: function() {
                                        i && i.disconnect(), a = !0
                                    },
                                    get: function(t = !0) {
                                        if (t && u) return u;
                                        if (!t && c) return c;
                                        let e = v(o).reduce((e, n) => {
                                            let r = parseInt(n),
                                                {
                                                    isIntersecting: i
                                                } = o[r];
                                            return (t && i || !t && !i) && e.push(r), e
                                        }, []);
                                        return t && (u = e), t || (c = e), e
                                    }
                                }
                            }(e, n, u, j), {
                                slideRegistry: tE
                            } = function(t, e, n, r, i, o) {
                                let {
                                    groupSlides: u
                                } = i, {
                                    min: c,
                                    max: a
                                } = r;
                                return {
                                    slideRegistry: function() {
                                        let r = u(o);
                                        return 1 === n.length ? [o] : t && "keepSnaps" !== e ? r.slice(c, a).map((t, e, n) => {
                                            let r = e === g(n);
                                            return e ? r ? h(g(o) - m(n)[0] + 1, m(n)[0]) : t : h(m(n[0]) + 1)
                                        }) : r
                                    }()
                                }
                            }(J, P, ti, tr, K, ta), tO = function(t, e, n, r, i, o, u, a) {
                                let l = {
                                        passive: !0,
                                        capture: !0
                                    },
                                    f = 0;

                                function d(t) {
                                    "Tab" === t.code && (f = new Date().getTime())
                                }
                                return {
                                    init: function(p) {
                                        a && (o.add(document, "keydown", d, !1), e.forEach((e, d) => {
                                            o.add(e, "focus", e => {
                                                (s(a) || a(p, e)) && function(e) {
                                                    if (new Date().getTime() - f > 10) return;
                                                    u.emit("slideFocusStart"), t.scrollLeft = 0;
                                                    let o = n.findIndex(t => t.includes(e));
                                                    c(o) && (i.useDuration(0), r.index(o, 0), u.emit("slideFocus"))
                                                }(d)
                                            }, l)
                                        }))
                                    }
                                }
                            }(t, n, tE, tb, tv, tx, u, R), tk = {
                                ownerDocument: r,
                                ownerWindow: i,
                                eventHandler: u,
                                containerRect: B,
                                slideRects: U,
                                animation: tf,
                                axis: $,
                                dragHandler: function(t, e, n, r, i, o, u, c, a, l, p, m, g, h, v, x, S, E, O) {
                                    let {
                                        cross: k,
                                        direction: D
                                    } = t, L = ["INPUT", "SELECT", "TEXTAREA"], M = {
                                        passive: !1
                                    }, I = b(), A = b(), F = w(50, 225).constrain(h.measure(20)), j = {
                                        mouse: 300,
                                        touch: 400
                                    }, T = {
                                        mouse: 500,
                                        touch: 600
                                    }, N = v ? 43 : 25, P = !1, z = 0, H = 0, V = !1, R = !1, C = !1, B = !1;

                                    function U(t) {
                                        if (!y(t, r) && t.touches.length >= 2) return $(t);
                                        let e = o.readPoint(t),
                                            n = o.readPoint(t, k),
                                            u = f(e - z),
                                            a = f(n - H);
                                        if (!R && !B && (!t.cancelable || !(R = u > a))) return $(t);
                                        let s = o.pointerMove(t);
                                        u > x && (C = !0), l.useFriction(.3).useDuration(.75), c.start(), i.add(D(s)), t.preventDefault()
                                    }

                                    function $(t) {
                                        let e = p.byDistance(0, !1).index !== m.get(),
                                            n = o.pointerUp(t) * (v ? T : j)[B ? "mouse" : "touch"],
                                            r = function(t, e) {
                                                let n = m.add(-1 * d(t)),
                                                    r = p.byDistance(t, !v).distance;
                                                return v || f(t) < F ? r : S && e ? .5 * r : p.byIndex(n.get(), 0).distance
                                            }(D(n), e),
                                            i = function(t, e) {
                                                var n, r;
                                                if (0 === t || 0 === e || f(t) <= f(e)) return 0;
                                                let i = (n = f(t), r = f(e), f(n - r));
                                                return f(i / t)
                                            }(n, r);
                                        R = !1, V = !1, A.clear(), l.useDuration(N - 10 * i).useFriction(.68 + i / 50), a.distance(r, !v), B = !1, g.emit("pointerUp")
                                    }

                                    function q(t) {
                                        C && (t.stopPropagation(), t.preventDefault(), C = !1)
                                    }
                                    return {
                                        init: function(t) {
                                            O && I.add(e, "dragstart", t => t.preventDefault(), M).add(e, "touchmove", () => void 0, M).add(e, "touchend", () => void 0).add(e, "touchstart", c).add(e, "mousedown", c).add(e, "touchcancel", $).add(e, "contextmenu", $).add(e, "click", q, !0);

                                            function c(c) {
                                                (s(O) || O(t, c)) && function(t) {
                                                    let c = y(t, r);
                                                    B = c, C = v && c && !t.buttons && P, P = f(i.get() - u.get()) >= 2, c && 0 !== t.button || function(t) {
                                                        let e = t.nodeName || "";
                                                        return L.includes(e)
                                                    }(t.target) || (V = !0, o.pointerDown(t), l.useFriction(0).useDuration(0), i.set(u), function() {
                                                        let t = B ? n : e;
                                                        A.add(t, "touchmove", U, M).add(t, "touchend", $).add(t, "mousemove", U, M).add(t, "mouseup", $)
                                                    }(), z = o.readPoint(t), H = o.readPoint(t, k), g.emit("pointerDown"))
                                                }(c)
                                            }
                                        },
                                        destroy: function() {
                                            I.clear(), A.clear()
                                        },
                                        pointerDown: function() {
                                            return V
                                        }
                                    }
                                }($, t, r, i, th, function(t, e) {
                                    let n, r;

                                    function i(t) {
                                        return t.timeStamp
                                    }

                                    function o(n, r) {
                                        let i = r || t.scroll,
                                            o = `client${"x"===i?"X":"Y"}`;
                                        return (y(n, e) ? n : n.touches[0])[o]
                                    }
                                    return {
                                        pointerDown: function(t) {
                                            return n = t, r = t, o(t)
                                        },
                                        pointerMove: function(t) {
                                            let e = o(t) - o(r),
                                                u = i(t) - i(n) > 170;
                                            return r = t, u && (n = t), e
                                        },
                                        pointerUp: function(t) {
                                            if (!n || !r) return 0;
                                            let e = o(r) - o(n),
                                                u = i(t) - i(n),
                                                c = i(t) - i(r) > 170,
                                                a = e / u;
                                            return u && !c && f(a) > .1 ? a : 0
                                        },
                                        readPoint: o
                                    }
                                }($, i), tp, tf, tb, tv, ty, tu, u, Z, A, F, N, 0, V),
                                eventStore: tx,
                                percentOfView: Z,
                                index: tu,
                                indexPrevious: tc,
                                limit: to,
                                location: tp,
                                offsetLocation: tg,
                                previousLocation: tm,
                                options: o,
                                resizeHandler: function(t, e, n, r, i, o, u) {
                                    let c, a;
                                    let l = [t].concat(r),
                                        d = [],
                                        p = !1;

                                    function m(t) {
                                        return i.measureSize(u.measure(t))
                                    }
                                    return {
                                        init: function(i) {
                                            o && (a = m(t), d = r.map(m), c = new ResizeObserver(n => {
                                                (s(o) || o(i, n)) && function(n) {
                                                    for (let o of n) {
                                                        if (p) return;
                                                        let n = o.target === t,
                                                            u = r.indexOf(o.target),
                                                            c = n ? a : d[u];
                                                        if (f(m(n ? t : r[u]) - c) >= .5) {
                                                            i.reInit(), e.emit("resize");
                                                            break
                                                        }
                                                    }
                                                }(n)
                                            }), n.requestAnimationFrame(() => {
                                                l.forEach(t => c.observe(t))
                                            }))
                                        },
                                        destroy: function() {
                                            p = !0, c && c.disconnect()
                                        }
                                    }
                                }(e, u, i, n, $, z, C),
                                scrollBody: tv,
                                scrollBounds: function(t, e, n, r, i) {
                                    let o = i.measure(10),
                                        u = i.measure(50),
                                        c = w(.1, .99),
                                        a = !1;

                                    function s() {
                                        return !!(!a && t.reachedAny(n.get()) && t.reachedAny(e.get()))
                                    }
                                    return {
                                        shouldConstrain: s,
                                        constrain: function(i) {
                                            if (!s()) return;
                                            let a = t.reachedMin(e.get()) ? "min" : "max",
                                                l = f(t[a] - e.get()),
                                                d = n.get() - e.get(),
                                                p = c.constrain(l / u);
                                            n.subtract(d * p), !i && f(d) < o && (n.set(t.constrain(n.get())), r.useDuration(25).useBaseFriction())
                                        },
                                        toggleActive: function(t) {
                                            a = !t
                                        }
                                    }
                                }(to, tg, th, tv, Z),
                                scrollLooper: function(t, e, n, r) {
                                    let {
                                        reachedMin: i,
                                        reachedMax: o
                                    } = w(e.min + .1, e.max + .1);
                                    return {
                                        loop: function(e) {
                                            if (!(1 === e ? o(n.get()) : -1 === e && i(n.get()))) return;
                                            let u = -1 * e * t;
                                            r.forEach(t => t.add(u))
                                        }
                                    }
                                }(te, to, tg, [tp, tg, tm, th]),
                                scrollProgress: tw,
                                scrollSnapList: ti.map(tw.get),
                                scrollSnaps: ti,
                                scrollTarget: ty,
                                scrollTo: tb,
                                slideLooper: function(t, e, n, r, i, o, u, c, a) {
                                    let s = p(i),
                                        l = m(d(p(i).reverse(), u[0]), n, !1).concat(m(d(s, e - u[0] - 1), -n, !0));

                                    function f(t, e) {
                                        return t.reduce((t, e) => t - i[e], e)
                                    }

                                    function d(t, e) {
                                        return t.reduce((t, n) => f(t, e) > 0 ? t.concat([n]) : t, [])
                                    }

                                    function m(i, u, s) {
                                        let l = o.map((t, n) => ({
                                            start: t - r[n] + .5 + u,
                                            end: t + e - .5 + u
                                        }));
                                        return i.map(e => {
                                            let r = s ? 0 : -n,
                                                i = s ? n : 0,
                                                o = l[e][s ? "end" : "start"];
                                            return {
                                                index: e,
                                                loopPoint: o,
                                                slideLocation: x(-1),
                                                translate: S(t, a[e]),
                                                target: () => c.get() > o ? r : i
                                            }
                                        })
                                    }
                                    return {
                                        canLoop: function() {
                                            return l.every(({
                                                index: t
                                            }) => .1 >= f(s.filter(e => e !== t), e))
                                        },
                                        clear: function() {
                                            l.forEach(t => t.translate.clear())
                                        },
                                        loop: function() {
                                            l.forEach(t => {
                                                let {
                                                    target: e,
                                                    translate: n,
                                                    slideLocation: r
                                                } = t, i = e();
                                                i !== r.get() && (n.to(i), r.set(i))
                                            })
                                        },
                                        loopPoints: l
                                    }
                                }($, q, te, X, Q, W, ti, tg, n),
                                slideFocus: tO,
                                slidesHandler: (E = !1, {
                                    init: function(t) {
                                        H && (l = new MutationObserver(e => {
                                            !E && (s(H) || H(t, e)) && function(e) {
                                                for (let n of e)
                                                    if ("childList" === n.type) {
                                                        t.reInit(), u.emit("slidesChanged");
                                                        break
                                                    }
                                            }(e)
                                        })).observe(e, {
                                            childList: !0
                                        })
                                    },
                                    destroy: function() {
                                        l && l.disconnect(), E = !0
                                    }
                                }),
                                slidesInView: tS,
                                slideIndexes: ta,
                                slideRegistry: tE,
                                slidesToScroll: K,
                                target: th,
                                translate: S($, e)
                            };
                            return tk
                        }(t, o, u, D, L, n, F);
                        return n.loop && !r.slideLooper.canLoop() ? e(Object.assign({}, n, {
                            loop: !1
                        })) : r
                    }(C), N([R, ...B.map(({
                        options: t
                    }) => t)]).forEach(t => A.add(t, "change", $)), C.active && (r.translate.to(r.location.get()), r.animation.init(), r.slidesInView.init(), r.slideFocus.init(J), r.eventHandler.init(J), r.resizeHandler.init(J), r.slidesHandler.init(J), r.options.loop && r.slideLooper.loop(), o.offsetParent && u.length && r.dragHandler.init(J), i = I.init(J, B)))
                }

                function $(t, e) {
                    let n = _();
                    q(), U(j({
                        startIndex: n
                    }, t), e), F.emit("reInit")
                }

                function q() {
                    r.dragHandler.destroy(), r.eventStore.clear(), r.translate.clear(), r.slideLooper.clear(), r.resizeHandler.destroy(), r.slidesHandler.destroy(), r.slidesInView.destroy(), r.animation.destroy(), I.destroy(), A.clear()
                }

                function Z(t, e, n) {
                    C.active && !V && (r.scrollBody.useBaseFriction().useDuration(!0 === e ? 0 : C.duration), r.scrollTo.index(t, n || 0))
                }

                function _() {
                    return r.index.get()
                }
                let J = {
                    canScrollNext: function() {
                        return r.index.add(1).get() !== _()
                    },
                    canScrollPrev: function() {
                        return r.index.add(-1).get() !== _()
                    },
                    containerNode: function() {
                        return o
                    },
                    internalEngine: function() {
                        return r
                    },
                    destroy: function() {
                        V || (V = !0, A.clear(), q(), F.emit("destroy"), F.clear())
                    },
                    off: z,
                    on: P,
                    emit: H,
                    plugins: function() {
                        return i
                    },
                    previousScrollSnap: function() {
                        return r.indexPrevious.get()
                    },
                    reInit: $,
                    rootNode: function() {
                        return t
                    },
                    scrollNext: function(t) {
                        Z(r.index.add(1).get(), t, -1)
                    },
                    scrollPrev: function(t) {
                        Z(r.index.add(-1).get(), t, 1)
                    },
                    scrollProgress: function() {
                        return r.scrollProgress.get(r.location.get())
                    },
                    scrollSnapList: function() {
                        return r.scrollSnapList
                    },
                    scrollTo: Z,
                    selectedScrollSnap: _,
                    slideNodes: function() {
                        return u
                    },
                    slidesInView: function() {
                        return r.slidesInView.get()
                    },
                    slidesNotInView: function() {
                        return r.slidesInView.get(!1)
                    }
                };
                return U(e, n), setTimeout(() => F.emit("init"), 0), J
            }

            function k(t = {}, e = []) {
                let n = (0, r.useRef)(t),
                    i = (0, r.useRef)(e),
                    [c, a] = (0, r.useState)(),
                    [s, l] = (0, r.useState)(),
                    f = (0, r.useCallback)(() => {
                        c && c.reInit(n.current, i.current)
                    }, [c]);
                return (0, r.useEffect)(() => {
                    o(n.current, t) || (n.current = t, f())
                }, [t, f]), (0, r.useEffect)(() => {
                    ! function(t, e) {
                        if (t.length !== e.length) return !1;
                        let n = u(t),
                            r = u(e);
                        return n.every((t, e) => o(t, r[e]))
                    }(i.current, e) && (i.current = e, f())
                }, [e, f]), (0, r.useEffect)(() => {
                    if ("undefined" != typeof window && window.document && window.document.createElement && s) {
                        O.globalOptions = k.globalOptions;
                        let t = O(s, n.current, i.current);
                        return a(t), () => t.destroy()
                    }
                    a(void 0)
                }, [s, a]), [l, c]
            }
            O.globalOptions = void 0, k.globalOptions = void 0
        }
    }
]);
//# sourceMappingURL=610-ab3db9ad36272f0e.js.map